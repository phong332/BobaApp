if ( TRACE ) { TRACE( JSON.parse( '["ActionDispatcher#init","ActionDispatcher#Scored","ApplyPhysicsForceManager#init","ApplyPhysicsForceManager#ApplyForceToBody","ApplyPhysicsForceManager#Start","ApplyPhysicsForceManager#Update","ApplyPhysicsForceManager#PlaySoundLoopEnum","AutoDestroy#init","AutoDestroy#OnEnable","AutoDestroy#Update","AutoDestroy#OnDestroy","AutoDestroy#OnDisable","AutoDestructor#init","AutoDestructor#OnEnable","AutoDestructor#AutoDestroy","AutoDestructor#OnDisable","BezierCurve.BezierCollider2D#init","BezierCurve.BezierCollider2D#CalculateBezierPoint","BezierCurve.BezierCollider2D#Calculate2DPoints","ButtonBeverage#OnClick","ButtonBeverage#EffectOnClick","DecoratorManager#Update","DefineHelper#init","DeleteParticles#OnCollisionEnter2D","DeleteTriggerBoundingBox#init","DeleteTriggerBoundingBox#Start","DeleteTriggerBoundingBox#DeleteOnCollide","DeleteTriggerBoundingBox#Delete","DG.Tweening.DOTweenCYInstruction.WaitForCompletion#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForCompletion#ctor","DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#ctor","DG.Tweening.DOTweenCYInstruction.WaitForKill#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForKill#ctor","DG.Tweening.DOTweenCYInstruction.WaitForPosition#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForPosition#ctor","DG.Tweening.DOTweenCYInstruction.WaitForRewind#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForRewind#ctor","DG.Tweening.DOTweenCYInstruction.WaitForStart#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForStart#ctor","DG.Tweening.DOTweenModuleAudio#DOFade","DG.Tweening.DOTweenModuleAudio#DOPitch","DG.Tweening.DOTweenModuleAudio#DOSetFloat","DG.Tweening.DOTweenModuleAudio#DOComplete","DG.Tweening.DOTweenModuleAudio#DOKill","DG.Tweening.DOTweenModuleAudio#DOFlip","DG.Tweening.DOTweenModuleAudio#DOGoto","DG.Tweening.DOTweenModuleAudio#DOPause","DG.Tweening.DOTweenModuleAudio#DOPlay","DG.Tweening.DOTweenModuleAudio#DOPlayBackwards","DG.Tweening.DOTweenModuleAudio#DOPlayForward","DG.Tweening.DOTweenModuleAudio#DORestart","DG.Tweening.DOTweenModuleAudio#DORewind","DG.Tweening.DOTweenModuleAudio#DOSmoothRewind","DG.Tweening.DOTweenModuleAudio#DOTogglePause","DG.Tweening.DOTweenModulePhysics#DOMove","DG.Tweening.DOTweenModulePhysics#DOMoveX","DG.Tweening.DOTweenModulePhysics#DOMoveY","DG.Tweening.DOTweenModulePhysics#DOMoveZ","DG.Tweening.DOTweenModulePhysics#DORotate","DG.Tweening.DOTweenModulePhysics#DOLookAt","DG.Tweening.DOTweenModulePhysics#DOJump","DG.Tweening.DOTweenModulePhysics#DOPath","DG.Tweening.DOTweenModulePhysics#DOPath$1","DG.Tweening.DOTweenModulePhysics#DOLocalPath","DG.Tweening.DOTweenModulePhysics#DOLocalPath$1","DG.Tweening.DOTweenModulePhysics2D#DOMove","DG.Tweening.DOTweenModulePhysics2D#DOMoveX","DG.Tweening.DOTweenModulePhysics2D#DOMoveY","DG.Tweening.DOTweenModulePhysics2D#DORotate","DG.Tweening.DOTweenModulePhysics2D#DOJump","DG.Tweening.DOTweenModulePhysics2D#DOPath","DG.Tweening.DOTweenModulePhysics2D#DOPath$1","DG.Tweening.DOTweenModulePhysics2D#DOLocalPath","DG.Tweening.DOTweenModulePhysics2D#DOLocalPath$1","DG.Tweening.DOTweenModuleSprite#DOColor","DG.Tweening.DOTweenModuleSprite#DOFade","DG.Tweening.DOTweenModuleSprite#DOGradientColor","DG.Tweening.DOTweenModuleSprite#DOBlendableColor","DG.Tweening.DOTweenModuleUI#DOFade","DG.Tweening.DOTweenModuleUI#DOFade$1","DG.Tweening.DOTweenModuleUI#DOFade$2","DG.Tweening.DOTweenModuleUI#DOFade$3","DG.Tweening.DOTweenModuleUI#DOFade$4","DG.Tweening.DOTweenModuleUI#DOColor","DG.Tweening.DOTweenModuleUI#DOColor$1","DG.Tweening.DOTweenModuleUI#DOColor$2","DG.Tweening.DOTweenModuleUI#DOColor$3","DG.Tweening.DOTweenModuleUI#DOFillAmount","DG.Tweening.DOTweenModuleUI#DOGradientColor","DG.Tweening.DOTweenModuleUI#DOFlexibleSize","DG.Tweening.DOTweenModuleUI#DOMinSize","DG.Tweening.DOTweenModuleUI#DOPreferredSize","DG.Tweening.DOTweenModuleUI#DOScale","DG.Tweening.DOTweenModuleUI#DOAnchorPos","DG.Tweening.DOTweenModuleUI#DOAnchorPosX","DG.Tweening.DOTweenModuleUI#DOAnchorPosY","DG.Tweening.DOTweenModuleUI#DOAnchorPos3D","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DX","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DY","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DZ","DG.Tweening.DOTweenModuleUI#DOAnchorMax","DG.Tweening.DOTweenModuleUI#DOAnchorMin","DG.Tweening.DOTweenModuleUI#DOPivot","DG.Tweening.DOTweenModuleUI#DOPivotX","DG.Tweening.DOTweenModuleUI#DOPivotY","DG.Tweening.DOTweenModuleUI#DOSizeDelta","DG.Tweening.DOTweenModuleUI#DOPunchAnchorPos","DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos","DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos$1","DG.Tweening.DOTweenModuleUI#DOJumpAnchorPos","DG.Tweening.DOTweenModuleUI#DONormalizedPos","DG.Tweening.DOTweenModuleUI#DOHorizontalNormalizedPos","DG.Tweening.DOTweenModuleUI#DOVerticalNormalizedPos","DG.Tweening.DOTweenModuleUI#DOValue","DG.Tweening.DOTweenModuleUI#DOCounter","DG.Tweening.DOTweenModuleUI#DOText","DG.Tweening.DOTweenModuleUI#DOBlendableColor","DG.Tweening.DOTweenModuleUI#DOBlendableColor$1","DG.Tweening.DOTweenModuleUI#DOBlendableColor$2","DG.Tweening.DOTweenModuleUI#DOShapeCircle","DG.Tweening.DOTweenModuleUI.Utils#SwitchToRectTransform","DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor","DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor$1","DG.Tweening.DOTweenModuleUnityVersion#WaitForCompletion","DG.Tweening.DOTweenModuleUnityVersion#WaitForRewind","DG.Tweening.DOTweenModuleUnityVersion#WaitForKill","DG.Tweening.DOTweenModuleUnityVersion#WaitForElapsedLoops","DG.Tweening.DOTweenModuleUnityVersion#WaitForPosition","DG.Tweening.DOTweenModuleUnityVersion#WaitForStart","DG.Tweening.DOTweenModuleUnityVersion#DOOffset","DG.Tweening.DOTweenModuleUnityVersion#DOTiling","DG.Tweening.DOTweenModuleUtils#Init","DG.Tweening.DOTweenModuleUtils#Preserver","DG.Tweening.DOTweenModuleUtils.Physics#SetOrientationOnPath","DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody2D","DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody","DG.Tweening.DOTweenModuleUtils.Physics#CreateDOTweenPathTween","DrinkMaterial#init","DrinkMaterial#Rb#get","DrinkMaterial#init","DrinkMaterial#Set","DrinkMaterial#Awake","DrinkMaterial#Start","DrinkMaterial#OnDestroy","DrinkMaterial#OnEnable","DrinkMaterial#OnBecameInvisible","DrinkMaterial#Update","DrinkMaterial#LateUpdate","DrinkMaterial#IsInView","DrinkMaterial#Destroying","DrinkMaterial#FallsOutOfView","DrinkMaterial#OnCollisionEnter2D","DrinkMaterial#PlaySound","EventDispatcher#Instance#get","EventDispatcher#Instance#set","EventDispatcher#HasInstance","EventDispatcher#init","EventDispatcher#Awake","EventDispatcher#OnDestroy","EventDispatcher#RegisterListener","EventDispatcher#PostEvent","EventDispatcher#RemoveListener","EventDispatcher#ClearAllListener","EventDispatcherExtension#RegisterListener","EventDispatcherExtension#PostEvent$1","EventDispatcherExtension#PostEvent","EventDispatcherExtension#RemoveListener","Faucet#particleCount#get","Faucet#Color#get","Faucet#init","Faucet#Awake","Faucet#Clean","Faucet#OnPointerDown","Faucet#OnPointerUp","Faucet#Spawn","Faucet#StopSpawning","Faucet#SetColor","Faucet#OnValidate","FaucetManager#Faucets#get","FaucetManager#init","FaucetManager#Awake","FaucetManager#SetColors","FaucetManager#CreateFaucetWithAmount","FaucetManager#Clean","SingletonMono$1#init","SingletonMono$1#Awake","GeneratorController#init","GeneratorController#Start","GeneratorController#FixedUpdate","GeneratorController#Update","GeneratorController#PrintResults","Glass#SetUp","Glass#TearDown","HelperUtility#DecimalRounding","HelperUtility#DisruptiveArrayObject","HelperUtility#CountCornersVisibleFrom","HelperUtility#GetRandom","HelperUtility#IsEmpty","HelperUtility#IsVisibleFrom","HelperUtility#DisruptiveListObject$1","HelperUtility#DisruptiveListObject","HelperUtility#DisruptiveList","HelperUtility#DisruptiveListSelf","HelperUtility#SelectionSortList","HelperUtility#StartThread","HelperUtility#StartThread$1","HelperUtility#StartAction$1","HelperUtility#StartAction","HelperUtility#StartActionRealTime","HelperUtility#StartActionNotUseCorutines","HelperUtility#GetPointDistanceFromObject","HelperUtility#GetDirectionFromAngle","HelperUtility#GetDirectionFromAngle_2","HelperUtility#DOLocalRotateQuaternion","HelperUtility#GetRotateDirection","HelperUtility#LookAtToDirection","HelperUtility#LookAtToDirectionAngleDetal","HelperUtility#LookAtToPosition","HelperUtility#LookAtToPositionAngleDetal","HelperUtility#RandomCustom","HelperUtility#RandomUnduplicated$1","HelperUtility#RandomUnduplicated","HelperUtility#SetPos","HelperUtility#PosHandle","Ingredient#init","LavaColorPicker#Start","LavaColorPicker#getColor","LavaEvents#init","LavaEvents#Start","LavaEvents#OnCollideLava","LunaPool#init","LunaPool#init","LunaPool#Awake","LunaPool#Spawn","LunaPool#Despawn","MetaballParticleClass#Active#get","MetaballParticleClass#Active#set","MetaballParticleClass#init","MetaballParticleClass#SetColor","MetaballParticleClass#SetFreeze","MetaballParticleClass#GetFreeze","MetaballParticleClass#SetHighDensity","MetaballParticleClass#removeGlow","MetaballParticleClass#Start","MetaballParticleClass#Update","MetaballParticleClass#AnimInEditor","MetaballParticleClass#VelocityLimiter","MetaballParticleClass#OnCollisionEnter2D","MetaballParticleClass#OnCollisionEnter2DEditor","MetaballParticleClass#ScaleItDown","MetaballParticleClass#ScaleDownPerform","MetaballParticleClass#Blend","MetaballParticleClass#Blend2","MMMaths#Vector3ToVector2","MMMaths#Vector2ToVector3","MMMaths#Vector2ToVector3$1","MMMaths#RandomVector3","MMMaths#RotatePointAroundPivot","MMMaths#RotatePointAroundPivot$1","MMMaths#Sum","MMMaths#RollADice","MMMaths#Chance","MMMaths#Approach","MouseColliderController#Start","MouseColliderController#Update","Mover#init","Mover#FixedUpdate","NameTag#init","PlaySoundOnEverySpawn#PlaySound","ResizeQuadEffectController#RebuildTextures","ResizeQuadEffectController#init","ResizeQuadEffectController#Awake","ResizeQuadEffectController#Start","ResizeQuadEffectController#Update","ResizeQuadEffectController#AboutToRebuildAll","ResizeQuadEffectController#RebuildRenderTexturesAll","ResizeQuadEffectController#SetSorting","RotateObject#Start","Rotation#init","Rotation#Start","screenshot#init","screenshot#Update","SharpJson.JsonDecoder#DecodeText","SharpJson.JsonDecoder#ctor","SharpJson.JsonDecoder#Decode","SharpJson.JsonDecoder#ParseObject","SharpJson.JsonDecoder#ParseArray","SharpJson.JsonDecoder#ParseValue","SharpJson.JsonDecoder#TriggerError","SharpJson.JsonDecoder#EvalLexer","SharpJson.Lexer#NextToken","SharpJson.Lexer#hasError#get","SharpJson.Lexer#init","SharpJson.Lexer#ctor","SharpJson.Lexer#Reset","SharpJson.Lexer#ParseString","SharpJson.Lexer#GetNumberString","SharpJson.Lexer#ParseFloatNumber","SharpJson.Lexer#ParseDoubleNumber","SharpJson.Lexer#GetLastIndexOfNumber","SharpJson.Lexer#SkipWhiteSpaces","SharpJson.Lexer#LookAhead","SharpJson.Lexer#NextToken","SimplePool#init","SimplePool#Init","SimplePool#PoolPreLoad","SimplePool#Preload","SimplePool#Spawn$3","SimplePool#Spawn$2","SimplePool#Spawn","SimplePool#Spawn$1","SimplePool#Despawn","SimplePool#GetStackCount","SimplePool#ClearPool","SimplePool.Pool#StackCount#get","SimplePool.Pool#init","SimplePool.Pool#ctor","SimplePool.Pool#Preload","SimplePool.Pool#Spawn$1","SimplePool.Pool#Spawn","SimplePool.Pool#Despawn","SimpleRotation#init","SimpleRotation#Start","SimpleRotation#FixedUpdate","SimpleRotation#StartRotation","SingletonWithouMono$1#Instance#get","SingletonWithouMono$1#init","SingletonWithouMono$1#init","SingletonWithouMono$1#Initialize","SingletonWithouMono$1#Preload","Spine.Animation#BinarySearch$1","Spine.Animation#BinarySearch","Spine.Animation#LinearSearch","Spine.Animation#Timelines#get","Spine.Animation#Timelines#set","Spine.Animation#Duration#get","Spine.Animation#Duration#set","Spine.Animation#Name#get","Spine.Animation#ctor","Spine.Animation#HasTimeline","Spine.Animation#Apply","Spine.Animation#toString","Spine.AnimationState#init","Spine.AnimationState#ApplyRotateTimeline","Spine.AnimationState#TimeScale#get","Spine.AnimationState#TimeScale#set","Spine.AnimationState#Data#get","Spine.AnimationState#Data#set","Spine.AnimationState#Tracks#get","Spine.AnimationState#init","Spine.AnimationState#ctor","Spine.AnimationState#OnStart","Spine.AnimationState#OnInterrupt","Spine.AnimationState#OnEnd","Spine.AnimationState#OnDispose","Spine.AnimationState#OnComplete","Spine.AnimationState#OnEvent","Spine.AnimationState#AssignEventSubscribersFrom","Spine.AnimationState#AddEventSubscribersFrom","Spine.AnimationState#Update","Spine.AnimationState#UpdateMixingFrom","Spine.AnimationState#Apply","Spine.AnimationState#ApplyEventTimelinesOnly","Spine.AnimationState#ApplyMixingFrom","Spine.AnimationState#ApplyMixingFromEventTimelinesOnly","Spine.AnimationState#ApplyAttachmentTimeline","Spine.AnimationState#SetAttachment","Spine.AnimationState#QueueEvents","Spine.AnimationState#ClearTracks","Spine.AnimationState#ClearTrack","Spine.AnimationState#SetCurrent","Spine.AnimationState#SetAnimation$1","Spine.AnimationState#SetAnimation","Spine.AnimationState#AddAnimation$1","Spine.AnimationState#AddAnimation","Spine.AnimationState#SetEmptyAnimation","Spine.AnimationState#AddEmptyAnimation","Spine.AnimationState#SetEmptyAnimations","Spine.AnimationState#ExpandToIndex","Spine.AnimationState#NewTrackEntry","Spine.AnimationState#DisposeNext","Spine.AnimationState#AnimationsChanged","Spine.AnimationState#ComputeHold","Spine.AnimationState#GetCurrent","Spine.AnimationState#ClearListenerNotifications","Spine.AnimationState#toString","Spine.AnimationStateData#SkeletonData#get","Spine.AnimationStateData#DefaultMix#get","Spine.AnimationStateData#DefaultMix#set","Spine.AnimationStateData#init","Spine.AnimationStateData#ctor","Spine.AnimationStateData#SetMix$1","Spine.AnimationStateData#SetMix","Spine.AnimationStateData#GetMix","Spine.AnimationStateData.AnimationPair#getDefaultValue","Spine.AnimationStateData.AnimationPair#$ctor1","Spine.AnimationStateData.AnimationPair#ctor","Spine.AnimationStateData.AnimationPair#toString","Spine.AnimationStateData.AnimationPair#getHashCode","Spine.AnimationStateData.AnimationPair#equals","Spine.AnimationStateData.AnimationPair#$clone","Spine.AtlasRegion#Clone","Spine.AtlasPage#Clone","Spine.Attachment#ctor","Spine.Attachment#toString","Spine.BoneData#Index#get","Spine.BoneData#Name#get","Spine.BoneData#Parent#get","Spine.BoneData#Length#get","Spine.BoneData#Length#set","Spine.BoneData#X#get","Spine.BoneData#X#set","Spine.BoneData#Y#get","Spine.BoneData#Y#set","Spine.BoneData#Rotation#get","Spine.BoneData#Rotation#set","Spine.BoneData#ScaleX#get","Spine.BoneData#ScaleX#set","Spine.BoneData#ScaleY#get","Spine.BoneData#ScaleY#set","Spine.BoneData#ShearX#get","Spine.BoneData#ShearX#set","Spine.BoneData#ShearY#get","Spine.BoneData#ShearY#set","Spine.BoneData#TransformMode#get","Spine.BoneData#TransformMode#set","Spine.BoneData#SkinRequired#get","Spine.BoneData#SkinRequired#set","Spine.BoneData#init","Spine.BoneData#ctor","Spine.BoneData#toString","Spine.BoneMatrix#CalculateSetupWorld","Spine.BoneMatrix#GetInheritedInternal","Spine.BoneMatrix#getDefaultValue","Spine.BoneMatrix#$ctor2","Spine.BoneMatrix#$ctor1","Spine.BoneMatrix#ctor","Spine.BoneMatrix#TransformMatrix","Spine.BoneMatrix#getHashCode","Spine.BoneMatrix#equals","Spine.BoneMatrix#$clone","Spine.Collections.CollectionExtensions#ToOrderedDictionary","Spine.Collections.CollectionExtensions#ToOrderedDictionary$1","Spine.Collections.OrderedDictionary$2#init","Spine.Collections.OrderedDictionary$2#Comparer#get","Spine.Collections.OrderedDictionary$2#Keys#get","Spine.Collections.OrderedDictionary$2#Values#get","Spine.Collections.OrderedDictionary$2#Count#get","Spine.Collections.OrderedDictionary$2#System$Collections$Generic$IDictionary$2$Keys#get","Spine.Collections.OrderedDictionary$2#System$Collections$Generic$IDictionary$2$Values#get","Spine.Collections.OrderedDictionary$2#System$Collections$Generic$ICollection$1$IsReadOnly#get","Spine.Collections.OrderedDictionary$2#ctor","Spine.Collections.OrderedDictionary$2#$ctor2","Spine.Collections.OrderedDictionary$2#$ctor1","Spine.Collections.OrderedDictionary$2#$ctor3","Spine.Collections.OrderedDictionary$2#getItem$1","Spine.Collections.OrderedDictionary$2#setItem$1","Spine.Collections.OrderedDictionary$2#getItem","Spine.Collections.OrderedDictionary$2#setItem","Spine.Collections.OrderedDictionary$2#System$Collections$Generic$IList$1$getItem","Spine.Collections.OrderedDictionary$2#System$Collections$Generic$IList$1$setItem","Spine.Collections.OrderedDictionary$2#add","Spine.Collections.OrderedDictionary$2#System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$add","Spine.Collections.OrderedDictionary$2#Insert","Spine.Collections.OrderedDictionary$2#System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$insert","Spine.Collections.OrderedDictionary$2#containsKey","Spine.Collections.OrderedDictionary$2#GetKey","Spine.Collections.OrderedDictionary$2#IndexOf","Spine.Collections.OrderedDictionary$2#System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$indexOf","Spine.Collections.OrderedDictionary$2#remove","Spine.Collections.OrderedDictionary$2#System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$remove","Spine.Collections.OrderedDictionary$2#removeAt","Spine.Collections.OrderedDictionary$2#tryGetValue","Spine.Collections.OrderedDictionary$2#clear","Spine.Collections.OrderedDictionary$2#GetEnumerator","Spine.Collections.OrderedDictionary$2#System$Collections$IEnumerable$GetEnumerator","Spine.Collections.OrderedDictionary$2#System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$contains","Spine.Collections.OrderedDictionary$2#System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$copyTo","Spine.Collections.OrderedDictionary$2.KeyCollection#Count#get","Spine.Collections.OrderedDictionary$2.KeyCollection#System$Collections$Generic$ICollection$1$IsReadOnly#get","Spine.Collections.OrderedDictionary$2.KeyCollection#ctor","Spine.Collections.OrderedDictionary$2.KeyCollection#copyTo","Spine.Collections.OrderedDictionary$2.KeyCollection#GetEnumerator","Spine.Collections.OrderedDictionary$2.KeyCollection#System$Collections$IEnumerable$GetEnumerator","Spine.Collections.OrderedDictionary$2.KeyCollection#System$Collections$Generic$ICollection$1$contains","Spine.Collections.OrderedDictionary$2.KeyCollection#System$Collections$Generic$ICollection$1$add","Spine.Collections.OrderedDictionary$2.KeyCollection#System$Collections$Generic$ICollection$1$clear","Spine.Collections.OrderedDictionary$2.KeyCollection#System$Collections$Generic$ICollection$1$remove","Spine.Collections.OrderedDictionary$2.ValueCollection#Count#get","Spine.Collections.OrderedDictionary$2.ValueCollection#System$Collections$Generic$ICollection$1$IsReadOnly#get","Spine.Collections.OrderedDictionary$2.ValueCollection#ctor","Spine.Collections.OrderedDictionary$2.ValueCollection#copyTo","Spine.Collections.OrderedDictionary$2.ValueCollection#GetEnumerator","Spine.Collections.OrderedDictionary$2.ValueCollection#System$Collections$IEnumerable$GetEnumerator","Spine.Collections.OrderedDictionary$2.ValueCollection#System$Collections$Generic$ICollection$1$contains","Spine.Collections.OrderedDictionary$2.ValueCollection#System$Collections$Generic$ICollection$1$add","Spine.Collections.OrderedDictionary$2.ValueCollection#System$Collections$Generic$ICollection$1$clear","Spine.Collections.OrderedDictionary$2.ValueCollection#System$Collections$Generic$ICollection$1$remove","Spine.Collections.OrderedDictionaryDebugView$2#Items#get","Spine.Collections.OrderedDictionaryDebugView$2#ctor","Spine.ConstraintData#Name#get","Spine.ConstraintData#Order#get","Spine.ConstraintData#Order#set","Spine.ConstraintData#SkinRequired#get","Spine.ConstraintData#SkinRequired#set","Spine.ConstraintData#ctor","Spine.ConstraintData#toString","Spine.Event#Data#get","Spine.Event#Time#get","Spine.Event#Int#get","Spine.Event#Int#set","Spine.Event#Float#get","Spine.Event#Float#set","Spine.Event#String#get","Spine.Event#String#set","Spine.Event#Volume#get","Spine.Event#Volume#set","Spine.Event#Balance#get","Spine.Event#Balance#set","Spine.Event#ctor","Spine.Event#toString","Spine.EventData#Name#get","Spine.EventData#ctor","Spine.EventData#toString","Spine.EventQueue#init","Spine.EventQueue#ctor","Spine.EventQueue#Start","Spine.EventQueue#Interrupt","Spine.EventQueue#End","Spine.EventQueue#Dispose","Spine.EventQueue#Complete","Spine.EventQueue#Event","Spine.EventQueue#Drain","Spine.EventQueue#Clear","Spine.EventQueue.EventQueueEntry#getDefaultValue","Spine.EventQueue.EventQueueEntry#$ctor1","Spine.EventQueue.EventQueueEntry#ctor","Spine.EventQueue.EventQueueEntry#getHashCode","Spine.EventQueue.EventQueueEntry#equals","Spine.EventQueue.EventQueueEntry#$clone","Spine.ExposedList$1#init","Spine.ExposedList$1#CheckMatch","Spine.ExposedList$1#Capacity#get","Spine.ExposedList$1#Capacity#set","Spine.ExposedList$1#ctor","Spine.ExposedList$1#$ctor2","Spine.ExposedList$1#$ctor3","Spine.ExposedList$1#$ctor1","Spine.ExposedList$1#Add","Spine.ExposedList$1#GrowIfNeeded","Spine.ExposedList$1#Resize","Spine.ExposedList$1#EnsureCapacity","Spine.ExposedList$1#CheckRange","Spine.ExposedList$1#AddCollection","Spine.ExposedList$1#AddEnumerable","Spine.ExposedList$1#AddRange","Spine.ExposedList$1#AddRange$1","Spine.ExposedList$1#BinarySearch","Spine.ExposedList$1#BinarySearch$1","Spine.ExposedList$1#BinarySearch$2","Spine.ExposedList$1#Clear","Spine.ExposedList$1#Contains","Spine.ExposedList$1#ConvertAll","Spine.ExposedList$1#CopyTo","Spine.ExposedList$1#CopyTo$1","Spine.ExposedList$1#CopyTo$2","Spine.ExposedList$1#Exists","Spine.ExposedList$1#Find","Spine.ExposedList$1#FindAll","Spine.ExposedList$1#FindAllList","Spine.ExposedList$1#FindIndex$2","Spine.ExposedList$1#FindIndex$1","Spine.ExposedList$1#FindIndex","Spine.ExposedList$1#GetIndex","Spine.ExposedList$1#FindLast","Spine.ExposedList$1#FindLastIndex$2","Spine.ExposedList$1#FindLastIndex$1","Spine.ExposedList$1#FindLastIndex","Spine.ExposedList$1#GetLastIndex","Spine.ExposedList$1#ForEach","Spine.ExposedList$1#GetEnumerator","Spine.ExposedList$1#System$Collections$Generic$IEnumerable$1$GetEnumerator","Spine.ExposedList$1#System$Collections$IEnumerable$GetEnumerator","Spine.ExposedList$1#GetRange","Spine.ExposedList$1#IndexOf","Spine.ExposedList$1#IndexOf$1","Spine.ExposedList$1#IndexOf$2","Spine.ExposedList$1#Shift","Spine.ExposedList$1#CheckIndex","Spine.ExposedList$1#Insert","Spine.ExposedList$1#CheckCollection","Spine.ExposedList$1#InsertRange","Spine.ExposedList$1#InsertCollection","Spine.ExposedList$1#InsertEnumeration","Spine.ExposedList$1#LastIndexOf","Spine.ExposedList$1#LastIndexOf$1","Spine.ExposedList$1#LastIndexOf$2","Spine.ExposedList$1#Remove","Spine.ExposedList$1#RemoveAll","Spine.ExposedList$1#RemoveAt","Spine.ExposedList$1#Pop","Spine.ExposedList$1#RemoveRange","Spine.ExposedList$1#Reverse","Spine.ExposedList$1#Reverse$1","Spine.ExposedList$1#Sort","Spine.ExposedList$1#Sort$1","Spine.ExposedList$1#Sort$2","Spine.ExposedList$1#Sort$3","Spine.ExposedList$1#ToArray","Spine.ExposedList$1#TrimExcess","Spine.ExposedList$1#TrueForAll","Spine.ExposedList$1.Enumerator#getDefaultValue","Spine.ExposedList$1.Enumerator#Current#get","Spine.ExposedList$1.Enumerator#System$Collections$IEnumerator$Current#get","Spine.ExposedList$1.Enumerator#init","Spine.ExposedList$1.Enumerator#$ctor1","Spine.ExposedList$1.Enumerator#ctor","Spine.ExposedList$1.Enumerator#Dispose","Spine.ExposedList$1.Enumerator#VerifyState","Spine.ExposedList$1.Enumerator#moveNext","Spine.ExposedList$1.Enumerator#System$Collections$IEnumerator$reset","Spine.ExposedList$1.Enumerator#getHashCode","Spine.ExposedList$1.Enumerator#equals","Spine.ExposedList$1.Enumerator#$clone","Spine.IInterpolation#init","Spine.IInterpolation#Apply","Spine.Json#Deserialize","Spine.MathUtils#init","Spine.MathUtils#Sin","Spine.MathUtils#Cos","Spine.MathUtils#SinDeg","Spine.MathUtils#CosDeg","Spine.MathUtils#Atan2","Spine.MathUtils#Clamp","Spine.MathUtils#RandomTriangle","Spine.MathUtils#RandomTriangle$1","Spine.Polygon#ctor","Spine.Pool$1#Count#get","Spine.Pool$1#ctor","Spine.Pool$1#Obtain","Spine.Pool$1#Free","Spine.Pool$1#Clear","Spine.Pool$1#Reset","Spine.Skeleton#SortReset","Spine.Skeleton#Data#get","Spine.Skeleton#Bones#get","Spine.Skeleton#UpdateCacheList#get","Spine.Skeleton#Slots#get","Spine.Skeleton#DrawOrder#get","Spine.Skeleton#IkConstraints#get","Spine.Skeleton#PathConstraints#get","Spine.Skeleton#TransformConstraints#get","Spine.Skeleton#Skin#get","Spine.Skeleton#Skin#set","Spine.Skeleton#R#get","Spine.Skeleton#R#set","Spine.Skeleton#G#get","Spine.Skeleton#G#set","Spine.Skeleton#B#get","Spine.Skeleton#B#set","Spine.Skeleton#A#get","Spine.Skeleton#A#set","Spine.Skeleton#Time#get","Spine.Skeleton#Time#set","Spine.Skeleton#X#get","Spine.Skeleton#X#set","Spine.Skeleton#Y#get","Spine.Skeleton#Y#set","Spine.Skeleton#ScaleX#get","Spine.Skeleton#ScaleX#set","Spine.Skeleton#ScaleY#get","Spine.Skeleton#ScaleY#set","Spine.Skeleton#FlipX#get","Spine.Skeleton#FlipX#set","Spine.Skeleton#FlipY#get","Spine.Skeleton#FlipY#set","Spine.Skeleton#RootBone#get","Spine.Skeleton#init","Spine.Skeleton#ctor","Spine.Skeleton#UpdateCache","Spine.Skeleton#SortIkConstraint","Spine.Skeleton#SortPathConstraint","Spine.Skeleton#SortTransformConstraint","Spine.Skeleton#SortPathConstraintAttachment$1","Spine.Skeleton#SortPathConstraintAttachment","Spine.Skeleton#SortBone","Spine.Skeleton#UpdateWorldTransform","Spine.Skeleton#UpdateWorldTransform$1","Spine.Skeleton#SetToSetupPose","Spine.Skeleton#SetBonesToSetupPose","Spine.Skeleton#SetSlotsToSetupPose","Spine.Skeleton#FindBone","Spine.Skeleton#FindBoneIndex","Spine.Skeleton#FindSlot","Spine.Skeleton#FindSlotIndex","Spine.Skeleton#SetSkin$1","Spine.Skeleton#SetSkin","Spine.Skeleton#GetAttachment$1","Spine.Skeleton#GetAttachment","Spine.Skeleton#SetAttachment","Spine.Skeleton#FindIkConstraint","Spine.Skeleton#FindTransformConstraint","Spine.Skeleton#FindPathConstraint","Spine.Skeleton#Update","Spine.Skeleton#GetBounds","Spine.SkeletonBinary#init","Spine.SkeletonBinary#GetVersionString","Spine.SkeletonBinary#init","Spine.SkeletonBinary#ctor","Spine.SkeletonBinary#$ctor1","Spine.SkeletonBinary#ReadSkeletonData$1","Spine.SkeletonBinary#ReadSkeletonData","Spine.SkeletonBinary#ReadSkin","Spine.SkeletonBinary#ReadAttachment","Spine.SkeletonBinary#ReadVertices","Spine.SkeletonBinary#ReadFloatArray","Spine.SkeletonBinary#ReadShortArray","Spine.SkeletonBinary#ReadAnimation","Spine.SkeletonBinary#ReadCurve","Spine.SkeletonBinary.SkeletonInput#init","Spine.SkeletonBinary.SkeletonInput#ctor","Spine.SkeletonBinary.SkeletonInput#ReadByte","Spine.SkeletonBinary.SkeletonInput#ReadSByte","Spine.SkeletonBinary.SkeletonInput#ReadBoolean","Spine.SkeletonBinary.SkeletonInput#ReadFloat","Spine.SkeletonBinary.SkeletonInput#ReadInt","Spine.SkeletonBinary.SkeletonInput#ReadInt$1","Spine.SkeletonBinary.SkeletonInput#ReadString","Spine.SkeletonBinary.SkeletonInput#ReadStringRef","Spine.SkeletonBinary.SkeletonInput#ReadFully","Spine.SkeletonBinary.SkeletonInput#GetVersionString","Spine.SkeletonBounds#MinX#get","Spine.SkeletonBounds#MinX#set","Spine.SkeletonBounds#MinY#get","Spine.SkeletonBounds#MinY#set","Spine.SkeletonBounds#MaxX#get","Spine.SkeletonBounds#MaxX#set","Spine.SkeletonBounds#MaxY#get","Spine.SkeletonBounds#MaxY#set","Spine.SkeletonBounds#Width#get","Spine.SkeletonBounds#Height#get","Spine.SkeletonBounds#init","Spine.SkeletonBounds#ctor","Spine.SkeletonBounds#Update","Spine.SkeletonBounds#AabbCompute","Spine.SkeletonBounds#AabbContainsPoint","Spine.SkeletonBounds#AabbIntersectsSegment","Spine.SkeletonBounds#AabbIntersectsSkeleton","Spine.SkeletonBounds#ContainsPoint$1","Spine.SkeletonBounds#ContainsPoint","Spine.SkeletonBounds#IntersectsSegment","Spine.SkeletonBounds#IntersectsSegment$1","Spine.SkeletonBounds#GetPolygon","Spine.SkeletonClipping#MakeClockwise","Spine.SkeletonClipping#ClippedVertices#get","Spine.SkeletonClipping#ClippedTriangles#get","Spine.SkeletonClipping#ClippedUVs#get","Spine.SkeletonClipping#IsClipping#get","Spine.SkeletonClipping#init","Spine.SkeletonClipping#ClipStart","Spine.SkeletonClipping#ClipEnd$1","Spine.SkeletonClipping#ClipEnd","Spine.SkeletonClipping#ClipTriangles","Spine.SkeletonClipping#Clip","Spine.SkeletonData#Name#get","Spine.SkeletonData#Name#set","Spine.SkeletonData#Bones#get","Spine.SkeletonData#Slots#get","Spine.SkeletonData#Skins#get","Spine.SkeletonData#Skins#set","Spine.SkeletonData#DefaultSkin#get","Spine.SkeletonData#DefaultSkin#set","Spine.SkeletonData#Events#get","Spine.SkeletonData#Events#set","Spine.SkeletonData#Animations#get","Spine.SkeletonData#Animations#set","Spine.SkeletonData#IkConstraints#get","Spine.SkeletonData#IkConstraints#set","Spine.SkeletonData#TransformConstraints#get","Spine.SkeletonData#TransformConstraints#set","Spine.SkeletonData#PathConstraints#get","Spine.SkeletonData#PathConstraints#set","Spine.SkeletonData#X#get","Spine.SkeletonData#X#set","Spine.SkeletonData#Y#get","Spine.SkeletonData#Y#set","Spine.SkeletonData#Width#get","Spine.SkeletonData#Width#set","Spine.SkeletonData#Height#get","Spine.SkeletonData#Height#set","Spine.SkeletonData#Version#get","Spine.SkeletonData#Version#set","Spine.SkeletonData#Hash#get","Spine.SkeletonData#Hash#set","Spine.SkeletonData#ImagesPath#get","Spine.SkeletonData#ImagesPath#set","Spine.SkeletonData#AudioPath#get","Spine.SkeletonData#AudioPath#set","Spine.SkeletonData#Fps#get","Spine.SkeletonData#Fps#set","Spine.SkeletonData#init","Spine.SkeletonData#FindBone","Spine.SkeletonData#FindBoneIndex","Spine.SkeletonData#FindSlot","Spine.SkeletonData#FindSlotIndex","Spine.SkeletonData#FindSkin","Spine.SkeletonData#FindEvent","Spine.SkeletonData#FindAnimation","Spine.SkeletonData#FindIkConstraint","Spine.SkeletonData#FindTransformConstraint","Spine.SkeletonData#FindPathConstraint","Spine.SkeletonData#FindPathConstraintIndex","Spine.SkeletonData#toString","Spine.SkeletonJson#ReadCurve","Spine.SkeletonJson#GetFloatArray","Spine.SkeletonJson#GetIntArray","Spine.SkeletonJson#GetFloat","Spine.SkeletonJson#GetInt","Spine.SkeletonJson#GetBoolean","Spine.SkeletonJson#GetString","Spine.SkeletonJson#ToColor","Spine.SkeletonJson#init","Spine.SkeletonJson#ctor","Spine.SkeletonJson#$ctor1","Spine.SkeletonJson#ReadSkeletonData$1","Spine.SkeletonJson#ReadSkeletonData","Spine.SkeletonJson#ReadAttachment","Spine.SkeletonJson#ReadVertices","Spine.SkeletonJson#ReadAnimation","Spine.SkeletonJson.LinkedMesh#ctor","Spine.Skin#Name#get","Spine.Skin#Attachments#get","Spine.Skin#Bones#get","Spine.Skin#Constraints#get","Spine.Skin#init","Spine.Skin#ctor","Spine.Skin#SetAttachment","Spine.Skin#AddSkin","Spine.Skin#CopySkin","Spine.Skin#GetAttachment","Spine.Skin#RemoveAttachment","Spine.Skin#GetAttachments","Spine.Skin#GetAttachments$1","Spine.Skin#Clear","Spine.Skin#toString","Spine.Skin#AttachAll","Spine.Skin.SkinEntry#getDefaultValue","Spine.Skin.SkinEntry#SlotIndex#get","Spine.Skin.SkinEntry#Name#get","Spine.Skin.SkinEntry#Attachment#get","Spine.Skin.SkinEntry#$ctor1","Spine.Skin.SkinEntry#ctor","Spine.Skin.SkinEntry#getHashCode","Spine.Skin.SkinEntry#equals","Spine.Skin.SkinEntry#$clone","Spine.Slot#Data#get","Spine.Slot#Bone#get","Spine.Slot#Skeleton#get","Spine.Slot#R#get","Spine.Slot#R#set","Spine.Slot#G#get","Spine.Slot#G#set","Spine.Slot#B#get","Spine.Slot#B#set","Spine.Slot#A#get","Spine.Slot#A#set","Spine.Slot#R2#get","Spine.Slot#R2#set","Spine.Slot#G2#get","Spine.Slot#G2#set","Spine.Slot#B2#get","Spine.Slot#B2#set","Spine.Slot#HasSecondColor#get","Spine.Slot#HasSecondColor#set","Spine.Slot#Attachment#get","Spine.Slot#Attachment#set","Spine.Slot#AttachmentTime#get","Spine.Slot#AttachmentTime#set","Spine.Slot#Deform#get","Spine.Slot#Deform#set","Spine.Slot#init","Spine.Slot#$ctor1","Spine.Slot#ctor","Spine.Slot#ClampColor","Spine.Slot#ClampSecondColor","Spine.Slot#SetToSetupPose","Spine.Slot#toString","Spine.SlotData#Index#get","Spine.SlotData#Name#get","Spine.SlotData#BoneData#get","Spine.SlotData#R#get","Spine.SlotData#R#set","Spine.SlotData#G#get","Spine.SlotData#G#set","Spine.SlotData#B#get","Spine.SlotData#B#set","Spine.SlotData#A#get","Spine.SlotData#A#set","Spine.SlotData#R2#get","Spine.SlotData#R2#set","Spine.SlotData#G2#get","Spine.SlotData#G2#set","Spine.SlotData#B2#get","Spine.SlotData#B2#set","Spine.SlotData#HasSecondColor#get","Spine.SlotData#HasSecondColor#set","Spine.SlotData#AttachmentName#get","Spine.SlotData#AttachmentName#set","Spine.SlotData#BlendMode#get","Spine.SlotData#BlendMode#set","Spine.SlotData#init","Spine.SlotData#ctor","Spine.SlotData#toString","Spine.SpineSkeletonExtensions#IsWeighted","Spine.SpineSkeletonExtensions#IsRenderable","Spine.SpineSkeletonExtensions#InheritsRotation","Spine.SpineSkeletonExtensions#InheritsScale","Spine.SpineSkeletonExtensions#SetPropertyToSetupPose","Spine.SpineSkeletonExtensions#SetDrawOrderToSetupPose","Spine.SpineSkeletonExtensions#SetSlotAttachmentsToSetupPose","Spine.SpineSkeletonExtensions#SetColorToSetupPose","Spine.SpineSkeletonExtensions#SetAttachmentToSetupPose","Spine.SpineSkeletonExtensions#SetSlotAttachmentToSetupPose","Spine.SpineSkeletonExtensions#SetKeyedItemsToSetupPose","Spine.SpineSkeletonExtensions#AllowImmediateQueue","Spine.Triangulator#IsConcave","Spine.Triangulator#PositiveArea","Spine.Triangulator#Winding","Spine.Triangulator#init","Spine.Triangulator#Triangulate","Spine.Triangulator#Decompose","Spine.Unity.ActivateBasedOnFlipDirection#init","Spine.Unity.ActivateBasedOnFlipDirection#Start","Spine.Unity.ActivateBasedOnFlipDirection#FixedUpdate","Spine.Unity.ActivateBasedOnFlipDirection#HandleFlip","Spine.Unity.ActivateBasedOnFlipDirection#ResetJointPositions","Spine.Unity.ActivateBasedOnFlipDirection#CompensateMovementAfterFlipX","Spine.Unity.AnimationTools.TimelineExtensions#Evaluate","Spine.Unity.AnimationTools.TimelineExtensions#FindTranslateTimelineForBone","Spine.Unity.AttachmentTools.AtlasUtilities#init","Spine.Unity.AttachmentTools.AtlasUtilities#Init","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$2","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$3","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$1","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$4","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$2","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$3","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$1","Spine.Unity.AttachmentTools.AtlasUtilities#ToSpineAtlasPage","Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedAttachments","Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedSkin","Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedSkin$1","Spine.Unity.AttachmentTools.AtlasUtilities#ToSprite","Spine.Unity.AttachmentTools.AtlasUtilities#ClearCache","Spine.Unity.AttachmentTools.AtlasUtilities#ToTexture","Spine.Unity.AttachmentTools.AtlasUtilities#ToTexture$1","Spine.Unity.AttachmentTools.AtlasUtilities#GetClone","Spine.Unity.AttachmentTools.AtlasUtilities#CopyTexture","Spine.Unity.AttachmentTools.AtlasUtilities#CopyTextureApplyPMA","Spine.Unity.AttachmentTools.AtlasUtilities#IsRenderable","Spine.Unity.AttachmentTools.AtlasUtilities#SpineUnityFlipRect","Spine.Unity.AttachmentTools.AtlasUtilities#GetUnityRect","Spine.Unity.AttachmentTools.AtlasUtilities#GetUnityRect$1","Spine.Unity.AttachmentTools.AtlasUtilities#GetSpineAtlasRect","Spine.Unity.AttachmentTools.AtlasUtilities#UVRectToTextureRect","Spine.Unity.AttachmentTools.AtlasUtilities#TextureRectToUVRect","Spine.Unity.AttachmentTools.AtlasUtilities#UVRectToAtlasRegion","Spine.Unity.AttachmentTools.AtlasUtilities#GetMainTexture","Spine.Unity.AttachmentTools.AtlasUtilities#GetTexture$1","Spine.Unity.AttachmentTools.AtlasUtilities#GetTexture","Spine.Unity.AttachmentTools.AtlasUtilities#CopyTextureAttributesFrom","Spine.Unity.AttachmentTools.AtlasUtilities#InverseLerp","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#getDefaultValue","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#$ctor1","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#ctor","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#getHashCode","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#equals","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#$clone","Spine.Unity.AttachmentTools.AttachmentCloneExtensions#GetCopy","Spine.Unity.AttachmentTools.AttachmentCloneExtensions#GetLinkedMesh","Spine.Unity.AttachmentTools.AttachmentCloneExtensions#GetLinkedMesh$2","Spine.Unity.AttachmentTools.AttachmentCloneExtensions#GetLinkedMesh$1","Spine.Unity.AttachmentTools.AttachmentCloneExtensions#GetRemappedClone$1","Spine.Unity.AttachmentTools.AttachmentCloneExtensions#GetRemappedClone","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#GetRegion","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#GetRegion$2","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#GetRegion$1","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetRegion","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetRegion$2","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetRegion$1","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment$2","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment$1","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachmentPMAClone$1","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachmentPMAClone","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetScale$1","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetScale","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetPositionOffset$1","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetPositionOffset","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetRotation","Spine.Unity.AttachmentTools.SkinUtilities#UnshareSkin","Spine.Unity.AttachmentTools.SkinUtilities#GetClonedSkin","Spine.Unity.AttachmentTools.SkinUtilities#GetClone","Spine.Unity.AttachmentTools.SkinUtilities#SetAttachment$1","Spine.Unity.AttachmentTools.SkinUtilities#SetAttachment","Spine.Unity.AttachmentTools.SkinUtilities#AddAttachments","Spine.Unity.AttachmentTools.SkinUtilities#GetAttachment","Spine.Unity.AttachmentTools.SkinUtilities#RemoveAttachment","Spine.Unity.AttachmentTools.SkinUtilities#Clear","Spine.Unity.AttachmentTools.SkinUtilities#Append","Spine.Unity.AttachmentTools.SkinUtilities#CopyTo","Spine.Unity.BlendModeMaterials#RequiresBlendModeMaterials#get","Spine.Unity.BlendModeMaterials#RequiresBlendModeMaterials#set","Spine.Unity.BlendModeMaterials#init","Spine.Unity.BlendModeMaterials#ApplyMaterials","Spine.Unity.BlendModeMaterials#CloneAtlasRegionWithMaterial","Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#init","Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#CloneAtlasRegionWithMaterial","Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#GetAtlasPageWithMaterial","Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#Dispose","Spine.Unity.BoneFollower#SkeletonRenderer#get","Spine.Unity.BoneFollower#SkeletonRenderer#set","Spine.Unity.BoneFollower#init","Spine.Unity.BoneFollower#SetBone","Spine.Unity.BoneFollower#Awake","Spine.Unity.BoneFollower#HandleRebuildRenderer","Spine.Unity.BoneFollower#Initialize","Spine.Unity.BoneFollower#OnDestroy","Spine.Unity.BoneFollower#LateUpdate","Spine.Unity.BoneFollowerGraphic#SkeletonGraphic#get","Spine.Unity.BoneFollowerGraphic#SkeletonGraphic#set","Spine.Unity.BoneFollowerGraphic#init","Spine.Unity.BoneFollowerGraphic#SetBone","Spine.Unity.BoneFollowerGraphic#Awake","Spine.Unity.BoneFollowerGraphic#Initialize","Spine.Unity.BoneFollowerGraphic#LateUpdate","Spine.Unity.BoundingBoxFollower#init","Spine.Unity.BoundingBoxFollower#Slot#get","Spine.Unity.BoundingBoxFollower#CurrentAttachment#get","Spine.Unity.BoundingBoxFollower#CurrentAttachmentName#get","Spine.Unity.BoundingBoxFollower#CurrentCollider#get","Spine.Unity.BoundingBoxFollower#IsTrigger#get","Spine.Unity.BoundingBoxFollower#init","Spine.Unity.BoundingBoxFollower#Start","Spine.Unity.BoundingBoxFollower#OnEnable","Spine.Unity.BoundingBoxFollower#HandleRebuild","Spine.Unity.BoundingBoxFollower#Initialize","Spine.Unity.BoundingBoxFollower#AddCollidersForSkin","Spine.Unity.BoundingBoxFollower#OnDisable","Spine.Unity.BoundingBoxFollower#ClearState","Spine.Unity.BoundingBoxFollower#DisposeExcessCollidersAfter","Spine.Unity.BoundingBoxFollower#LateUpdate","Spine.Unity.BoundingBoxFollower#MatchAttachment","Spine.Unity.BoundingBoxFollowerGraphic#init","Spine.Unity.BoundingBoxFollowerGraphic#Slot#get","Spine.Unity.BoundingBoxFollowerGraphic#CurrentAttachment#get","Spine.Unity.BoundingBoxFollowerGraphic#CurrentAttachmentName#get","Spine.Unity.BoundingBoxFollowerGraphic#CurrentCollider#get","Spine.Unity.BoundingBoxFollowerGraphic#IsTrigger#get","Spine.Unity.BoundingBoxFollowerGraphic#init","Spine.Unity.BoundingBoxFollowerGraphic#Start","Spine.Unity.BoundingBoxFollowerGraphic#OnEnable","Spine.Unity.BoundingBoxFollowerGraphic#HandleRebuild","Spine.Unity.BoundingBoxFollowerGraphic#Initialize","Spine.Unity.BoundingBoxFollowerGraphic#AddCollidersForSkin","Spine.Unity.BoundingBoxFollowerGraphic#OnDisable","Spine.Unity.BoundingBoxFollowerGraphic#ClearState","Spine.Unity.BoundingBoxFollowerGraphic#DisposeExcessCollidersAfter","Spine.Unity.BoundingBoxFollowerGraphic#LateUpdate","Spine.Unity.BoundingBoxFollowerGraphic#MatchAttachment","Spine.Unity.Deprecated.SlotBlendModes#MaterialTable#get","Spine.Unity.Deprecated.SlotBlendModes#GetOrAddMaterialFor","Spine.Unity.Deprecated.SlotBlendModes#GetExistingMaterialFor","Spine.Unity.Deprecated.SlotBlendModes#RemoveMaterialFromTable","Spine.Unity.Deprecated.SlotBlendModes#init","Spine.Unity.Deprecated.SlotBlendModes#Start","Spine.Unity.Deprecated.SlotBlendModes#OnDestroy","Spine.Unity.Deprecated.SlotBlendModes#Apply","Spine.Unity.Deprecated.SlotBlendModes#Remove","Spine.Unity.Deprecated.SlotBlendModes#GetTexture","Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair#getDefaultValue","Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair#ctor","Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair#getHashCode","Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair#equals","Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair#$clone","Spine.Unity.Deprecated.SlotBlendModes.MaterialWithRefcount#init","Spine.Unity.Deprecated.SlotBlendModes.MaterialWithRefcount#ctor","Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple#getDefaultValue","Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple#$ctor1","Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple#ctor","Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple#getHashCode","Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple#equals","Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple#$clone","Spine.Unity.DoubleBuffered$1#init","Spine.Unity.DoubleBuffered$1#GetCurrent","Spine.Unity.DoubleBuffered$1#GetNext","Spine.Unity.EventDataReferenceAsset#init","Spine.Unity.EventDataReferenceAsset#op_Implicit","Spine.Unity.EventDataReferenceAsset#EventData#get","Spine.Unity.EventDataReferenceAsset#Initialize","Spine.Unity.FollowLocationRigidbody#Awake","Spine.Unity.FollowLocationRigidbody#FixedUpdate","Spine.Unity.FollowLocationRigidbody2D#Awake","Spine.Unity.FollowLocationRigidbody2D#FixedUpdate","Spine.Unity.FollowSkeletonUtilityRootRotation#init","Spine.Unity.FollowSkeletonUtilityRootRotation#init","Spine.Unity.FollowSkeletonUtilityRootRotation#Start","Spine.Unity.FollowSkeletonUtilityRootRotation#FixedUpdate","Spine.Unity.FollowSkeletonUtilityRootRotation#CompensatePositionToYRotation","Spine.Unity.FollowSkeletonUtilityRootRotation#CompensatePositionToXRotation","Spine.Unity.MeshGenerator#init","Spine.Unity.MeshGenerator#GenerateSingleSubmeshInstruction","Spine.Unity.MeshGenerator#RequiresMultipleSubmeshesByDrawOrder","Spine.Unity.MeshGenerator#GenerateSkeletonRendererInstruction","Spine.Unity.MeshGenerator#TryReplaceMaterials","Spine.Unity.MeshGenerator#SolveTangents2DEnsureSize","Spine.Unity.MeshGenerator#SolveTangents2DTriangles","Spine.Unity.MeshGenerator#SolveTangents2DBuffer","Spine.Unity.MeshGenerator#FillMeshLocal$1","Spine.Unity.MeshGenerator#FillMeshLocal","Spine.Unity.MeshGenerator#VertexCount#get","Spine.Unity.MeshGenerator#Buffers#get","Spine.Unity.MeshGenerator#init","Spine.Unity.MeshGenerator#ctor","Spine.Unity.MeshGenerator#Begin","Spine.Unity.MeshGenerator#AddSubmesh","Spine.Unity.MeshGenerator#BuildMesh","Spine.Unity.MeshGenerator#BuildMeshWithArrays","Spine.Unity.MeshGenerator#ScaleVertexData","Spine.Unity.MeshGenerator#AddAttachmentTintBlack","Spine.Unity.MeshGenerator#FillVertexData","Spine.Unity.MeshGenerator#FillLateVertexData","Spine.Unity.MeshGenerator#FillTriangles","Spine.Unity.MeshGenerator#EnsureVertexCapacity","Spine.Unity.MeshGenerator#TrimExcess","Spine.Unity.MeshGenerator.Settings#Default#get","Spine.Unity.MeshGenerator.Settings#getDefaultValue","Spine.Unity.MeshGenerator.Settings#ctor","Spine.Unity.MeshGenerator.Settings#getHashCode","Spine.Unity.MeshGenerator.Settings#equals","Spine.Unity.MeshGenerator.Settings#$clone","Spine.Unity.MeshGeneratorBuffers#getDefaultValue","Spine.Unity.MeshGeneratorBuffers#ctor","Spine.Unity.MeshGeneratorBuffers#getHashCode","Spine.Unity.MeshGeneratorBuffers#equals","Spine.Unity.MeshGeneratorBuffers#$clone","Spine.Unity.MeshRendererBuffers#init","Spine.Unity.MeshRendererBuffers#Initialize","Spine.Unity.MeshRendererBuffers#GetUpdatedSharedMaterialsArray","Spine.Unity.MeshRendererBuffers#MaterialsChangedInLastUpdate","Spine.Unity.MeshRendererBuffers#UpdateSharedMaterials","Spine.Unity.MeshRendererBuffers#GetNextMesh","Spine.Unity.MeshRendererBuffers#Clear","Spine.Unity.MeshRendererBuffers#Dispose","Spine.Unity.MeshRendererBuffers.SmartMesh#init","Spine.Unity.MeshRendererBuffers.SmartMesh#Clear","Spine.Unity.MeshRendererBuffers.SmartMesh#Dispose","Spine.Unity.SkeletonDataAsset#CreateRuntimeInstance","Spine.Unity.SkeletonDataAsset#CreateRuntimeInstance$1","Spine.Unity.SkeletonDataAsset#ReadSkeletonData","Spine.Unity.SkeletonDataAsset#ReadSkeletonData$1","Spine.Unity.SkeletonDataAsset#IsLoaded#get","Spine.Unity.SkeletonDataAsset#init","Spine.Unity.SkeletonDataAsset#Reset","Spine.Unity.SkeletonDataAsset#Clear","Spine.Unity.SkeletonDataAsset#GetAnimationStateData","Spine.Unity.SkeletonDataAsset#GetSkeletonData","Spine.Unity.SkeletonDataAsset#InitializeWithData","Spine.Unity.SkeletonDataAsset#FillStateData","Spine.Unity.SkeletonDataAsset#GetAtlasArray","Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo#DescriptionString","Spine.Unity.SkeletonExtensions#init","Spine.Unity.SkeletonExtensions#GetColor$2","Spine.Unity.SkeletonExtensions#GetColor$1","Spine.Unity.SkeletonExtensions#GetColor","Spine.Unity.SkeletonExtensions#GetColor$3","Spine.Unity.SkeletonExtensions#GetColorTintBlack","Spine.Unity.SkeletonExtensions#SetColor$4","Spine.Unity.SkeletonExtensions#SetColor$5","Spine.Unity.SkeletonExtensions#SetColor$6","Spine.Unity.SkeletonExtensions#SetColor$7","Spine.Unity.SkeletonExtensions#SetColor$2","Spine.Unity.SkeletonExtensions#SetColor$3","Spine.Unity.SkeletonExtensions#SetColor","Spine.Unity.SkeletonExtensions#SetColor$1","Spine.Unity.SkeletonExtensions#SetLocalScale","Spine.Unity.SkeletonExtensions#GetMatrix4x4","Spine.Unity.SkeletonExtensions#SetLocalPosition","Spine.Unity.SkeletonExtensions#SetLocalPosition$1","Spine.Unity.SkeletonExtensions#GetLocalPosition","Spine.Unity.SkeletonExtensions#GetSkeletonSpacePosition","Spine.Unity.SkeletonExtensions#GetSkeletonSpacePosition$1","Spine.Unity.SkeletonExtensions#GetWorldPosition","Spine.Unity.SkeletonExtensions#GetWorldPosition$1","Spine.Unity.SkeletonExtensions#GetWorldPosition$3","Spine.Unity.SkeletonExtensions#GetWorldPosition$2","Spine.Unity.SkeletonExtensions#GetQuaternion","Spine.Unity.SkeletonExtensions#GetLocalQuaternion","Spine.Unity.SkeletonExtensions#GetLocalScale","Spine.Unity.SkeletonExtensions#GetWorldToLocalMatrix","Spine.Unity.SkeletonExtensions#WorldToLocal","Spine.Unity.SkeletonExtensions#SetPositionSkeletonSpace","Spine.Unity.SkeletonExtensions#GetMaterial","Spine.Unity.SkeletonExtensions#GetLocalVertices","Spine.Unity.SkeletonExtensions#GetWorldVertices","Spine.Unity.SkeletonGraphicCustomMaterials#init","Spine.Unity.SkeletonGraphicCustomMaterials#SetCustomMaterialOverrides","Spine.Unity.SkeletonGraphicCustomMaterials#RemoveCustomMaterialOverrides","Spine.Unity.SkeletonGraphicCustomMaterials#SetCustomTextureOverrides","Spine.Unity.SkeletonGraphicCustomMaterials#RemoveCustomTextureOverrides","Spine.Unity.SkeletonGraphicCustomMaterials#OnEnable","Spine.Unity.SkeletonGraphicCustomMaterials#OnDisable","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#inherits","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#getDefaultValue","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#ctor","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#equalsT","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#getHashCode","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#$clone","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#inherits","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#getDefaultValue","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#ctor","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#equalsT","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#getHashCode","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#$clone","Spine.Unity.SkeletonMecanim.MecanimTranslator#init","Spine.Unity.SkeletonMecanim.MecanimTranslator#AnimationTime$1","Spine.Unity.SkeletonMecanim.MecanimTranslator#AnimationTime","Spine.Unity.SkeletonMecanim.MecanimTranslator#Animator#get","Spine.Unity.SkeletonMecanim.MecanimTranslator#MecanimLayerCount#get","Spine.Unity.SkeletonMecanim.MecanimTranslator#MecanimLayerNames#get","Spine.Unity.SkeletonMecanim.MecanimTranslator#init","Spine.Unity.SkeletonMecanim.MecanimTranslator#addOnClipApplied","Spine.Unity.SkeletonMecanim.MecanimTranslator#removeOnClipApplied","Spine.Unity.SkeletonMecanim.MecanimTranslator#Initialize","Spine.Unity.SkeletonMecanim.MecanimTranslator#ApplyAnimation","Spine.Unity.SkeletonMecanim.MecanimTranslator#ApplyInterruptionAnimation","Spine.Unity.SkeletonMecanim.MecanimTranslator#OnClipAppliedCallback","Spine.Unity.SkeletonMecanim.MecanimTranslator#Apply","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetActiveAnimationAndTime","Spine.Unity.SkeletonMecanim.MecanimTranslator#InitClipInfosForLayers","Spine.Unity.SkeletonMecanim.MecanimTranslator#ClearClipInfosForLayers","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetMixMode","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetStateUpdatesFromAnimator","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimatorClipInfos","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimatorStateInfos","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimation","Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#init","Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#equals2","Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#getHashCode2","Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos#init","Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#init","Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#equals2","Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#getHashCode2","Spine.Unity.SkeletonRootMotionBase#UsesRigidbody#get","Spine.Unity.SkeletonRootMotionBase#AdditionalScale#get","Spine.Unity.SkeletonRootMotionBase#init","Spine.Unity.SkeletonRootMotionBase#Reset","Spine.Unity.SkeletonRootMotionBase#Start","Spine.Unity.SkeletonRootMotionBase#FixedUpdate","Spine.Unity.SkeletonRootMotionBase#OnDisable","Spine.Unity.SkeletonRootMotionBase#FindRigidbodyComponent","Spine.Unity.SkeletonRootMotionBase#SetRootMotionBone","Spine.Unity.SkeletonRootMotionBase#AdjustRootMotionToDistance","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotion","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotion$1","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionInfo","Spine.Unity.SkeletonRootMotionBase#GetTimelineMovementDelta","Spine.Unity.SkeletonRootMotionBase#GatherTopLevelBones","Spine.Unity.SkeletonRootMotionBase#HandleUpdateLocal","Spine.Unity.SkeletonRootMotionBase#ApplyRootMotion","Spine.Unity.SkeletonRootMotionBase#GetScaleAffectingRootMotion","Spine.Unity.SkeletonRootMotionBase#GetScaleAffectingRootMotion$1","Spine.Unity.SkeletonRootMotionBase#GetSkeletonSpaceMovementDelta","Spine.Unity.SkeletonRootMotionBase#SetEffectiveBoneOffsetsTo","Spine.Unity.SkeletonRootMotionBase#ClearEffectiveBoneOffsets","Spine.Unity.SkeletonPartsRenderer#NewPartsRendererGameObject","Spine.Unity.SkeletonPartsRenderer#MeshGenerator#get","Spine.Unity.SkeletonPartsRenderer#MeshRenderer#get","Spine.Unity.SkeletonPartsRenderer#MeshFilter#get","Spine.Unity.SkeletonPartsRenderer#init","Spine.Unity.SkeletonPartsRenderer#LazyIntialize","Spine.Unity.SkeletonPartsRenderer#ClearMesh","Spine.Unity.SkeletonPartsRenderer#RenderParts","Spine.Unity.SkeletonPartsRenderer#SetPropertyBlock","Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials#AnyMaterialCreated#get","Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials#init","Spine.Unity.SkeletonRendererCustomMaterials#init","Spine.Unity.SkeletonRendererCustomMaterials#SetCustomSlotMaterials","Spine.Unity.SkeletonRendererCustomMaterials#RemoveCustomSlotMaterials","Spine.Unity.SkeletonRendererCustomMaterials#SetCustomMaterialOverrides","Spine.Unity.SkeletonRendererCustomMaterials#RemoveCustomMaterialOverrides","Spine.Unity.SkeletonRendererCustomMaterials#OnEnable","Spine.Unity.SkeletonRendererCustomMaterials#OnDisable","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#inherits","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#getDefaultValue","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#ctor","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#equalsT","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#getHashCode","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#$clone","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#inherits","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#getDefaultValue","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#ctor","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#equalsT","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#getHashCode","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#$clone","Spine.Unity.SkeletonRendererInstruction#GeometryNotEqual","Spine.Unity.SkeletonRendererInstruction#init","Spine.Unity.SkeletonRendererInstruction#Clear","Spine.Unity.SkeletonRendererInstruction#Dispose","Spine.Unity.SkeletonRendererInstruction#SetWithSubset","Spine.Unity.SkeletonRendererInstruction#Set","Spine.Unity.SkeletonRenderSeparator#init","Spine.Unity.SkeletonRenderSeparator#AddToSkeletonRenderer","Spine.Unity.SkeletonRenderSeparator#SkeletonRenderer#get","Spine.Unity.SkeletonRenderSeparator#SkeletonRenderer#set","Spine.Unity.SkeletonRenderSeparator#init","Spine.Unity.SkeletonRenderSeparator#AddPartsRenderer","Spine.Unity.SkeletonRenderSeparator#OnEnable","Spine.Unity.SkeletonRenderSeparator#OnDisable","Spine.Unity.SkeletonRenderSeparator#HandleRender","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#getDefaultValue","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#init","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#ctor","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#getHashCode","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#equals","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#$clone","Spine.Unity.SkeletonUtility#AddBoundingBoxGameObject","Spine.Unity.SkeletonUtility#AddBoundingBoxGameObject$1","Spine.Unity.SkeletonUtility#AddBoundingBoxAsComponent","Spine.Unity.SkeletonUtility#SetColliderPointsLocal","Spine.Unity.SkeletonUtility#GetBoundingBoxBounds","Spine.Unity.SkeletonUtility#AddBoneRigidbody2D","Spine.Unity.SkeletonUtility#SkeletonComponent#get","Spine.Unity.SkeletonUtility#Skeleton#get","Spine.Unity.SkeletonUtility#IsValid#get","Spine.Unity.SkeletonUtility#PositionScale#get","Spine.Unity.SkeletonUtility#init","Spine.Unity.SkeletonUtility#Update","Spine.Unity.SkeletonUtility#ResubscribeEvents","Spine.Unity.SkeletonUtility#OnEnable","Spine.Unity.SkeletonUtility#Start","Spine.Unity.SkeletonUtility#OnDisable","Spine.Unity.SkeletonUtility#HandleRendererReset$1","Spine.Unity.SkeletonUtility#HandleRendererReset","Spine.Unity.SkeletonUtility#RegisterBone","Spine.Unity.SkeletonUtility#UnregisterBone","Spine.Unity.SkeletonUtility#RegisterConstraint","Spine.Unity.SkeletonUtility#UnregisterConstraint","Spine.Unity.SkeletonUtility#CollectBones","Spine.Unity.SkeletonUtility#UpdateLocal","Spine.Unity.SkeletonUtility#UpdateWorld","Spine.Unity.SkeletonUtility#UpdateComplete","Spine.Unity.SkeletonUtility#UpdateAllBones","Spine.Unity.SkeletonUtility#GetBoneRoot","Spine.Unity.SkeletonUtility#SpawnRoot","Spine.Unity.SkeletonUtility#SpawnHierarchy","Spine.Unity.SkeletonUtility#SpawnBoneRecursively","Spine.Unity.SkeletonUtility#SpawnBone","Spine.Unity.SkeletonUtilityBone#BoneTransformModeIncompatible","Spine.Unity.SkeletonUtilityBone#IncompatibleTransformMode#get","Spine.Unity.SkeletonUtilityBone#init","Spine.Unity.SkeletonUtilityBone#Reset","Spine.Unity.SkeletonUtilityBone#OnEnable","Spine.Unity.SkeletonUtilityBone#HandleOnReset","Spine.Unity.SkeletonUtilityBone#OnDisable","Spine.Unity.SkeletonUtilityBone#DoUpdate","Spine.Unity.SkeletonUtilityBone#AddBoundingBox","Spine.Unity.SkeletonUtilityConstraint#OnEnable","Spine.Unity.SkeletonUtilityConstraint#OnDisable","Spine.Unity.SpineAttributeBase#init","Spine.Unity.SpineAtlasRegion#ctor","Spine.Unity.SpineAttachment.Hierarchy#getDefaultValue","Spine.Unity.SpineAttachment.Hierarchy#$ctor1","Spine.Unity.SpineAttachment.Hierarchy#ctor","Spine.Unity.SpineAttachment.Hierarchy#getHashCode","Spine.Unity.SpineAttachment.Hierarchy#equals","Spine.Unity.SpineAttachment.Hierarchy#$clone","Spine.Unity.SpineMesh#init","Spine.Unity.SpineMesh#NewSkeletonMesh","Spine.Unity.SubmeshInstruction#getDefaultValue","Spine.Unity.SubmeshInstruction#SlotCount#get","Spine.Unity.SubmeshInstruction#ctor","Spine.Unity.SubmeshInstruction#toString","Spine.Unity.SubmeshInstruction#getHashCode","Spine.Unity.SubmeshInstruction#equals","Spine.Unity.SubmeshInstruction#$clone","Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$Current#get","Spine.Unity.WaitForSpineAnimation#init","Spine.Unity.WaitForSpineAnimation#ctor","Spine.Unity.WaitForSpineAnimation#NowWaitFor","Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$moveNext","Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$reset","Spine.Unity.WaitForSpineAnimation#SafeSubscribe","Spine.Unity.WaitForSpineAnimation#HandleComplete","Spine.Unity.WaitForSpineEvent#WillUnsubscribeAfterFiring#get","Spine.Unity.WaitForSpineEvent#WillUnsubscribeAfterFiring#set","Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$Current#get","Spine.Unity.WaitForSpineEvent#init","Spine.Unity.WaitForSpineEvent#ctor","Spine.Unity.WaitForSpineEvent#$ctor2","Spine.Unity.WaitForSpineEvent#$ctor1","Spine.Unity.WaitForSpineEvent#$ctor3","Spine.Unity.WaitForSpineEvent#Subscribe","Spine.Unity.WaitForSpineEvent#SubscribeByName","Spine.Unity.WaitForSpineEvent#HandleAnimationStateEventByName","Spine.Unity.WaitForSpineEvent#HandleAnimationStateEvent","Spine.Unity.WaitForSpineEvent#NowWaitFor","Spine.Unity.WaitForSpineEvent#NowWaitFor$1","Spine.Unity.WaitForSpineEvent#Clear","Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$moveNext","Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$reset","Spine.Unity.WaitForSpineTrackEntryEnd#System$Collections$IEnumerator$Current#get","Spine.Unity.WaitForSpineTrackEntryEnd#init","Spine.Unity.WaitForSpineTrackEntryEnd#ctor","Spine.Unity.WaitForSpineTrackEntryEnd#HandleEnd","Spine.Unity.WaitForSpineTrackEntryEnd#SafeSubscribe","Spine.Unity.WaitForSpineTrackEntryEnd#NowWaitFor","Spine.Unity.WaitForSpineTrackEntryEnd#System$Collections$IEnumerator$moveNext","Spine.Unity.WaitForSpineTrackEntryEnd#System$Collections$IEnumerator$reset","TransformToMouseDirection#init","TransformToMouseDirection#Start","TransformToMouseDirection#Update","VectorUlti#GetVectorFromAngle","VectorUlti#GetAngleFromVector","VectorUlti#Set$1","VectorUlti#Set","VectorUlti#Move","VectorUlti#ToVectorXZ","Water2D._SpawnExampleController#Start","Water2D._SpawnExampleController#Update","Water2D.ColliderFiller#GetBoxPoints","Water2D.ColliderFiller#GetCirclePoints","Water2D.ColliderFiller#GetPolygonPoints","Water2D.ColliderFiller#IsPointInPolygon","Water2D.ColliderFiller#PointsInside#get","Water2D.ColliderFiller#PointsOutside#get","Water2D.ColliderFiller#InsidePointsCount#get","Water2D.ColliderFiller#OutsidePointsCount#get","Water2D.ColliderFiller#Radius#get","Water2D.ColliderFiller#init","Water2D.ColliderFiller#Update","Water2D.ColliderFiller#Refresh","Water2D.ColliderFiller#Fill","Water2D.ColliderFiller#Clear","Water2D.ColliderFiller#GetPointsInCollider","Water2D.ColliderFiller#FillByGrid","Water2D.ColorPicker#Update","Water2D.Extentions.ColliderTrigger#init","Water2D.Extentions.ColliderTrigger#Start","Water2D.Extentions.ColliderTrigger#Apply","Water2D.Extentions.ColliderTrigger#CheckFilled","Water2D.Extentions.ColliderTrigger#OnTriggerEnter2D","Water2D.Extentions.ColliderTrigger#OnTriggerExit2D","Water2D.MetaballCameraEffect#Restart","Water2D.MetaballCameraEffect#OnEnable","Water2D.MetaballCameraEffect#OnDisable","Water2D.MetaballCameraEffect#Start","Water2D.MetaballCameraEffect#OnRenderImage","Water2D.microSpawn#getDefaultValue","Water2D.microSpawn#init","Water2D.microSpawn#$ctor1","Water2D.microSpawn#ctor","Water2D.microSpawn#getHashCode","Water2D.microSpawn#equals","Water2D.microSpawn#$clone","Water2D.SpawnersManager#Initialize","Water2D.SpawnersManager#RegisterSpawner","Water2D.SpawnersManager#ChangeSpawnerValues","Water2D.SpawnersManager#DeleteSpawnerValues","Water2D.SpawnersManager#SetFresnelColor","Water2D.SpawnersManager#SetSorting","Water2D.SpawnersManager#GetAllParticles","Water2D.SpawnersManager#init","Water2D.SpawnersManager#clearColorBuffers","Water2D.SpawnersManager#reloadAllSpawners","Water2D.SpawnersManager#Update","Water2D.SpawnersManager#isCloseTo","Water2D.SpawnersManager#setFloatToShader","Water2D.SpawnersManager#setArraysToShader","Water2D.SpawnersManager#convertToarrayOfSize$1","Water2D.SpawnersManager#convertToarrayOfSize","Water2D.SpawnersManager#fetchAllParticles","Water2D.Water2D_Spawner#init","Water2D.Water2D_Spawner#Awake","Water2D.Water2D_Spawner#Start","Water2D.Water2D_Spawner#StartEnumerator","Water2D.Water2D_Spawner#RunSpawner","Water2D.Water2D_Spawner#StopSpawner","Water2D.Water2D_Spawner#SetupParticles","Water2D.Water2D_Spawner#Update","Water2D.Water2D_Spawner#CallShapeFillValidationUpdate","Water2D.Water2D_Spawner#Spawn","Water2D.Water2D_Spawner#Spawn$1","Water2D.Water2D_Spawner#Spawn$2","Water2D.Water2D_Spawner#Spawn$3","Water2D.Water2D_Spawner#SpawnAll","Water2D.Water2D_Spawner#StopSpawning","Water2D.Water2D_Spawner#Restore","Water2D.Water2D_Spawner#loop_editor","Water2D.Water2D_Spawner#loop","Water2D.Water2D_Spawner#SpawnAllParticles","Water2D.Water2D_Spawner#InvokeOnShapeFill","Water2D.Water2D_Spawner#InvokeOnCollisionEnter2D","Water2D.Water2D_Spawner#InvokeOnSpawnerStart","Water2D.Water2D_Spawner#InvokeOnSpawnerEnd","Water2D.Water2D_Spawner#InvokeOnSpawnerEmittinEachParticle","Water2D.Water2D_Spawner#SetRegularWaterparams","Water2D.Water2D_Spawner#UpdateQuietParticleProperties","Water2D.Water2D_Spawner#GetCurrentMaterial","Water2D.Water2D_Spawner#StartCheckingFillShape","Water2D.Water2D_Spawner#RestoreCheckingFillShape","Water2D.Water2D_Spawner#_restoreCheckingFillShapeEnum","Water2D.Water2D_Spawner#CheckOnFill","Water2D.Water2D_Spawner#OnDestroy","Singleton$1#Instance#get","Ice#gravityDirection#get","Ice#init","Ice#OnValidate","Ice#OnDrawGizmosSelected","Ice#OnEnable","Ice#FixedUpdate","Ice#GetDistance","Liquid#init","Liquid#OnValidate","Liquid#OnEnable","Liquid#OnTriggerEnter2D","Liquid#FallsOutOfView","Spine.AnimationStateData.AnimationPairComparer#init","Spine.AnimationStateData.AnimationPairComparer#System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$equals2","Spine.AnimationStateData.AnimationPairComparer#System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$getHashCode2","Spine.Atlas#ReadValue","Spine.Atlas#ReadTuple","Spine.Atlas#Regions#get","Spine.Atlas#Pages#get","Spine.Atlas#init","Spine.Atlas#$ctor1","Spine.Atlas#ctor","Spine.Atlas#GetEnumerator","Spine.Atlas#System$Collections$IEnumerable$GetEnumerator","Spine.Atlas#Load","Spine.Atlas#FlipV","Spine.Atlas#FindRegion","Spine.Atlas#Dispose","Spine.AtlasAttachmentLoader#ctor","Spine.AtlasAttachmentLoader#NewRegionAttachment","Spine.AtlasAttachmentLoader#NewMeshAttachment","Spine.AtlasAttachmentLoader#NewBoundingBoxAttachment","Spine.AtlasAttachmentLoader#NewPathAttachment","Spine.AtlasAttachmentLoader#NewPointAttachment","Spine.AtlasAttachmentLoader#NewClippingAttachment","Spine.AtlasAttachmentLoader#FindRegion","Spine.AttachmentTimeline#PropertyId#get","Spine.AttachmentTimeline#FrameCount#get","Spine.AttachmentTimeline#SlotIndex#get","Spine.AttachmentTimeline#SlotIndex#set","Spine.AttachmentTimeline#Frames#get","Spine.AttachmentTimeline#Frames#set","Spine.AttachmentTimeline#AttachmentNames#get","Spine.AttachmentTimeline#AttachmentNames#set","Spine.AttachmentTimeline#ctor","Spine.AttachmentTimeline#SetFrame","Spine.AttachmentTimeline#Apply","Spine.AttachmentTimeline#SetAttachment","Spine.Bone#Data#get","Spine.Bone#Skeleton#get","Spine.Bone#Parent#get","Spine.Bone#Children#get","Spine.Bone#Active#get","Spine.Bone#X#get","Spine.Bone#X#set","Spine.Bone#Y#get","Spine.Bone#Y#set","Spine.Bone#Rotation#get","Spine.Bone#Rotation#set","Spine.Bone#ScaleX#get","Spine.Bone#ScaleX#set","Spine.Bone#ScaleY#get","Spine.Bone#ScaleY#set","Spine.Bone#ShearX#get","Spine.Bone#ShearX#set","Spine.Bone#ShearY#get","Spine.Bone#ShearY#set","Spine.Bone#AppliedRotation#get","Spine.Bone#AppliedRotation#set","Spine.Bone#AX#get","Spine.Bone#AX#set","Spine.Bone#AY#get","Spine.Bone#AY#set","Spine.Bone#AScaleX#get","Spine.Bone#AScaleX#set","Spine.Bone#AScaleY#get","Spine.Bone#AScaleY#set","Spine.Bone#AShearX#get","Spine.Bone#AShearX#set","Spine.Bone#AShearY#get","Spine.Bone#AShearY#set","Spine.Bone#A#get","Spine.Bone#B#get","Spine.Bone#C#get","Spine.Bone#D#get","Spine.Bone#WorldX#get","Spine.Bone#WorldY#get","Spine.Bone#WorldRotationX#get","Spine.Bone#WorldRotationY#get","Spine.Bone#WorldScaleX#get","Spine.Bone#WorldScaleY#get","Spine.Bone#WorldToLocalRotationX#get","Spine.Bone#WorldToLocalRotationY#get","Spine.Bone#init","Spine.Bone#ctor","Spine.Bone#Update","Spine.Bone#UpdateWorldTransform","Spine.Bone#UpdateWorldTransform$1","Spine.Bone#SetToSetupPose","Spine.Bone#UpdateAppliedTransform","Spine.Bone#WorldToLocal","Spine.Bone#LocalToWorld","Spine.Bone#WorldToLocalRotation","Spine.Bone#LocalToWorldRotation","Spine.Bone#RotateWorld","Spine.Bone#toString","Spine.VertexAttachment#init","Spine.VertexAttachment#Id#get","Spine.VertexAttachment#Bones#get","Spine.VertexAttachment#Bones#set","Spine.VertexAttachment#Vertices#get","Spine.VertexAttachment#Vertices#set","Spine.VertexAttachment#WorldVerticesLength#get","Spine.VertexAttachment#WorldVerticesLength#set","Spine.VertexAttachment#DeformAttachment#get","Spine.VertexAttachment#DeformAttachment#set","Spine.VertexAttachment#ctor","Spine.VertexAttachment#ComputeWorldVertices$1","Spine.VertexAttachment#ComputeWorldVertices","Spine.VertexAttachment#CopyTo","Spine.CurveTimeline#init","Spine.CurveTimeline#FrameCount#get","Spine.CurveTimeline#ctor","Spine.CurveTimeline#SetLinear","Spine.CurveTimeline#SetStepped","Spine.CurveTimeline#GetCurveType","Spine.CurveTimeline#SetCurve","Spine.CurveTimeline#GetCurvePercent","Spine.DrawOrderTimeline#PropertyId#get","Spine.DrawOrderTimeline#FrameCount#get","Spine.DrawOrderTimeline#Frames#get","Spine.DrawOrderTimeline#Frames#set","Spine.DrawOrderTimeline#DrawOrders#get","Spine.DrawOrderTimeline#DrawOrders#set","Spine.DrawOrderTimeline#ctor","Spine.DrawOrderTimeline#SetFrame","Spine.DrawOrderTimeline#Apply","Spine.EventTimeline#PropertyId#get","Spine.EventTimeline#FrameCount#get","Spine.EventTimeline#Frames#get","Spine.EventTimeline#Frames#set","Spine.EventTimeline#Events#get","Spine.EventTimeline#Events#set","Spine.EventTimeline#ctor","Spine.EventTimeline#SetFrame","Spine.EventTimeline#Apply","Spine.IkConstraint#Apply$1","Spine.IkConstraint#Apply","Spine.IkConstraint#Bones#get","Spine.IkConstraint#Target#get","Spine.IkConstraint#Target#set","Spine.IkConstraint#Mix#get","Spine.IkConstraint#Mix#set","Spine.IkConstraint#Softness#get","Spine.IkConstraint#Softness#set","Spine.IkConstraint#BendDirection#get","Spine.IkConstraint#BendDirection#set","Spine.IkConstraint#Compress#get","Spine.IkConstraint#Compress#set","Spine.IkConstraint#Stretch#get","Spine.IkConstraint#Stretch#set","Spine.IkConstraint#Active#get","Spine.IkConstraint#Data#get","Spine.IkConstraint#init","Spine.IkConstraint#$ctor1","Spine.IkConstraint#ctor","Spine.IkConstraint#Apply","Spine.IkConstraint#Update","Spine.IkConstraint#toString","Spine.IkConstraintData#Bones#get","Spine.IkConstraintData#Target#get","Spine.IkConstraintData#Target#set","Spine.IkConstraintData#Mix#get","Spine.IkConstraintData#Mix#set","Spine.IkConstraintData#Softness#get","Spine.IkConstraintData#Softness#set","Spine.IkConstraintData#BendDirection#get","Spine.IkConstraintData#BendDirection#set","Spine.IkConstraintData#Compress#get","Spine.IkConstraintData#Compress#set","Spine.IkConstraintData#Stretch#get","Spine.IkConstraintData#Stretch#set","Spine.IkConstraintData#Uniform#get","Spine.IkConstraintData#Uniform#set","Spine.IkConstraintData#init","Spine.IkConstraintData#ctor","Spine.PathConstraint#init","Spine.PathConstraint#AddBeforePosition","Spine.PathConstraint#AddAfterPosition","Spine.PathConstraint#AddCurvePosition","Spine.PathConstraint#Position#get","Spine.PathConstraint#Position#set","Spine.PathConstraint#Spacing#get","Spine.PathConstraint#Spacing#set","Spine.PathConstraint#RotateMix#get","Spine.PathConstraint#RotateMix#set","Spine.PathConstraint#TranslateMix#get","Spine.PathConstraint#TranslateMix#set","Spine.PathConstraint#Bones#get","Spine.PathConstraint#Target#get","Spine.PathConstraint#Target#set","Spine.PathConstraint#Active#get","Spine.PathConstraint#Data#get","Spine.PathConstraint#init","Spine.PathConstraint#$ctor1","Spine.PathConstraint#ctor","Spine.PathConstraint#Apply","Spine.PathConstraint#Update","Spine.PathConstraint#ComputeWorldPositions","Spine.PathConstraintData#Bones#get","Spine.PathConstraintData#Target#get","Spine.PathConstraintData#Target#set","Spine.PathConstraintData#PositionMode#get","Spine.PathConstraintData#PositionMode#set","Spine.PathConstraintData#SpacingMode#get","Spine.PathConstraintData#SpacingMode#set","Spine.PathConstraintData#RotateMode#get","Spine.PathConstraintData#RotateMode#set","Spine.PathConstraintData#OffsetRotation#get","Spine.PathConstraintData#OffsetRotation#set","Spine.PathConstraintData#Position#get","Spine.PathConstraintData#Position#set","Spine.PathConstraintData#Spacing#get","Spine.PathConstraintData#Spacing#set","Spine.PathConstraintData#RotateMix#get","Spine.PathConstraintData#RotateMix#set","Spine.PathConstraintData#TranslateMix#get","Spine.PathConstraintData#TranslateMix#set","Spine.PathConstraintData#init","Spine.PathConstraintData#ctor","Spine.PointAttachment#X#get","Spine.PointAttachment#X#set","Spine.PointAttachment#Y#get","Spine.PointAttachment#Y#set","Spine.PointAttachment#Rotation#get","Spine.PointAttachment#Rotation#set","Spine.PointAttachment#ctor","Spine.PointAttachment#ComputeWorldPosition","Spine.PointAttachment#ComputeWorldRotation","Spine.PointAttachment#Copy","Spine.Pow#ctor","Spine.Pow#Apply$1","Spine.RegionAttachment#init","Spine.RegionAttachment#X#get","Spine.RegionAttachment#X#set","Spine.RegionAttachment#Y#get","Spine.RegionAttachment#Y#set","Spine.RegionAttachment#Rotation#get","Spine.RegionAttachment#Rotation#set","Spine.RegionAttachment#ScaleX#get","Spine.RegionAttachment#ScaleX#set","Spine.RegionAttachment#ScaleY#get","Spine.RegionAttachment#ScaleY#set","Spine.RegionAttachment#Width#get","Spine.RegionAttachment#Width#set","Spine.RegionAttachment#Height#get","Spine.RegionAttachment#Height#set","Spine.RegionAttachment#R#get","Spine.RegionAttachment#R#set","Spine.RegionAttachment#G#get","Spine.RegionAttachment#G#set","Spine.RegionAttachment#B#get","Spine.RegionAttachment#B#set","Spine.RegionAttachment#A#get","Spine.RegionAttachment#A#set","Spine.RegionAttachment#RegionOffsetX#get","Spine.RegionAttachment#RegionOffsetX#set","Spine.RegionAttachment#RegionOffsetY#get","Spine.RegionAttachment#RegionOffsetY#set","Spine.RegionAttachment#RegionWidth#get","Spine.RegionAttachment#RegionWidth#set","Spine.RegionAttachment#RegionHeight#get","Spine.RegionAttachment#RegionHeight#set","Spine.RegionAttachment#RegionOriginalWidth#get","Spine.RegionAttachment#RegionOriginalWidth#set","Spine.RegionAttachment#RegionOriginalHeight#get","Spine.RegionAttachment#RegionOriginalHeight#set","Spine.RegionAttachment#Offset#get","Spine.RegionAttachment#UVs#get","Spine.RegionAttachment#init","Spine.RegionAttachment#ctor","Spine.RegionAttachment#UpdateOffset","Spine.RegionAttachment#SetUVs","Spine.RegionAttachment#ComputeWorldVertices","Spine.RegionAttachment#Copy","Spine.Skin.SkinEntryComparer#init","Spine.Skin.SkinEntryComparer#System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinEntry$equals2","Spine.Skin.SkinEntryComparer#System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinEntry$getHashCode2","Spine.TrackEntry#inherits","Spine.TrackEntry#TrackIndex#get","Spine.TrackEntry#Animation#get","Spine.TrackEntry#Loop#get","Spine.TrackEntry#Loop#set","Spine.TrackEntry#Delay#get","Spine.TrackEntry#Delay#set","Spine.TrackEntry#TrackTime#get","Spine.TrackEntry#TrackTime#set","Spine.TrackEntry#TrackEnd#get","Spine.TrackEntry#TrackEnd#set","Spine.TrackEntry#AnimationStart#get","Spine.TrackEntry#AnimationStart#set","Spine.TrackEntry#AnimationEnd#get","Spine.TrackEntry#AnimationEnd#set","Spine.TrackEntry#AnimationLast#get","Spine.TrackEntry#AnimationLast#set","Spine.TrackEntry#AnimationTime#get","Spine.TrackEntry#TimeScale#get","Spine.TrackEntry#TimeScale#set","Spine.TrackEntry#Alpha#get","Spine.TrackEntry#Alpha#set","Spine.TrackEntry#EventThreshold#get","Spine.TrackEntry#EventThreshold#set","Spine.TrackEntry#AttachmentThreshold#get","Spine.TrackEntry#AttachmentThreshold#set","Spine.TrackEntry#DrawOrderThreshold#get","Spine.TrackEntry#DrawOrderThreshold#set","Spine.TrackEntry#Next#get","Spine.TrackEntry#IsComplete#get","Spine.TrackEntry#MixTime#get","Spine.TrackEntry#MixTime#set","Spine.TrackEntry#MixDuration#get","Spine.TrackEntry#MixDuration#set","Spine.TrackEntry#MixBlend#get","Spine.TrackEntry#MixBlend#set","Spine.TrackEntry#MixingFrom#get","Spine.TrackEntry#MixingTo#get","Spine.TrackEntry#HoldPrevious#get","Spine.TrackEntry#HoldPrevious#set","Spine.TrackEntry#init","Spine.TrackEntry#OnStart","Spine.TrackEntry#OnInterrupt","Spine.TrackEntry#OnEnd","Spine.TrackEntry#OnDispose","Spine.TrackEntry#OnComplete","Spine.TrackEntry#OnEvent","Spine.TrackEntry#Reset","Spine.TrackEntry#ResetRotationDirections","Spine.TrackEntry#toString","Spine.TransformConstraint#Bones#get","Spine.TransformConstraint#Target#get","Spine.TransformConstraint#Target#set","Spine.TransformConstraint#RotateMix#get","Spine.TransformConstraint#RotateMix#set","Spine.TransformConstraint#TranslateMix#get","Spine.TransformConstraint#TranslateMix#set","Spine.TransformConstraint#ScaleMix#get","Spine.TransformConstraint#ScaleMix#set","Spine.TransformConstraint#ShearMix#get","Spine.TransformConstraint#ShearMix#set","Spine.TransformConstraint#Active#get","Spine.TransformConstraint#Data#get","Spine.TransformConstraint#$ctor1","Spine.TransformConstraint#ctor","Spine.TransformConstraint#Apply","Spine.TransformConstraint#Update","Spine.TransformConstraint#ApplyAbsoluteWorld","Spine.TransformConstraint#ApplyRelativeWorld","Spine.TransformConstraint#ApplyAbsoluteLocal","Spine.TransformConstraint#ApplyRelativeLocal","Spine.TransformConstraint#toString","Spine.TransformConstraintData#Bones#get","Spine.TransformConstraintData#Target#get","Spine.TransformConstraintData#Target#set","Spine.TransformConstraintData#RotateMix#get","Spine.TransformConstraintData#RotateMix#set","Spine.TransformConstraintData#TranslateMix#get","Spine.TransformConstraintData#TranslateMix#set","Spine.TransformConstraintData#ScaleMix#get","Spine.TransformConstraintData#ScaleMix#set","Spine.TransformConstraintData#ShearMix#get","Spine.TransformConstraintData#ShearMix#set","Spine.TransformConstraintData#OffsetRotation#get","Spine.TransformConstraintData#OffsetRotation#set","Spine.TransformConstraintData#OffsetX#get","Spine.TransformConstraintData#OffsetX#set","Spine.TransformConstraintData#OffsetY#get","Spine.TransformConstraintData#OffsetY#set","Spine.TransformConstraintData#OffsetScaleX#get","Spine.TransformConstraintData#OffsetScaleX#set","Spine.TransformConstraintData#OffsetScaleY#get","Spine.TransformConstraintData#OffsetScaleY#set","Spine.TransformConstraintData#OffsetShearY#get","Spine.TransformConstraintData#OffsetShearY#set","Spine.TransformConstraintData#Relative#get","Spine.TransformConstraintData#Relative#set","Spine.TransformConstraintData#Local#get","Spine.TransformConstraintData#Local#set","Spine.TransformConstraintData#init","Spine.TransformConstraintData#ctor","Spine.Unity.AnimationReferenceAsset#init","Spine.Unity.AnimationReferenceAsset#op_Implicit","Spine.Unity.AnimationReferenceAsset#SkeletonDataAsset#get","Spine.Unity.AnimationReferenceAsset#Animation#get","Spine.Unity.AnimationReferenceAsset#Initialize","Spine.Unity.BlendModeMaterialsAsset#ApplyMaterials","Spine.Unity.BlendModeMaterialsAsset#init","Spine.Unity.BlendModeMaterialsAsset#Apply","Spine.Unity.MaterialsTextureLoader#ctor","Spine.Unity.MaterialsTextureLoader#Load","Spine.Unity.MaterialsTextureLoader#Unload","Spine.Unity.PointFollower#SkeletonRenderer#get","Spine.Unity.PointFollower#SkeletonComponent#get","Spine.Unity.PointFollower#IsValid#get","Spine.Unity.PointFollower#init","Spine.Unity.PointFollower#Initialize","Spine.Unity.PointFollower#HandleRebuildRenderer","Spine.Unity.PointFollower#UpdateReferences","Spine.Unity.PointFollower#OnDestroy","Spine.Unity.PointFollower#LateUpdate","Spine.Unity.RegionlessAttachmentLoader#EmptyRegion#get","Spine.Unity.RegionlessAttachmentLoader#NewRegionAttachment","Spine.Unity.RegionlessAttachmentLoader#NewMeshAttachment","Spine.Unity.RegionlessAttachmentLoader#NewBoundingBoxAttachment","Spine.Unity.RegionlessAttachmentLoader#NewPathAttachment","Spine.Unity.RegionlessAttachmentLoader#NewPointAttachment","Spine.Unity.RegionlessAttachmentLoader#NewClippingAttachment","Spine.Unity.SkeletonRenderer#init","Spine.Unity.SkeletonRenderer#NewSpineGameObject","Spine.Unity.SkeletonRenderer#AddSpineComponent","Spine.Unity.SkeletonRenderer#UpdateMode#get","Spine.Unity.SkeletonRenderer#UpdateMode#set","Spine.Unity.SkeletonRenderer#CustomMaterialOverride#get","Spine.Unity.SkeletonRenderer#CustomSlotMaterials#get","Spine.Unity.SkeletonRenderer#Skeleton#get","Spine.Unity.SkeletonRenderer#SkeletonDataAsset#get","Spine.Unity.SkeletonRenderer#init","Spine.Unity.SkeletonRenderer#addGenerateMeshOverride","Spine.Unity.SkeletonRenderer#removeGenerateMeshOverride","Spine.Unity.SkeletonRenderer#SetMeshSettings","Spine.Unity.SkeletonRenderer#Awake","Spine.Unity.SkeletonRenderer#OnDisable","Spine.Unity.SkeletonRenderer#OnDestroy","Spine.Unity.SkeletonRenderer#ClearState","Spine.Unity.SkeletonRenderer#EnsureMeshGeneratorCapacity","Spine.Unity.SkeletonRenderer#Initialize","Spine.Unity.SkeletonRenderer#LateUpdate","Spine.Unity.SkeletonRenderer#OnBecameVisible","Spine.Unity.SkeletonRenderer#OnBecameInvisible","Spine.Unity.SkeletonRenderer#FindAndApplySeparatorSlots$1","Spine.Unity.SkeletonRenderer#FindAndApplySeparatorSlots","Spine.Unity.SkeletonRenderer#ReapplySeparatorSlotNames","Spine.Unity.SkeletonRenderer#AssignSpriteMaskMaterials","Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsInsideMask","Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsOutsideMask","Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsForMaskType","Spine.Unity.SkeletonRenderer#SetMaterialSettingsToFixDrawOrder","Spine.Unity.SkeletonGraphic#init","Spine.Unity.SkeletonGraphic#NewSkeletonGraphicGameObject","Spine.Unity.SkeletonGraphic#AddSkeletonGraphicComponent","Spine.Unity.SkeletonGraphic#SkeletonDataAsset#get","Spine.Unity.SkeletonGraphic#UpdateMode#get","Spine.Unity.SkeletonGraphic#UpdateMode#set","Spine.Unity.SkeletonGraphic#SeparatorParts#get","Spine.Unity.SkeletonGraphic#CustomTextureOverride#get","Spine.Unity.SkeletonGraphic#CustomMaterialOverride#get","Spine.Unity.SkeletonGraphic#OverrideTexture#get","Spine.Unity.SkeletonGraphic#OverrideTexture#set","Spine.Unity.SkeletonGraphic#mainTexture#get","Spine.Unity.SkeletonGraphic#Skeleton#get","Spine.Unity.SkeletonGraphic#Skeleton#set","Spine.Unity.SkeletonGraphic#SkeletonData#get","Spine.Unity.SkeletonGraphic#IsValid#get","Spine.Unity.SkeletonGraphic#AnimationState#get","Spine.Unity.SkeletonGraphic#MeshGenerator#get","Spine.Unity.SkeletonGraphic#init","Spine.Unity.SkeletonGraphic#Awake","Spine.Unity.SkeletonGraphic#OnDestroy","Spine.Unity.SkeletonGraphic#Rebuild","Spine.Unity.SkeletonGraphic#OnDisable","Spine.Unity.SkeletonGraphic#Update","Spine.Unity.SkeletonGraphic#Update$1","Spine.Unity.SkeletonGraphic#SyncRawImagesWithCanvasRenderers","Spine.Unity.SkeletonGraphic#UpdateAnimationStatus","Spine.Unity.SkeletonGraphic#ApplyAnimation","Spine.Unity.SkeletonGraphic#LateUpdate","Spine.Unity.SkeletonGraphic#OnCullStateChanged","Spine.Unity.SkeletonGraphic#OnBecameVisible","Spine.Unity.SkeletonGraphic#OnBecameInvisible","Spine.Unity.SkeletonGraphic#ReapplySeparatorSlotNames","Spine.Unity.SkeletonGraphic#GetLastMesh","Spine.Unity.SkeletonGraphic#MatchRectTransformWithBounds","Spine.Unity.SkeletonGraphic#MatchRectTransformSingleRenderer","Spine.Unity.SkeletonGraphic#MatchRectTransformMultipleRenderers","Spine.Unity.SkeletonGraphic#SetRectTransformBounds","Spine.Unity.SkeletonGraphic#Clear","Spine.Unity.SkeletonGraphic#TrimRenderers","Spine.Unity.SkeletonGraphic#Initialize","Spine.Unity.SkeletonGraphic#UpdateMesh","Spine.Unity.SkeletonGraphic#HasMultipleSubmeshInstructions","Spine.Unity.SkeletonGraphic#InitMeshBuffers","Spine.Unity.SkeletonGraphic#DisposeMeshBuffers","Spine.Unity.SkeletonGraphic#UpdateMeshSingleCanvasRenderer","Spine.Unity.SkeletonGraphic#UpdateMeshMultipleCanvasRenderers","Spine.Unity.SkeletonGraphic#EnsureCanvasRendererCount","Spine.Unity.SkeletonGraphic#DisableUnusedCanvasRenderers","Spine.Unity.SkeletonGraphic#EnsureMeshesCount","Spine.Unity.SkeletonGraphic#DestroyMeshes","Spine.Unity.SkeletonGraphic#EnsureSeparatorPartCount","Spine.Unity.SkeletonGraphic#UpdateSeparatorPartParents","Spine.Unity.SkeletonMecanimRootMotion#init","Spine.Unity.SkeletonMecanimRootMotion#SkeletonMecanim#get","Spine.Unity.SkeletonMecanimRootMotion#init","Spine.Unity.SkeletonMecanimRootMotion#GetRemainingRootMotion","Spine.Unity.SkeletonMecanimRootMotion#GetRootMotionInfo","Spine.Unity.SkeletonMecanimRootMotion#Reset","Spine.Unity.SkeletonMecanimRootMotion#Start","Spine.Unity.SkeletonMecanimRootMotion#OnClipApplied","Spine.Unity.SkeletonMecanimRootMotion#CalculateAnimationsMovementDelta","Spine.Unity.SkeletonRootMotion#init","Spine.Unity.SkeletonRootMotion#AdditionalScale#get","Spine.Unity.SkeletonRootMotion#init","Spine.Unity.SkeletonRootMotion#GetRemainingRootMotion","Spine.Unity.SkeletonRootMotion#GetRootMotionInfo","Spine.Unity.SkeletonRootMotion#Reset","Spine.Unity.SkeletonRootMotion#Start","Spine.Unity.SkeletonRootMotion#CalculateAnimationsMovementDelta","Spine.Unity.SkeletonRootMotion#ApplyMixAlphaToDelta","Spine.Unity.SpineAnimation#ctor","Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance","Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance$1","Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance$2","Spine.Unity.SpineAtlasAsset#IsLoaded#get","Spine.Unity.SpineAtlasAsset#Materials#get","Spine.Unity.SpineAtlasAsset#MaterialCount#get","Spine.Unity.SpineAtlasAsset#PrimaryMaterial#get","Spine.Unity.SpineAtlasAsset#Reset","Spine.Unity.SpineAtlasAsset#Clear","Spine.Unity.SpineAtlasAsset#GetAtlas","Spine.Unity.SpineAtlasAsset#GenerateMesh","Spine.Unity.SpineAttachment#getHierarchy","Spine.Unity.SpineAttachment#getAttachment","Spine.Unity.SpineAttachment#getAttachment$1","Spine.Unity.SpineAttachment#init","Spine.Unity.SpineAttachment#ctor","Spine.Unity.SpineBone#getBone","Spine.Unity.SpineBone#getBoneData","Spine.Unity.SpineBone#ctor","Spine.Unity.SpineEvent#init","Spine.Unity.SpineEvent#ctor","Spine.Unity.SpineIkConstraint#ctor","Spine.Unity.SpinePathConstraint#ctor","Spine.Unity.SpineSkin#init","Spine.Unity.SpineSkin#ctor","Spine.Unity.SpineSlot#init","Spine.Unity.SpineSlot#ctor","Spine.Unity.SpineSpriteAtlasAsset#CreateRuntimeInstance","Spine.Unity.SpineSpriteAtlasAsset#AccessPackedTexture","Spine.Unity.SpineSpriteAtlasAsset#AccessPackedSprites","Spine.Unity.SpineSpriteAtlasAsset#IsLoaded#get","Spine.Unity.SpineSpriteAtlasAsset#Materials#get","Spine.Unity.SpineSpriteAtlasAsset#MaterialCount#get","Spine.Unity.SpineSpriteAtlasAsset#PrimaryMaterial#get","Spine.Unity.SpineSpriteAtlasAsset#Reset","Spine.Unity.SpineSpriteAtlasAsset#Clear","Spine.Unity.SpineSpriteAtlasAsset#GetAtlas","Spine.Unity.SpineSpriteAtlasAsset#AssignRegionsFromSavedRegions","Spine.Unity.SpineSpriteAtlasAsset#LoadAtlas","Spine.Unity.SpineTransformConstraint#ctor","Spine.Unity.WaitForSpineAnimationComplete#ctor","Spine.Unity.WaitForSpineAnimationComplete#NowWaitFor$1","Spine.Unity.WaitForSpineAnimationEnd#ctor","Spine.Unity.WaitForSpineAnimationEnd#NowWaitFor$1","GameManager1#inherits","GameManager1#init","GameManager1#Start","GameManager1#InitBeverageToFill","GameManager1#OnClickBtnDrink","GameManager1#OnFill","GameManager1#StartFillGlass","GameManager1#StartDropTopping","GameManager1#SpawnTopping","GameManager1#StartFill","GameManager1#ResetBeverage","GameManager1#InstallFullGame","GameManager1#CheckShowEndcard","GameManager2#inherits","GameManager2#Start","GameManager2#InstallFullGame","GameManager2#FillGlass","GameManager2#StartFillGlass","GlobalInstance#inherits","GlobalInstance#init","SingletonDontDestroyOnLoad$1#Awake","SoundManager#inherits","SoundManager#PlaySound","Spine.BoundingBoxAttachment#ctor","Spine.BoundingBoxAttachment#Copy","Spine.ClippingAttachment#EndSlot#get","Spine.ClippingAttachment#EndSlot#set","Spine.ClippingAttachment#ctor","Spine.ClippingAttachment#Copy","Spine.ColorTimeline#init","Spine.ColorTimeline#PropertyId#get","Spine.ColorTimeline#SlotIndex#get","Spine.ColorTimeline#SlotIndex#set","Spine.ColorTimeline#Frames#get","Spine.ColorTimeline#Frames#set","Spine.ColorTimeline#ctor","Spine.ColorTimeline#SetFrame","Spine.ColorTimeline#Apply","Spine.DeformTimeline#PropertyId#get","Spine.DeformTimeline#SlotIndex#get","Spine.DeformTimeline#SlotIndex#set","Spine.DeformTimeline#Attachment#get","Spine.DeformTimeline#Attachment#set","Spine.DeformTimeline#Frames#get","Spine.DeformTimeline#Frames#set","Spine.DeformTimeline#Vertices#get","Spine.DeformTimeline#Vertices#set","Spine.DeformTimeline#ctor","Spine.DeformTimeline#SetFrame","Spine.DeformTimeline#Apply","Spine.IkConstraintTimeline#init","Spine.IkConstraintTimeline#PropertyId#get","Spine.IkConstraintTimeline#IkConstraintIndex#get","Spine.IkConstraintTimeline#IkConstraintIndex#set","Spine.IkConstraintTimeline#Frames#get","Spine.IkConstraintTimeline#Frames#set","Spine.IkConstraintTimeline#ctor","Spine.IkConstraintTimeline#SetFrame","Spine.IkConstraintTimeline#Apply","Spine.MeshAttachment#HullLength#get","Spine.MeshAttachment#HullLength#set","Spine.MeshAttachment#RegionUVs#get","Spine.MeshAttachment#RegionUVs#set","Spine.MeshAttachment#UVs#get","Spine.MeshAttachment#UVs#set","Spine.MeshAttachment#Triangles#get","Spine.MeshAttachment#Triangles#set","Spine.MeshAttachment#R#get","Spine.MeshAttachment#R#set","Spine.MeshAttachment#G#get","Spine.MeshAttachment#G#set","Spine.MeshAttachment#B#get","Spine.MeshAttachment#B#set","Spine.MeshAttachment#A#get","Spine.MeshAttachment#A#set","Spine.MeshAttachment#RegionOffsetX#get","Spine.MeshAttachment#RegionOffsetX#set","Spine.MeshAttachment#RegionOffsetY#get","Spine.MeshAttachment#RegionOffsetY#set","Spine.MeshAttachment#RegionWidth#get","Spine.MeshAttachment#RegionWidth#set","Spine.MeshAttachment#RegionHeight#get","Spine.MeshAttachment#RegionHeight#set","Spine.MeshAttachment#RegionOriginalWidth#get","Spine.MeshAttachment#RegionOriginalWidth#set","Spine.MeshAttachment#RegionOriginalHeight#get","Spine.MeshAttachment#RegionOriginalHeight#set","Spine.MeshAttachment#ParentMesh#get","Spine.MeshAttachment#ParentMesh#set","Spine.MeshAttachment#init","Spine.MeshAttachment#ctor","Spine.MeshAttachment#UpdateUVs","Spine.MeshAttachment#Copy","Spine.MeshAttachment#NewLinkedMesh","Spine.PathAttachment#Lengths#get","Spine.PathAttachment#Lengths#set","Spine.PathAttachment#Closed#get","Spine.PathAttachment#Closed#set","Spine.PathAttachment#ConstantSpeed#get","Spine.PathAttachment#ConstantSpeed#set","Spine.PathAttachment#ctor","Spine.PathAttachment#Copy","Spine.PathConstraintMixTimeline#init","Spine.PathConstraintMixTimeline#PropertyId#get","Spine.PathConstraintMixTimeline#PathConstraintIndex#get","Spine.PathConstraintMixTimeline#PathConstraintIndex#set","Spine.PathConstraintMixTimeline#Frames#get","Spine.PathConstraintMixTimeline#Frames#set","Spine.PathConstraintMixTimeline#ctor","Spine.PathConstraintMixTimeline#SetFrame","Spine.PathConstraintMixTimeline#Apply","Spine.PathConstraintPositionTimeline#init","Spine.PathConstraintPositionTimeline#PropertyId#get","Spine.PathConstraintPositionTimeline#PathConstraintIndex#get","Spine.PathConstraintPositionTimeline#PathConstraintIndex#set","Spine.PathConstraintPositionTimeline#Frames#get","Spine.PathConstraintPositionTimeline#Frames#set","Spine.PathConstraintPositionTimeline#ctor","Spine.PathConstraintPositionTimeline#SetFrame","Spine.PathConstraintPositionTimeline#Apply","Spine.PowOut#ctor","Spine.PowOut#Apply$1","Spine.RotateTimeline#init","Spine.RotateTimeline#PropertyId#get","Spine.RotateTimeline#BoneIndex#get","Spine.RotateTimeline#BoneIndex#set","Spine.RotateTimeline#Frames#get","Spine.RotateTimeline#Frames#set","Spine.RotateTimeline#ctor","Spine.RotateTimeline#SetFrame","Spine.RotateTimeline#Apply","Spine.TranslateTimeline#init","Spine.TranslateTimeline#PropertyId#get","Spine.TranslateTimeline#BoneIndex#get","Spine.TranslateTimeline#BoneIndex#set","Spine.TranslateTimeline#Frames#get","Spine.TranslateTimeline#Frames#set","Spine.TranslateTimeline#ctor","Spine.TranslateTimeline#SetFrame","Spine.TranslateTimeline#Apply","Spine.TransformConstraintTimeline#init","Spine.TransformConstraintTimeline#PropertyId#get","Spine.TransformConstraintTimeline#TransformConstraintIndex#get","Spine.TransformConstraintTimeline#TransformConstraintIndex#set","Spine.TransformConstraintTimeline#Frames#get","Spine.TransformConstraintTimeline#Frames#set","Spine.TransformConstraintTimeline#ctor","Spine.TransformConstraintTimeline#SetFrame","Spine.TransformConstraintTimeline#Apply","Spine.TwoColorTimeline#init","Spine.TwoColorTimeline#PropertyId#get","Spine.TwoColorTimeline#SlotIndex#get","Spine.TwoColorTimeline#SlotIndex#set","Spine.TwoColorTimeline#Frames#get","Spine.TwoColorTimeline#ctor","Spine.TwoColorTimeline#SetFrame","Spine.TwoColorTimeline#Apply","Spine.Unity.SkeletonAnimation#AddToGameObject","Spine.Unity.SkeletonAnimation#NewSkeletonAnimationGameObject","Spine.Unity.SkeletonAnimation#AnimationState#get","Spine.Unity.SkeletonAnimation#AnimationName#get","Spine.Unity.SkeletonAnimation#AnimationName#set","Spine.Unity.SkeletonAnimation#init","Spine.Unity.SkeletonAnimation#addBeforeApply","Spine.Unity.SkeletonAnimation#removeBeforeApply","Spine.Unity.SkeletonAnimation#addUpdateLocal","Spine.Unity.SkeletonAnimation#removeUpdateLocal","Spine.Unity.SkeletonAnimation#addUpdateWorld","Spine.Unity.SkeletonAnimation#removeUpdateWorld","Spine.Unity.SkeletonAnimation#addUpdateComplete","Spine.Unity.SkeletonAnimation#removeUpdateComplete","Spine.Unity.SkeletonAnimation#ClearState","Spine.Unity.SkeletonAnimation#Initialize","Spine.Unity.SkeletonAnimation#Update$1","Spine.Unity.SkeletonAnimation#Update","Spine.Unity.SkeletonAnimation#UpdateAnimationStatus","Spine.Unity.SkeletonAnimation#ApplyAnimation","Spine.Unity.SkeletonAnimation#LateUpdate","Spine.Unity.SkeletonMecanim#Translator#get","Spine.Unity.SkeletonMecanim#init","Spine.Unity.SkeletonMecanim#addBeforeApply","Spine.Unity.SkeletonMecanim#removeBeforeApply","Spine.Unity.SkeletonMecanim#addUpdateLocal","Spine.Unity.SkeletonMecanim#removeUpdateLocal","Spine.Unity.SkeletonMecanim#addUpdateWorld","Spine.Unity.SkeletonMecanim#removeUpdateWorld","Spine.Unity.SkeletonMecanim#addUpdateComplete","Spine.Unity.SkeletonMecanim#removeUpdateComplete","Spine.Unity.SkeletonMecanim#Initialize","Spine.Unity.SkeletonMecanim#Update","Spine.Unity.SkeletonMecanim#ApplyAnimation","Spine.Unity.SkeletonMecanim#LateUpdate","Spine.PathConstraintSpacingTimeline#PropertyId#get","Spine.PathConstraintSpacingTimeline#ctor","Spine.PathConstraintSpacingTimeline#Apply","Spine.ScaleTimeline#PropertyId#get","Spine.ScaleTimeline#ctor","Spine.ScaleTimeline#Apply","Spine.ShearTimeline#PropertyId#get","Spine.ShearTimeline#ctor","Spine.ShearTimeline#Apply"]' ) ); }
/**
 * @version 1.0.8637.32599
 * @copyright anton
 * @compiler Bridge.NET 17.9.33-luna
 */
Bridge.assembly("UnityScriptsCompiler", function ($asm, globals) {
    "use strict";

    /*ActionDispatcher start.*/
    Bridge.define("ActionDispatcher", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            TextScore: null,
            audio: null,
            confetti: null,
            score: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "ActionDispatcher#init", this ); }

                this.score = 0;
            }
        },
        methods: {
            /*ActionDispatcher.Scored start.*/
            Scored: function (g1, g2) {
if ( TRACE ) { TRACE( "ActionDispatcher#Scored", this ); }

                // Add points
                this.score = (this.score + 1) | 0;
                this.TextScore.text = Bridge.toString(this.score);

                // g1 is the active spawner of the event
                g1.GetComponent(Water2D.Water2D_Spawner).instance.RestoreCheckingFillShape();

                //g2 is the gameobject of collider triggered
                g2.GetComponent(UnityEngine.BoxCollider2D).enabled = false;

                this.audio.Play();
                this.confetti.Play();

            },
            /*ActionDispatcher.Scored end.*/


        }
    });
    /*ActionDispatcher end.*/

    /*ApplyPhysicsForceManager start.*/
    Bridge.define("ApplyPhysicsForceManager", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            rb: null,
            jet1: null,
            jet2: null,
            fx: null,
            initPOs: null,
            canPlay: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "ApplyPhysicsForceManager#init", this ); }

                this.initPOs = new UnityEngine.Vector3();
                this.canPlay = false;
            }
        },
        methods: {
            /*ApplyPhysicsForceManager.ApplyForceToBody start.*/
            ApplyForceToBody: function (g1, g2) {
if ( TRACE ) { TRACE( "ApplyPhysicsForceManager#ApplyForceToBody", this ); }

                this.rb.AddForce(g2.GetComponent(UnityEngine.Rigidbody2D).velocity.$clone().scale( -0.8 ));
            },
            /*ApplyPhysicsForceManager.ApplyForceToBody end.*/

            /*ApplyPhysicsForceManager.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "ApplyPhysicsForceManager#Start", this ); }

                for (var i = 1; i < this.fx.length; i = (i + 1) | 0) {
                    this.fx[i] = UnityEngine.Object.Instantiate(UnityEngine.AudioSource, this.fx[0]);
                }

                this.StartCoroutine$1(this.PlaySoundLoopEnum());

                this.initPOs = this.transform.position.$clone();
            },
            /*ApplyPhysicsForceManager.Start end.*/

            /*ApplyPhysicsForceManager.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "ApplyPhysicsForceManager#Update", this ); }

                if (UnityEngine.Input.GetKey(UnityEngine.KeyCode.LeftArrow)) {

                    this.rb.AddTorque(15.0);
                }


                if (UnityEngine.Input.GetKey(UnityEngine.KeyCode.RightArrow)) {

                    this.rb.AddTorque(-15.0);
                }

                if (UnityEngine.Input.GetKey(UnityEngine.KeyCode.UpArrow)) {

                    this.jet1.Spawn();
                    this.jet2.Spawn();
                    this.canPlay = true;

                } else {

                    this.jet2.StopSpawning();
                    this.jet1.StopSpawning();
                }

                if (UnityEngine.Input.GetKey(UnityEngine.KeyCode.R)) {
                    this.transform.position = this.initPOs.$clone();
                    this.transform.localEulerAngles = pc.Vec3.ZERO.clone();
                    this.rb.velocity = pc.Vec2.ZERO.clone();
                }
            },
            /*ApplyPhysicsForceManager.Update end.*/

            /*ApplyPhysicsForceManager.PlaySoundLoopEnum start.*/
            PlaySoundLoopEnum: function () {
if ( TRACE ) { TRACE( "ApplyPhysicsForceManager#PlaySoundLoopEnum", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if ( true ) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 6;
                                        continue;
                                }
                                case 1: {
                                    $enumerator.current = null;
                                        $step = 2;
                                        return true;
                                }
                                case 2: {
                                    if (this.canPlay) {
                                            $step = 3;
                                            continue;
                                        } 
                                        $step = 5;
                                        continue;
                                }
                                case 3: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(0.05);
                                        $step = 4;
                                        return true;
                                }
                                case 4: {
                                    for (var i = 0; i < this.fx.length; i = (i + 1) | 0) {
                                            if (this.fx[i].isPlaying) {
                                                continue;
                                            }

                                            this.fx[i].pitch = UnityEngine.Mathf.Max(0.5, this.rb.velocity.lengthSq() * 0.002);
                                            this.fx[i].Play();
                                            this.canPlay = false;
                                            break;
                                        }
                                    $step = 5;
                                    continue;
                                }
                                case 5: {
                                    
                                        $step = 0;
                                        continue;
                                }
                                case 6: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*ApplyPhysicsForceManager.PlaySoundLoopEnum end.*/


        }
    });
    /*ApplyPhysicsForceManager end.*/

    /*AudioConfig start.*/
    Bridge.define("AudioConfig", {
        fields: {
            keySound: null,
            clip: null,
            audioSource: null,
            volume: 0
        }
    });
    /*AudioConfig end.*/

    /*AutoDestroy start.*/
    Bridge.define("AutoDestroy", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            timeOut: 0,
            typeDestroy: 0,
            timeStart: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "AutoDestroy#init", this ); }

                this.timeOut = 0.5;
                this.typeDestroy = TypeDestroy.DISABLE;
            }
        },
        methods: {
            /*AutoDestroy.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "AutoDestroy#OnEnable", this ); }

                this.timeStart = UnityEngine.Time.time;
            },
            /*AutoDestroy.OnEnable end.*/

            /*AutoDestroy.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "AutoDestroy#Update", this ); }

                if (UnityEngine.Time.time - this.timeStart > this.timeOut) {
                    this.OnDestroy();
                }
            },
            /*AutoDestroy.Update end.*/

            /*AutoDestroy.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "AutoDestroy#OnDestroy", this ); }

                if (this.typeDestroy === TypeDestroy.DISABLE) {
                    this.gameObject.SetActive(false);
                } else {
                    if (this.typeDestroy === TypeDestroy.RESPAWNER) {
                        SimplePool.Despawn(this.gameObject);
                    } else {
                        if (this.typeDestroy === TypeDestroy.DESTROY) {
                            UnityEngine.MonoBehaviour.Destroy(this.gameObject);
                        }
                    }
                }
            },
            /*AutoDestroy.OnDestroy end.*/

            /*AutoDestroy.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "AutoDestroy#OnDisable", this ); }

                this.OnDestroy();
            },
            /*AutoDestroy.OnDisable end.*/


        }
    });
    /*AutoDestroy end.*/

    /*AutoDestructor start.*/
    Bridge.define("AutoDestructor", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            timeDestroy: 0,
            isPutToPool: false,
            typeDestroy: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "AutoDestructor#init", this ); }

                this.timeDestroy = 1.5;
                this.isPutToPool = true;
            }
        },
        methods: {
            /*AutoDestructor.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "AutoDestructor#OnEnable", this ); }

                this.Invoke("AutoDestroy", this.timeDestroy);
            },
            /*AutoDestructor.OnEnable end.*/

            /*AutoDestructor.AutoDestroy start.*/
            AutoDestroy: function () {
if ( TRACE ) { TRACE( "AutoDestructor#AutoDestroy", this ); }

                if (this.isPutToPool) {
                    SimplePool.Despawn(this.gameObject);
                } else {
                    switch (this.typeDestroy) {
                        case AutoDestructor.TypeDestroy.Disable: 
                            this.gameObject.SetActive(false);
                            break;
                        case AutoDestructor.TypeDestroy.PutToPool: 
                            SimplePool.Despawn(this.gameObject);
                            break;
                        case AutoDestructor.TypeDestroy.Destroy: 
                        default: 
                            UnityEngine.MonoBehaviour.Destroy(this.gameObject);
                            break;
                    }

                }
            },
            /*AutoDestructor.AutoDestroy end.*/

            /*AutoDestructor.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "AutoDestructor#OnDisable", this ); }

                this.CancelInvoke();
            },
            /*AutoDestructor.OnDisable end.*/


        }
    });
    /*AutoDestructor end.*/

    /*AutoDestructor+TypeDestroy start.*/
    Bridge.define("AutoDestructor.TypeDestroy", {
        $kind: 1006,
        statics: {
            fields: {
                Disable: 0,
                PutToPool: 1,
                Destroy: 2
            }
        }
    });
    /*AutoDestructor+TypeDestroy end.*/

    /*BezierCurve.BezierCollider2D start.*/
    Bridge.define("BezierCurve.BezierCollider2D", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            firstPoint: null,
            secondPoint: null,
            handlerFirstPoint: null,
            handlerSecondPoint: null,
            pointsQuantity: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "BezierCurve.BezierCollider2D#init", this ); }

                this.firstPoint = new UnityEngine.Vector2();
                this.secondPoint = new UnityEngine.Vector2();
                this.handlerFirstPoint = new UnityEngine.Vector2();
                this.handlerSecondPoint = new UnityEngine.Vector2();
            }
        },
        methods: {
            /*BezierCurve.BezierCollider2D.CalculateBezierPoint start.*/
            CalculateBezierPoint: function (t, p0, handlerP0, handlerP1, p1) {
if ( TRACE ) { TRACE( "BezierCurve.BezierCollider2D#CalculateBezierPoint", this ); }

                var u = 1.0 - t;
                var tt = t * t;
                var uu = u * u;
                var uuu = uu * u;
                var ttt = tt * t;

                var p = p0.clone().scale( uuu ); //first term
                p = p.$clone().add( handlerP0.clone().scale( 3.0 * uu * t ) ); //second term
                p = p.$clone().add( handlerP1.clone().scale( 3.0 * u * tt ) ); //third term
                p = p.$clone().add( p1.clone().scale( ttt ) ); //fourth term

                return p.$clone();
            },
            /*BezierCurve.BezierCollider2D.CalculateBezierPoint end.*/

            /*BezierCurve.BezierCollider2D.Calculate2DPoints start.*/
            Calculate2DPoints: function () {
if ( TRACE ) { TRACE( "BezierCurve.BezierCollider2D#Calculate2DPoints", this ); }

                var points = new (System.Collections.Generic.List$1(UnityEngine.Vector2)).ctor();

                points.add(this.firstPoint.$clone());
                for (var i = 1; i < this.pointsQuantity; i = (i + 1) | 0) {
                    points.add(UnityEngine.Vector2.FromVector3(this.CalculateBezierPoint((1.0 / this.pointsQuantity) * i, UnityEngine.Vector3.FromVector2(this.firstPoint.$clone()), UnityEngine.Vector3.FromVector2(this.handlerFirstPoint.$clone()), UnityEngine.Vector3.FromVector2(this.handlerSecondPoint.$clone()), UnityEngine.Vector3.FromVector2(this.secondPoint.$clone()))));
                }

                points.add(this.secondPoint.$clone());

                return points.ToArray();
            },
            /*BezierCurve.BezierCollider2D.Calculate2DPoints end.*/


        }
    });
    /*BezierCurve.BezierCollider2D end.*/

    /*ButtonBeverage start.*/
    Bridge.define("ButtonBeverage", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            typeBeverage: 0
        },
        methods: {
            /*ButtonBeverage.OnClick start.*/
            OnClick: function () {
if ( TRACE ) { TRACE( "ButtonBeverage#OnClick", this ); }


                if (!Singleton$1(GameManager1).Instance.CheckShowEndcard()) {
                    this.EffectOnClick();
                    Singleton$1(GameManager1).Instance.OnFill(this.typeBeverage);
                } else {
                    Luna.Unity.LifeCycle.GameEnded();
                    Luna.Unity.Playable.InstallFullGame();
                    Singleton$1(GameManager1).Instance.btnAll.SetActive(true);
                }
            },
            /*ButtonBeverage.OnClick end.*/

            /*ButtonBeverage.EffectOnClick start.*/
            EffectOnClick: function () {
if ( TRACE ) { TRACE( "ButtonBeverage#EffectOnClick", this ); }

                var sequence = DG.Tweening.DOTween.Sequence();
                DG.Tweening.TweenSettingsExtensions.Append(sequence, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.transform, new pc.Vec3( 1, 1, 1 ).clone().scale( 0.6 ), 0.5), DG.Tweening.Ease.Linear));
                DG.Tweening.TweenSettingsExtensions.AppendInterval(sequence, 0.2);
                DG.Tweening.TweenSettingsExtensions.Append(sequence, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.transform, new pc.Vec3( 1, 1, 1 ).clone().scale( 0.5 ), 0.1), DG.Tweening.Ease.Linear));

            },
            /*ButtonBeverage.EffectOnClick end.*/


        }
    });
    /*ButtonBeverage end.*/

    /*DecoratorManager start.*/
    Bridge.define("DecoratorManager", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            Spawner: null,
            _colors: null
        },
        methods: {
            /*DecoratorManager.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "DecoratorManager#Update", this ); }

                if (UnityEngine.Input.GetMouseButton(0)) {
                    this.Spawner.Spawn();
                } else {
                    this.Spawner.StopSpawning();

                }

                if (UnityEngine.Input.GetMouseButtonUp(0)) {
                    this.Spawner.FillColor = this._colors[UnityEngine.Random.Range(0, this._colors.length)].$clone();
                } // new Color(Mathf.Max(Random.value, .5f), Mathf.Max(Random.value, .5f), Mathf.Max(Random.value, .5f), .4f);

            },
            /*DecoratorManager.Update end.*/


        }
    });
    /*DecoratorManager end.*/

    /*DefineHelper start.*/
    Bridge.define("DefineHelper", {
        statics: {
            fields: {
                Moving: null,
                Attack: null,
                Dead: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "DefineHelper#init", this ); }

                    this.Moving = "Moving";
                    this.Attack = "Attack";
                    this.Dead = "Dead";
                }
            }
        }
    });
    /*DefineHelper end.*/

    /*DeleteParticles start.*/
    Bridge.define("DeleteParticles", {
        inherits: [UnityEngine.MonoBehaviour],
        methods: {
            /*DeleteParticles.OnCollisionEnter2D start.*/
            OnCollisionEnter2D: function (col) {
if ( TRACE ) { TRACE( "DeleteParticles#OnCollisionEnter2D", this ); }


                var m1 = col.gameObject.GetComponent(MetaballParticleClass);
                m1.Active = false;

            },
            /*DeleteParticles.OnCollisionEnter2D end.*/


        }
    });
    /*DeleteParticles end.*/

    /*DeleteTriggerBoundingBox start.*/
    Bridge.define("DeleteTriggerBoundingBox", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            SteamPS: null,
            c: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "DeleteTriggerBoundingBox#init", this ); }

                this.c = new UnityEngine.Color();
                this.c = new pc.Color( 1.0, 0, 0, 0.5 );
            }
        },
        methods: {
            /*DeleteTriggerBoundingBox.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "DeleteTriggerBoundingBox#Start", this ); }

                for (var i = 1; i < this.SteamPS.length; i = (i + 1) | 0) {
                    this.SteamPS[i] = UnityEngine.Object.Instantiate(UnityEngine.ParticleSystem, this.SteamPS[0]);
                }
            },
            /*DeleteTriggerBoundingBox.Start end.*/

            /*DeleteTriggerBoundingBox.DeleteOnCollide start.*/
            DeleteOnCollide: function (drop, other) {
if ( TRACE ) { TRACE( "DeleteTriggerBoundingBox#DeleteOnCollide", this ); }


                this.Delete(drop, other);

            },
            /*DeleteTriggerBoundingBox.DeleteOnCollide end.*/

            /*DeleteTriggerBoundingBox.Delete start.*/
            Delete: function (drop, another) {
if ( TRACE ) { TRACE( "DeleteTriggerBoundingBox#Delete", this ); }


                if (another.GetInstanceID() === this.gameObject.GetInstanceID()) {
                    drop.GetComponent(MetaballParticleClass).Active = false;
                    for (var i = 0; i < this.SteamPS.length; i = (i + 1) | 0) {
                        if (this.SteamPS[i].isPlaying) {
                            continue;
                        }

                        this.SteamPS[i].transform.position = drop.transform.position.$clone();
                        this.SteamPS[i].Play();
                        break;

                    }

                }

            },
            /*DeleteTriggerBoundingBox.Delete end.*/


        }
    });
    /*DeleteTriggerBoundingBox end.*/

    /*DG.Tweening.DOTweenCYInstruction start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction");
    /*DG.Tweening.DOTweenCYInstruction end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForCompletion", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForCompletion#keepWaiting#get", this ); }

                    return this.t.active && !DG.Tweening.TweenExtensions.IsComplete(this.t);
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForCompletion#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null,
            elapsedLoops: 0
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#keepWaiting#get", this ); }

                    return this.t.active && DG.Tweening.TweenExtensions.CompletedLoops(this.t) < this.elapsedLoops;
                }
            }
        },
        ctors: {
            ctor: function (tween, elapsedLoops) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
                this.elapsedLoops = elapsedLoops;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForKill start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForKill", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForKill#keepWaiting#get", this ); }

                    return this.t.active;
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForKill#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForKill end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForPosition", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null,
            position: 0
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForPosition#keepWaiting#get", this ); }

                    return this.t.active && this.t.position * (((DG.Tweening.TweenExtensions.CompletedLoops(this.t) + 1) | 0)) < this.position;
                }
            }
        },
        ctors: {
            ctor: function (tween, position) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForPosition#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
                this.position = position;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForRewind", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForRewind#keepWaiting#get", this ); }

                    return this.t.active && (!this.t.playedOnce || this.t.position * (((DG.Tweening.TweenExtensions.CompletedLoops(this.t) + 1) | 0)) > 0);
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForRewind#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForStart start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForStart", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForStart#keepWaiting#get", this ); }

                    return this.t.active && !this.t.playedOnce;
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForStart#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForStart end.*/

    /*DG.Tweening.DOTweenModuleAudio start.*/
    Bridge.define("DG.Tweening.DOTweenModuleAudio", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleAudio.DOFade:static start.*/
                /**
                 * Tweens an AudioSource's volume to the given value.
                 Also stores the AudioSource as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.AudioSource}           target      
                 * @param   {number}                            endValue    The end value to reach (0 to 1)
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOFade", this ); }

                    if (endValue < 0) {
                        endValue = 0;
                    } else {
                        if (endValue > 1) {
                            endValue = 1;
                        }
                    }
                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.volume;
                    }, function (x) {
                        target.volume = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleAudio.DOFade:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPitch:static start.*/
                /**
                 * Tweens an AudioSource's pitch to the given value.
                 Also stores the AudioSource as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.AudioSource}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPitch: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPitch", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.pitch;
                    }, function (x) {
                        target.pitch = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPitch:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOSetFloat:static start.*/
                /**
                 * Tweens an AudioMixer's exposed float to the given value.
                 Also stores the AudioMixer as the tween's target so it can be used for filtered operations.
                 Note that you need to manually expose a float in an AudioMixerGroup in order to be able to tween it from an AudioMixer.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}      target       
                 * @param   {string}                            floatName    Name given to the exposed float to set
                 * @param   {number}                            endValue     The end value to reach
                 * @param   {number}                            duration     The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOSetFloat: function (target, floatName, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOSetFloat", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        var currVal = { };
                        target.GetFloat(floatName, currVal);
                        return currVal.v;
                    }, function (x) {
                        target.SetFloat(floatName, x);
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleAudio.DOSetFloat:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOComplete:static start.*/
                /**
                 * Completes all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens completed
                 (meaning the tweens that don't have infinite loops and were not already complete)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target           
                 * @param   {boolean}                         withCallbacks    For Sequences only: if TRUE also internal Sequence callbacks will be fired,
                 otherwise they will be ignored
                 * @return  {number}
                 */
                DOComplete: function (target, withCallbacks) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOComplete", this ); }

                    if (withCallbacks === void 0) { withCallbacks = false; }
                    return DG.Tweening.DOTween.Complete(target, withCallbacks);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOComplete:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOKill:static start.*/
                /**
                 * Kills all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens killed.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target      
                 * @param   {boolean}                         complete    If TRUE completes the tween before killing it
                 * @return  {number}
                 */
                DOKill: function (target, complete) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOKill", this ); }

                    if (complete === void 0) { complete = false; }
                    return DG.Tweening.DOTween.Kill(target, complete);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOKill:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOFlip:static start.*/
                /**
                 * Flips the direction (backwards if it was going forward or viceversa) of all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens flipped.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOFlip: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOFlip", this ); }

                    return DG.Tweening.DOTween.Flip(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOFlip:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOGoto:static start.*/
                /**
                 * Sends to the given position all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens involved.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target     
                 * @param   {number}                          to         Time position to reach
                 (if higher than the whole tween duration the tween will simply reach its end)
                 * @param   {boolean}                         andPlay    If TRUE will play the tween after reaching the given position, otherwise it will pause it
                 * @return  {number}
                 */
                DOGoto: function (target, to, andPlay) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOGoto", this ); }

                    if (andPlay === void 0) { andPlay = false; }
                    return DG.Tweening.DOTween.Goto(target, to, andPlay);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOGoto:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPause:static start.*/
                /**
                 * Pauses all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens paused.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOPause: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPause", this ); }

                    return DG.Tweening.DOTween.Pause(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPause:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPlay:static start.*/
                /**
                 * Plays all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens played.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOPlay: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPlay", this ); }

                    return DG.Tweening.DOTween.Play(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPlay:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPlayBackwards:static start.*/
                /**
                 * Plays backwards all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens played.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOPlayBackwards: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPlayBackwards", this ); }

                    return DG.Tweening.DOTween.PlayBackwards(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPlayBackwards:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPlayForward:static start.*/
                /**
                 * Plays forward all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens played.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOPlayForward: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPlayForward", this ); }

                    return DG.Tweening.DOTween.PlayForward(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPlayForward:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DORestart:static start.*/
                /**
                 * Restarts all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens restarted.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DORestart: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DORestart", this ); }

                    return DG.Tweening.DOTween.Restart(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DORestart:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DORewind:static start.*/
                /**
                 * Rewinds all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens rewinded.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DORewind: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DORewind", this ); }

                    return DG.Tweening.DOTween.Rewind(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DORewind:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOSmoothRewind:static start.*/
                /**
                 * Smoothly rewinds all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens rewinded.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOSmoothRewind: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOSmoothRewind", this ); }

                    return DG.Tweening.DOTween.SmoothRewind(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOSmoothRewind:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOTogglePause:static start.*/
                /**
                 * Toggles the paused state (plays if it was paused, pauses if it was playing) of all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens involved.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOTogglePause: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOTogglePause", this ); }

                    return DG.Tweening.DOTween.TogglePause(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOTogglePause:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleAudio end.*/

    /*DG.Tweening.DOTweenModulePhysics start.*/
    Bridge.define("DG.Tweening.DOTweenModulePhysics", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModulePhysics.DOMove:static start.*/
                /**
                 * Tweens a Rigidbody's position to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMove: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMove", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$13(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMove:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOMoveX:static start.*/
                /**
                 * Tweens a Rigidbody's X position to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMoveX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( endValue, 0, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMoveX:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOMoveY:static start.*/
                /**
                 * Tweens a Rigidbody's Y position to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMoveY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0, endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMoveY:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOMoveZ:static start.*/
                /**
                 * Tweens a Rigidbody's Z position to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveZ: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMoveZ", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0, 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Z, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMoveZ:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DORotate:static start.*/
                /**
                 * Tweens a Rigidbody's rotation to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {DG.Tweening.RotateMode}            mode        Rotation mode
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DORotate: function (target, endValue, duration, mode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DORotate", this ); }

                    if (mode === void 0) { mode = 0; }
                    var t = DG.Tweening.DOTween.To$9(function () {
                        return target.rotation;
                    }, Bridge.fn.cacheBind(target, target.MoveRotation), endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), t, target);
                    t.plugOptions.rotateMode = mode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DORotate:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOLookAt:static start.*/
                /**
                 * Tweens a Rigidbody's rotation so that it will look towards the given position.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target            
                 * @param   {UnityEngine.Vector3}               towards           The position to look at
                 * @param   {number}                            duration          The duration of the tween
                 * @param   {DG.Tweening.AxisConstraint}        axisConstraint    Eventual axis constraint for the rotation
                 * @param   {?UnityEngine.Vector3}              up                The vector that defines in which direction up is (default: Vector3.up)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOLookAt: function (target, towards, duration, axisConstraint, up) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOLookAt", this ); }

                    if (axisConstraint === void 0) { axisConstraint = 0; }
                    if (up === void 0) { up = null; }
                    var t = DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.DOTween.To$9(function () {
                        return target.rotation;
                    }, Bridge.fn.cacheBind(target, target.MoveRotation), towards.$clone(), duration), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetLookAt);
                    t.plugOptions.axisConstraint = axisConstraint;
                    t.plugOptions.up = (pc.Vec3.equals( up, null )) ? pc.Vec3.UP.clone() : System.Nullable.getValue(up);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOLookAt:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOJump:static start.*/
                /**
                 * Tweens a Rigidbody's position to the given value, while also applying a jump effect along the Y axis.
                 Returns a Sequence instead of a Tweener.
                 Also stores the Rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}    target       
                 * @param   {UnityEngine.Vector3}      endValue     The end value to reach
                 * @param   {number}                   jumpPower    Power of the jump (the max height of the jump is represented by this plus the final Y offset)
                 * @param   {number}                   numJumps     Total number of jumps
                 * @param   {number}                   duration     The duration of the tween
                 * @param   {boolean}                  snapping     If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Sequence}
                 */
                DOJump: function (target, endValue, jumpPower, numJumps, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOJump", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (numJumps < 1) {
                        numJumps = 1;
                    }
                    var startPosY = 0;
                    var offsetY = -1;
                    var offsetYSet = false;
                    var s = DG.Tweening.DOTween.Sequence();
                    var yTween = DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetRelative(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0, jumpPower, 0 ), duration / (Bridge.Int.mul(numJumps, 2))), DG.Tweening.AxisConstraint.Y, snapping), DG.Tweening.Ease.OutQuad)), Bridge.Int.mul(numJumps, 2), DG.Tweening.LoopType.Yoyo), function () {
                        startPosY = target.position.y;
                    });
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( endValue.x, 0, 0 ), duration), DG.Tweening.AxisConstraint.X, snapping), DG.Tweening.Ease.Linear)), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0, 0, endValue.z ), duration), DG.Tweening.AxisConstraint.Z, snapping), DG.Tweening.Ease.Linear)), yTween), target), DG.Tweening.DOTween.defaultEaseType);
                    DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Tween, yTween, function () {
                        if (!offsetYSet) {
                            offsetYSet = true;
                            offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                        }
                        var pos = target.position.$clone();
                        pos.y += DG.Tweening.DOVirtual.EasedValue(0, offsetY, DG.Tweening.TweenExtensions.ElapsedPercentage(yTween), DG.Tweening.Ease.OutQuad);
                        target.MovePosition(pos);
                    });
                    return s;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOJump:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOPath:static start.*/
                /**
                 * Tweens a Rigidbody's position through the given path waypoints, using the chosen path algorithm.
                 Also stores the Rigidbody as the tween's target so it can be used for filtered operations.
                 <p>NOTE: to tween a rigidbody correctly it should be set to kinematic at least while being tweened.</p><p>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
                 If you plan to publish there you should use a regular transform.DOPath.</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target        
                 * @param   {Array.<UnityEngine.Vector3>}       path          The waypoints to go through
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {DG.Tweening.PathType}              pathType      The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)
                 * @param   {DG.Tweening.PathMode}              pathMode      The path mode: 3D, side-scroller 2D, top-down 2D
                 * @param   {number}                            resolution    The resolution of the path (useless in case of Linear paths): higher resolutions make for more detailed curved paths but are more expensive.
                 Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints
                 * @param   {?UnityEngine.Color}                gizmoColor    The color of the path (shown when gizmos are active in the Play panel and the tween is running)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOPath:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOPath$1:static start.*/
                DOPath$1: function (target, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOPath$1", this ); }

                    if (pathMode === void 0) { pathMode = 1; }
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), path, duration), target);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOPath$1:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath:static start.*/
                /**
                 * Tweens a Rigidbody's localPosition through the given path waypoints, using the chosen path algorithm.
                 Also stores the Rigidbody as the tween's target so it can be used for filtered operations
                 <p>NOTE: to tween a rigidbody correctly it should be set to kinematic at least while being tweened.</p><p>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
                 If you plan to publish there you should use a regular transform.DOLocalPath.</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target        
                 * @param   {Array.<UnityEngine.Vector3>}       path          The waypoint to go through
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {DG.Tweening.PathType}              pathType      The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)
                 * @param   {DG.Tweening.PathMode}              pathMode      The path mode: 3D, side-scroller 2D, top-down 2D
                 * @param   {number}                            resolution    The resolution of the path: higher resolutions make for more detailed curved paths but are more expensive.
                 Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints
                 * @param   {?UnityEngine.Color}                gizmoColor    The color of the path (shown when gizmos are active in the Play panel and the tween is running)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOLocalPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOLocalPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var trans = target.transform;
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return trans.localPosition;
                    }, function (x) {
                        target.MovePosition(UnityEngine.Component.op_Equality(trans.parent, null) ? x.$clone() : trans.parent.TransformPoint$1(x));
                    }, new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath$1:static start.*/
                DOLocalPath$1: function (target, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOLocalPath$1", this ); }

                    if (pathMode === void 0) { pathMode = 1; }
                    var trans = target.transform;
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return trans.localPosition;
                    }, function (x) {
                        target.MovePosition(UnityEngine.Component.op_Equality(trans.parent, null) ? x.$clone() : trans.parent.TransformPoint$1(x));
                    }, path, duration), target);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath$1:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModulePhysics end.*/

    /*DG.Tweening.DOTweenModulePhysics2D start.*/
    Bridge.define("DG.Tweening.DOTweenModulePhysics2D", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModulePhysics2D.DOMove:static start.*/
                /**
                 * Tweens a Rigidbody2D's position to the given value.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMove: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOMove", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOMove:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveX:static start.*/
                /**
                 * Tweens a Rigidbody2D's X position to the given value.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOMoveX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec2( endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveX:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveY:static start.*/
                /**
                 * Tweens a Rigidbody2D's Y position to the given value.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOMoveY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec2( 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveY:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DORotate:static start.*/
                /**
                 * Tweens a Rigidbody2D's rotation to the given value.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DORotate: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DORotate", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.rotation;
                    }, Bridge.fn.cacheBind(target, target.MoveRotation), endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DORotate:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOJump:static start.*/
                /**
                 * Tweens a Rigidbody2D's position to the given value, while also applying a jump effect along the Y axis.
                 Returns a Sequence instead of a Tweener.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations.
                 <p>IMPORTANT: a rigidbody2D can't be animated in a jump arc using MovePosition, so the tween will directly set the position</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}    target       
                 * @param   {UnityEngine.Vector2}        endValue     The end value to reach
                 * @param   {number}                     jumpPower    Power of the jump (the max height of the jump is represented by this plus the final Y offset)
                 * @param   {number}                     numJumps     Total number of jumps
                 * @param   {number}                     duration     The duration of the tween
                 * @param   {boolean}                    snapping     If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Sequence}
                 */
                DOJump: function (target, endValue, jumpPower, numJumps, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOJump", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (numJumps < 1) {
                        numJumps = 1;
                    }
                    var startPosY = 0;
                    var offsetY = -1;
                    var offsetYSet = false;
                    var s = DG.Tweening.DOTween.Sequence();
                    var yTween = DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetRelative(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, function (x) {
                        target.position = x.$clone();
                    }, new pc.Vec2( 0, jumpPower ), duration / (Bridge.Int.mul(numJumps, 2))), DG.Tweening.AxisConstraint.Y, snapping), DG.Tweening.Ease.OutQuad)), Bridge.Int.mul(numJumps, 2), DG.Tweening.LoopType.Yoyo), function () {
                        startPosY = target.position.y;
                    });
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, function (x) {
                        target.position = x.$clone();
                    }, new pc.Vec2( endValue.x, 0 ), duration), DG.Tweening.AxisConstraint.X, snapping), DG.Tweening.Ease.Linear)), yTween), target), DG.Tweening.DOTween.defaultEaseType);
                    DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Tween, yTween, function () {
                        if (!offsetYSet) {
                            offsetYSet = true;
                            offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                        }
                        var pos = UnityEngine.Vector3.FromVector2(target.position.$clone());
                        pos.y += DG.Tweening.DOVirtual.EasedValue(0, offsetY, DG.Tweening.TweenExtensions.ElapsedPercentage(yTween), DG.Tweening.Ease.OutQuad);
                        target.MovePosition$1(pos.$clone());
                    });
                    return s;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOJump:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOPath:static start.*/
                /**
                 * Tweens a Rigidbody2D's position through the given path waypoints, using the chosen path algorithm.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations.
                 <p>NOTE: to tween a Rigidbody2D correctly it should be set to kinematic at least while being tweened.</p><p>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
                 If you plan to publish there you should use a regular transform.DOPath.</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target        
                 * @param   {Array.<UnityEngine.Vector2>}       path          The waypoints to go through
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {DG.Tweening.PathType}              pathType      The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)
                 * @param   {DG.Tweening.PathMode}              pathMode      The path mode: 3D, side-scroller 2D, top-down 2D
                 * @param   {number}                            resolution    The resolution of the path (useless in case of Linear paths): higher resolutions make for more detailed curved paths but are more expensive.
                 Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints
                 * @param   {?UnityEngine.Color}                gizmoColor    The color of the path (shown when gizmos are active in the Play panel and the tween is running)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var len = path.length;
                    var path3D = System.Array.init(len, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        path3D[i] = UnityEngine.Vector3.FromVector2(path[i].$clone());
                    }
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return UnityEngine.Vector3.FromVector2(target.position);
                    }, function (x) {
                        target.MovePosition$1(x.$clone());
                    }, new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path3D, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);

                    t.plugOptions.isRigidbody2D = true;
                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOPath:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOPath$1:static start.*/
                DOPath$1: function (target, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOPath$1", this ); }

                    if (pathMode === void 0) { pathMode = 1; }
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return UnityEngine.Vector3.FromVector2(target.position);
                    }, function (x) {
                        target.MovePosition$1(x.$clone());
                    }, path, duration), target);

                    t.plugOptions.isRigidbody2D = true;
                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOPath$1:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOLocalPath:static start.*/
                /**
                 * Tweens a Rigidbody2D's localPosition through the given path waypoints, using the chosen path algorithm.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 <p>NOTE: to tween a Rigidbody2D correctly it should be set to kinematic at least while being tweened.</p><p>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
                 If you plan to publish there you should use a regular transform.DOLocalPath.</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target        
                 * @param   {Array.<UnityEngine.Vector2>}       path          The waypoint to go through
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {DG.Tweening.PathType}              pathType      The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)
                 * @param   {DG.Tweening.PathMode}              pathMode      The path mode: 3D, side-scroller 2D, top-down 2D
                 * @param   {number}                            resolution    The resolution of the path: higher resolutions make for more detailed curved paths but are more expensive.
                 Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints
                 * @param   {?UnityEngine.Color}                gizmoColor    The color of the path (shown when gizmos are active in the Play panel and the tween is running)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOLocalPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOLocalPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var len = path.length;
                    var path3D = System.Array.init(len, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        path3D[i] = UnityEngine.Vector3.FromVector2(path[i].$clone());
                    }
                    var trans = target.transform;
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return trans.localPosition;
                    }, function (x) {
                        target.MovePosition$1(UnityEngine.Component.op_Equality(trans.parent, null) ? x.$clone() : trans.parent.TransformPoint$1(x));
                    }, new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path3D, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);

                    t.plugOptions.isRigidbody2D = true;
                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOLocalPath:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOLocalPath$1:static start.*/
                DOLocalPath$1: function (target, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOLocalPath$1", this ); }

                    if (pathMode === void 0) { pathMode = 1; }
                    var trans = target.transform;
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return trans.localPosition;
                    }, function (x) {
                        target.MovePosition$1(UnityEngine.Component.op_Equality(trans.parent, null) ? x.$clone() : trans.parent.TransformPoint$1(x));
                    }, path, duration), target);

                    t.plugOptions.isRigidbody2D = true;
                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOLocalPath$1:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModulePhysics2D end.*/

    /*DG.Tweening.DOTweenModuleSprite start.*/
    Bridge.define("DG.Tweening.DOTweenModuleSprite", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleSprite.DOColor:static start.*/
                /**
                 * Tweens a SpriteRenderer's color to the given value.
                 Also stores the spriteRenderer as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}        target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOColor", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOColor:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOFade:static start.*/
                /**
                 * Tweens a Material's alpha color to the given value.
                 Also stores the spriteRenderer as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}        target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOFade", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOFade:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOGradientColor:static start.*/
                /**
                 * Tweens a SpriteRenderer's color using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}    target      
                 * @param   {pc.ColorGradient}              gradient    The gradient to use
                 * @param   {number}                        duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.DOTweenModuleSprite.DOColor(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOBlendableColor:static start.*/
                /**
                 * Tweens a SpriteRenderer's color to the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the SpriteRenderer as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}    target      
                 * @param   {UnityEngine.Color}             endValue    The value to tween to
                 * @param   {number}                        duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOBlendableColor", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleSprite.DOBlendableColor:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleSprite end.*/

    /*DG.Tweening.DOTweenModuleUI start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUI", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUI.DOFade:static start.*/
                /**
                 * Tweens a CanvasGroup's alpha color to the given value.
                 Also stores the canvasGroup as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.CanvasGroup}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.alpha;
                    }, function (x) {
                        target.alpha = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$1:static start.*/
                /**
                 * Tweens an Graphic's alpha color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Graphic}            target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$1", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$2:static start.*/
                /**
                 * Tweens an Image's alpha color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}              target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$2", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$2:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$3:static start.*/
                /**
                 * Tweens a Outline's effectColor alpha to the given value.
                 Also stores the Outline as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Outline}            target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$3: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$3", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.effectColor;
                    }, function (x) {
                        target.effectColor = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$3:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$4:static start.*/
                /**
                 * Tweens a Text's alpha color to the given value.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}               target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$4: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$4", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$4:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor:static start.*/
                /**
                 * Tweens an Graphic's color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Graphic}            target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor$1:static start.*/
                /**
                 * Tweens an Image's color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}              target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor$1", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor$2:static start.*/
                /**
                 * Tweens a Outline's effectColor to the given value.
                 Also stores the Outline as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Outline}            target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor$2", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.effectColor;
                    }, function (x) {
                        target.effectColor = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor$2:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor$3:static start.*/
                /**
                 * Tweens a Text's color to the given value.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}               target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$3: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor$3", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor$3:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFillAmount:static start.*/
                /**
                 * Tweens an Image's fillAmount to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}              target      
                 * @param   {number}                            endValue    The end value to reach (0 to 1)
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFillAmount: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFillAmount", this ); }

                    if (endValue > 1) {
                        endValue = 1;
                    } else {
                        if (endValue < 0) {
                            endValue = 0;
                        }
                    }
                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.fillAmount;
                    }, function (x) {
                        target.fillAmount = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFillAmount:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOGradientColor:static start.*/
                /**
                 * Tweens an Image's colors using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}    target      
                 * @param   {pc.ColorGradient}        gradient    The gradient to use
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.DOTweenModuleUI.DOColor$1(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUI.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFlexibleSize:static start.*/
                /**
                 * Tweens an LayoutElement's flexibleWidth/Height to the given value.
                 Also stores the LayoutElement as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.LayoutElement}      target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFlexibleSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFlexibleSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.flexibleWidth, target.flexibleHeight );
                    }, function (x) {
                        target.flexibleWidth = x.x;
                        target.flexibleHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFlexibleSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOMinSize:static start.*/
                /**
                 * Tweens an LayoutElement's minWidth/Height to the given value.
                 Also stores the LayoutElement as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.LayoutElement}      target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMinSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOMinSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.minWidth, target.minHeight );
                    }, function (x) {
                        target.minWidth = x.x;
                        target.minHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOMinSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPreferredSize:static start.*/
                /**
                 * Tweens an LayoutElement's preferredWidth/Height to the given value.
                 Also stores the LayoutElement as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.LayoutElement}      target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPreferredSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPreferredSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.preferredWidth, target.preferredHeight );
                    }, function (x) {
                        target.preferredWidth = x.x;
                        target.preferredHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPreferredSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOScale:static start.*/
                /**
                 * Tweens a Outline's effectDistance to the given value.
                 Also stores the Outline as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Outline}            target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOScale: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOScale", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.effectDistance;
                    }, function (x) {
                        target.effectDistance = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOScale:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosX:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition X to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPosX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPosX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosY:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition Y to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPosY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPosY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3D:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3D: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3D", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$13(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3D:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DX:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D X to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3DX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( endValue, 0, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DY:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D Y to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3DY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( 0, endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DZ:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D Z to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3DZ: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DZ", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( 0, 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Z, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DZ:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorMax:static start.*/
                /**
                 * Tweens a RectTransform's anchorMax to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorMax: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorMax", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchorMax;
                    }, function (x) {
                        target.anchorMax = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorMax:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorMin:static start.*/
                /**
                 * Tweens a RectTransform's anchorMin to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorMin: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorMin", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchorMin;
                    }, function (x) {
                        target.anchorMin = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorMin:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivot:static start.*/
                /**
                 * Tweens a RectTransform's pivot to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPivot: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivot", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivot:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivotX:static start.*/
                /**
                 * Tweens a RectTransform's pivot X to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPivotX: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivotX", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, new pc.Vec2( endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.X), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivotX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivotY:static start.*/
                /**
                 * Tweens a RectTransform's pivot Y to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPivotY: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivotY", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, new pc.Vec2( 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.Y), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivotY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOSizeDelta:static start.*/
                /**
                 * Tweens a RectTransform's sizeDelta to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOSizeDelta: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOSizeDelta", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.sizeDelta;
                    }, function (x) {
                        target.sizeDelta = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOSizeDelta:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPunchAnchorPos:static start.*/
                /**
                 * Punches a RectTransform's anchoredPosition towards the given direction and then back to the starting one
                 as if it was connected to the starting position via an elastic.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}    target        
                 * @param   {UnityEngine.Vector2}          punch         The direction and strength of the punch (added to the RectTransform's current position)
                 * @param   {number}                       duration      The duration of the tween
                 * @param   {number}                       vibrato       Indicates how much will the punch vibrate
                 * @param   {number}                       elasticity    Represents how much (0 to 1) the vector will go beyond the starting position when bouncing backwards.
                 1 creates a full oscillation between the punch direction and the opposite direction,
                 while 0 oscillates only between the punch and the start position
                 * @param   {boolean}                      snapping      If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOPunchAnchorPos: function (target, punch, duration, vibrato, elasticity, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPunchAnchorPos", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (elasticity === void 0) { elasticity = 1.0; }
                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Punch(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, UnityEngine.Vector3.FromVector2(punch.$clone()), duration, vibrato, elasticity), target), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOPunchAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos:static start.*/
                /**
                 * Shakes a RectTransform's anchoredPosition with the given values.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}    target        
                 * @param   {number}                       duration      The duration of the tween
                 * @param   {number}                       strength      The shake strength
                 * @param   {number}                       vibrato       Indicates how much will the shake vibrate
                 * @param   {number}                       randomness    Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware). 
                 Setting it to 0 will shake along a single direction.
                 * @param   {boolean}                      snapping      If TRUE the tween will smoothly snap all values to integers
                 * @param   {boolean}                      fadeOut       If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it will not
                 * @return  {DG.Tweening.Tweener}
                 */
                DOShakeAnchorPos: function (target, duration, strength, vibrato, randomness, snapping, fadeOut) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos", this ); }

                    if (strength === void 0) { strength = 100.0; }
                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (snapping === void 0) { snapping = false; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Shake(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, duration, strength, vibrato, randomness, true, fadeOut), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetShake), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos$1:static start.*/
                /**
                 * Shakes a RectTransform's anchoredPosition with the given values.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}    target        
                 * @param   {number}                       duration      The duration of the tween
                 * @param   {UnityEngine.Vector2}          strength      The shake strength on each axis
                 * @param   {number}                       vibrato       Indicates how much will the shake vibrate
                 * @param   {number}                       randomness    Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware). 
                 Setting it to 0 will shake along a single direction.
                 * @param   {boolean}                      snapping      If TRUE the tween will smoothly snap all values to integers
                 * @param   {boolean}                      fadeOut       If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it will not
                 * @return  {DG.Tweening.Tweener}
                 */
                DOShakeAnchorPos$1: function (target, duration, strength, vibrato, randomness, snapping, fadeOut) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos$1", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (snapping === void 0) { snapping = false; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Shake$1(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, duration, UnityEngine.Vector3.FromVector2(strength.$clone()), vibrato, randomness, fadeOut), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetShake), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOJumpAnchorPos:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition to the given value, while also applying a jump effect along the Y axis.
                 Returns a Sequence instead of a Tweener.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}    target       
                 * @param   {UnityEngine.Vector2}          endValue     The end value to reach
                 * @param   {number}                       jumpPower    Power of the jump (the max height of the jump is represented by this plus the final Y offset)
                 * @param   {number}                       numJumps     Total number of jumps
                 * @param   {number}                       duration     The duration of the tween
                 * @param   {boolean}                      snapping     If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Sequence}
                 */
                DOJumpAnchorPos: function (target, endValue, jumpPower, numJumps, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOJumpAnchorPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (numJumps < 1) {
                        numJumps = 1;
                    }
                    var startPosY = 0;
                    var offsetY = -1;
                    var offsetYSet = false;

                    // Separate Y Tween so we can elaborate elapsedPercentage on that insted of on the Sequence
                    // (in case users add a delay or other elements to the Sequence)
                    var s = DG.Tweening.DOTween.Sequence();
                    var yTween = DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetRelative(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( 0, jumpPower ), duration / (Bridge.Int.mul(numJumps, 2))), DG.Tweening.AxisConstraint.Y, snapping), DG.Tweening.Ease.OutQuad)), Bridge.Int.mul(numJumps, 2), DG.Tweening.LoopType.Yoyo), function () {
                        startPosY = target.anchoredPosition.y;
                    });
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( endValue.x, 0 ), duration), DG.Tweening.AxisConstraint.X, snapping), DG.Tweening.Ease.Linear)), yTween), target), DG.Tweening.DOTween.defaultEaseType);
                    DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Sequence, s, function () {
                        if (!offsetYSet) {
                            offsetYSet = true;
                            offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                        }
                        var pos = target.anchoredPosition.$clone();
                        pos.y += DG.Tweening.DOVirtual.EasedValue(0, offsetY, DG.Tweening.TweenExtensions.ElapsedDirectionalPercentage(s), DG.Tweening.Ease.OutQuad);
                        target.anchoredPosition = pos.$clone();
                    });
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUI.DOJumpAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DONormalizedPos:static start.*/
                /**
                 * Tweens a ScrollRect's horizontal/verticalNormalizedPosition to the given value.
                 Also stores the ScrollRect as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.ScrollRect}    target      
                 * @param   {UnityEngine.Vector2}          endValue    The end value to reach
                 * @param   {number}                       duration    The duration of the tween
                 * @param   {boolean}                      snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DONormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DONormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.horizontalNormalizedPosition, target.verticalNormalizedPosition );
                    }, function (x) {
                        target.horizontalNormalizedPosition = x.x;
                        target.verticalNormalizedPosition = x.y;
                    }, endValue.$clone(), duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DONormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOHorizontalNormalizedPos:static start.*/
                /**
                 * Tweens a ScrollRect's horizontalNormalizedPosition to the given value.
                 Also stores the ScrollRect as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.ScrollRect}    target      
                 * @param   {number}                       endValue    The end value to reach
                 * @param   {number}                       duration    The duration of the tween
                 * @param   {boolean}                      snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOHorizontalNormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOHorizontalNormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(DG.Tweening.DOTween.To$4(function () {
                        return target.horizontalNormalizedPosition;
                    }, function (x) {
                        target.horizontalNormalizedPosition = x;
                    }, endValue, duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOHorizontalNormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOVerticalNormalizedPos:static start.*/
                /**
                 * Tweens a ScrollRect's verticalNormalizedPosition to the given value.
                 Also stores the ScrollRect as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.ScrollRect}    target      
                 * @param   {number}                       endValue    The end value to reach
                 * @param   {number}                       duration    The duration of the tween
                 * @param   {boolean}                      snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOVerticalNormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOVerticalNormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(DG.Tweening.DOTween.To$4(function () {
                        return target.verticalNormalizedPosition;
                    }, function (x) {
                        target.verticalNormalizedPosition = x;
                    }, endValue, duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOVerticalNormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOValue:static start.*/
                /**
                 * Tweens a Slider's value to the given value.
                 Also stores the Slider as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Slider}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOValue: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOValue", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.value;
                    }, function (x) {
                        target.value = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOValue:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOCounter:static start.*/
                /**
                 * Tweens a Text's text from one integer to another, with options for thousands separators
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}                 target                   
                 * @param   {number}                              fromValue                The value to start from
                 * @param   {number}                              endValue                 The end value to reach
                 * @param   {number}                              duration                 The duration of the tween
                 * @param   {boolean}                             addThousandsSeparator    If TRUE (default) also adds thousands separators
                 * @param   {System.Globalization.CultureInfo}    culture                  The {@link } to use (InvariantCulture if NULL)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOCounter: function (target, fromValue, endValue, duration, addThousandsSeparator, culture) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOCounter", this ); }

                    if (addThousandsSeparator === void 0) { addThousandsSeparator = true; }
                    if (culture === void 0) { culture = null; }
                    var v = fromValue;
                    var cInfo = !addThousandsSeparator ? null : culture || System.Globalization.CultureInfo.invariantCulture;
                    var t = DG.Tweening.DOTween.To$2(function () {
                        return v;
                    }, function (x) {
                        v = x;
                        target.text = addThousandsSeparator ? System.Int32.format(v, "N0", cInfo) : Bridge.toString(v);
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Int32,System.Int32,DG.Tweening.Plugins.Options.NoOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOCounter:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOText:static start.*/
                /**
                 * Tweens a Text's text to the given value.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}               target             
                 * @param   {string}                            endValue           The end string to tween to
                 * @param   {number}                            duration           The duration of the tween
                 * @param   {boolean}                           richTextEnabled    If TRUE (default), rich text will be interpreted correctly while animated,
                 otherwise all tags will be considered as normal text
                 * @param   {DG.Tweening.ScrambleMode}          scrambleMode       The type of scramble mode to use, if any
                 * @param   {string}                            scrambleChars      A string containing the characters to use for scrambling.
                 Use as many characters as possible (minimum 10) because DOTween uses a fast scramble mode which gives better results with more characters.
                 Leave it to NULL (default) to use default ones
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOText: function (target, endValue, duration, richTextEnabled, scrambleMode, scrambleChars) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOText", this ); }

                    if (richTextEnabled === void 0) { richTextEnabled = true; }
                    if (scrambleMode === void 0) { scrambleMode = 0; }
                    if (scrambleChars === void 0) { scrambleChars = null; }
                    if (endValue == null) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogWarning("You can't pass a NULL string to DOText: an empty string will be used instead to avoid errors");
                        }
                        endValue = "";
                    }
                    var t = DG.Tweening.DOTween.To$5(function () {
                        return target.text;
                    }, function (x) {
                        target.text = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$3(t, richTextEnabled, scrambleMode, scrambleChars), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOText:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor:static start.*/
                /**
                 * Tweens a Graphic's color to the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the Graphic as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Graphic}    target      
                 * @param   {UnityEngine.Color}         endValue    The value to tween to
                 * @param   {number}                    duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$1:static start.*/
                /**
                 * Tweens a Image's color to the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the Image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}    target      
                 * @param   {UnityEngine.Color}       endValue    The value to tween to
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor$1", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$2:static start.*/
                /**
                 * Tweens a Text's color BY the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}    target      
                 * @param   {UnityEngine.Color}      endValue    The value to tween to
                 * @param   {number}                 duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor$2", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$2:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOShapeCircle:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition so that it draws a circle around the given center.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations.<p />
                 IMPORTANT: SetFrom(value) requires a {@link } instead of a float, where the X property represents the "from degrees value"
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target             
                 * @param   {UnityEngine.Vector2}               center             Circle-center/pivot around which to rotate (in UI anchoredPosition coordinates)
                 * @param   {number}                            endValueDegrees    The end value degrees to reach (to rotate counter-clockwise pass a negative value)
                 * @param   {number}                            duration           The duration of the tween
                 * @param   {boolean}                           relativeCenter     If TRUE the {@link } coordinates will be considered as relative to the target's current anchoredPosition
                 * @param   {boolean}                           snapping           If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOShapeCircle: function (target, center, endValueDegrees, duration, relativeCenter, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOShapeCircle", this ); }

                    if (relativeCenter === void 0) { relativeCenter = false; }
                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To(UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.CircleOptions, DG.Tweening.Plugins.CirclePlugin.Get(), function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, center.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$7(t, endValueDegrees, relativeCenter, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOShapeCircle:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUI end.*/

    /*DG.Tweening.DOTweenModuleUI+Utils start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUI.Utils", {
        $kind: 1002,
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUI+Utils.SwitchToRectTransform:static start.*/
                /**
                 * Converts the anchoredPosition of the first RectTransform to the second RectTransform,
                 taking into consideration offset, anchors and pivot, and returns the new anchoredPosition
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI.Utils
                 * @memberof DG.Tweening.DOTweenModuleUI.Utils
                 * @param   {UnityEngine.RectTransform}    from    
                 * @param   {UnityEngine.RectTransform}    to
                 * @return  {UnityEngine.Vector2}
                 */
                SwitchToRectTransform: function (from, to) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI.Utils#SwitchToRectTransform", this ); }

                    var localPoint = { v : new UnityEngine.Vector2() };
                    var fromPivotDerivedOffset = new pc.Vec2( from.rect.width * 0.5 + from.rect.xMin, from.rect.height * 0.5 + from.rect.yMin );
                    var screenP = UnityEngine.RectTransformUtility.WorldToScreenPoint(null, from.position.$clone());
                    screenP = screenP.$clone().add( fromPivotDerivedOffset.$clone() );
                    UnityEngine.RectTransformUtility.ScreenPointToLocalPointInRectangle(to, screenP, null, localPoint);
                    var pivotDerivedOffset = new pc.Vec2( to.rect.width * 0.5 + to.rect.xMin, to.rect.height * 0.5 + to.rect.yMin );
                    return to.anchoredPosition.$clone().add( localPoint.v ).sub( pivotDerivedOffset );
                },
                /*DG.Tweening.DOTweenModuleUI+Utils.SwitchToRectTransform:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUI+Utils end.*/

    /*DG.Tweening.DOTweenModuleUnityVersion start.*/
    /** @namespace DG.Tweening */

    /**
     * Shortcuts/functions that are not strictly related to specific Modules
     but are available only on some Unity versions
     *
     * @static
     * @abstract
     * @public
     * @class DG.Tweening.DOTweenModuleUnityVersion
     */
    Bridge.define("DG.Tweening.DOTweenModuleUnityVersion", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor:static start.*/
                /**
                 * Tweens a Material's color using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}    target      
                 * @param   {pc.ColorGradient}        gradient    The gradient to use
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.ShortcutExtensions.DOColor$3(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor$1:static start.*/
                /**
                 * Tweens a Material's named color property using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}    target      
                 * @param   {pc.ColorGradient}        gradient    The gradient to use
                 * @param   {string}                  property    The name of the material property to tween (like _Tint or _SpecColor)
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor$1: function (target, gradient, property, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor$1", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.SetColor$1(property, c.color.$clone());
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.ShortcutExtensions.DOColor$4(target, c.color.$clone(), property, colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForCompletion:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or complete.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForCompletion(true);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForCompletion: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForCompletion", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForCompletion(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForCompletion:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForRewind:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or rewinded.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForRewind();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForRewind: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForRewind", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForRewind(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForRewind:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForKill:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForKill();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForKill: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForKill", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForKill(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForKill:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForElapsedLoops:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or has gone through the given amount of loops.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForElapsedLoops(2);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {number}                                elapsedLoops                    Elapsed loops to wait for
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForElapsedLoops: function (t, elapsedLoops, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForElapsedLoops", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops(t, elapsedLoops);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForElapsedLoops:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForPosition:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed
                 or has reached the given time position (loops included, delays excluded).
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForPosition(2.5f);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {number}                                position                        Position (loops included, delays excluded) to wait for
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForPosition: function (t, position, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForPosition", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForPosition(t, position);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForPosition:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForStart:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or started
                 (meaning when the tween is set in a playing state the first time, after any eventual delay).
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForStart();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForStart: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForStart", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForStart(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForStart:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOOffset:static start.*/
                /**
                 * Tweens a Material's named texture offset property with the given ID to the given value.
                 Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}              target        
                 * @param   {UnityEngine.Vector2}               endValue      The end value to reach
                 * @param   {number}                            propertyID    The ID of the material property to tween (also called nameID in Unity's manual)
                 * @param   {number}                            duration      The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOOffset: function (target, endValue, propertyID, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOOffset", this ); }

                    if (!target.HasProperty(propertyID)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty(propertyID);
                        }
                        return null;
                    }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.GetTextureOffset(propertyID);
                    }, function (x) {
                        target.SetTextureOffset(propertyID, x.$clone());
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOOffset:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOTiling:static start.*/
                /**
                 * Tweens a Material's named texture scale property with the given ID to the given value.
                 Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}              target        
                 * @param   {UnityEngine.Vector2}               endValue      The end value to reach
                 * @param   {number}                            propertyID    The ID of the material property to tween (also called nameID in Unity's manual)
                 * @param   {number}                            duration      The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOTiling: function (target, endValue, propertyID, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOTiling", this ); }

                    if (!target.HasProperty(propertyID)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty(propertyID);
                        }
                        return null;
                    }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.GetTextureScale(propertyID);
                    }, function (x) {
                        target.SetTextureScale(propertyID, x.$clone());
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOTiling:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUnityVersion end.*/

    /*DG.Tweening.DOTweenModuleUtils start.*/
    /**
     * Utility functions that deal with available Modules.
     Modules defines:
     - DOTAUDIO
     - DOTPHYSICS
     - DOTPHYSICS2D
     - DOTSPRITE
     - DOTUI
     Extra defines set and used for implementation of external assets:
     - DOTWEEN_TMP  TextMesh Pro
     - DOTWEEN_TK2D  2D Toolkit
     *
     * @static
     * @abstract
     * @public
     * @class DG.Tweening.DOTweenModuleUtils
     */
    Bridge.define("DG.Tweening.DOTweenModuleUtils", {
        statics: {
            fields: {
                _initialized: false
            },
            methods: {
                /*DG.Tweening.DOTweenModuleUtils.Init:static start.*/
                /**
                 * Called via Reflection by DOTweenComponent on Awake
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUtils
                 * @memberof DG.Tweening.DOTweenModuleUtils
                 * @return  {void}
                 */
                Init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils#Init", this ); }

                    if (DG.Tweening.DOTweenModuleUtils._initialized) {
                        return;
                    }

                    DG.Tweening.DOTweenModuleUtils._initialized = true;
                    DG.Tweening.Core.DOTweenExternalCommand.addSetOrientationOnPath(DG.Tweening.DOTweenModuleUtils.Physics.SetOrientationOnPath);

                },
                /*DG.Tweening.DOTweenModuleUtils.Init:static end.*/

                /*DG.Tweening.DOTweenModuleUtils.Preserver:static start.*/
                Preserver: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils#Preserver", this ); }

                    var loadedAssemblies = System.AppDomain.getAssemblies();
                    var mi = Bridge.Reflection.getMembers(UnityEngine.MonoBehaviour, 8, 284, "Stub");
                },
                /*DG.Tweening.DOTweenModuleUtils.Preserver:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUtils end.*/

    /*DG.Tweening.DOTweenModuleUtils+Physics start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUtils.Physics", {
        $kind: 1002,
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUtils+Physics.SetOrientationOnPath:static start.*/
                SetOrientationOnPath: function (options, t, newRot, trans) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#SetOrientationOnPath", this ); }

                    if (options.isRigidbody) {
                        Bridge.cast(t.target, UnityEngine.Rigidbody).rotation = newRot.$clone();
                    } else {
                        trans.rotation = newRot.$clone();
                    }
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.SetOrientationOnPath:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody2D:static start.*/
                HasRigidbody2D: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody2D", this ); }

                    return UnityEngine.Component.op_Inequality(target.GetComponent(UnityEngine.Rigidbody2D), null);
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody2D:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody:static start.*/
                HasRigidbody: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody", this ); }

                    return UnityEngine.Component.op_Inequality(target.GetComponent(UnityEngine.Rigidbody), null);
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.CreateDOTweenPathTween:static start.*/
                CreateDOTweenPathTween: function (target, tweenRigidbody, isLocal, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#CreateDOTweenPathTween", this ); }

                    var t = null;
                    var rBodyFoundAndTweened = false;
                    if (tweenRigidbody) {
                        var rBody = target.GetComponent(UnityEngine.Rigidbody);
                        if (UnityEngine.Component.op_Inequality(rBody, null)) {
                            rBodyFoundAndTweened = true;
                            t = isLocal ? DG.Tweening.DOTweenModulePhysics.DOLocalPath$1(rBody, path, duration, pathMode) : DG.Tweening.DOTweenModulePhysics.DOPath$1(rBody, path, duration, pathMode);
                        }
                    }
                    if (!rBodyFoundAndTweened && tweenRigidbody) {
                        var rBody2D = target.GetComponent(UnityEngine.Rigidbody2D);
                        if (UnityEngine.Component.op_Inequality(rBody2D, null)) {
                            rBodyFoundAndTweened = true;
                            t = isLocal ? DG.Tweening.DOTweenModulePhysics2D.DOLocalPath$1(rBody2D, path, duration, pathMode) : DG.Tweening.DOTweenModulePhysics2D.DOPath$1(rBody2D, path, duration, pathMode);
                        }
                    }
                    if (!rBodyFoundAndTweened) {
                        t = isLocal ? DG.Tweening.ShortcutExtensions.DOLocalPath(target.transform, path, duration, pathMode) : DG.Tweening.ShortcutExtensions.DOPath(target.transform, path, duration, pathMode);
                    }
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.CreateDOTweenPathTween:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUtils+Physics end.*/

    /*Difficult start.*/
    Bridge.define("Difficult", {
        $kind: 6,
        statics: {
            fields: {
                EASY: 0,
                NORMAL: 1,
                HARD: 2
            }
        }
    });
    /*Difficult end.*/

    /*DrinkMaterial start.*/
    Bridge.define("DrinkMaterial", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                WaterLayer: 0,
                ToppingsLayer: 0,
                IceLayer: 0,
                GlassLayer: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "DrinkMaterial#init", this ); }

                    this.WaterLayer = 4;
                    this.ToppingsLayer = 7;
                    this.IceLayer = 8;
                    this.GlassLayer = 3;
                }
            }
        },
        fields: {
            isCollided: false,
            rb: null,
            isNeverInView: false,
            isRectTransformNull: false,
            rectTransform: null,
            AllowCollisionWithWater: false,
            currentWidth: 0,
            currentHeight: 0
        },
        props: {
            Rb: {
                get: function () {
if ( TRACE ) { TRACE( "DrinkMaterial#Rb#get", this ); }

                    if (UnityEngine.Component.op_Equality(this.rb, null)) {
                        this.rb = this.GetComponent(UnityEngine.Rigidbody2D);
                    }

                    return this.rb;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "DrinkMaterial#init", this ); }

                this.isCollided = false;
                this.AllowCollisionWithWater = true;
            }
        },
        methods: {
            /*DrinkMaterial.Set start.*/
            Set: function (scale) {
if ( TRACE ) { TRACE( "DrinkMaterial#Set", this ); }

                Bridge.cast(this.transform, UnityEngine.RectTransform).sizeDelta = Bridge.cast(this.transform, UnityEngine.RectTransform).sizeDelta.$clone().scale( scale );
            },
            /*DrinkMaterial.Set end.*/

            /*DrinkMaterial.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "DrinkMaterial#Awake", this ); }

                if (UnityEngine.Component.op_Equality(this.rb, null)) {
                    this.rb = this.GetComponent(UnityEngine.Rigidbody2D);
                }
            },
            /*DrinkMaterial.Awake end.*/

            /*DrinkMaterial.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "DrinkMaterial#Start", this ); }

                this.currentWidth = UnityEngine.Screen.width;
                this.currentHeight = UnityEngine.Screen.height;
                if (UnityEngine.Component.op_Equality(this.rectTransform, null)) {
                    this.rectTransform = Bridge.as(this.transform, UnityEngine.RectTransform);
                }
                this.isRectTransformNull = UnityEngine.Component.op_Equality(this.rectTransform, null);
                EventDispatcherExtension.RegisterListener(this, EventID.Destroy, Bridge.fn.bind(this, function (param) {
                    this.FallsOutOfView();
                }));
            },
            /*DrinkMaterial.Start end.*/

            /*DrinkMaterial.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "DrinkMaterial#OnDestroy", this ); }

                EventDispatcherExtension.RemoveListener(this, EventID.Destroy, Bridge.fn.bind(this, function (param) {
                    this.FallsOutOfView();
                }));

            },
            /*DrinkMaterial.OnDestroy end.*/

            /*DrinkMaterial.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "DrinkMaterial#OnEnable", this ); }

                this.isNeverInView = true;
            },
            /*DrinkMaterial.OnEnable end.*/

            /*DrinkMaterial.OnBecameInvisible start.*/
            OnBecameInvisible: function () {
if ( TRACE ) { TRACE( "DrinkMaterial#OnBecameInvisible", this ); }

                this.FallsOutOfView();
            },
            /*DrinkMaterial.OnBecameInvisible end.*/

            /*DrinkMaterial.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "DrinkMaterial#Update", this ); }

                if ((this.currentHeight !== UnityEngine.Screen.height) && (this.currentWidth !== UnityEngine.Screen.width)) {
                    this.currentWidth = UnityEngine.Screen.width;
                    this.currentHeight = UnityEngine.Screen.height;
                    this.rb.isKinematic = true;
                } else {
                    this.rb.isKinematic = false;
                }
            },
            /*DrinkMaterial.Update end.*/

            /*DrinkMaterial.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "DrinkMaterial#LateUpdate", this ); }

                //if (isRectTransformNull) return;


                //if (IsInView())
                //{
                //    isNeverInView = false;
                //    return;
                //}

                //if (isNeverInView) return;

                //FallsOutOfView();
            },
            /*DrinkMaterial.LateUpdate end.*/

            /*DrinkMaterial.IsInView start.*/
            IsInView: function () {
if ( TRACE ) { TRACE( "DrinkMaterial#IsInView", this ); }

                return HelperUtility.IsVisibleFrom(this.rectTransform, UnityEngine.Camera.main);
            },
            /*DrinkMaterial.IsInView end.*/

            /*DrinkMaterial.Destroying start.*/
            Destroying: function () {
if ( TRACE ) { TRACE( "DrinkMaterial#Destroying", this ); }

                this.FallsOutOfView();
            },
            /*DrinkMaterial.Destroying end.*/

            /*DrinkMaterial.FallsOutOfView start.*/
            FallsOutOfView: function () {
if ( TRACE ) { TRACE( "DrinkMaterial#FallsOutOfView", this ); }

                UnityEngine.MonoBehaviour.Destroy(this.gameObject);
            },
            /*DrinkMaterial.FallsOutOfView end.*/

            /*DrinkMaterial.OnCollisionEnter2D start.*/
            OnCollisionEnter2D: function (collision) {
if ( TRACE ) { TRACE( "DrinkMaterial#OnCollisionEnter2D", this ); }

                if (this.isCollided) {
                    return;
                }
                if ((collision.gameObject.layer !== DrinkMaterial.WaterLayer) && (collision.gameObject.layer !== DrinkMaterial.GlassLayer) && (collision.gameObject.layer !== DrinkMaterial.ToppingsLayer)) {
                    return;
                }
                if ((this.gameObject.layer !== DrinkMaterial.ToppingsLayer) && (this.gameObject.layer !== DrinkMaterial.IceLayer)) {
                    return;
                }
                if (!this.IsInView()) {
                    return;
                }
                this.isCollided = true;
                this.PlaySound(collision);
            },
            /*DrinkMaterial.OnCollisionEnter2D end.*/

            /*DrinkMaterial.PlaySound start.*/
            PlaySound: function (collision) {
if ( TRACE ) { TRACE( "DrinkMaterial#PlaySound", this ); }

                if (this.gameObject.layer === DrinkMaterial.IceLayer) {
                    Singleton$1(SoundManager).Instance.PlaySound(2);
                    return;
                } else {
                    Singleton$1(SoundManager).Instance.PlaySound(1);
                }

            },
            /*DrinkMaterial.PlaySound end.*/


        }
    });
    /*DrinkMaterial end.*/

    /*ElementTopping start.*/
    Bridge.define("ElementTopping", {
        fields: {
            prefebTopping: null,
            number: 0
        }
    });
    /*ElementTopping end.*/
    /** @namespace System */

    /**
     * @memberof System
     * @callback System.Action
     * @param   {System.Object}    arg
     * @return  {void}
     */


    /*EventDispatcher start.*/
    Bridge.define("EventDispatcher", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                s_instance: null
            },
            props: {
                Instance: {
                    get: function () {
if ( TRACE ) { TRACE( "EventDispatcher#Instance#get", this ); }

                        // instance not exist, then create new one
                        if (UnityEngine.MonoBehaviour.op_Equality(EventDispatcher.s_instance, null)) {
                            // create new Gameobject, and add EventDispatcher component
                            var singletonObject = new UnityEngine.GameObject.ctor();
                            EventDispatcher.s_instance = singletonObject.AddComponent(EventDispatcher);
                            singletonObject.name = "Singleton - EventDispatcher";
                            //Commons.Log("Create singleton : {0}", singletonObject.name);
                        }
                        return EventDispatcher.s_instance;
                    },
                    set: function (value) {
if ( TRACE ) { TRACE( "EventDispatcher#Instance#set", this ); }
 }
                }
            },
            methods: {
                /*EventDispatcher.HasInstance:static start.*/
                HasInstance: function () {
if ( TRACE ) { TRACE( "EventDispatcher#HasInstance", this ); }

                    return UnityEngine.MonoBehaviour.op_Inequality(EventDispatcher.s_instance, null);
                },
                /*EventDispatcher.HasInstance:static end.*/


            }
        },
        fields: {
            /**
             * @instance
             * @private
             * @memberof EventDispatcher
             * @type System.Collections.Generic.Dictionary$2
             */
            _listeners: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "EventDispatcher#init", this ); }

                this._listeners = new (System.Collections.Generic.Dictionary$2(EventID,Function)).ctor();
            }
        },
        methods: {
            /*EventDispatcher.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "EventDispatcher#Awake", this ); }

                // check if there's another instance already exist in scene
                if (UnityEngine.MonoBehaviour.op_Inequality(EventDispatcher.s_instance, null) && EventDispatcher.s_instance.GetInstanceID() !== this.GetInstanceID()) {
                    // Destroy this instances because already exist the singleton of EventsDispatcer
                    //Commons.Log("An instance of EventDispatcher already exist : <{1}>, So destroy this instance : <{2}>!!", s_instance.name, name);
                    UnityEngine.MonoBehaviour.Destroy(this.gameObject);
                } else {
                    // set instance
                    EventDispatcher.s_instance = this;
                }

                //DontDestroyOnLoad(this);
            },
            /*EventDispatcher.Awake end.*/

            /*EventDispatcher.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "EventDispatcher#OnDestroy", this ); }

                // reset this static var to null if it's the singleton instance
                if (UnityEngine.MonoBehaviour.op_Equality(EventDispatcher.s_instance, this)) {
                    this.ClearAllListener();
                    EventDispatcher.s_instance = null;
                }
            },
            /*EventDispatcher.OnDestroy end.*/

            /*EventDispatcher.RegisterListener start.*/
            /**
             * Register to listen for eventID
             *
             * @instance
             * @public
             * @this EventDispatcher
             * @memberof EventDispatcher
             * @param   {EventID}          eventID     
             * @param   {System.Action}    callback
             * @return  {void}
             */
            RegisterListener: function (eventID, callback) {
if ( TRACE ) { TRACE( "EventDispatcher#RegisterListener", this ); }

                // checking params
                //Commons.Assert(callback != null, "AddListener, event {0}, callback = null !!", eventID.ToString());
                //Commons.Assert(eventID != EventID.None, "RegisterListener, event = None !!");

                // check if listener exist in distionary
                if (this._listeners.containsKey(eventID)) {
                    // add callback to our collection
                    this._listeners.setItem(eventID, Bridge.fn.combine(this._listeners.getItem(eventID), callback));
                } else {
                    // add new key-value pair
                    this._listeners.add(eventID, null);
                    this._listeners.setItem(eventID, Bridge.fn.combine(this._listeners.getItem(eventID), callback));
                }
            },
            /*EventDispatcher.RegisterListener end.*/

            /*EventDispatcher.PostEvent start.*/
            /**
             * Posts the event. This will notify all listener that register for this event
             *
             * @instance
             * @public
             * @this EventDispatcher
             * @memberof EventDispatcher
             * @param   {EventID}          eventID    
             * @param   {System.Object}    param
             * @return  {void}
             */
            PostEvent: function (eventID, param) {
if ( TRACE ) { TRACE( "EventDispatcher#PostEvent", this ); }

                if (param === void 0) { param = null; }
                if (!this._listeners.containsKey(eventID)) {
                    //Commons.Log("No listeners for this event : {0}", eventID);
                    return;
                }

                // posting event
                var callbacks = this._listeners.getItem(eventID);
                // if there's no listener remain, then do nothing
                if (!Bridge.staticEquals(callbacks, null)) {
                    callbacks(param);
                } else {
                    //Commons.Log("PostEvent {0}, but no listener remain, Remove this key", eventID);
                    this._listeners.remove(eventID);
                }
            },
            /*EventDispatcher.PostEvent end.*/

            /*EventDispatcher.RemoveListener start.*/
            /**
             * Removes the listener. Use to Unregister listener
             *
             * @instance
             * @public
             * @this EventDispatcher
             * @memberof EventDispatcher
             * @param   {EventID}          eventID     
             * @param   {System.Action}    callback
             * @return  {void}
             */
            RemoveListener: function (eventID, callback) {
if ( TRACE ) { TRACE( "EventDispatcher#RemoveListener", this ); }

                // checking params
                //Commons.Assert(callback != null, "RemoveListener, event {0}, callback = null !!", eventID.ToString());
                //Commons.Assert(eventID != EventID.None, "AddListener, event = None !!");

                if (this._listeners.containsKey(eventID)) {
                    this._listeners.setItem(eventID, Bridge.fn.remove(this._listeners.getItem(eventID), callback));
                } else {
                    //Commons.Warning(false, "RemoveListener, not found key : " + eventID);
                }
            },
            /*EventDispatcher.RemoveListener end.*/

            /*EventDispatcher.ClearAllListener start.*/
            /**
             * Clears all the listener.
             *
             * @instance
             * @public
             * @this EventDispatcher
             * @memberof EventDispatcher
             * @return  {void}
             */
            ClearAllListener: function () {
if ( TRACE ) { TRACE( "EventDispatcher#ClearAllListener", this ); }

                this._listeners.clear();
            },
            /*EventDispatcher.ClearAllListener end.*/


        }
    });
    /*EventDispatcher end.*/

    /*EventDispatcherExtension start.*/
    /**
     * Delare some "shortcut" for using EventDispatcher easier
     *
     * @static
     * @abstract
     * @public
     * @class EventDispatcherExtension
     */
    Bridge.define("EventDispatcherExtension", {
        statics: {
            methods: {
                /*EventDispatcherExtension.RegisterListener:static start.*/
                /**
                 * @static
                 * @public
                 * @this EventDispatcherExtension
                 * @memberof EventDispatcherExtension
                 * @param   {UnityEngine.MonoBehaviour}    listener    
                 * @param   {EventID}                      eventID     
                 * @param   {System.Action}                callback
                 * @return  {void}
                 */
                RegisterListener: function (listener, eventID, callback) {
if ( TRACE ) { TRACE( "EventDispatcherExtension#RegisterListener", this ); }

                    EventDispatcher.Instance.RegisterListener(eventID, callback);
                },
                /*EventDispatcherExtension.RegisterListener:static end.*/

                /*EventDispatcherExtension.PostEvent$1:static start.*/
                /**
                 * @static
                 * @public
                 * @this EventDispatcherExtension
                 * @memberof EventDispatcherExtension
                 * @param   {UnityEngine.MonoBehaviour}    listener    
                 * @param   {EventID}                      eventID     
                 * @param   {System.Object}                param
                 * @return  {void}
                 */
                PostEvent$1: function (listener, eventID, param) {
if ( TRACE ) { TRACE( "EventDispatcherExtension#PostEvent$1", this ); }

                    EventDispatcher.Instance.PostEvent(eventID, param);
                },
                /*EventDispatcherExtension.PostEvent$1:static end.*/

                /*EventDispatcherExtension.PostEvent:static start.*/
                /**
                 * @static
                 * @public
                 * @this EventDispatcherExtension
                 * @memberof EventDispatcherExtension
                 * @param   {UnityEngine.MonoBehaviour}    sender     
                 * @param   {EventID}                      eventID
                 * @return  {void}
                 */
                PostEvent: function (sender, eventID) {
if ( TRACE ) { TRACE( "EventDispatcherExtension#PostEvent", this ); }

                    EventDispatcher.Instance.PostEvent(eventID, null);
                },
                /*EventDispatcherExtension.PostEvent:static end.*/

                /*EventDispatcherExtension.RemoveListener:static start.*/
                /**
                 * @static
                 * @public
                 * @this EventDispatcherExtension
                 * @memberof EventDispatcherExtension
                 * @param   {UnityEngine.MonoBehaviour}    sender      
                 * @param   {EventID}                      eventID     
                 * @param   {System.Action}                callback
                 * @return  {void}
                 */
                RemoveListener: function (sender, eventID, callback) {
if ( TRACE ) { TRACE( "EventDispatcherExtension#RemoveListener", this ); }

                    EventDispatcher.Instance.RemoveListener(eventID, callback);
                },
                /*EventDispatcherExtension.RemoveListener:static end.*/


            }
        }
    });
    /*EventDispatcherExtension end.*/

    /*EventID start.*/
    Bridge.define("EventID", {
        $kind: 6,
        statics: {
            fields: {
                Destroy: 0,
                CheckMerge: 1,
                EndGame: 2
            }
        }
    });
    /*EventID end.*/

    /*Faucet start.*/
    Bridge.define("Faucet", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            color: null,
            image: null,
            spawner: null,
            eventTrigger: null
        },
        props: {
            particleCount: {
                get: function () {
if ( TRACE ) { TRACE( "Faucet#particleCount#get", this ); }

                    return this.spawner.transform.childCount;
                }
            },
            Color: {
                get: function () {
if ( TRACE ) { TRACE( "Faucet#Color#get", this ); }

                    return this.color.$clone();
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Faucet#init", this ); }

                this.color = new UnityEngine.Color();
            }
        },
        methods: {
            /*Faucet.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Faucet#Awake", this ); }

                var pointerDownEntry = new UnityEngine.EventSystems.EventTrigger.Entry();
                pointerDownEntry.eventID = UnityEngine.EventSystems.EventTriggerType.PointerDown;
                pointerDownEntry.callback.AddListener(Bridge.fn.cacheBind(this, this.OnPointerDown));

                var pointerUpEntry = new UnityEngine.EventSystems.EventTrigger.Entry();
                pointerUpEntry.eventID = UnityEngine.EventSystems.EventTriggerType.PointerUp;
                pointerUpEntry.callback.AddListener(Bridge.fn.cacheBind(this, this.OnPointerUp));

                this.eventTrigger.triggers.add(pointerDownEntry);
                this.eventTrigger.triggers.add(pointerUpEntry);
                this.SetColor(this.color.$clone());
            },
            /*Faucet.Awake end.*/

            /*Faucet.Clean start.*/
            Clean: function () {
if ( TRACE ) { TRACE( "Faucet#Clean", this ); }

                this.spawner.Restore();
            },
            /*Faucet.Clean end.*/

            /*Faucet.OnPointerDown start.*/
            OnPointerDown: function (arg0) {
if ( TRACE ) { TRACE( "Faucet#OnPointerDown", this ); }

                // Spawn();
            },
            /*Faucet.OnPointerDown end.*/

            /*Faucet.OnPointerUp start.*/
            OnPointerUp: function (arg0) {
if ( TRACE ) { TRACE( "Faucet#OnPointerUp", this ); }

                // StopSpawning();
            },
            /*Faucet.OnPointerUp end.*/

            /*Faucet.Spawn start.*/
            Spawn: function () {
if ( TRACE ) { TRACE( "Faucet#Spawn", this ); }

                this.spawner.Spawn();
            },
            /*Faucet.Spawn end.*/

            /*Faucet.StopSpawning start.*/
            StopSpawning: function () {
if ( TRACE ) { TRACE( "Faucet#StopSpawning", this ); }

                this.spawner.StopSpawning();
            },
            /*Faucet.StopSpawning end.*/

            /*Faucet.SetColor start.*/
            SetColor: function (color) {
if ( TRACE ) { TRACE( "Faucet#SetColor", this ); }

                this.color = color.$clone();
                this.spawner.FillColor = color.$clone();
                this.image.color = color.$clone();
            },
            /*Faucet.SetColor end.*/

            /*Faucet.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "Faucet#OnValidate", this ); }

                if (!pc.Color.equals( this.color, this.spawner.FillColor )) {
                    this.SetColor(this.color.$clone());
                }
            },
            /*Faucet.OnValidate end.*/


        }
    });
    /*Faucet end.*/

    /*FaucetManager start.*/
    Bridge.define("FaucetManager", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            CanvasGroup: null,
            faucetPrefab: null,
            faucets: null
        },
        props: {
            Faucets: {
                get: function () {
if ( TRACE ) { TRACE( "FaucetManager#Faucets#get", this ); }

                    return this.faucets;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "FaucetManager#init", this ); }

                this.faucets = new (System.Collections.Generic.List$1(Faucet)).ctor();
            }
        },
        methods: {
            /*FaucetManager.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "FaucetManager#Awake", this ); }

                this.faucets.add(this.faucetPrefab);
            },
            /*FaucetManager.Awake end.*/

            /*FaucetManager.SetColors start.*/
            SetColors: function (colors) {
if ( TRACE ) { TRACE( "FaucetManager#SetColors", this ); }

                if (colors === void 0) { colors = []; }
                if (colors.length === 0) {
                    colors = System.Array.init([Liquid.defaultColor.$clone()], UnityEngine.Color);
                }

                this.CreateFaucetWithAmount(colors.length);

                for (var i = 0; i < this.faucets.Count; i = (i + 1) | 0) {
                    var faucet = this.faucets.getItem(i);
                    if (i >= colors.length) {
                        faucet.gameObject.SetActive(false);
                        continue;
                    }

                    faucet.gameObject.SetActive(true);
                    faucet.SetColor(colors[i].$clone());
                }
            },
            /*FaucetManager.SetColors end.*/

            /*FaucetManager.CreateFaucetWithAmount start.*/
            CreateFaucetWithAmount: function (count) {
if ( TRACE ) { TRACE( "FaucetManager#CreateFaucetWithAmount", this ); }

                for (var i = this.faucets.Count; i < count; i = (i + 1) | 0) {
                    this.faucets.add(UnityEngine.Object.Instantiate(Faucet, this.faucetPrefab, this.transform));
                }

                for (var i1 = (this.faucets.Count - 1) | 0; i1 > count; i1 = (i1 - 1) | 0) {
                    UnityEngine.MonoBehaviour.Destroy(this.faucets.getItem(i1).gameObject);
                    this.faucets.removeAt(i1);
                    UnityEngine.Debug.LogError$1(Bridge.box(i1, System.Int32));
                }
            },
            /*FaucetManager.CreateFaucetWithAmount end.*/

            /*FaucetManager.Clean start.*/
            Clean: function () {
if ( TRACE ) { TRACE( "FaucetManager#Clean", this ); }

                for (var i = 0; i < this.faucets.Count; i = (i + 1) | 0) {
                    this.faucets.getItem(i).Clean();
                }
            },
            /*FaucetManager.Clean end.*/


        }
    });
    /*FaucetManager end.*/

    /*SingletonMono$1 start.*/
    Bridge.define("SingletonMono$1", function (T) { return {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                instance: Bridge.getDefaultValue(T)
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "SingletonMono$1#init", this ); }

                    this.instance = Bridge.getDefaultValue(T);
                }
            }
        },
        methods: {
            /*SingletonMono$1.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "SingletonMono$1#Awake", this ); }

                if (Bridge.rValue(SingletonMono$1(T).instance) == null) {
                    SingletonMono$1(T).instance = Bridge.as(this, T);
                } else {
                    if (UnityEngine.Component.op_Inequality(this, Bridge.rValue(SingletonMono$1(T).instance))) {
                        UnityEngine.Debug.LogWarningFormat("[Singleton] Another instance of" + (Bridge.Reflection.getTypeFullName(T) || "") + "is already exist ");
                        UnityEngine.Object.DestroyImmediate(this.gameObject);
                        return;
                    }
                }
            },
            /*SingletonMono$1.Awake end.*/


        }
    }; });
    /*SingletonMono$1 end.*/

    /*GeneratorController start.*/
    Bridge.define("GeneratorController", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            lamp: null,
            glow: null,
            point: null,
            _text: null,
            _text2: null,
            water2d: null,
            battery: 0,
            currentLosesCoef: 0,
            rb: null,
            _c: null,
            _speed: 0,
            relaxFrames: 0,
            _frames: 0,
            avgVolts: 0,
            avgRpm: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "GeneratorController#init", this ); }

                this._c = new UnityEngine.Color();
                this.currentLosesCoef = 0.975;
                this.relaxFrames = 30;
            }
        },
        methods: {
            /*GeneratorController.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "GeneratorController#Start", this ); }

                this.rb = this.GetComponent(UnityEngine.Rigidbody2D);
            },
            /*GeneratorController.Start end.*/

            /*GeneratorController.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "GeneratorController#FixedUpdate", this ); }

                if (UnityEngine.Object.op_Implicit(this.rb)) {
                    this.battery += (this.rb.angularVelocity / 360.0) * 2.0;
                    var rpm = this.rb.angularVelocity / 6.28;
                    this.battery *= this.currentLosesCoef;
                    if (this.battery < 0.1) {
                        this.battery *= 0;
                    }

                    this._c = this.lamp.color.$clone();
                    this._c.a = pc.math.lerp(0.0, 1.0, this.battery * 0.01);
                    this.lamp.color = this._c.$clone();



                    this.point.intensity = pc.math.lerp(0.0, 40.0, this.battery * 0.003);

                    this.PrintResults(rpm, pc.math.lerp(0.0, 300.0, this._c.a));

                }
            },
            /*GeneratorController.FixedUpdate end.*/

            /*GeneratorController.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "GeneratorController#Update", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.water2d, null)) {
                    this._speed = this.water2d.Speed;
                    if (UnityEngine.Input.GetMouseButton(0)) {
                        this._speed += 0.1;
                    }
                    if (UnityEngine.Input.GetMouseButton(1)) {
                        this._speed -= 0.1;
                    }
                    if (this._speed < 1.0) {
                        this._speed = 1.0;
                    }

                    if (this._speed > 80.0) {
                        this._speed = 80.0;
                    }

                    this.water2d.Speed = this._speed;
                }
            },
            /*GeneratorController.Update end.*/

            /*GeneratorController.PrintResults start.*/
            PrintResults: function (rpm, volts) {
if ( TRACE ) { TRACE( "GeneratorController#PrintResults", this ); }



                if (this._frames > this.relaxFrames) {
                    this._frames = Bridge.Int.mul(this._frames, 0);

                    this._text.text = "Volts \n" + (System.Single.format((this.avgVolts / this.relaxFrames), "00.00") || "");
                    this._text2.text = "RPM \n " + (System.Single.format((this.avgRpm / this.relaxFrames), "0") || "");

                    this.avgVolts *= 0;
                    this.avgRpm *= 0;
                } else {
                    this._frames = (this._frames + 1) | 0;

                    this.avgVolts += volts;
                    this.avgRpm += rpm;

                }

            },
            /*GeneratorController.PrintResults end.*/


        }
    });
    /*GeneratorController end.*/

    /*Glass start.*/
    Bridge.define("Glass", {
        inherits: [UnityEngine.MonoBehaviour],
        methods: {
            /*Glass.SetUp start.*/
            SetUp: function () {
if ( TRACE ) { TRACE( "Glass#SetUp", this ); }
 },
            /*Glass.SetUp end.*/

            /*Glass.TearDown start.*/
            TearDown: function () {
if ( TRACE ) { TRACE( "Glass#TearDown", this ); }


            },
            /*Glass.TearDown end.*/


        }
    });
    /*Glass end.*/
    /**
     * @memberof System
     * @callback System.Func
     * @return  {boolean}
     */

    /** @namespace UnityEngine.Events */

    /**
     * @memberof UnityEngine.Events
     * @callback UnityEngine.Events.UnityAction
     * @return  {void}
     */

    /**
     * @callback HelperUtility.Compare
     * @param   {System.Object}    a1    
     * @param   {System.Object}    a2
     * @return  {number}
     */


    /*HelperUtility start.*/
    Bridge.define("HelperUtility", {
        statics: {
            methods: {
                /*HelperUtility.DecimalRounding:static start.*/
                /**
                 * B cc s sau du phy ca s thp
                 *
                 * @static
                 * @public
                 * @this HelperUtility
                 * @memberof HelperUtility
                 * @param   {number}    Num      
                 * @param   {number}    Round    S ch s sau du phy
                 * @return  {number}
                 */
                DecimalRounding: function (Num, Round) {
if ( TRACE ) { TRACE( "HelperUtility#DecimalRounding", this ); }

                    Num = (Bridge.Int.clip32(Math.pow(10, Round) * Num)) / Math.pow(10, Round);
                    return Num;
                },
                /*HelperUtility.DecimalRounding:static end.*/

                /*HelperUtility.DisruptiveArrayObject:static start.*/
                DisruptiveArrayObject: function (T, array) {
if ( TRACE ) { TRACE( "HelperUtility#DisruptiveArrayObject", this ); }

                    for (var i = 0; i < array.length; i = (i + 1) | 0) {
                        //int r1 = System.Random.Next
                        var r1 = UnityEngine.Random.Range(0, array.length);
                        var r2 = UnityEngine.Random.Range(0, array.length);

                        var temp = Bridge.rValue(array[r1]);
                        array[r1] = Bridge.rValue(array[r2]);
                        array[r2] = Bridge.rValue(temp);
                    }

                    return array;
                },
                /*HelperUtility.DisruptiveArrayObject:static end.*/

                /*HelperUtility.CountCornersVisibleFrom:static start.*/
                CountCornersVisibleFrom: function (rectTransform, camera) {
if ( TRACE ) { TRACE( "HelperUtility#CountCornersVisibleFrom", this ); }

                    var screenBounds = new UnityEngine.Rect.$ctor1(0.0, 0.0, UnityEngine.Screen.width, UnityEngine.Screen.height); // Screen space bounds (assumes camera renders across the entire screen)
                    var objectCorners = System.Array.init(4, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    rectTransform.GetWorldCorners(objectCorners);

                    var visibleCorners = 0;
                    var tempScreenSpaceCorner = new UnityEngine.Vector3(); // Cached
                    for (var i = 0; i < objectCorners.length; i = (i + 1) | 0) {
                        tempScreenSpaceCorner = camera.WorldToScreenPoint(objectCorners[i]); // Transform world space position of corner to screen space
                        if (screenBounds.Contains$1(tempScreenSpaceCorner.$clone())) {
                            visibleCorners = (visibleCorners + 1) | 0;
                        }
                    }

                    return visibleCorners;
                },
                /*HelperUtility.CountCornersVisibleFrom:static end.*/

                /*HelperUtility.GetRandom:static start.*/
                GetRandom: function (T, deck) {
if ( TRACE ) { TRACE( "HelperUtility#GetRandom", this ); }

                    return Bridge.rValue(deck[UnityEngine.Random.Range(0, deck.length)]);
                },
                /*HelperUtility.GetRandom:static end.*/

                /*HelperUtility.IsEmpty:static start.*/
                IsEmpty: function (T, deck) {
if ( TRACE ) { TRACE( "HelperUtility#IsEmpty", this ); }

                    return deck.length === 0;
                },
                /*HelperUtility.IsEmpty:static end.*/

                /*HelperUtility.IsVisibleFrom:static start.*/
                IsVisibleFrom: function (rectTransform, camera) {
if ( TRACE ) { TRACE( "HelperUtility#IsVisibleFrom", this ); }

                    return HelperUtility.CountCornersVisibleFrom(rectTransform, camera) > 0; // True if any corners are visible
                },
                /*HelperUtility.IsVisibleFrom:static end.*/

                /*HelperUtility.DisruptiveListObject$1:static start.*/
                DisruptiveListObject$1: function (array) {
if ( TRACE ) { TRACE( "HelperUtility#DisruptiveListObject$1", this ); }

                    for (var i = 0; i < array.Count; i = (i + 1) | 0) {
                        //int r1 = System.Random.Next
                        var r1 = UnityEngine.Random.Range(0, array.Count);
                        var r2 = UnityEngine.Random.Range(0, array.Count);

                        var temp = array.getItem(r1);
                        array.setItem(r1, array.getItem(r2));
                        array.setItem(r2, temp);
                    }

                    return array;
                },
                /*HelperUtility.DisruptiveListObject$1:static end.*/

                /*HelperUtility.DisruptiveListObject:static start.*/
                DisruptiveListObject: function (T, array) {
if ( TRACE ) { TRACE( "HelperUtility#DisruptiveListObject", this ); }

                    for (var i = 0; i < array.Count; i = (i + 1) | 0) {
                        //int r1 = System.Random.Next
                        var r1 = UnityEngine.Random.Range(0, array.Count);
                        var r2 = UnityEngine.Random.Range(0, array.Count);

                        var temp = Bridge.rValue(array.getItem(r1));
                        array.setItem(r1, Bridge.rValue(array.getItem(r2)));
                        array.setItem(r2, Bridge.rValue(temp));
                    }

                    return array;
                },
                /*HelperUtility.DisruptiveListObject:static end.*/

                /*HelperUtility.DisruptiveList:static start.*/
                DisruptiveList: function (T, array) {
if ( TRACE ) { TRACE( "HelperUtility#DisruptiveList", this ); }

                    for (var i = 0; i < array.Count; i = (i + 1) | 0) {
                        //int r1 = System.Random.Next
                        var r1 = UnityEngine.Random.Range(0, array.Count);
                        var r2 = UnityEngine.Random.Range(0, array.Count);

                        var temp = Bridge.rValue(array.getItem(r1));
                        array.setItem(r1, Bridge.rValue(array.getItem(r2)));
                        array.setItem(r2, Bridge.rValue(temp));
                    }

                    return array;
                },
                /*HelperUtility.DisruptiveList:static end.*/

                /*HelperUtility.DisruptiveListSelf:static start.*/
                DisruptiveListSelf: function (T, array) {
if ( TRACE ) { TRACE( "HelperUtility#DisruptiveListSelf", this ); }

                    for (var i = 0; i < array.Count; i = (i + 1) | 0) {
                        //int r1 = System.Random.Next
                        var r1 = UnityEngine.Random.Range(0, array.Count);
                        var r2 = UnityEngine.Random.Range(0, array.Count);

                        var temp = Bridge.rValue(array.getItem(r1));
                        array.setItem(r1, Bridge.rValue(array.getItem(r2)));
                        array.setItem(r2, Bridge.rValue(temp));
                    }

                    return array;
                },
                /*HelperUtility.DisruptiveListSelf:static end.*/

                /*HelperUtility.SelectionSortList:static start.*/
                /**
                 * Sp xp gim dn
                 *
                 * @static
                 * @public
                 * @this HelperUtility
                 * @memberof HelperUtility
                 * @param   {System.Collections.Generic.List$1}    A                     
                 * @param   {HelperUtility.Compare}                compareElementList
                 * @return  {System.Collections.Generic.List$1}
                 */
                SelectionSortList: function (A, compareElementList) {
if ( TRACE ) { TRACE( "HelperUtility#SelectionSortList", this ); }

                    var i, j, min_idx;
                    var n = A.Count;

                    for (i = 0; i < ((n - 1) | 0); i = (i + 1) | 0) {
                        // Tm phn t nh nht trong mng
                        min_idx = i;
                        for (j = (i + 1) | 0; j < n; j = (j + 1) | 0) {
                            if (compareElementList(A.getItem(j), A.getItem(min_idx)) < 0) {
                                min_idx = j;
                            }
                        }

                        // i ch phn t nh nht trong mng
                        var temp = A.getItem(min_idx);
                        A.setItem(min_idx, A.getItem(i));
                        A.setItem(i, temp);
                    }

                    return A;
                },
                /*HelperUtility.SelectionSortList:static end.*/

                /*HelperUtility.StartThread:static start.*/
                /**
                 * Gi mt Hm chy lin tc
                 *
                 * @static
                 * @public
                 * @this HelperUtility
                 * @memberof HelperUtility
                 * @param   {UnityEngine.Events.UnityAction}    action           
                 * @param   {System.Func}                       conditionStop    
                 * @param   {UnityEngine.Events.UnityAction}    actionStop       
                 * @param   {number}                            time
                 * @return  {System.Collections.IEnumerator}
                 */
                StartThread: function (action, conditionStop, actionStop, time) {
if ( TRACE ) { TRACE( "HelperUtility#StartThread", this ); }

                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        isStop,
                        $async_e;

                    var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        if (actionStop === void 0) { actionStop = null; }
                                            if (time === void 0) { time = 0.01; }
                                            isStop = false;
                                        $step = 1;
                                        continue;
                                    }
                                    case 1: {
                                        if ( isStop === false ) {
                                                $step = 2;
                                                continue;
                                            } 
                                            $step = 4;
                                            continue;
                                    }
                                    case 2: {
                                        $enumerator.current = new UnityEngine.WaitForSecondsRealtime(time);
                                            $step = 3;
                                            return true;
                                    }
                                    case 3: {
                                        // Debug.Log("conditionStop " + conditionStop());
                                            if (conditionStop() === true) {
                                                isStop = true;
                                                if (!Bridge.staticEquals(actionStop, null)) {
                                                    actionStop();
                                                }
                                            } else {
                                                action();
                                            }

                                            $step = 1;
                                            continue;
                                    }
                                    case 4: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                },
                /*HelperUtility.StartThread:static end.*/

                /*HelperUtility.StartThread$1:static start.*/
                /**
                 * Gi mt Hm chy lin tc
                 *
                 * @static
                 * @public
                 * @this HelperUtility
                 * @memberof HelperUtility
                 * @param   {UnityEngine.Events.UnityAction}    action        
                 * @param   {number}                            timeToStop    
                 * @param   {UnityEngine.Events.UnityAction}    actionStop
                 * @return  {System.Collections.IEnumerator}
                 */
                StartThread$1: function (action, timeToStop, actionStop) {
if ( TRACE ) { TRACE( "HelperUtility#StartThread$1", this ); }

                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        isStop,
                        timer,
                        $async_e;

                    var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        if (actionStop === void 0) { actionStop = null; }
                                            isStop = false;

                                            timer = 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 1: {
                                        if ( isStop === false ) {
                                                $step = 2;
                                                continue;
                                            } 
                                            $step = 4;
                                            continue;
                                    }
                                    case 2: {
                                        $enumerator.current = new UnityEngine.WaitForSeconds(0.02);
                                            $step = 3;
                                            return true;
                                    }
                                    case 3: {
                                        timer += 0.02;
                                            //Debug.Log(timer);
                                            if (timer >= timeToStop - 1) {
                                                isStop = true;
                                                if (!Bridge.staticEquals(actionStop, null)) {
                                                    actionStop();
                                                }
                                            } else {
                                                action();
                                            }

                                            $step = 1;
                                            continue;
                                    }
                                    case 4: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                },
                /*HelperUtility.StartThread$1:static end.*/

                /*HelperUtility.StartAction$1:static start.*/
                /**
                 * To mt hm chy sau mt khong thi gian
                 *
                 * @static
                 * @public
                 * @this HelperUtility
                 * @memberof HelperUtility
                 * @param   {UnityEngine.Events.UnityAction}    action    
                 * @param   {number}                            time
                 * @return  {System.Collections.IEnumerator}
                 */
                StartAction$1: function (action, time) {
if ( TRACE ) { TRACE( "HelperUtility#StartAction$1", this ); }

                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        $async_e;

                    var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        $enumerator.current = new UnityEngine.WaitForSeconds(time);
                                            $step = 1;
                                            return true;
                                    }
                                    case 1: {
                                        action();

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                },
                /*HelperUtility.StartAction$1:static end.*/

                /*HelperUtility.StartAction:static start.*/
                /**
                 * To mt hm chy khi mt iu kin tha mn
                 *
                 * @static
                 * @public
                 * @this HelperUtility
                 * @memberof HelperUtility
                 * @param   {UnityEngine.Events.UnityAction}    action       
                 * @param   {System.Func}                       condition
                 * @return  {System.Collections.IEnumerator}
                 */
                StartAction: function (action, condition) {
if ( TRACE ) { TRACE( "HelperUtility#StartAction", this ); }

                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        $async_e;

                    var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        $enumerator.current = new UnityEngine.WaitUntil(condition);
                                            $step = 1;
                                            return true;
                                    }
                                    case 1: {
                                        action();

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                },
                /*HelperUtility.StartAction:static end.*/

                /*HelperUtility.StartActionRealTime:static start.*/
                StartActionRealTime: function (action, time) {
if ( TRACE ) { TRACE( "HelperUtility#StartActionRealTime", this ); }

                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        $async_e;

                    var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        $enumerator.current = new UnityEngine.WaitForSecondsRealtime(time);
                                            $step = 1;
                                            return true;
                                    }
                                    case 1: {
                                        action();

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                },
                /*HelperUtility.StartActionRealTime:static end.*/

                /*HelperUtility.StartActionNotUseCorutines:static start.*/
                StartActionNotUseCorutines: function (action, time) {
if ( TRACE ) { TRACE( "HelperUtility#StartActionNotUseCorutines", this ); }

                    // Observable.Timer(TimeSpan.FromSeconds(time)).Subscribe(l => { action(); });
                },
                /*HelperUtility.StartActionNotUseCorutines:static end.*/

                /*HelperUtility.GetPointDistanceFromObject:static start.*/
                /**
                 * Ly mt im cch 1 im cho trc v theo 1 hng
                 *
                 * @static
                 * @public
                 * @this HelperUtility
                 * @memberof HelperUtility
                 * @param   {number}                 distance     
                 * @param   {UnityEngine.Vector3}    direction    
                 * @param   {UnityEngine.Vector3}    fromPoint
                 * @return  {UnityEngine.Vector3}
                 */
                GetPointDistanceFromObject: function (distance, direction, fromPoint) {
if ( TRACE ) { TRACE( "HelperUtility#GetPointDistanceFromObject", this ); }

                    distance -= 1;
                    //if (distance < 0)
                    //    distance = 0;

                    var finalDirection = direction.$clone().add( direction.clone().normalize().$clone().clone().scale( distance ) );
                    var targetPosition = fromPoint.$clone().add( finalDirection );

                    return targetPosition.$clone();
                },
                /*HelperUtility.GetPointDistanceFromObject:static end.*/

                /*HelperUtility.GetDirectionFromAngle:static start.*/
                /**
                 * Ly ra mt Vector hp vi VectorP mt gc angle. im u ca Vector l PositionStart
                 *
                 * @static
                 * @public
                 * @this HelperUtility
                 * @memberof HelperUtility
                 * @param   {UnityEngine.Vector3}    vectorP          
                 * @param   {number}                 angle            
                 * @param   {UnityEngine.Vector3}    positionStart
                 * @return  {UnityEngine.Vector3}
                 */
                GetDirectionFromAngle: function (vectorP, angle, positionStart) {
if ( TRACE ) { TRACE( "HelperUtility#GetDirectionFromAngle", this ); }

                    if (angle === 90) {
                        return new pc.Vec3( vectorP.y, -vectorP.x, 0 ).clone().normalize().$clone();
                    } else if (angle === 0) {
                        return vectorP.$clone();
                    } else if (angle === 180) {
                        return vectorP.$clone().scale( -1 );
                    } else if (angle === 360) {
                        return new pc.Vec3( -vectorP.y, vectorP.x, 0 ).clone().normalize().$clone();
                    }

                    if (angle > 360) {
                        angle -= 360;
                    }
                    if (angle < 0) {
                        angle *= -1;
                    }

                    var radiaAngle = (angle * UnityEngine.Mathf.PI) / 180;
                    var tanAngle = Math.tan(radiaAngle);
                    var u = new pc.Vec2( vectorP.y, -vectorP.x );

                    var B = HelperUtility.GetPointDistanceFromObject(1, vectorP.$clone(), positionStart.$clone());
                    //Debug.Log("Distance "+ Vector3.Distance(positionStart, B));

                    var result = HelperUtility.GetPointDistanceFromObject(tanAngle, UnityEngine.Vector3.FromVector2(u.$clone()), B.$clone());

                    return (result.$clone().sub( positionStart )).clone().normalize().$clone();
                },
                /*HelperUtility.GetDirectionFromAngle:static end.*/

                /*HelperUtility.GetDirectionFromAngle_2:static start.*/
                /**
                 * Ly ra mt Vector hp vi VectorP mt gc angle. im u ca Vector l PositionStart
                 *
                 * @static
                 * @public
                 * @this HelperUtility
                 * @memberof HelperUtility
                 * @param   {UnityEngine.Vector3}    vectorP          
                 * @param   {number}                 angle            
                 * @param   {UnityEngine.Vector3}    positionStart
                 * @return  {UnityEngine.Vector3}
                 */
                GetDirectionFromAngle_2: function (vectorP, angle, positionStart) {
if ( TRACE ) { TRACE( "HelperUtility#GetDirectionFromAngle_2", this ); }

                    if (angle === 90) {
                        return new pc.Vec3( vectorP.y, -vectorP.x, 0 ).clone().normalize().$clone();
                    } else if (angle === 0) {
                        return vectorP.$clone();
                    } else if (angle === 180) {
                        return vectorP.$clone().scale( -1 );
                    } else if (angle === 360) {
                        return new pc.Vec3( -vectorP.y, vectorP.x, 0 ).clone().normalize().$clone();
                    }

                    if (angle > 360) {
                        angle -= 360;
                    }
                    if (angle < 0) {
                        angle *= -1;
                    }

                    if (angle > 90 && angle < 270) {
                        vectorP = vectorP.$clone().scale( -1 );
                    }

                    var radiaAngle = (angle * UnityEngine.Mathf.PI) / 180;
                    var tanAngle = Math.tan(radiaAngle);
                    var u = new pc.Vec2( vectorP.y, -vectorP.x );

                    var B = HelperUtility.GetPointDistanceFromObject(1, vectorP.$clone(), positionStart.$clone());
                    //Debug.Log("Distance "+ Vector3.Distance(positionStart, B));

                    var result = HelperUtility.GetPointDistanceFromObject(tanAngle, UnityEngine.Vector3.FromVector2(u.$clone()), B.$clone());

                    return (result.$clone().sub( positionStart )).clone().normalize().$clone();
                },
                /*HelperUtility.GetDirectionFromAngle_2:static end.*/

                /*HelperUtility.DOLocalRotateQuaternion:static start.*/
                DOLocalRotateQuaternion: function (endValue, speedRotate, objLookAt, actionComplete) {
if ( TRACE ) { TRACE( "HelperUtility#DOLocalRotateQuaternion", this ); }

                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        isStop,
                        $async_e;

                    var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        isStop = false;
                                        $step = 1;
                                        continue;
                                    }
                                    case 1: {
                                        if ( isStop === false ) {
                                                $step = 2;
                                                continue;
                                            } 
                                            $step = 4;
                                            continue;
                                    }
                                    case 2: {
                                        $enumerator.current = new UnityEngine.WaitForSecondsRealtime(UnityEngine.Time.deltaTime);
                                            $step = 3;
                                            return true;
                                    }
                                    case 3: {
                                        //Debug.Log(objLookAt.name + " "   + Quaternion.Angle(objLookAt.transform.localRotation, endValue));
                                            if (pc.Quat.angle( objLookAt.transform.localRotation.$clone(), endValue.$clone() ) <= 8.0) {
                                                isStop = true;
                                                $step = 4;
                                                continue;
                                            } else {
                                                objLookAt.transform.localRotation = new pc.Quat().slerp( objLookAt.transform.localRotation, endValue, UnityEngine.Time.deltaTime * speedRotate );
                                            }

                                            $step = 1;
                                            continue;
                                    }
                                    case 4: {
                                        actionComplete();

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                },
                /*HelperUtility.DOLocalRotateQuaternion:static end.*/

                /*HelperUtility.GetRotateDirection:static start.*/
                GetRotateDirection: function (from, to) {
if ( TRACE ) { TRACE( "HelperUtility#GetRotateDirection", this ); }

                    var fromY = from.getPositiveEulerAngles().y;
                    var toY = to.getPositiveEulerAngles().y;
                    var clockWise = 0.0;
                    var counterClockWise = 0.0;

                    if (fromY <= toY) {
                        clockWise = toY - fromY;
                        counterClockWise = fromY + (360 - toY);
                    } else {
                        clockWise = (360 - fromY) + toY;
                        counterClockWise = fromY - toY;
                    }
                    return (clockWise <= counterClockWise);
                },
                /*HelperUtility.GetRotateDirection:static end.*/

                /*HelperUtility.LookAtToDirection:static start.*/
                LookAtToDirection: function (diretion, objLookAt, speedLockAt) {
if ( TRACE ) { TRACE( "HelperUtility#LookAtToDirection", this ); }

                    if (speedLockAt === void 0) { speedLockAt = 500.0; }
                    var xTarget = diretion.x;
                    var yTarget = diretion.y;
                    var angle = Math.atan2(yTarget, xTarget) * UnityEngine.Mathf.Rad2Deg + 90;

                    var q = new pc.Quat().setFromAxisAngle( new pc.Vec3( 0, 0, 1 ), angle );



                    objLookAt.transform.rotation = new pc.Quat().slerp( objLookAt.transform.rotation, q, UnityEngine.Time.deltaTime * speedLockAt );
                },
                /*HelperUtility.LookAtToDirection:static end.*/

                /*HelperUtility.LookAtToDirectionAngleDetal:static start.*/
                LookAtToDirectionAngleDetal: function (diretion, objLookAt, AngleDetal, speedLockAt) {
if ( TRACE ) { TRACE( "HelperUtility#LookAtToDirectionAngleDetal", this ); }

                    if (speedLockAt === void 0) { speedLockAt = 500.0; }
                    var xTarget = diretion.x;
                    var yTarget = diretion.y;
                    var angle = Math.atan2(yTarget, xTarget) * UnityEngine.Mathf.Rad2Deg + 90 + AngleDetal;
                    var q = new pc.Quat().setFromAxisAngle( new pc.Vec3( 0, 0, 1 ), angle );
                    objLookAt.transform.rotation = new pc.Quat().slerp( objLookAt.transform.rotation, q, UnityEngine.Time.deltaTime * speedLockAt );
                },
                /*HelperUtility.LookAtToDirectionAngleDetal:static end.*/

                /*HelperUtility.LookAtToPosition:static start.*/
                LookAtToPosition: function (position, objLookAt, speedRotate) {
if ( TRACE ) { TRACE( "HelperUtility#LookAtToPosition", this ); }

                    if (speedRotate === void 0) { speedRotate = 500.0; }
                    var xTarget = position.x - objLookAt.transform.position.x;
                    var yTarget = position.z - objLookAt.transform.position.z;
                    var angle = Math.atan2(yTarget, xTarget) * UnityEngine.Mathf.Rad2Deg + 90;
                    var q = new pc.Quat().setFromAxisAngle( new pc.Vec3( 0, 0, 1 ), angle );
                    objLookAt.transform.rotation = new pc.Quat().slerp( objLookAt.transform.rotation, q, UnityEngine.Time.deltaTime * speedRotate );
                },
                /*HelperUtility.LookAtToPosition:static end.*/

                /*HelperUtility.LookAtToPositionAngleDetal:static start.*/
                LookAtToPositionAngleDetal: function (position, objLookAt, AngleDetal, speedRotate) {
if ( TRACE ) { TRACE( "HelperUtility#LookAtToPositionAngleDetal", this ); }

                    if (speedRotate === void 0) { speedRotate = 500.0; }
                    var xTarget = position.x - objLookAt.transform.position.x;
                    var yTarget = position.y - objLookAt.transform.position.y;
                    var angle = Math.atan2(yTarget, xTarget) * UnityEngine.Mathf.Rad2Deg + 90 + AngleDetal;
                    var q = new pc.Quat().setFromAxisAngle( new pc.Vec3( 0, 0, 1 ), angle );
                    objLookAt.transform.rotation = new pc.Quat().slerp( objLookAt.transform.rotation, q, UnityEngine.Time.deltaTime * speedRotate );
                },
                /*HelperUtility.LookAtToPositionAngleDetal:static end.*/

                /*HelperUtility.RandomCustom:static start.*/
                RandomCustom: function (first, last, diff) {
if ( TRACE ) { TRACE( "HelperUtility#RandomCustom", this ); }

                    var r = -1;
                    while (r < 0) {
                        r = UnityEngine.Random.Range(first, last);
                        for (var i = 0; i < diff.Count; i = (i + 1) | 0) {
                            if (r === diff.getItem(i)) {
                                r = -1;
                                break;
                            }
                        }
                    }
                    return r;
                },
                /*HelperUtility.RandomCustom:static end.*/

                /*HelperUtility.RandomUnduplicated$1:static start.*/
                /**
                 * Random mt phn t trong 1 mng khng trng lp vi 1 phn t cho trc
                 *
                 * @static
                 * @public
                 * @this HelperUtility
                 * @memberof HelperUtility
                 * @param   {number}                               oldValue    Gi tr mu khng c trng lp
                 * @param   {System.Collections.Generic.List$1}    diff        List gi tr
                 * @return  {number}
                 */
                RandomUnduplicated$1: function (oldValue, diff) {
if ( TRACE ) { TRACE( "HelperUtility#RandomUnduplicated$1", this ); }

                    var m_diff = new (System.Collections.Generic.List$1(System.Int32)).$ctor1(diff);

                    //Trn List
                    m_diff = HelperUtility.DisruptiveListObject(System.Int32, m_diff);

                    for (var i = 0; i < m_diff.Count; i = (i + 1) | 0) {
                        if (oldValue !== m_diff.getItem(i)) {
                            return m_diff.getItem(i);
                        }
                    }

                    return oldValue;
                },
                /*HelperUtility.RandomUnduplicated$1:static end.*/

                /*HelperUtility.RandomUnduplicated:static start.*/
                /**
                 * Random mt phn t trong 1 mng khng trng lp vi 1 phn t cho trc
                 *
                 * @static
                 * @public
                 * @this HelperUtility
                 * @memberof HelperUtility
                 * @param   {System.Collections.Generic.List$1}    diff         List gi tr
                 * @param   {Array.<number>}                       oldValues    Gi tr mu khng c trng lp
                 * @return  {number}
                 */
                RandomUnduplicated: function (diff, oldValues) {
if ( TRACE ) { TRACE( "HelperUtility#RandomUnduplicated", this ); }

                    if (oldValues === void 0) { oldValues = []; }
                    var m_diff = new (System.Collections.Generic.List$1(System.Int32)).$ctor1(diff);

                    //Trn List
                    m_diff = HelperUtility.DisruptiveListObject(System.Int32, m_diff);

                    for (var i = 0; i < m_diff.Count; i = (i + 1) | 0) {
                        var isHasSame = false;
                        for (var j = 0; j < oldValues.length; j = (j + 1) | 0) {
                            if (oldValues[j] === m_diff.getItem(i)) {
                                isHasSame = true;
                                break;
                            }
                        }

                        if (!isHasSame) {
                            return m_diff.getItem(i);
                        }
                    }

                    return 0;
                },
                /*HelperUtility.RandomUnduplicated:static end.*/

                /*HelperUtility.SetPos:static start.*/
                SetPos: function (numCount, MaxERow) {
if ( TRACE ) { TRACE( "HelperUtility#SetPos", this ); }

                    var result = new (System.Collections.Generic.List$1(System.Int32)).ctor();


                    if (numCount === 1) {
                        return function (_o1) {
                                _o1.add(1);
                                return _o1;
                            }(new (System.Collections.Generic.List$1(System.Int32)).ctor());
                    } else {
                        if (numCount === 2) {
                            return function (_o2) {
                                    _o2.add(2);
                                    return _o2;
                                }(new (System.Collections.Generic.List$1(System.Int32)).ctor());
                        } else {
                            if (numCount === 3) {
                                return function (_o3) {
                                        _o3.add(1);
                                        _o3.add(2);
                                        return _o3;
                                    }(new (System.Collections.Generic.List$1(System.Int32)).ctor());
                            } else {
                                if (numCount === 4) {
                                    return function (_o4) {
                                            _o4.add(2);
                                            _o4.add(2);
                                            return _o4;
                                        }(new (System.Collections.Generic.List$1(System.Int32)).ctor());
                                } else {
                                    if (numCount === 5) {
                                        return function (_o5) {
                                                _o5.add(1);
                                                _o5.add(2);
                                                _o5.add(2);
                                                return _o5;
                                            }(new (System.Collections.Generic.List$1(System.Int32)).ctor());
                                    } else {
                                        if (numCount === 6) {
                                            return function (_o6) {
                                                    _o6.add(1);
                                                    _o6.add(2);
                                                    _o6.add(2);
                                                    _o6.add(1);
                                                    return _o6;
                                                }(new (System.Collections.Generic.List$1(System.Int32)).ctor());
                                        } else {
                                            if (numCount === 7) {
                                                return function (_o7) {
                                                        _o7.add(1);
                                                        _o7.add(2);
                                                        _o7.add(2);
                                                        _o7.add(2);
                                                        return _o7;
                                                    }(new (System.Collections.Generic.List$1(System.Int32)).ctor());
                                            } else {
                                                if (numCount === 8) {
                                                    return function (_o8) {
                                                            _o8.add(1);
                                                            _o8.add(2);
                                                            _o8.add(3);
                                                            _o8.add(2);
                                                            return _o8;
                                                        }(new (System.Collections.Generic.List$1(System.Int32)).ctor());
                                                } else {
                                                    if (numCount === 9) {
                                                        return function (_o9) {
                                                                _o9.add(1);
                                                                _o9.add(2);
                                                                _o9.add(3);
                                                                _o9.add(3);
                                                                return _o9;
                                                            }(new (System.Collections.Generic.List$1(System.Int32)).ctor());
                                                    } else {
                                                        if (numCount === 10) {
                                                            return function (_o10) {
                                                                    _o10.add(2);
                                                                    _o10.add(3);
                                                                    _o10.add(3);
                                                                    _o10.add(2);
                                                                    return _o10;
                                                                }(new (System.Collections.Generic.List$1(System.Int32)).ctor());
                                                        } else {
                                                            var numCount_1 = (Bridge.Int.div(numCount, 2)) | 0;
                                                            var lst_1 = HelperUtility.PosHandle(numCount_1, MaxERow);
                                                            result.AddRange(lst_1);

                                                            var numCount_2 = (numCount - numCount_1) | 0;
                                                            var lst_2 = HelperUtility.PosHandle(numCount_2, MaxERow);
                                                            lst_2.Reverse();

                                                            result.AddRange(lst_2);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    return result;
                },
                /*HelperUtility.SetPos:static end.*/

                /*HelperUtility.PosHandle:static start.*/
                PosHandle: function (numCount, MaxERow) {
if ( TRACE ) { TRACE( "HelperUtility#PosHandle", this ); }

                    var minCountInRow = 5;

                    var result = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    var hs = minCountInRow;

                    var index = 0;
                    while (numCount > 0) {
                        if (numCount >= hs && hs >= MaxERow) {
                            result.add(hs);
                        }

                        if (numCount < hs) {
                            if (numCount < result.getItem(((index - 1) | 0))) {
                                if (numCount <= minCountInRow) {
                                    result.insert(0, numCount);
                                    break;
                                } else {
                                    while (numCount > 0) {
                                        for (var i = 0; i < result.Count; i = (i + 1) | 0) {
                                            if (i === 0) {
                                                result.insert(0, minCountInRow);
                                                numCount = (numCount - minCountInRow) | 0;
                                                if (numCount <= 0) {
                                                    break;
                                                }
                                            } else {
                                                var value = result.getItem(i);
                                                value = (value + 1) | 0;
                                                if (value > MaxERow) {
                                                    break;
                                                }

                                                result.setItem(i, (result.getItem(i) + 1) | 0);

                                                numCount = (numCount - 1) | 0;
                                                if (numCount <= 0) {
                                                    break;
                                                }
                                            }



                                        }
                                    }
                                }
                            } else {
                                result.add(numCount);
                            }
                            break;
                        }

                        numCount = (numCount - hs) | 0;

                        result.add(hs);
                        hs = (hs + 1) | 0;
                        if (hs >= MaxERow) {
                            hs = MaxERow;
                        }
                        index = (index + 1) | 0;
                    }

                    return result;
                },
                /*HelperUtility.PosHandle:static end.*/


            }
        }
    });
    /*HelperUtility end.*/

    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty start.*/
    Bridge.define("IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty", {
        inherits: [UnityEngine.MonoBehaviour]
    });
    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty end.*/

    /*Ingredient start.*/
    Bridge.define("Ingredient", {
        fields: {
            typeBeverage: 0,
            lstTopping: null,
            waterColor: null,
            glass: null,
            timeFillWater: 0,
            timeFillTopping: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Ingredient#init", this ); }

                this.waterColor = new UnityEngine.Color();
            }
        }
    });
    /*Ingredient end.*/

    /*LavaColorPicker start.*/
    Bridge.define("LavaColorPicker", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            Colors: null,
            Spawner: null
        },
        methods: {
            /*LavaColorPicker.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "LavaColorPicker#Start", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if ( true ) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 3;
                                        continue;
                                }
                                case 1: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(0.1);
                                        $step = 2;
                                        return true;
                                }
                                case 2: {
                                    this.Spawner.FillColor = this.getColor();

                                        $step = 0;
                                        continue;
                                }
                                case 3: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*LavaColorPicker.Start end.*/

            /*LavaColorPicker.getColor start.*/
            getColor: function () {
if ( TRACE ) { TRACE( "LavaColorPicker#getColor", this ); }

                return this.Colors[UnityEngine.Random.Range(0, this.Colors.length)].$clone();

            },
            /*LavaColorPicker.getColor end.*/


        }
    });
    /*LavaColorPicker end.*/

    /*LavaEvents start.*/
    Bridge.define("LavaEvents", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            feverMode: false,
            steamP: null,
            solidLavaMaterial: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "LavaEvents#init", this ); }

                this.feverMode = false;
            }
        },
        methods: {
            /*LavaEvents.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "LavaEvents#Start", this ); }

                for (var i = 1; i < this.steamP.length; i = (i + 1) | 0) {
                    this.steamP[i] = UnityEngine.Object.Instantiate(UnityEngine.ParticleSystem, this.steamP[0]);
                }
            },
            /*LavaEvents.Start end.*/

            /*LavaEvents.OnCollideLava start.*/
            OnCollideLava: function (p1, p2) {
if ( TRACE ) { TRACE( "LavaEvents#OnCollideLava", this ); }

                var $t;
                /* p1 = particle 1 in the collision*/
                /* p2= particle 2 in the collision */


                if (Bridge.referenceEquals(p1.tag, p2.tag)) {

                    return;

                    /* 
                    MetaballParticleClass m1 = p1.GetComponent<MetaballParticleClass>();
                    MetaballParticleClass m2 = p2.GetComponent<MetaballParticleClass>();

                    if (m1.GetFreeze())
                    {
                       m2.SetFreeze();
                       m2.SetColor(Color.black * .6f);
                       m2.GetComponent<Rigidbody2D>().sharedMaterial = solidLavaMaterial;
                    }

                    if (m2.GetFreeze())
                    {
                       m1.SetFreeze();
                       m1.SetColor(Color.black * .6f);
                       m2.GetComponent<Rigidbody2D>().sharedMaterial = solidLavaMaterial;
                    }
                    */


                }



                if (Bridge.referenceEquals(p1.tag, "Metaball_liquid") && Bridge.referenceEquals(p2.tag, "Player")) {
                    //Lava 
                    var m = p2.GetComponent(MetaballParticleClass);
                    if (this.feverMode) {
                        m.LifeTime = 0.2;
                    } else {

                        //m.LifeTime = 10f;
                    }

                    m.SetColor(($t = new pc.Color( 0.5, 0.5, 0.5, 1 ), new pc.Color( $t.r * 0.6, $t.g * 0.6, $t.b * 0.6, $t.a * 0.6 )));
                    m.SetHighDensity();
                    m.removeGlow();
                    // m.ScaleDown = true;


                    //Water
                    // if (!m.GetFreeze())
                    // {
                    //m = p1.GetComponent<MetaballParticleClass>();
                    // m.LifeTime = 1f;
                    //}

                    // Play Steam particles to simulate water vaporation
                    for (var i = 0; i < this.steamP.length; i = (i + 1) | 0) {
                        if (this.steamP[i].isPlaying) {
                            continue;
                        }

                        this.steamP[i].transform.position = p1.transform.position.$clone();
                        this.steamP[i].Play();
                        break;
                    }


                }





            },
            /*LavaEvents.OnCollideLava end.*/


        }
    });
    /*LavaEvents end.*/

    /*LunaPool start.*/
    Bridge.define("LunaPool", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                POOL_SIZE: 0,
                Instance: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "LunaPool#init", this ); }

                    this.POOL_SIZE = 5;
                }
            }
        },
        fields: {
            pooledObjects: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "LunaPool#init", this ); }

                this.pooledObjects = new (System.Collections.Generic.Dictionary$2(UnityEngine.GameObject,System.Collections.Generic.Queue$1(UnityEngine.GameObject))).ctor();
            }
        },
        methods: {
            /*LunaPool.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "LunaPool#Awake", this ); }

                if (!UnityEngine.Object.op_Implicit(LunaPool.Instance) || UnityEngine.MonoBehaviour.op_Inequality(LunaPool.Instance, this)) {
                    LunaPool.Instance = this;
                }
            },
            /*LunaPool.Awake end.*/

            /*LunaPool.Spawn start.*/
            Spawn: function (prefab, position, rotation) {
if ( TRACE ) { TRACE( "LunaPool#Spawn", this ); }

                if (this.pooledObjects.containsKey(prefab)) {
                    // Extract the first one from the pool, set its parameters then move to the end
                    var obj = this.pooledObjects.getItem(prefab).Dequeue();
                    obj.transform.position = position.$clone();
                    obj.transform.rotation = rotation.$clone();
                    obj.SetActive(true);
                    this.pooledObjects.getItem(prefab).Enqueue(obj);
                    return obj;
                } else {
                    var pool = new (System.Collections.Generic.Queue$1(UnityEngine.GameObject)).ctor();
                    var instance;
                    for (var i = 0; i < LunaPool.POOL_SIZE; i = (i + 1) | 0) {
                        instance = UnityEngine.Object.Instantiate(UnityEngine.GameObject, prefab);
                        instance.SetActive(false);
                        pool.Enqueue(instance);
                    }
                    this.pooledObjects.add(prefab, pool);
                    return this.Spawn(prefab, position.$clone(), rotation.$clone());
                }
            },
            /*LunaPool.Spawn end.*/

            /*LunaPool.Despawn start.*/
            Despawn: function (obj) {
if ( TRACE ) { TRACE( "LunaPool#Despawn", this ); }

                obj.SetActive(false);
            },
            /*LunaPool.Despawn end.*/


        }
    });
    /*LunaPool end.*/

    /*MetaballParticleClass start.*/
    Bridge.define("MetaballParticleClass", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            MObject: null,
            LifeTime: 0,
            SpawnerParent: null,
            witinTarget: false,
            Editor_Velocity: null,
            Velocity_Limiter_X: null,
            Velocity_Limiter_Y: null,
            ScaleDown: false,
            endSize: 0,
            BlendingColor: false,
            glowSP: null,
            _active: false,
            _isFreeze: false,
            delta: 0,
            rb: null,
            cc: null,
            tr: null,
            sr: null,
            Contacts: null,
            deltaSimul: 0,
            fixedDeltaSimul: 0,
            wakeUpTime: 0,
            pos_aux: null,
            ScaleDownIsPerforming: false,
            deltaScale: null,
            initScale: null,
            tmpScale: null,
            breathFrames: 0,
            framesCount: 0
        },
        props: {
            Active: {
                get: function () {
if ( TRACE ) { TRACE( "MetaballParticleClass#Active#get", this ); }

                    return this._active;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "MetaballParticleClass#Active#set", this ); }

                    var $t;
                    this._active = value;
                    if (UnityEngine.Object.op_Implicit(this.MObject)) {
                        this.MObject.SetActive(value);

                        if (UnityEngine.Object.op_Implicit(this.tr)) {
                            this.tr.Clear();
                        }

                    }

                    if (value) {
                        this.delta *= 0;
                        this.wakeUpTime = UnityEngine.Time.time;

                        if (UnityEngine.Object.op_Implicit(this.glowSP)) {
                            this.glowSP.enabled = true;
                        }
                    }

                    if (!value) {
                        //substrac 1 unit of particle using.
                        if (UnityEngine.Object.op_Implicit(this.SpawnerParent)) {
                            ($t = this.SpawnerParent).DropsUsed = ($t.DropsUsed - 1) | 0;
                        }

                        if (UnityEngine.Component.op_Inequality(this.rb, null)) {
                            this.rb.velocity = this.rb.velocity.$clone().scale( 0.0 );
                        }

                        if (this._isFreeze) {
                            this.rb.constraints = UnityEngine.RigidbodyConstraints2D.None;
                            this.rb.sharedMaterial = null;
                            this._isFreeze = false;
                        }


                        this.delta *= 0;

                    }
                    this.ScaleDownIsPerforming = false;

                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "MetaballParticleClass#init", this ); }

                this.Editor_Velocity = new UnityEngine.Vector2();
                this.Velocity_Limiter_X = new UnityEngine.Vector2();
                this.Velocity_Limiter_Y = new UnityEngine.Vector2();
                this.pos_aux = new UnityEngine.Vector3();
                this.deltaScale = new UnityEngine.Vector2();
                this.initScale = new UnityEngine.Vector2();
                this.tmpScale = new UnityEngine.Vector2();
                this.ScaleDown = false;
                this.endSize = 0.0;
                this.fixedDeltaSimul = 0.0;
                this.ScaleDownIsPerforming = false;
                this.breathFrames = 6;
                this.framesCount = 0;
            }
        },
        methods: {
            /*MetaballParticleClass.SetColor start.*/
            SetColor: function (_color) {
if ( TRACE ) { TRACE( "MetaballParticleClass#SetColor", this ); }

                this.sr.color = _color.$clone();
            },
            /*MetaballParticleClass.SetColor end.*/

            /*MetaballParticleClass.SetFreeze start.*/
            SetFreeze: function (_val) {
if ( TRACE ) { TRACE( "MetaballParticleClass#SetFreeze", this ); }

                if (_val === void 0) { _val = true; }
                this._isFreeze = _val;
                this.rb.constraints = UnityEngine.RigidbodyConstraints2D.FreezeAll;
                //rb.gravityScale = .5f;
            },
            /*MetaballParticleClass.SetFreeze end.*/

            /*MetaballParticleClass.GetFreeze start.*/
            GetFreeze: function () {
if ( TRACE ) { TRACE( "MetaballParticleClass#GetFreeze", this ); }

                return this._isFreeze;
            },
            /*MetaballParticleClass.GetFreeze end.*/

            /*MetaballParticleClass.SetHighDensity start.*/
            SetHighDensity: function (_val) {
if ( TRACE ) { TRACE( "MetaballParticleClass#SetHighDensity", this ); }

                if (_val === void 0) { _val = true; }
                this._isFreeze = _val;
                //rb.drag = 25f;
                this.rb.angularDrag = 25.0;
                this.rb.constraints = UnityEngine.RigidbodyConstraints2D.FreezeRotation;
            },
            /*MetaballParticleClass.SetHighDensity end.*/

            /*MetaballParticleClass.removeGlow start.*/
            removeGlow: function () {
if ( TRACE ) { TRACE( "MetaballParticleClass#removeGlow", this ); }

                this.glowSP.enabled = false;
            },
            /*MetaballParticleClass.removeGlow end.*/

            /*MetaballParticleClass.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "MetaballParticleClass#Start", this ); }

                //MObject = gameObject;
                this.rb = this.GetComponent(UnityEngine.Rigidbody2D);
                this.tr = this.GetComponent(UnityEngine.TrailRenderer);
                this.cc = this.GetComponent(UnityEngine.CircleCollider2D);
                this.sr = this.GetComponent(UnityEngine.SpriteRenderer);

                this.Contacts = System.Array.init(4, null, UnityEngine.Collider2D);
            },
            /*MetaballParticleClass.Start end.*/

            /*MetaballParticleClass.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "MetaballParticleClass#Update", this ); }




                if (this.Active === true) {
                    // cache the spriterender component
                    if (this.SpawnerParent.GlowEffect && UnityEngine.Component.op_Equality(this.glowSP, null)) {
                        var t = this.MObject.transform.Find("_glow");
                        if (UnityEngine.Component.op_Inequality(t, null)) {
                            this.glowSP = t.GetComponent(UnityEngine.SpriteRenderer);
                        }
                    }




                    if (this.ScaleDown) {
                        this.ScaleItDown();
                    }

                    this.VelocityLimiter();

                    if (this.BlendingColor) {

                        this.Blend();
                    }

                    if (this.SpawnerParent.Water2DEmissionType === Water2D.Water2D_Spawner.EmissionType.FillerCollider) {
                        return;
                    }

                    if (this.LifeTime < 0) {
                        return;
                    }

                    if (this.delta > this.LifeTime) {
                        this.delta *= 0;
                        this.Active = false;
                    } else {
                        this.delta += UnityEngine.Time.deltaTime;
                    }



                    // Handle collisions in fixedtime only editor
                    if (this.deltaSimul > this.fixedDeltaSimul) {
                        this.deltaSimul *= 0;
                        this.OnCollisionEnter2DEditor();
                    } else {
                        this.deltaSimul += UnityEngine.Time.deltaTime;
                    }



                }

            },
            /*MetaballParticleClass.Update end.*/

            /*MetaballParticleClass.AnimInEditor start.*/
            AnimInEditor: function () {
if ( TRACE ) { TRACE( "MetaballParticleClass#AnimInEditor", this ); }

                this.Editor_Velocity = this.Editor_Velocity.$clone().add( UnityEngine.Physics2D.gravity.$clone().scale( 0.0001 ) );
                // VelocityLimiterEditor();
                this.pos_aux = this.transform.position.$clone();
                this.pos_aux = UnityEngine.Vector3.FromVector2(UnityEngine.Vector2.FromVector3(this.pos_aux).add( this.Editor_Velocity ));
                this.transform.position = this.pos_aux.$clone();
                //print(Time.deltaTime);
            },
            /*MetaballParticleClass.AnimInEditor end.*/

            /*MetaballParticleClass.VelocityLimiter start.*/
            VelocityLimiter: function () {
if ( TRACE ) { TRACE( "MetaballParticleClass#VelocityLimiter", this ); }

                if (UnityEngine.Component.op_Equality(this.rb, null)) {
                    return;
                }

                var _vel = this.rb.velocity.$clone();
                _vel = this.rb.velocity.$clone();

                if (_vel.x < this.Velocity_Limiter_X.x) {
                    _vel.x = this.Velocity_Limiter_X.x;
                }

                if (_vel.x > this.Velocity_Limiter_X.y) {
                    _vel.x = this.Velocity_Limiter_X.y;
                }

                if (_vel.y < this.Velocity_Limiter_Y.x) {
                    _vel.y = this.Velocity_Limiter_Y.x;
                }

                if (_vel.y > this.Velocity_Limiter_Y.y) {
                    _vel.y = this.Velocity_Limiter_Y.y;
                }

                this.rb.velocity = _vel.$clone();
            },
            /*MetaballParticleClass.VelocityLimiter end.*/

            /*MetaballParticleClass.OnCollisionEnter2D start.*/
            OnCollisionEnter2D: function (collision) {
if ( TRACE ) { TRACE( "MetaballParticleClass#OnCollisionEnter2D", this ); }

                // SpawnerParent.InvokeOnCollisionEnter2D(gameObject, collision.contacts[0].collider.gameObject);
            },
            /*MetaballParticleClass.OnCollisionEnter2D end.*/

            /*MetaballParticleClass.OnCollisionEnter2DEditor start.*/
            OnCollisionEnter2DEditor: function () {
if ( TRACE ) { TRACE( "MetaballParticleClass#OnCollisionEnter2DEditor", this ); }

                if (UnityEngine.Application.isPlaying) {
                    return;
                }

                if (UnityEngine.Component.op_Equality(this.cc, null)) {
                    return;
                }

                if (this.Contacts == null) {
                    return;
                }


                var i = UnityEngine.Physics2D.OverlapCircleNonAlloc(this.rb.position, this.cc.radius * 0.9, this.Contacts);

                if (i > 0) {
                    for (var j = 0; j < this.Contacts.length; j = (j + 1) | 0) {
                        if (UnityEngine.Component.op_Equality(this.Contacts[j], null)) {
                            continue;
                        }

                        if (this.Contacts[j].GetInstanceID() === this.gameObject.GetInstanceID()) {
                            continue;
                        }

                        this.SpawnerParent.InvokeOnCollisionEnter2D(this.gameObject, this.Contacts[j].gameObject);
                    }

                }


            },
            /*MetaballParticleClass.OnCollisionEnter2DEditor end.*/

            /*MetaballParticleClass.ScaleItDown start.*/
            ScaleItDown: function () {
if ( TRACE ) { TRACE( "MetaballParticleClass#ScaleItDown", this ); }

                // Initializes
                if (!this.ScaleDownIsPerforming) {
                    this.ScaleDownIsPerforming = true;
                }

                if (this.ScaleDownIsPerforming) {
                    this.ScaleDownPerform();
                }
            },
            /*MetaballParticleClass.ScaleItDown end.*/

            /*MetaballParticleClass.ScaleDownPerform start.*/
            ScaleDownPerform: function () {
if ( TRACE ) { TRACE( "MetaballParticleClass#ScaleDownPerform", this ); }

                this.transform.localScale = UnityEngine.Vector3.FromVector2(new pc.Vec2().lerp( UnityEngine.Vector2.FromVector3(this.transform.localScale), new pc.Vec2( this.endSize, this.endSize ), (this.delta / this.LifeTime) * UnityEngine.Time.deltaTime * 0.8 ));
                //print(Time.deltaTime);
                //elapsedTime += Time.deltaTime;
            },
            /*MetaballParticleClass.ScaleDownPerform end.*/

            /*MetaballParticleClass.Blend start.*/
            Blend: function () {
if ( TRACE ) { TRACE( "MetaballParticleClass#Blend", this ); }

                if (true) {

                    if (UnityEngine.Component.op_Equality(this.cc, null)) {
                        return;
                    }

                    if (this.Contacts == null) {
                        this.Contacts = System.Array.init(2, null, UnityEngine.Collider2D);
                    }

                    if (this.framesCount < this.breathFrames) {
                        this.framesCount = (this.framesCount + 1) | 0;
                        return;
                    }

                    this.framesCount = Bridge.Int.mul(this.framesCount, 0);
                    //print("try blending");
                    //mix only in movement

                    if (this.rb.velocity.lengthSq() < 1E-06) {
                        return;
                    }

                    var i = UnityEngine.Physics2D.OverlapCircleNonAlloc(this.rb.position, this.cc.radius * 0.3, this.Contacts, 1 << this.gameObject.layer);

                    if (i > 0) {


                        for (var j = 0; j < this.Contacts.length; j = (j + 1) | 0) {
                            if (UnityEngine.Component.op_Equality(this.Contacts[j], null)) {
                                continue;
                            }

                            if (!this.Contacts[j].gameObject.activeSelf) {
                                continue;
                            }

                            if (this.Contacts[j].GetInstanceID() === this.gameObject.GetInstanceID()) {
                                continue;
                            }

                            if (!Bridge.referenceEquals(this.Contacts[j].tag, "Metaball_liquid")) {
                                continue;
                            }

                            //print("blending");
                            var c2 = this.Contacts[j].GetComponent(UnityEngine.SpriteRenderer).color.$clone();

                            if (pc.Color.equals( c2, this.sr.color )) {
                                return;
                            }

                            //print("mixing");

                            this.sr.color = pc.Color.lerp( this.sr.color, c2, 0.025 );
                            if (this.Contacts[j].GetComponent(MetaballParticleClass).SpawnerParent.Blending) {
                                this.Contacts[j].GetComponent(UnityEngine.SpriteRenderer).color = pc.Color.lerp( c2, this.sr.color, 0.025 );
                            }

                        }

                    }


                }
            },
            /*MetaballParticleClass.Blend end.*/

            /*MetaballParticleClass.Blend2 start.*/
            Blend2: function () {
if ( TRACE ) { TRACE( "MetaballParticleClass#Blend2", this ); }

                var $t, $t1, $t2, $t3;
                if (true) {

                    if (UnityEngine.Component.op_Equality(this.cc, null)) {
                        return;
                    }



                    if (this.framesCount < this.breathFrames) {
                        this.framesCount = (this.framesCount + 1) | 0;
                        return;
                    }

                    this.framesCount = Bridge.Int.mul(this.framesCount, 0);

                    //mix only in movement

                    if (this.rb.velocity.lengthSq() < 1E-08) {
                        return;
                    }

                    var c = 0;
                    var ContactsMax = 60;
                    var _contacts = System.Array.init(ContactsMax, null, MetaballParticleClass);



                    if (UnityEngine.MonoBehaviour.op_Equality(Water2D.SpawnersManager.instance, null)) {
                        Water2D.SpawnersManager.GetAllParticles();
                    }


                    if (Water2D.SpawnersManager.instance._allparticles == null) {
                        return;
                    }


                    for (var i = 0; i < Water2D.SpawnersManager.instance._allparticles.length; i = (i + 1) | 0) {
                        if (c >= ContactsMax) {
                            break;
                        }

                        if (($t = Water2D.SpawnersManager.instance._allparticles)[i].gameObject.getHashCode() === this.gameObject.getHashCode()) {
                            continue;
                        }

                        if (!($t1 = Water2D.SpawnersManager.instance._allparticles)[i].gameObject.activeSelf) {
                            continue;
                        }

                        if (!Bridge.referenceEquals(($t2 = Water2D.SpawnersManager.instance._allparticles)[i].gameObject.tag, "Metaball_liquid")) {
                            continue;
                        }

                        if ((($t3 = Water2D.SpawnersManager.instance._allparticles)[i].transform.position.$clone().sub( this.gameObject.transform.position )).lengthSq() < (this.cc.radius + 0.1) * (this.cc.radius + 0.1)) {
                            // Contact!SpawnersManager.instance._allparticles[i];
                            c = (c + 1) | 0;

                        }
                    }


                    //int i = Physics2D.OverlapCircleNonAlloc(rb.position, cc.radius * .9f, Contacts, 1 << gameObject.layer);

                    if (c > 0) {

                        for (var j = 0; j < _contacts.length; j = (j + 1) | 0) {
                            if (UnityEngine.MonoBehaviour.op_Equality(_contacts[j], null)) {
                                continue;
                            }


                            var c2 = _contacts[j].gameObject.GetComponent(UnityEngine.SpriteRenderer).color.$clone();

                            if (pc.Color.equals( c2, this.sr.color )) {
                                return;
                            }



                            this.sr.color = pc.Color.lerpUnclamped( this.sr.color.$clone(), c2.$clone(), 0.02 );
                            // print(sr.color + " " + c2);
                        }

                    }


                }
            },
            /*MetaballParticleClass.Blend2 end.*/


        }
    });
    /*MetaballParticleClass end.*/

    /*MMMaths start.*/
    Bridge.define("MMMaths", {
        statics: {
            methods: {
                /*MMMaths.Vector3ToVector2:static start.*/
                /**
                 * Takes a Vector3 and turns it into a Vector2
                 *
                 * @static
                 * @public
                 * @this MMMaths
                 * @memberof MMMaths
                 * @param   {UnityEngine.Vector3}    target    The Vector3 to turn into a Vector2.
                 * @return  {UnityEngine.Vector2}              The vector2.
                 */
                Vector3ToVector2: function (target) {
if ( TRACE ) { TRACE( "MMMaths#Vector3ToVector2", this ); }

                    return new pc.Vec2( target.x, target.y );
                },
                /*MMMaths.Vector3ToVector2:static end.*/

                /*MMMaths.Vector2ToVector3:static start.*/
                /**
                 * Takes a Vector2 and turns it into a Vector3 with a null z value
                 *
                 * @static
                 * @public
                 * @this MMMaths
                 * @memberof MMMaths
                 * @param   {UnityEngine.Vector2}    target    The Vector2 to turn into a Vector3.
                 * @return  {UnityEngine.Vector3}              The vector3.
                 */
                Vector2ToVector3: function (target) {
if ( TRACE ) { TRACE( "MMMaths#Vector2ToVector3", this ); }

                    return new pc.Vec3( target.x, target.y, 0 );
                },
                /*MMMaths.Vector2ToVector3:static end.*/

                /*MMMaths.Vector2ToVector3$1:static start.*/
                /**
                 * Takes a Vector2 and turns it into a Vector3 with the specified z value
                 *
                 * @static
                 * @public
                 * @this MMMaths
                 * @memberof MMMaths
                 * @param   {UnityEngine.Vector2}    target       The Vector2 to turn into a Vector3.
                 * @param   {number}                 newZValue    New Z value.
                 * @return  {UnityEngine.Vector3}                 The vector3.
                 */
                Vector2ToVector3$1: function (target, newZValue) {
if ( TRACE ) { TRACE( "MMMaths#Vector2ToVector3$1", this ); }

                    return new pc.Vec3( target.x, target.y, newZValue );
                },
                /*MMMaths.Vector2ToVector3$1:static end.*/

                /*MMMaths.RandomVector3:static start.*/
                /**
                 * Returns a random vector3 from 2 defined vector3.
                 *
                 * @static
                 * @public
                 * @this MMMaths
                 * @memberof MMMaths
                 * @param   {UnityEngine.Vector3}    minimum    
                 * @param   {UnityEngine.Vector3}    maximum
                 * @return  {UnityEngine.Vector3}               The vector3.
                 */
                RandomVector3: function (minimum, maximum) {
if ( TRACE ) { TRACE( "MMMaths#RandomVector3", this ); }

                    return new pc.Vec3( UnityEngine.Random.Range$1(minimum.x, maximum.x), UnityEngine.Random.Range$1(minimum.y, maximum.y), UnityEngine.Random.Range$1(minimum.z, maximum.z) );
                },
                /*MMMaths.RandomVector3:static end.*/

                /*MMMaths.RotatePointAroundPivot:static start.*/
                /**
                 * Rotates a point around the given pivot.
                 *
                 * @static
                 * @public
                 * @this MMMaths
                 * @memberof MMMaths
                 * @param   {UnityEngine.Vector3}    point    The point to rotate.
                 * @param   {UnityEngine.Vector3}    pivot    The pivot's position.
                 * @param   {number}                 angle    The angle we want to rotate our point.
                 * @return  {UnityEngine.Vector3}             The new point position.
                 */
                RotatePointAroundPivot: function (point, pivot, angle) {
if ( TRACE ) { TRACE( "MMMaths#RotatePointAroundPivot", this ); }

                    angle = angle * (0.0174532924);
                    var rotatedX = Math.cos(angle) * (point.x - pivot.x) - Math.sin(angle) * (point.y - pivot.y) + pivot.x;
                    var rotatedY = Math.sin(angle) * (point.x - pivot.x) + Math.cos(angle) * (point.y - pivot.y) + pivot.y;
                    return new pc.Vec3( rotatedX, rotatedY, 0 );
                },
                /*MMMaths.RotatePointAroundPivot:static end.*/

                /*MMMaths.RotatePointAroundPivot$1:static start.*/
                /**
                 * Rotates a point around the given pivot.
                 *
                 * @static
                 * @public
                 * @this MMMaths
                 * @memberof MMMaths
                 * @param   {UnityEngine.Vector3}    point    The point to rotate.
                 * @param   {UnityEngine.Vector3}    pivot    The pivot's position.
                 * @param   {UnityEngine.Vector3}    angle
                 * @return  {UnityEngine.Vector3}             The new point position.
                 */
                RotatePointAroundPivot$1: function (point, pivot, angle) {
if ( TRACE ) { TRACE( "MMMaths#RotatePointAroundPivot$1", this ); }

                    // we get point direction from the point to the pivot
                    var direction = point.$clone().sub( pivot );
                    // we rotate the direction
                    direction = new pc.Quat().setFromEulerAngles_Unity( angle.x, angle.y, angle.z ).transformVector( direction );
                    // we determine the rotated point's position
                    point = direction.$clone().add( pivot );
                    return point.$clone();
                },
                /*MMMaths.RotatePointAroundPivot$1:static end.*/

                /*MMMaths.Sum:static start.*/
                /**
                 * Returns the sum of all the int passed in parameters
                 *
                 * @static
                 * @public
                 * @this MMMaths
                 * @memberof MMMaths
                 * @param   {Array.<number>}    thingsToAdd    Things to add.
                 * @return  {number}
                 */
                Sum: function (thingsToAdd) {
if ( TRACE ) { TRACE( "MMMaths#Sum", this ); }

                    if (thingsToAdd === void 0) { thingsToAdd = []; }
                    var result = 0;
                    for (var i = 0; i < thingsToAdd.length; i = (i + 1) | 0) {
                        result = (result + thingsToAdd[i]) | 0;
                    }
                    return result;
                },
                /*MMMaths.Sum:static end.*/

                /*MMMaths.RollADice:static start.*/
                /**
                 * Returns the result of rolling a dice of the specified number of sides
                 *
                 * @static
                 * @public
                 * @this MMMaths
                 * @memberof MMMaths
                 * @param   {number}    numberOfSides    Number of sides of the dice.
                 * @return  {number}                     The result of the dice roll.
                 */
                RollADice: function (numberOfSides) {
if ( TRACE ) { TRACE( "MMMaths#RollADice", this ); }

                    return (UnityEngine.Random.Range(1, numberOfSides));
                },
                /*MMMaths.RollADice:static end.*/

                /*MMMaths.Chance:static start.*/
                /**
                 * Returns a random success based on X% of chance.
                 Example : I have 20% of chance to do X, Chance(20) &gt; true, yay!
                 *
                 * @static
                 * @public
                 * @this MMMaths
                 * @memberof MMMaths
                 * @param   {number}     percent    Percent of chance.
                 * @return  {boolean}
                 */
                Chance: function (percent) {
if ( TRACE ) { TRACE( "MMMaths#Chance", this ); }

                    return (UnityEngine.Random.Range(0, 100) <= percent);
                },
                /*MMMaths.Chance:static end.*/

                /*MMMaths.Approach:static start.*/
                /**
                 * Moves from "from" to "to" by the specified amount and returns the corresponding value
                 *
                 * @static
                 * @public
                 * @this MMMaths
                 * @memberof MMMaths
                 * @param   {number}    from      From.
                 * @param   {number}    to        To.
                 * @param   {number}    amount    Amount.
                 * @return  {number}
                 */
                Approach: function (from, to, amount) {
if ( TRACE ) { TRACE( "MMMaths#Approach", this ); }

                    if (from < to) {
                        from += amount;
                        if (from > to) {
                            return to;
                        }
                    } else {
                        from -= amount;
                        if (from < to) {
                            return to;
                        }
                    }
                    return from;
                },
                /*MMMaths.Approach:static end.*/


            }
        }
    });
    /*MMMaths end.*/

    /*MouseColliderController start.*/
    Bridge.define("MouseColliderController", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            col: null
        },
        methods: {
            /*MouseColliderController.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "MouseColliderController#Start", this ); }

                this.col = this.GetComponent(UnityEngine.CircleCollider2D);
            },
            /*MouseColliderController.Start end.*/

            /*MouseColliderController.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "MouseColliderController#Update", this ); }

                if (UnityEngine.Input.GetMouseButton(0)) {
                    this.col.enabled = true;
                    this.col.transform.position = UnityEngine.Vector3.FromVector2(UnityEngine.Vector2.FromVector3(UnityEngine.Camera.main.ScreenToWorldPoint(UnityEngine.Input.mousePosition)));
                } else {
                    this.col.enabled = false;
                }
            },
            /*MouseColliderController.Update end.*/


        }
    });
    /*MouseColliderController end.*/

    /*Mover start.*/
    Bridge.define("Mover", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            Plates: null,
            vel: null,
            pos: null,
            speed_Amount: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Mover#init", this ); }

                this.vel = new UnityEngine.Vector3();
                this.pos = new UnityEngine.Vector3();
                this.speed_Amount = 1.8;
            }
        },
        methods: {
            /*Mover.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Mover#FixedUpdate", this ); }

                for (var i = 0; i < this.Plates.length; i = (i + 1) | 0) {
                    this.vel = UnityEngine.Vector3.FromVector2(this.Plates[i].GetComponent(UnityEngine.Rigidbody2D).velocity.$clone());
                    this.pos = UnityEngine.Vector3.FromVector2(this.Plates[i].GetComponent(UnityEngine.Rigidbody2D).position.$clone());

                    if (this.pos.x <= -10.0) {
                        this.pos.x = 11.0;
                        this.Plates[i].transform.Find("trigger").GetComponent(UnityEngine.Collider2D).enabled = true;
                    } else {
                        this.vel.x = -this.speed_Amount;
                    }


                    this.Plates[i].GetComponent(UnityEngine.Rigidbody2D).velocity = UnityEngine.Vector2.FromVector3(this.vel.$clone());
                    this.Plates[i].GetComponent(UnityEngine.Rigidbody2D).position = UnityEngine.Vector2.FromVector3(this.pos.$clone());
                }




            },
            /*Mover.FixedUpdate end.*/


        }
    });
    /*Mover end.*/

    /*NameTag start.*/
    Bridge.define("NameTag", {
        statics: {
            fields: {
                FakeGround: null,
                Player: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "NameTag#init", this ); }

                    this.FakeGround = "FakeGround";
                    this.Player = "Player";
                }
            }
        }
    });
    /*NameTag end.*/

    /*PlaySoundOnEverySpawn start.*/
    Bridge.define("PlaySoundOnEverySpawn", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            sfx: null
        },
        methods: {
            /*PlaySoundOnEverySpawn.PlaySound start.*/
            PlaySound: function () {
if ( TRACE ) { TRACE( "PlaySoundOnEverySpawn#PlaySound", this ); }

                if (UnityEngine.Object.op_Implicit(this.sfx)) {
                    this.sfx.Play();
                }
            },
            /*PlaySoundOnEverySpawn.PlaySound end.*/


        }
    });
    /*PlaySoundOnEverySpawn end.*/

    /*ResizeQuadEffectController start.*/
    Bridge.define("ResizeQuadEffectController", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                instance: null
            },
            methods: {
                /*ResizeQuadEffectController.RebuildTextures:static start.*/
                RebuildTextures: function (flipTex) {
if ( TRACE ) { TRACE( "ResizeQuadEffectController#RebuildTextures", this ); }

                    if (flipTex === void 0) { flipTex = -1; }

                    //flipTex -1 dont update
                    //flipTex 0 dont flip
                    //flipTex 1  flip


                    if (UnityEngine.MonoBehaviour.op_Equality(ResizeQuadEffectController.instance, null)) {

                        var aux = UnityEngine.Object.FindObjectsOfType(ResizeQuadEffectController);
                        if (aux.length > 1) {
                            for (var i = 1; i < aux.length; i = (i + 1) | 0) {
                                UnityEngine.Object.DestroyImmediate(aux[i].gameObject);
                            }
                        }

                        ResizeQuadEffectController.instance = aux[0].GetComponent(ResizeQuadEffectController);

                    }

                    if (flipTex === 0) {
                        ResizeQuadEffectController.instance.FlipTexture = false;
                    }
                    if (flipTex === 1) {
                        ResizeQuadEffectController.instance.FlipTexture = true;
                    }

                    ResizeQuadEffectController.instance.RebuildRenderTexturesAll();
                },
                /*ResizeQuadEffectController.RebuildTextures:static end.*/


            }
        },
        fields: {
            FlipTexture: false,
            sorting: 0,
            effectTex2d: null,
            effectCam: null,
            backTex2d: null,
            effectCamera: null,
            backgroundCamera: null,
            currentWidth: 0,
            currentHeight: 0,
            isHorizontalScreen: false,
            width: 0,
            height: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "ResizeQuadEffectController#init", this ); }

                this.FlipTexture = false;
                this.sorting = 0;
            }
        },
        methods: {
            /*ResizeQuadEffectController.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "ResizeQuadEffectController#Awake", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(ResizeQuadEffectController.instance, null)) {
                    ResizeQuadEffectController.instance = this;
                }
            },
            /*ResizeQuadEffectController.Awake end.*/

            /*ResizeQuadEffectController.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "ResizeQuadEffectController#Start", this ); }

                this.currentWidth = UnityEngine.Screen.width;
                this.currentHeight = UnityEngine.Screen.height;
                //if (currentWidth > currentHeight)
                //{
                //    isHorizontalScreen = true;
                //}
                //else
                //{
                //    isHorizontalScreen = false;
                //}
                this.RebuildRenderTexturesAll();
                this.gameObject.transform.hideFlags = UnityEngine.HideFlags.HideInInspector;

            },
            /*ResizeQuadEffectController.Start end.*/

            /*ResizeQuadEffectController.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "ResizeQuadEffectController#Update", this ); }


                if (this.effectCamera.GetComponent(UnityEngine.Camera).targetTexture == null) {
                    this.RebuildRenderTexturesAll();
                }
                if ((this.currentHeight !== UnityEngine.Screen.height) && (this.currentWidth !== UnityEngine.Screen.width)) {
                    this.RebuildRenderTexturesAll();

                }

            },
            /*ResizeQuadEffectController.Update end.*/

            /*ResizeQuadEffectController.AboutToRebuildAll start.*/
            AboutToRebuildAll: function () {
if ( TRACE ) { TRACE( "ResizeQuadEffectController#AboutToRebuildAll", this ); }
 // called when playing/stop is coming
                this.effectCamera.GetComponent(UnityEngine.Camera).targetTexture = null;
            },
            /*ResizeQuadEffectController.AboutToRebuildAll end.*/

            /*ResizeQuadEffectController.RebuildRenderTexturesAll start.*/
            RebuildRenderTexturesAll: function () {
if ( TRACE ) { TRACE( "ResizeQuadEffectController#RebuildRenderTexturesAll", this ); }

                this.currentWidth = UnityEngine.Screen.width;
                this.currentHeight = UnityEngine.Screen.height;

                // width = (int)Camera.main.pixelWidth;
                // height = (int)Camera.main.pixelHeight;
                this.effectCamera = this.gameObject.transform.parent.gameObject;

                // if (gameObject.transform.parent.parent.Find("0-BGCamera"))
                //     backgroundCamera = gameObject.transform.parent.parent.Find("0-BGCamera").gameObject;

                // Only for toon style
                if (UnityEngine.GameObject.op_Inequality(this.backgroundCamera, null)) {
                    var BackgroundRT = new UnityEngine.RenderTexture.$ctor3(this.currentWidth, this.currentHeight, 24, UnityEngine.RenderTextureFormat.ARGB32, UnityEngine.RenderTextureReadWrite.Default);
                    this.GetComponent(UnityEngine.MeshRenderer).sharedMaterial.SetTexture$1("_BackgroundTex", BackgroundRT);
                    //   backgroundCamera.GetComponent<Camera>().forceIntoRenderTexture = true;
                    //  backgroundCamera.GetComponent<Camera>().targetTexture = BackgroundRT;
                }

                var EffectRT = new UnityEngine.RenderTexture.$ctor3(this.currentWidth, this.currentHeight, 24, UnityEngine.RenderTextureFormat.ARGB32, UnityEngine.RenderTextureReadWrite.Default);
                //CREATING AND ADDING RT

                //For Regular shader
                this.GetComponent(UnityEngine.MeshRenderer).sharedMaterial.SetTexture$1("_MainTex", EffectRT);

                //For Toon Shader
                this.GetComponent(UnityEngine.MeshRenderer).sharedMaterial.SetTexture$1("_EffectTex", EffectRT);

                //  effectCamera.GetComponent<Camera>().forceIntoRenderTexture = true;
                this.effectCamera.GetComponent(UnityEngine.Camera).targetTexture = EffectRT;

                EffectRT.Release();



                //#if UNITY_EDITOR
                /* 
                if ((Application.platform == RuntimePlatform.WindowsEditor) || (Application.platform == RuntimePlatform.WindowsPlayer))
                {
                   if (GraphicsSettings.renderPipelineAsset != null)
                   {
                       GetComponent<MeshRenderer>().sharedMaterial.SetFloat("_FlipTex", 0f);
                   }
                   else {
                       GetComponent<MeshRenderer>().sharedMaterial.SetFloat("_FlipTex", 1f);
                   }
                }
                */


                /* 
                if (FlipTexture && (Application.platform == RuntimePlatform.WindowsPlayer || Application.platform == RuntimePlatform.WindowsEditor))

                    GetComponent<MeshRenderer>().sharedMaterial.SetFloat("_FlipTex", 1.0f);

                else
                   GetComponent<MeshRenderer>().sharedMaterial.SetFloat("_FlipTex", 0.0f);


                */


                //#endif






                if (this.FlipTexture && (UnityEngine.Application.platform === UnityEngine.RuntimePlatform.WindowsPlayer)) {
                    this.GetComponent(UnityEngine.MeshRenderer).sharedMaterial.SetFloat$1("_FlipTex", 1.0);
                } else {
                    this.GetComponent(UnityEngine.MeshRenderer).sharedMaterial.SetFloat$1("_FlipTex", 0.0);
                }


            },
            /*ResizeQuadEffectController.RebuildRenderTexturesAll end.*/

            /*ResizeQuadEffectController.SetSorting start.*/
            SetSorting: function (id) {
if ( TRACE ) { TRACE( "ResizeQuadEffectController#SetSorting", this ); }

                if (id === void 0) { id = 0; }
                this.GetComponent(UnityEngine.MeshRenderer).sortingOrder = id;
            },
            /*ResizeQuadEffectController.SetSorting end.*/


        }
    });
    /*ResizeQuadEffectController end.*/

    /*RotateObject start.*/
    Bridge.define("RotateObject", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            duration: 0,
            angle: 0
        },
        methods: {
            /*RotateObject.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "RotateObject#Start", this ); }

                DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.TweenSettingsExtensions.SetLoops(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.ShortcutExtensions.DORotate(this.transform, new pc.Vec3( 0, 0, this.angle ), this.duration, DG.Tweening.RotateMode.LocalAxisAdd), -1), DG.Tweening.Ease.Linear);
            },
            /*RotateObject.Start end.*/


        }
    });
    /*RotateObject end.*/

    /*Rotation start.*/
    Bridge.define("Rotation", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            amount: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Rotation#init", this ); }

                this.amount = 1.0;
            }
        },
        methods: {
            /*Rotation.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Rotation#Start", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    euler,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    euler = this.transform.localEulerAngles.$clone();
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( true ) {
                                            $step = 2;
                                            continue;
                                        } 
                                        $step = 4;
                                        continue;
                                }
                                case 2: {
                                    if (euler.z > 137 || euler.z < 110) {
                                            this.amount *= -1;
                                        }

                                        euler.z += this.amount;

                                        this.transform.localEulerAngles = euler.$clone();
                                        $enumerator.current = null;
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    
                                        $step = 1;
                                        continue;
                                }
                                case 4: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Rotation.Start end.*/


        }
    });
    /*Rotation end.*/

    /*screenshot start.*/
    Bridge.define("screenshot", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            TakeAShot: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "screenshot#init", this ); }

                this.TakeAShot = false;
            }
        },
        methods: {
            /*screenshot.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "screenshot#Update", this ); }


                //if (Application.isPlaying)
                //{
                //    if (Input.GetKeyDown(KeyCode.Space))
                //    {
                //        TakeAShot = false;
                //        ScreenCapture.CaptureScreenshot("shot_" + Time.time + ".png", 2);
                //    }
                //}
                //else {
                //    if (TakeAShot)
                //    {
                //        TakeAShot = false;
                //        ScreenCapture.CaptureScreenshot("shot_" + Time.time + ".png", 2);
                //    }
                //}


            },
            /*screenshot.Update end.*/


        }
    });
    /*screenshot end.*/

    /*SelfDefine start.*/
    Bridge.define("SelfDefine", {
        inherits: [UnityEngine.MonoBehaviour]
    });
    /*SelfDefine end.*/

    /*SharpJson.JsonDecoder start.*/
    Bridge.define("SharpJson.JsonDecoder", {
        statics: {
            methods: {
                /*SharpJson.JsonDecoder.DecodeText:static start.*/
                DecodeText: function (text) {
if ( TRACE ) { TRACE( "SharpJson.JsonDecoder#DecodeText", this ); }

                    var builder = new SharpJson.JsonDecoder();
                    return builder.Decode(text);
                },
                /*SharpJson.JsonDecoder.DecodeText:static end.*/


            }
        },
        fields: {
            errorMessage: null,
            parseNumbersAsFloat: false,
            lexer: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "SharpJson.JsonDecoder#ctor", this ); }

                this.$initialize();
                this.errorMessage = null;
                this.parseNumbersAsFloat = false;
            }
        },
        methods: {
            /*SharpJson.JsonDecoder.Decode start.*/
            Decode: function (text) {
if ( TRACE ) { TRACE( "SharpJson.JsonDecoder#Decode", this ); }

                this.errorMessage = null;

                this.lexer = new SharpJson.Lexer(text);
                this.lexer.parseNumbersAsFloat = this.parseNumbersAsFloat;

                return this.ParseValue();
            },
            /*SharpJson.JsonDecoder.Decode end.*/

            /*SharpJson.JsonDecoder.ParseObject start.*/
            ParseObject: function () {
if ( TRACE ) { TRACE( "SharpJson.JsonDecoder#ParseObject", this ); }

                var table = new (System.Collections.Generic.Dictionary$2(System.String,System.Object)).ctor();

                // {
                this.lexer.NextToken();

                while (true) {
                    var token = this.lexer.LookAhead();

                    switch (token) {
                        case SharpJson.Lexer.Token.None: 
                            this.TriggerError("Invalid token");
                            return null;
                        case SharpJson.Lexer.Token.Comma: 
                            this.lexer.NextToken();
                            break;
                        case SharpJson.Lexer.Token.CurlyClose: 
                            this.lexer.NextToken();
                            return table;
                        default: 
                            // name
                            var name = this.EvalLexer(System.String, this.lexer.ParseString());
                            if (this.errorMessage != null) {
                                return null;
                            }
                            // :
                            token = this.lexer.NextToken();
                            if (token !== SharpJson.Lexer.Token.Colon) {
                                this.TriggerError("Invalid token; expected ':'");
                                return null;
                            }
                            // value
                            var value = this.ParseValue();
                            if (this.errorMessage != null) {
                                return null;
                            }
                            table.setItem(name, value);
                            break;
                    }
                }

                //return null; // Unreachable code
            },
            /*SharpJson.JsonDecoder.ParseObject end.*/

            /*SharpJson.JsonDecoder.ParseArray start.*/
            ParseArray: function () {
if ( TRACE ) { TRACE( "SharpJson.JsonDecoder#ParseArray", this ); }

                var array = new (System.Collections.Generic.List$1(System.Object)).ctor();

                // [
                this.lexer.NextToken();

                while (true) {
                    var token = this.lexer.LookAhead();

                    switch (token) {
                        case SharpJson.Lexer.Token.None: 
                            this.TriggerError("Invalid token");
                            return null;
                        case SharpJson.Lexer.Token.Comma: 
                            this.lexer.NextToken();
                            break;
                        case SharpJson.Lexer.Token.SquaredClose: 
                            this.lexer.NextToken();
                            return array;
                        default: 
                            var value = this.ParseValue();
                            if (this.errorMessage != null) {
                                return null;
                            }
                            array.add(value);
                            break;
                    }
                }

                //return null; // Unreachable code
            },
            /*SharpJson.JsonDecoder.ParseArray end.*/

            /*SharpJson.JsonDecoder.ParseValue start.*/
            ParseValue: function () {
if ( TRACE ) { TRACE( "SharpJson.JsonDecoder#ParseValue", this ); }

                switch (this.lexer.LookAhead()) {
                    case SharpJson.Lexer.Token.String: 
                        return this.EvalLexer(System.String, this.lexer.ParseString());
                    case SharpJson.Lexer.Token.Number: 
                        if (this.parseNumbersAsFloat) {
                            return Bridge.box(this.EvalLexer(System.Single, this.lexer.ParseFloatNumber()), System.Single, System.Single.format, System.Single.getHashCode);
                        } else {
                            return Bridge.box(this.EvalLexer(System.Double, this.lexer.ParseDoubleNumber()), System.Double, System.Double.format, System.Double.getHashCode);
                        }
                    case SharpJson.Lexer.Token.CurlyOpen: 
                        return this.ParseObject();
                    case SharpJson.Lexer.Token.SquaredOpen: 
                        return this.ParseArray();
                    case SharpJson.Lexer.Token.True: 
                        this.lexer.NextToken();
                        return Bridge.box(true, System.Boolean, System.Boolean.toString);
                    case SharpJson.Lexer.Token.False: 
                        this.lexer.NextToken();
                        return Bridge.box(false, System.Boolean, System.Boolean.toString);
                    case SharpJson.Lexer.Token.Null: 
                        this.lexer.NextToken();
                        return null;
                    case SharpJson.Lexer.Token.None: 
                        break;
                }

                this.TriggerError("Unable to parse value");
                return null;
            },
            /*SharpJson.JsonDecoder.ParseValue end.*/

            /*SharpJson.JsonDecoder.TriggerError start.*/
            TriggerError: function (message) {
if ( TRACE ) { TRACE( "SharpJson.JsonDecoder#TriggerError", this ); }

                this.errorMessage = System.String.format("Error: '{0}' at line {1}", message, Bridge.box(this.lexer.lineNumber, System.Int32));
            },
            /*SharpJson.JsonDecoder.TriggerError end.*/

            /*SharpJson.JsonDecoder.EvalLexer start.*/
            EvalLexer: function (T, value) {
if ( TRACE ) { TRACE( "SharpJson.JsonDecoder#EvalLexer", this ); }

                if (this.lexer.hasError) {
                    this.TriggerError("Lexical error ocurred");
                }

                return Bridge.rValue(value);
            },
            /*SharpJson.JsonDecoder.EvalLexer end.*/


        }
    });
    /*SharpJson.JsonDecoder end.*/

    /*SharpJson.Lexer start.*/
    Bridge.define("SharpJson.Lexer", {
        statics: {
            methods: {
                /*SharpJson.Lexer.NextToken:static start.*/
                NextToken: function (json, index) {
if ( TRACE ) { TRACE( "SharpJson.Lexer#NextToken", this ); }

                    if (index.v === json.length) {
                        return SharpJson.Lexer.Token.None;
                    }

                    var c = json[Bridge.identity(index.v, ((index.v = (index.v + 1) | 0)))];

                    switch (c) {
                        case 123: 
                            return SharpJson.Lexer.Token.CurlyOpen;
                        case 125: 
                            return SharpJson.Lexer.Token.CurlyClose;
                        case 91: 
                            return SharpJson.Lexer.Token.SquaredOpen;
                        case 93: 
                            return SharpJson.Lexer.Token.SquaredClose;
                        case 44: 
                            return SharpJson.Lexer.Token.Comma;
                        case 34: 
                            return SharpJson.Lexer.Token.String;
                        case 48: 
                        case 49: 
                        case 50: 
                        case 51: 
                        case 52: 
                        case 53: 
                        case 54: 
                        case 55: 
                        case 56: 
                        case 57: 
                        case 45: 
                            return SharpJson.Lexer.Token.Number;
                        case 58: 
                            return SharpJson.Lexer.Token.Colon;
                    }

                    index.v = (index.v - 1) | 0;

                    var remainingLength = (json.length - index.v) | 0;

                    // false
                    if (remainingLength >= 5) {
                        if (json[index.v] === 102 && json[((index.v + 1) | 0)] === 97 && json[((index.v + 2) | 0)] === 108 && json[((index.v + 3) | 0)] === 115 && json[((index.v + 4) | 0)] === 101) {
                            index.v = (index.v + 5) | 0;
                            return SharpJson.Lexer.Token.False;
                        }
                    }

                    // true
                    if (remainingLength >= 4) {
                        if (json[index.v] === 116 && json[((index.v + 1) | 0)] === 114 && json[((index.v + 2) | 0)] === 117 && json[((index.v + 3) | 0)] === 101) {
                            index.v = (index.v + 4) | 0;
                            return SharpJson.Lexer.Token.True;
                        }
                    }

                    // null
                    if (remainingLength >= 4) {
                        if (json[index.v] === 110 && json[((index.v + 1) | 0)] === 117 && json[((index.v + 2) | 0)] === 108 && json[((index.v + 3) | 0)] === 108) {
                            index.v = (index.v + 4) | 0;
                            return SharpJson.Lexer.Token.Null;
                        }
                    }

                    return SharpJson.Lexer.Token.None;
                },
                /*SharpJson.Lexer.NextToken:static end.*/


            }
        },
        fields: {
            lineNumber: 0,
            parseNumbersAsFloat: false,
            json: null,
            index: 0,
            success: false,
            stringBuffer: null
        },
        props: {
            hasError: {
                get: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#hasError#get", this ); }

                    return !this.success;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#init", this ); }

                this.index = 0;
                this.success = true;
                this.stringBuffer = System.Array.init(4096, 0, System.Char);
            },
            ctor: function (text) {
if ( TRACE ) { TRACE( "SharpJson.Lexer#ctor", this ); }

                this.$initialize();
                this.Reset();

                this.json = System.String.toCharArray(text, 0, text.length);
                this.parseNumbersAsFloat = false;
            }
        },
        methods: {
            /*SharpJson.Lexer.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#Reset", this ); }

                this.index = 0;
                this.lineNumber = 1;
                this.success = true;
            },
            /*SharpJson.Lexer.Reset end.*/

            /*SharpJson.Lexer.ParseString start.*/
            ParseString: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#ParseString", this ); }

                var idx = 0;
                var builder = null;

                this.SkipWhiteSpaces();

                // "
                var c = this.json[Bridge.identity(this.index, ((this.index = (this.index + 1) | 0)))];

                var failed = false;
                var complete = false;

                while (!complete && !failed) {
                    if (this.index === this.json.length) {
                        break;
                    }

                    c = this.json[Bridge.identity(this.index, ((this.index = (this.index + 1) | 0)))];
                    if (c === 34) {
                        complete = true;
                        break;
                    } else if (c === 92) {
                        if (this.index === this.json.length) {
                            break;
                        }

                        c = this.json[Bridge.identity(this.index, ((this.index = (this.index + 1) | 0)))];

                        switch (c) {
                            case 34: 
                                this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = 34;
                                break;
                            case 92: 
                                this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = 92;
                                break;
                            case 47: 
                                this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = 47;
                                break;
                            case 98: 
                                this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = 8;
                                break;
                            case 102: 
                                this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = 12;
                                break;
                            case 110: 
                                this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = 10;
                                break;
                            case 114: 
                                this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = 13;
                                break;
                            case 116: 
                                this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = 9;
                                break;
                            case 117: 
                                var remainingLength = (this.json.length - this.index) | 0;
                                if (remainingLength >= 4) {
                                    var hex = System.String.fromCharArray(this.json, this.index, 4);

                                    // XXX: handle UTF
                                    this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = (System.Convert.toNumberInBase(hex, 16, 9)) & 65535;

                                    // skip 4 chars
                                    this.index = (this.index + 4) | 0;
                                } else {
                                    failed = true;
                                }
                                break;
                        }
                    } else {
                        this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = c;
                    }

                    if (idx >= this.stringBuffer.length) {
                        if (builder == null) {
                            builder = new System.Text.StringBuilder();
                        }

                        builder.append(this.stringBuffer.slice(0, idx).join());
                        idx = 0;
                    }
                }

                if (!complete) {
                    this.success = false;
                    return null;
                }

                if (builder != null) {
                    return builder.toString();
                } else {
                    return System.String.fromCharArray(this.stringBuffer, 0, idx);
                }
            },
            /*SharpJson.Lexer.ParseString end.*/

            /*SharpJson.Lexer.GetNumberString start.*/
            GetNumberString: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#GetNumberString", this ); }

                this.SkipWhiteSpaces();

                var lastIndex = this.GetLastIndexOfNumber(this.index);
                var charLength = ((((lastIndex - this.index) | 0)) + 1) | 0;

                var result = System.String.fromCharArray(this.json, this.index, charLength);

                this.index = (lastIndex + 1) | 0;

                return result;
            },
            /*SharpJson.Lexer.GetNumberString end.*/

            /*SharpJson.Lexer.ParseFloatNumber start.*/
            ParseFloatNumber: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#ParseFloatNumber", this ); }

                var number = { };
                var str = this.GetNumberString();

                if (!System.Single.tryParse4(str, 167, System.Globalization.CultureInfo.invariantCulture, number)) {
                    return 0;
                }

                return number.v;
            },
            /*SharpJson.Lexer.ParseFloatNumber end.*/

            /*SharpJson.Lexer.ParseDoubleNumber start.*/
            ParseDoubleNumber: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#ParseDoubleNumber", this ); }

                var number = { };
                var str = this.GetNumberString();

                if (!System.Double.tryParse4(str, 511, System.Globalization.CultureInfo.invariantCulture, number)) {
                    return 0;
                }

                return number.v;
            },
            /*SharpJson.Lexer.ParseDoubleNumber end.*/

            /*SharpJson.Lexer.GetLastIndexOfNumber start.*/
            GetLastIndexOfNumber: function (index) {
if ( TRACE ) { TRACE( "SharpJson.Lexer#GetLastIndexOfNumber", this ); }

                var lastIndex;

                for (lastIndex = index; lastIndex < this.json.length; lastIndex = (lastIndex + 1) | 0) {
                    var ch = this.json[lastIndex];

                    if ((ch < 48 || ch > 57) && ch !== 43 && ch !== 45 && ch !== 46 && ch !== 101 && ch !== 69) {
                        break;
                    }
                }

                return ((lastIndex - 1) | 0);
            },
            /*SharpJson.Lexer.GetLastIndexOfNumber end.*/

            /*SharpJson.Lexer.SkipWhiteSpaces start.*/
            SkipWhiteSpaces: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#SkipWhiteSpaces", this ); }

                for (; this.index < this.json.length; this.index = (this.index + 1) | 0) {
                    var ch = this.json[this.index];

                    if (ch === 10) {
                        this.lineNumber = (this.lineNumber + 1) | 0;
                    }

                    if (!System.Char.isWhiteSpace(String.fromCharCode(this.json[this.index]))) {
                        break;
                    }
                }
            },
            /*SharpJson.Lexer.SkipWhiteSpaces end.*/

            /*SharpJson.Lexer.LookAhead start.*/
            LookAhead: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#LookAhead", this ); }

                this.SkipWhiteSpaces();

                var savedIndex = { v : this.index };
                return SharpJson.Lexer.NextToken(this.json, savedIndex);
            },
            /*SharpJson.Lexer.LookAhead end.*/

            /*SharpJson.Lexer.NextToken start.*/
            NextToken: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#NextToken", this ); }

                this.SkipWhiteSpaces();
                return SharpJson.Lexer.NextToken(this.json, Bridge.ref(this, "index"));
            },
            /*SharpJson.Lexer.NextToken end.*/


        }
    });
    /*SharpJson.Lexer end.*/

    /*SharpJson.Lexer+Token start.*/
    Bridge.define("SharpJson.Lexer.Token", {
        $kind: 1006,
        statics: {
            fields: {
                None: 0,
                Null: 1,
                True: 2,
                False: 3,
                Colon: 4,
                Comma: 5,
                String: 6,
                Number: 7,
                CurlyOpen: 8,
                CurlyClose: 9,
                SquaredOpen: 10,
                SquaredClose: 11
            }
        }
    });
    /*SharpJson.Lexer+Token end.*/

    /*SimplePool start.*/
    Bridge.define("SimplePool", {
        statics: {
            fields: {
                DEFAULT_POOL_SIZE: 0,
                _pools: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "SimplePool#init", this ); }

                    this.DEFAULT_POOL_SIZE = 3;
                }
            },
            methods: {
                /*SimplePool.Init:static start.*/
                /**
                 * Initialize our dictionary.
                 *
                 * @static
                 * @private
                 * @this SimplePool
                 * @memberof SimplePool
                 * @param   {UnityEngine.GameObject}    prefab    
                 * @param   {number}                    qty
                 * @return  {void}
                 */
                Init: function (prefab, qty) {
if ( TRACE ) { TRACE( "SimplePool#Init", this ); }

                    if (prefab === void 0) { prefab = null; }
                    if (qty === void 0) { qty = 3; }
                    if (SimplePool._pools == null) {
                        SimplePool._pools = new (System.Collections.Generic.Dictionary$2(System.Int32,SimplePool.Pool)).ctor();
                    }

                    if (UnityEngine.GameObject.op_Inequality(prefab, null)) {
                        //changed from (prefab, Pool) to (int, Pool) which should be faster if we have 
                        //many different prefabs.
                        var prefabID = prefab.GetInstanceID();
                        if (!SimplePool._pools.containsKey(prefabID)) {
                            SimplePool._pools.setItem(prefabID, new SimplePool.Pool(prefab, qty));
                        }
                    }
                },
                /*SimplePool.Init:static end.*/

                /*SimplePool.PoolPreLoad:static start.*/
                PoolPreLoad: function (prefab, qty, newParent) {
if ( TRACE ) { TRACE( "SimplePool#PoolPreLoad", this ); }

                    if (newParent === void 0) { newParent = null; }
                    SimplePool.Init(prefab, 1);
                    SimplePool._pools.getItem(prefab.GetInstanceID()).Preload(qty, newParent);
                },
                /*SimplePool.PoolPreLoad:static end.*/

                /*SimplePool.Preload:static start.*/
                /**
                 * If you want to preload a few copies of an object at the start
                 of a scene, you can use this. Really not needed unless you're
                 going to go from zero instances to 100+ very quickly.
                 Could technically be optimized more, but in practice the
                 Spawn/Despawn sequence is going to be pretty darn quick and
                 this avoids code duplication.
                 *
                 * @static
                 * @public
                 * @this SimplePool
                 * @memberof SimplePool
                 * @param   {UnityEngine.GameObject}            prefab       
                 * @param   {number}                            qty          
                 * @param   {UnityEngine.Transform}             newParent
                 * @return  {Array.<UnityEngine.GameObject>}
                 */
                Preload: function (prefab, qty, newParent) {
if ( TRACE ) { TRACE( "SimplePool#Preload", this ); }

                    if (qty === void 0) { qty = 1; }
                    if (newParent === void 0) { newParent = null; }
                    SimplePool.Init(prefab, qty);
                    // Make an array to grab the objects we're about to pre-spawn.
                    var obs = System.Array.init(qty, null, UnityEngine.GameObject);
                    for (var i = 0; i < qty; i = (i + 1) | 0) {
                        obs[i] = SimplePool.Spawn$3(prefab, pc.Vec3.ZERO.clone(), pc.Quat.IDENTITY.clone());
                        if (UnityEngine.Component.op_Inequality(newParent, null)) {
                            obs[i].transform.SetParent(newParent);
                        }
                    }

                    // Now despawn them all.
                    for (var i1 = 0; i1 < qty; i1 = (i1 + 1) | 0) {
                        SimplePool.Despawn(obs[i1]);
                    }
                    return obs;
                },
                /*SimplePool.Preload:static end.*/

                /*SimplePool.Spawn$3:static start.*/
                /**
                 * Spawns a copy of the specified prefab (instantiating one if required).
                 NOTE: Remember that Awake() or Start() will only run on the very first
                 spawn and that member variables won't get reset.  OnEnable will run
                 after spawning -- but remember that toggling IsActive will also
                 call that function.
                 *
                 * @static
                 * @public
                 * @this SimplePool
                 * @memberof SimplePool
                 * @param   {UnityEngine.GameObject}    prefab    
                 * @param   {UnityEngine.Vector3}       pos       
                 * @param   {UnityEngine.Quaternion}    rot
                 * @return  {UnityEngine.GameObject}
                 */
                Spawn$3: function (prefab, pos, rot) {
if ( TRACE ) { TRACE( "SimplePool#Spawn$3", this ); }

                    SimplePool.Init(prefab);

                    return SimplePool._pools.getItem(prefab.GetInstanceID()).Spawn$1(pos.$clone(), rot.$clone());
                },
                /*SimplePool.Spawn$3:static end.*/

                /*SimplePool.Spawn$2:static start.*/
                Spawn$2: function (prefab) {
if ( TRACE ) { TRACE( "SimplePool#Spawn$2", this ); }

                    return SimplePool.Spawn$3(prefab, pc.Vec3.ZERO.clone(), pc.Quat.IDENTITY.clone());
                },
                /*SimplePool.Spawn$2:static end.*/

                /*SimplePool.Spawn:static start.*/
                Spawn: function (T, prefab) {
if ( TRACE ) { TRACE( "SimplePool#Spawn", this ); }

                    return SimplePool.Spawn$1(T, Bridge.rValue(prefab), pc.Vec3.ZERO.clone(), pc.Quat.IDENTITY.clone());
                },
                /*SimplePool.Spawn:static end.*/

                /*SimplePool.Spawn$1:static start.*/
                Spawn$1: function (T, prefab, pos, rot) {
if ( TRACE ) { TRACE( "SimplePool#Spawn$1", this ); }

                    SimplePool.Init(Bridge.rValue(prefab).gameObject);
                    return SimplePool._pools.getItem(Bridge.rValue(prefab).gameObject.GetInstanceID()).Spawn(T, pos.$clone(), rot.$clone());
                },
                /*SimplePool.Spawn$1:static end.*/

                /*SimplePool.Despawn:static start.*/
                /**
                 * Despawn the specified gameobject back into its pool.
                 *
                 * @static
                 * @public
                 * @this SimplePool
                 * @memberof SimplePool
                 * @param   {UnityEngine.GameObject}    obj
                 * @return  {void}
                 */
                Despawn: function (obj) {
if ( TRACE ) { TRACE( "SimplePool#Despawn", this ); }

                    var $t;
                    var p = null;
                    $t = Bridge.getEnumerator(SimplePool._pools.Values);
                    try {
                        while ($t.moveNext()) {
                            var pool = $t.Current;
                            if (pool.MemberIDs.contains(obj.GetInstanceID())) {
                                p = pool;
                                break;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    if (p == null) {
                        UnityEngine.Debug.LogFormat("Object '{0}' wasn't spawned from a pool. Destroying it instead.", [obj.name]);
                        UnityEngine.Object.Destroy(obj);
                    } else {
                        p.Despawn(obj);
                    }
                },
                /*SimplePool.Despawn:static end.*/

                /*SimplePool.GetStackCount:static start.*/
                GetStackCount: function (prefab) {
if ( TRACE ) { TRACE( "SimplePool#GetStackCount", this ); }

                    if (SimplePool._pools == null) {
                        SimplePool._pools = new (System.Collections.Generic.Dictionary$2(System.Int32,SimplePool.Pool)).ctor();
                    }
                    if (UnityEngine.GameObject.op_Equality(prefab, null)) {
                        return 0;
                    }
                    return SimplePool._pools.containsKey(prefab.GetInstanceID()) ? SimplePool._pools.getItem(prefab.GetInstanceID()).StackCount : 0;
                },
                /*SimplePool.GetStackCount:static end.*/

                /*SimplePool.ClearPool:static start.*/
                ClearPool: function () {
if ( TRACE ) { TRACE( "SimplePool#ClearPool", this ); }

                    if (SimplePool._pools != null) {
                        SimplePool._pools.clear();
                    }
                },
                /*SimplePool.ClearPool:static end.*/


            }
        }
    });
    /*SimplePool end.*/

    /*SimplePool+Pool start.*/
    /**
     * The Pool class represents the pool for a particular prefab.
     *
     * @public
     * @class SimplePool.Pool
     */
    Bridge.define("SimplePool.Pool", {
        $kind: 1002,
        fields: {
            _nextId: 0,
            _inactive: null,
            MemberIDs: null,
            _prefab: null
        },
        props: {
            StackCount: {
                get: function () {
if ( TRACE ) { TRACE( "SimplePool.Pool#StackCount#get", this ); }

                    return this._inactive.Count;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "SimplePool.Pool#init", this ); }

                this._nextId = 1;
            },
            ctor: function (prefab, initialQty) {
if ( TRACE ) { TRACE( "SimplePool.Pool#ctor", this ); }

                this.$initialize();
                this._prefab = prefab;
                // If Stack uses a linked list internally, then this
                // whole initialQty thing is a placebo that we could
                // strip out for more minimal code. But it can't *hurt*.
                this._inactive = new (System.Collections.Generic.Queue$1(UnityEngine.GameObject)).$ctor2(initialQty);
                this.MemberIDs = new (System.Collections.Generic.HashSet$1(System.Int32)).ctor();
            }
        },
        methods: {
            /*SimplePool+Pool.Preload start.*/
            Preload: function (initialQty, parent) {
if ( TRACE ) { TRACE( "SimplePool.Pool#Preload", this ); }

                if (parent === void 0) { parent = null; }
                for (var i = 0; i < initialQty; i = (i + 1) | 0) {
                    // instantiate a whole new object.
                    var obj = UnityEngine.Object.Instantiate(UnityEngine.GameObject, this._prefab, parent);
                    obj.name = System.String.format("{0} ({1})", this._prefab.name, Bridge.box(Bridge.identity(this._nextId, ((this._nextId = (this._nextId + 1) | 0))), System.Int32));

                    // Add the unique GameObject ID to our MemberHashset so we know this GO belongs to us.
                    this.MemberIDs.add(obj.GetInstanceID());

                    obj.SetActive(false);

                    this._inactive.Enqueue(obj);
                }
            },
            /*SimplePool+Pool.Preload end.*/

            /*SimplePool+Pool.Spawn$1 start.*/
            Spawn$1: function (pos, rot) {
if ( TRACE ) { TRACE( "SimplePool.Pool#Spawn$1", this ); }

                while (true) {
                    var obj;
                    if (this._inactive.Count === 0) {
                        // We don't have an object in our pool, so we
                        // instantiate a whole new object.
                        obj = UnityEngine.Object.Instantiate$2(UnityEngine.GameObject, this._prefab, pos.$clone(), rot.$clone());
                        obj.name = System.String.format("{0} ({1})", this._prefab.name, Bridge.box(Bridge.identity(this._nextId, ((this._nextId = (this._nextId + 1) | 0))), System.Int32));

                        // Add the unique GameObject ID to our MemberHashset so we know this GO belongs to us.
                        this.MemberIDs.add(obj.GetInstanceID());
                    } else {
                        // Grab the last object in the inactive array
                        obj = this._inactive.Dequeue();

                        if (UnityEngine.GameObject.op_Equality(obj, null)) {
                            // The inactive object we expected to find no longer exists.
                            // The most likely causes are:
                            //   - Someone calling Destroy() on our object
                            //   - A scene change (which will destroy all our objects).
                            //     NOTE: This could be prevented with a DontDestroyOnLoad
                            //	   if you really don't want this.
                            // No worries -- we'll just try the next one in our sequence.

                            continue;
                        }
                    }
                    obj.transform.position = pos.$clone();
                    obj.transform.rotation = rot.$clone();
                    obj.SetActive(true);
                    return obj;
                }
            },
            /*SimplePool+Pool.Spawn$1 end.*/

            /*SimplePool+Pool.Spawn start.*/
            Spawn: function (T, pos, rot) {
if ( TRACE ) { TRACE( "SimplePool.Pool#Spawn", this ); }

                return this.Spawn$1(pos.$clone(), rot.$clone()).GetComponent(T);
            },
            /*SimplePool+Pool.Spawn end.*/

            /*SimplePool+Pool.Despawn start.*/
            Despawn: function (obj) {
if ( TRACE ) { TRACE( "SimplePool.Pool#Despawn", this ); }

                if (!obj.activeSelf) {
                    return;
                }
                obj.SetActive(false);
                // Since Stack doesn't have a Capacity member, we can't control
                // the growth factor if it does have to expand an internal array.
                // On the other hand, it might simply be using a linked list 
                // internally.  But then, why does it allow us to specify a size
                // in the constructor? Maybe it's a placebo? Stack is weird.
                this._inactive.Enqueue(obj);
            },
            /*SimplePool+Pool.Despawn end.*/


        },
        overloads: {
            "Spawn(Vector3, Quaternion)": "Spawn$1"
        }
    });
    /*SimplePool+Pool end.*/

    /*SimpleRotation start.*/
    Bridge.define("SimpleRotation", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            water2d: null,
            rb: null,
            angle: 0,
            wise: 0,
            deadFrames: 0,
            deadFramesCount: 0,
            canRotate: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "SimpleRotation#init", this ); }

                this.angle = 0.0;
                this.wise = 1.0;
                this.deadFrames = 10;
                this.deadFramesCount = 0;
                this.canRotate = false;
            }
        },
        methods: {
            /*SimpleRotation.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "SimpleRotation#Start", this ); }

                this.rb = this.gameObject.GetComponent(UnityEngine.Rigidbody2D);
            },
            /*SimpleRotation.Start end.*/

            /*SimpleRotation.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "SimpleRotation#FixedUpdate", this ); }

                if (!this.canRotate) {
                    return;
                }

                if (UnityEngine.Object.op_Implicit(this.rb)) {

                    if (this.deadFramesCount <= this.deadFrames) {
                        this.deadFramesCount = (this.deadFramesCount + 1) | 0;
                        return;
                    }


                    this.rb.MoveRotation(this.angle);
                    this.angle += 0.8 * this.wise;


                    if (this.angle >= 140.0) {
                        this.wise *= -1;
                        this.deadFramesCount = Bridge.Int.mul(this.deadFramesCount, 0);
                    }

                    if (this.angle <= 0.0) {
                        this.wise *= -1;
                        this.canRotate = false;
                        //water2d.Spawn();
                    }

                }
            },
            /*SimpleRotation.FixedUpdate end.*/

            /*SimpleRotation.StartRotation start.*/
            StartRotation: function () {
if ( TRACE ) { TRACE( "SimpleRotation#StartRotation", this ); }

                this.canRotate = true;
                UnityEngine.MonoBehaviour.print("end spawn");
            },
            /*SimpleRotation.StartRotation end.*/


        }
    });
    /*SimpleRotation end.*/

    /*SingletonWithouMono$1 start.*/
    Bridge.define("SingletonWithouMono$1", function (T) { return {
        statics: {
            fields: {
                instance: Bridge.getDefaultValue(T)
            },
            props: {
                Instance: {
                    get: function () {
if ( TRACE ) { TRACE( "SingletonWithouMono$1#Instance#get", this ); }

                        if (Bridge.rValue(SingletonWithouMono$1(T).instance) != null) {
                            return Bridge.rValue(SingletonWithouMono$1(T).instance);
                        }
                        SingletonWithouMono$1(T).instance = Bridge.createInstance(T);
                        (Bridge.as(Bridge.rValue(SingletonWithouMono$1(T).instance), SingletonWithouMono$1(T))).Initialize();
                        return Bridge.rValue(SingletonWithouMono$1(T).instance);
                    }
                }
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "SingletonWithouMono$1#init", this ); }

                    this.instance = Bridge.getDefaultValue(T);
                }
            }
        },
        fields: {
            initialized: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "SingletonWithouMono$1#init", this ); }

                this.initialized = false;
            }
        },
        methods: {
            /*SingletonWithouMono$1.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "SingletonWithouMono$1#Initialize", this ); }

                if (this.initialized) {
                    return;
                }
                this.initialized = true;
            },
            /*SingletonWithouMono$1.Initialize end.*/

            /*SingletonWithouMono$1.Preload start.*/
            Preload: function () {
if ( TRACE ) { TRACE( "SingletonWithouMono$1#Preload", this ); }
 },
            /*SingletonWithouMono$1.Preload end.*/


        }
    }; });
    /*SingletonWithouMono$1 end.*/

    /*Spine.Animation start.*/
    /** @namespace Spine */

    /**
     * A simple container for a list of timelines and a name.
     *
     * @public
     * @class Spine.Animation
     */
    Bridge.define("Spine.Animation", {
        statics: {
            methods: {
                /*Spine.Animation.BinarySearch$1:static start.*/
                /**
                 * @static
                 * @this Spine.Animation
                 * @memberof Spine.Animation
                 * @param   {Array.<number>}    values    
                 * @param   {number}            target    After the first and before the last entry.
                 * @param   {number}            step
                 * @return  {number}                      Index of first value greater than the target.
                 */
                BinarySearch$1: function (values, target, step) {
if ( TRACE ) { TRACE( "Spine.Animation#BinarySearch$1", this ); }

                    var low = 0;
                    var high = (((Bridge.Int.div(values.length, step)) | 0) - 2) | 0;
                    if (high === 0) {
                        return step;
                    }
                    var current = ((high >>> 0) >>> 1) | 0;
                    while (true) {
                        if (values[Bridge.Int.mul((((current + 1) | 0)), step)] <= target) {
                            low = (current + 1) | 0;
                        } else {
                            high = current;
                        }
                        if (low === high) {
                            return Bridge.Int.mul((((low + 1) | 0)), step);
                        }
                        current = ((((((low + high) | 0))) >>> 0) >>> 1) | 0;
                    }
                },
                /*Spine.Animation.BinarySearch$1:static end.*/

                /*Spine.Animation.BinarySearch:static start.*/
                /**
                 * @static
                 * @this Spine.Animation
                 * @memberof Spine.Animation
                 * @param   {Array.<number>}    values    
                 * @param   {number}            target    After the first and before the last entry.
                 * @return  {number}
                 */
                BinarySearch: function (values, target) {
if ( TRACE ) { TRACE( "Spine.Animation#BinarySearch", this ); }

                    var low = 0;
                    var high = (values.length - 2) | 0;
                    if (high === 0) {
                        return 1;
                    }
                    var current = ((high >>> 0) >>> 1) | 0;
                    while (true) {
                        if (values[((current + 1) | 0)] <= target) {
                            low = (current + 1) | 0;
                        } else {
                            high = current;
                        }
                        if (low === high) {
                            return (((low + 1) | 0));
                        }
                        current = ((((((low + high) | 0))) >>> 0) >>> 1) | 0;
                    }
                },
                /*Spine.Animation.BinarySearch:static end.*/

                /*Spine.Animation.LinearSearch:static start.*/
                LinearSearch: function (values, target, step) {
if ( TRACE ) { TRACE( "Spine.Animation#LinearSearch", this ); }

                    for (var i = 0, last = (values.length - step) | 0; i <= last; i = (i + step) | 0) {
                        if (values[i] > target) {
                            return i;
                        }
                    }
                    return -1;
                },
                /*Spine.Animation.LinearSearch:static end.*/


            }
        },
        fields: {
            name: null,
            timelines: null,
            timelineIds: null,
            duration: 0
        },
        props: {
            Timelines: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Animation#Timelines#get", this ); }

                    return this.timelines;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Animation#Timelines#set", this ); }

                    this.timelines = value;
                }
            },
            /**
             * The duration of the animation in seconds, which is the highest time of all keys in the timeline.
             *
             * @instance
             * @public
             * @memberof Spine.Animation
             * @function Duration
             * @type number
             */
            Duration: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Animation#Duration#get", this ); }

                    return this.duration;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Animation#Duration#set", this ); }

                    this.duration = value;
                }
            },
            /**
             * The animation's name, which is unique across all animations in the skeleton.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Animation
             * @function Name
             * @type string
             */
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Animation#Name#get", this ); }

                    return this.name;
                }
            }
        },
        ctors: {
            ctor: function (name, timelines, duration) {
if ( TRACE ) { TRACE( "Spine.Animation#ctor", this ); }

                this.$initialize();
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor3("name", "name cannot be null.");
                }
                if (timelines == null) {
                    throw new System.ArgumentNullException.$ctor3("timelines", "timelines cannot be null.");
                }
                // Note: avoiding reallocations by adding all hash set entries at
                // once (EnsureCapacity() is only available in newer .Net versions).
                var propertyIDs = System.Array.init(timelines.Count, 0, System.Int32);
                for (var i = 0; i < timelines.Count; i = (i + 1) | 0) {
                    propertyIDs[i] = timelines.Items[i].Spine$Timeline$PropertyId;
                }
                this.timelineIds = new (System.Collections.Generic.HashSet$1(System.Int32)).$ctor1(propertyIDs);
                this.name = name;
                this.timelines = timelines;
                this.duration = duration;
            }
        },
        methods: {
            /*Spine.Animation.HasTimeline start.*/
            /**
             * Whether the timeline with the property id is contained in this animation.
             *
             * @instance
             * @public
             * @this Spine.Animation
             * @memberof Spine.Animation
             * @param   {number}     id
             * @return  {boolean}
             */
            HasTimeline: function (id) {
if ( TRACE ) { TRACE( "Spine.Animation#HasTimeline", this ); }

                return this.timelineIds.contains(id);
            },
            /*Spine.Animation.HasTimeline end.*/

            /*Spine.Animation.Apply start.*/
            /**
             * Applies all the animation's timelines to the specified skeleton.
             *
             * @instance
             * @public
             * @this Spine.Animation
             * @memberof Spine.Animation
             * @param   {Spine.Skeleton}         skeleton     
             * @param   {number}                 lastTime     
             * @param   {number}                 time         
             * @param   {boolean}                loop         
             * @param   {Spine.ExposedList$1}    events       
             * @param   {number}                 alpha        
             * @param   {Spine.MixBlend}         blend        
             * @param   {Spine.MixDirection}     direction
             * @return  {void}
             * @see {@link Timeline.Apply(Skeleton, float, float, ExposedList, float, MixBlend, MixDirection)}
             */
            Apply: function (skeleton, lastTime, time, loop, events, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.Animation#Apply", this ); }

                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                }

                if (loop && this.duration !== 0) {
                    time %= this.duration;
                    if (lastTime > 0) {
                        lastTime %= this.duration;
                    }
                }

                var timelines = this.timelines;
                for (var i = 0, n = timelines.Count; i < n; i = (i + 1) | 0) {
                    timelines.Items[i].Spine$Timeline$Apply(skeleton, lastTime, time, events, alpha, blend, direction);
                }
            },
            /*Spine.Animation.Apply end.*/

            /*Spine.Animation.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Animation#toString", this ); }

                return this.name;
            },
            /*Spine.Animation.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.Animation end.*/

    /*Spine.AnimationState start.*/
    /**
     * <p>Applies animations over time, queues animations for later playback, mixes (crossfading) between animations, and applies
     multiple animations on top of each other (layering).</p><p>See <a href="http://esotericsoftware.com/spine-applying-animations/">Applying Animations</a> in the Spine Runtimes Guide.</p>
     *
     * @public
     * @class Spine.AnimationState
     */
    Bridge.define("Spine.AnimationState", {
        statics: {
            fields: {
                /**
                 * @static
                 * @memberof Spine.AnimationState
                 * @constant
                 * @default 0
                 * @type number
                 */
                Subsequent: 0,
                /**
                 * @static
                 * @memberof Spine.AnimationState
                 * @constant
                 * @default 1
                 * @type number
                 */
                First: 0,
                
                HoldSubsequent: 0,
                /**
                 * @static
                 * @memberof Spine.AnimationState
                 * @constant
                 * @default 3
                 * @type number
                 */
                HoldFirst: 0,
                /**
                 * @static
                 * @memberof Spine.AnimationState
                 * @constant
                 * @default 4
                 * @type number
                 */
                HoldMix: 0,
                Setup: 0,
                Current: 0,
                EmptyAnimation: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#init", this ); }

                    this.Subsequent = 0;
                    this.First = 1;
                    this.HoldSubsequent = 2;
                    this.HoldFirst = 3;
                    this.HoldMix = 4;
                    this.Setup = 1;
                    this.Current = 2;
                    this.EmptyAnimation = new Spine.Animation("<empty>", new (Spine.ExposedList$1(Spine.Timeline)).ctor(), 0);
                }
            },
            methods: {
                /*Spine.AnimationState.ApplyRotateTimeline:static start.*/
                /**
                 * Applies the rotate timeline, mixing with the current pose while keeping the same rotation direction chosen as the shortest
                 the first time the mixing was applied.
                 *
                 * @static
                 * @private
                 * @this Spine.AnimationState
                 * @memberof Spine.AnimationState
                 * @param   {Spine.RotateTimeline}    timeline             
                 * @param   {Spine.Skeleton}          skeleton             
                 * @param   {number}                  time                 
                 * @param   {number}                  alpha                
                 * @param   {Spine.MixBlend}          blend                
                 * @param   {Array.<number>}          timelinesRotation    
                 * @param   {number}                  i                    
                 * @param   {boolean}                 firstFrame
                 * @return  {void}
                 */
                ApplyRotateTimeline: function (timeline, skeleton, time, alpha, blend, timelinesRotation, i, firstFrame) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ApplyRotateTimeline", this ); }

                    var $t;

                    if (firstFrame) {
                        timelinesRotation[i] = 0;
                    }

                    if (alpha === 1) {
                        timeline.Apply(skeleton, 0, time, null, 1, blend, Spine.MixDirection.In);
                        return;
                    }

                    var bone = ($t = skeleton.bones.Items)[timeline.boneIndex];
                    if (!bone.active) {
                        return;
                    }

                    var frames = timeline.frames;
                    var r1, r2;
                    if (time < frames[0]) { // Time is before first frame.
                        switch (blend) {
                            case Spine.MixBlend.Setup: 
                                bone.rotation = bone.data.rotation;
                                return;
                            default: 
                                return;
                            case Spine.MixBlend.First: 
                                r1 = bone.rotation;
                                r2 = bone.data.rotation;
                                break;
                        }
                    } else {
                        r1 = blend === Spine.MixBlend.Setup ? bone.data.rotation : bone.rotation;
                        if (time >= frames[((frames.length - Spine.RotateTimeline.ENTRIES) | 0)]) {
                            r2 = bone.data.rotation + frames[((frames.length + Spine.RotateTimeline.PREV_ROTATION) | 0)];
                        } else {
                            // Interpolate between the previous frame and the current frame.
                            var frame = Spine.Animation.BinarySearch$1(frames, time, Spine.RotateTimeline.ENTRIES);
                            var prevRotation = frames[((frame + Spine.RotateTimeline.PREV_ROTATION) | 0)];
                            var frameTime = frames[frame];
                            var percent = timeline.GetCurvePercent((((frame >> 1) - 1) | 0), 1 - (time - frameTime) / (frames[((frame + Spine.RotateTimeline.PREV_TIME) | 0)] - frameTime));

                            r2 = frames[((frame + Spine.RotateTimeline.ROTATION) | 0)] - prevRotation;
                            r2 -= Bridge.Int.mul((((16384 - Bridge.Int.clip32((16384.499999999996 - r2 / 360))) | 0)), 360);
                            r2 = prevRotation + r2 * percent + bone.data.rotation;
                            r2 -= Bridge.Int.mul((((16384 - Bridge.Int.clip32((16384.499999999996 - r2 / 360))) | 0)), 360);
                        }
                    }

                    // Mix between rotations using the direction of the shortest route on the first frame.
                    var total, diff = r2 - r1;
                    diff -= Bridge.Int.mul((((16384 - Bridge.Int.clip32((16384.499999999996 - diff / 360))) | 0)), 360);
                    if (diff === 0) {
                        total = timelinesRotation[i];
                    } else {
                        var lastTotal, lastDiff;
                        if (firstFrame) {
                            lastTotal = 0;
                            lastDiff = diff;
                        } else {
                            lastTotal = timelinesRotation[i]; // Angle and direction of mix, including loops.
                            lastDiff = timelinesRotation[((i + 1) | 0)]; // Difference between bones.
                        }
                        var current = diff > 0, dir = lastTotal >= 0;
                        // Detect cross at 0 (not 180).
                        if (Bridge.Int.sign(lastDiff) !== Bridge.Int.sign(diff) && Math.abs(lastDiff) <= 90) {
                            // A cross after a 360 rotation is a loop.
                            if (Math.abs(lastTotal) > 180) {
                                lastTotal += Bridge.Int.mul(360, Bridge.Int.sign(lastTotal));
                            }
                            dir = current;
                        }
                        total = diff + lastTotal - lastTotal % 360; // Store loops as part of lastTotal.
                        if (dir !== current) {
                            total += Bridge.Int.mul(360, Bridge.Int.sign(lastTotal));
                        }
                        timelinesRotation[i] = total;
                    }
                    timelinesRotation[((i + 1) | 0)] = diff;
                    r1 += total * alpha;
                    bone.rotation = r1 - Bridge.Int.mul((((16384 - Bridge.Int.clip32((16384.499999999996 - r1 / 360))) | 0)), 360);
                },
                /*Spine.AnimationState.ApplyRotateTimeline:static end.*/


            }
        },
        fields: {
            data: null,
            tracks: null,
            events: null,
            queue: null,
            propertyIDs: null,
            animationsChanged: false,
            timeScale: 0,
            unkeyedState: 0,
            trackEntryPool: null
        },
        events: {
            Start: null,
            Interrupt: null,
            End: null,
            Dispose: null,
            Complete: null,
            Event: null
        },
        props: {
            /**
             * <p>Multiplier for the delta time when the animation state is updated, causing time for all animations and mixes to play slower
             or faster. Defaults to 1.</p><p>See TrackEntry {@link } for affecting a single animation.</p>
             *
             * @instance
             * @public
             * @memberof Spine.AnimationState
             * @function TimeScale
             * @type number
             */
            TimeScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#TimeScale#get", this ); }

                    return this.timeScale;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.AnimationState#TimeScale#set", this ); }

                    this.timeScale = value;
                }
            },
            /**
             * The AnimationStateData to look up mix durations.
             *
             * @instance
             * @public
             * @memberof Spine.AnimationState
             * @function Data
             * @type Spine.AnimationStateData
             */
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#Data#get", this ); }

                    return this.data;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.AnimationState#Data#set", this ); }

                    if (this.data == null) {
                        throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                    }
                    this.data = value;
                }
            },
            /**
             * A list of tracks that have animations, which may contain nulls.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.AnimationState
             * @function Tracks
             * @type Spine.ExposedList$1
             */
            Tracks: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#Tracks#get", this ); }

                    return this.tracks;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#init", this ); }

                this.tracks = new (Spine.ExposedList$1(Spine.TrackEntry)).ctor();
                this.events = new (Spine.ExposedList$1(Spine.Event)).ctor();
                this.propertyIDs = new (System.Collections.Generic.HashSet$1(System.Int32)).ctor();
                this.timeScale = 1;
                this.trackEntryPool = new (Spine.Pool$1(Spine.TrackEntry))();
            },
            ctor: function (data) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ctor", this ); }

                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                this.data = data;
                this.queue = new Spine.EventQueue(this, Bridge.fn.bind(this, function () {
                    this.animationsChanged = true;
                }), this.trackEntryPool);
            }
        },
        methods: {
            /*Spine.AnimationState.OnStart start.*/
            OnStart: function (entry) {
if ( TRACE ) { TRACE( "Spine.AnimationState#OnStart", this ); }

                if (!Bridge.staticEquals(this.Start, null)) {
                    this.Start(entry);
                }
            },
            /*Spine.AnimationState.OnStart end.*/

            /*Spine.AnimationState.OnInterrupt start.*/
            OnInterrupt: function (entry) {
if ( TRACE ) { TRACE( "Spine.AnimationState#OnInterrupt", this ); }

                if (!Bridge.staticEquals(this.Interrupt, null)) {
                    this.Interrupt(entry);
                }
            },
            /*Spine.AnimationState.OnInterrupt end.*/

            /*Spine.AnimationState.OnEnd start.*/
            OnEnd: function (entry) {
if ( TRACE ) { TRACE( "Spine.AnimationState#OnEnd", this ); }

                if (!Bridge.staticEquals(this.End, null)) {
                    this.End(entry);
                }
            },
            /*Spine.AnimationState.OnEnd end.*/

            /*Spine.AnimationState.OnDispose start.*/
            OnDispose: function (entry) {
if ( TRACE ) { TRACE( "Spine.AnimationState#OnDispose", this ); }

                if (!Bridge.staticEquals(this.Dispose, null)) {
                    this.Dispose(entry);
                }
            },
            /*Spine.AnimationState.OnDispose end.*/

            /*Spine.AnimationState.OnComplete start.*/
            OnComplete: function (entry) {
if ( TRACE ) { TRACE( "Spine.AnimationState#OnComplete", this ); }

                if (!Bridge.staticEquals(this.Complete, null)) {
                    this.Complete(entry);
                }
            },
            /*Spine.AnimationState.OnComplete end.*/

            /*Spine.AnimationState.OnEvent start.*/
            OnEvent: function (entry, e) {
if ( TRACE ) { TRACE( "Spine.AnimationState#OnEvent", this ); }

                if (!Bridge.staticEquals(this.Event, null)) {
                    this.Event(entry, e);
                }
            },
            /*Spine.AnimationState.OnEvent end.*/

            /*Spine.AnimationState.AssignEventSubscribersFrom start.*/
            AssignEventSubscribersFrom: function (src) {
if ( TRACE ) { TRACE( "Spine.AnimationState#AssignEventSubscribersFrom", this ); }

                this.Event = src.Event;
                this.Start = src.Start;
                this.Interrupt = src.Interrupt;
                this.End = src.End;
                this.Dispose = src.Dispose;
                this.Complete = src.Complete;
            },
            /*Spine.AnimationState.AssignEventSubscribersFrom end.*/

            /*Spine.AnimationState.AddEventSubscribersFrom start.*/
            AddEventSubscribersFrom: function (src) {
if ( TRACE ) { TRACE( "Spine.AnimationState#AddEventSubscribersFrom", this ); }

                this.addEvent(src.Event);
                this.addStart(src.Start);
                this.addInterrupt(src.Interrupt);
                this.addEnd(src.End);
                this.addDispose(src.Dispose);
                this.addComplete(src.Complete);
            },
            /*Spine.AnimationState.AddEventSubscribersFrom end.*/

            /*Spine.AnimationState.Update start.*/
            /**
             * Increments the track entry {@link }, setting queued animations as current if needed.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}    delta    delta time
             * @return  {void}
             */
            Update: function (delta) {
if ( TRACE ) { TRACE( "Spine.AnimationState#Update", this ); }

                delta *= this.timeScale;
                var tracksItems = this.tracks.Items;
                for (var i = 0, n = this.tracks.Count; i < n; i = (i + 1) | 0) {
                    var current = tracksItems[i];
                    if (current == null) {
                        continue;
                    }

                    current.animationLast = current.nextAnimationLast;
                    current.trackLast = current.nextTrackLast;

                    var currentDelta = delta * current.timeScale;

                    if (current.delay > 0) {
                        current.delay -= currentDelta;
                        if (current.delay > 0) {
                            continue;
                        }
                        currentDelta = -current.delay;
                        current.delay = 0;
                    }

                    var next = current.next;
                    if (next != null) {
                        // When the next entry's delay is passed, change to the next entry, preserving leftover time.
                        var nextTime = current.trackLast - next.delay;
                        if (nextTime >= 0) {
                            next.delay = 0;
                            next.trackTime += current.timeScale === 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;
                            current.trackTime += currentDelta;
                            this.SetCurrent(i, next, true);
                            while (next.mixingFrom != null) {
                                next.mixTime += delta;
                                next = next.mixingFrom;
                            }
                            continue;
                        }
                    } else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {
                        // Clear the track when there is no next entry, the track end time is reached, and there is no mixingFrom.
                        tracksItems[i] = null;
                        this.queue.End(current);
                        this.DisposeNext(current);
                        continue;
                    }
                    if (current.mixingFrom != null && this.UpdateMixingFrom(current, delta)) {
                        // End mixing from entries once all have completed.
                        var from = current.mixingFrom;
                        current.mixingFrom = null;
                        if (from != null) {
                            from.mixingTo = null;
                        }
                        while (from != null) {
                            this.queue.End(from);
                            from = from.mixingFrom;
                        }
                    }

                    current.trackTime += currentDelta;
                }

                this.queue.Drain();
            },
            /*Spine.AnimationState.Update end.*/

            /*Spine.AnimationState.UpdateMixingFrom start.*/
            /**
             * Returns true when all mixing from entries are complete.
             *
             * @instance
             * @private
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {Spine.TrackEntry}    to       
             * @param   {number}              delta
             * @return  {boolean}
             */
            UpdateMixingFrom: function (to, delta) {
if ( TRACE ) { TRACE( "Spine.AnimationState#UpdateMixingFrom", this ); }

                var from = to.mixingFrom;
                if (from == null) {
                    return true;
                }

                var finished = this.UpdateMixingFrom(from, delta);

                from.animationLast = from.nextAnimationLast;
                from.trackLast = from.nextTrackLast;

                // Require mixTime > 0 to ensure the mixing from entry was applied at least once.
                if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {
                    // Require totalAlpha == 0 to ensure mixing is complete, unless mixDuration == 0 (the transition is a single frame).
                    if (from.totalAlpha === 0 || to.mixDuration === 0) {
                        to.mixingFrom = from.mixingFrom;
                        if (from.mixingFrom != null) {
                            from.mixingFrom.mixingTo = to;
                        }
                        to.interruptAlpha = from.interruptAlpha;
                        this.queue.End(from);
                    }
                    return finished;
                }

                from.trackTime += delta * from.timeScale;
                to.mixTime += delta;
                return false;
            },
            /*Spine.AnimationState.UpdateMixingFrom end.*/

            /*Spine.AnimationState.Apply start.*/
            /**
             * Poses the skeleton using the track entry animations.  The animation state is not changed, so can be applied to multiple
             skeletons to pose them identically.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {Spine.Skeleton}    skeleton
             * @return  {boolean}                       True if any animations were applied.
             */
            Apply: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.AnimationState#Apply", this ); }

                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                }
                if (this.animationsChanged) {
                    this.AnimationsChanged();
                }

                var events = this.events;
                var applied = false;
                var tracksItems = this.tracks.Items;
                for (var i = 0, n = this.tracks.Count; i < n; i = (i + 1) | 0) {
                    var current = tracksItems[i];
                    if (current == null || current.delay > 0) {
                        continue;
                    }
                    applied = true;

                    // Track 0 animations aren't for layering, so do not show the previously applied animations before the first key.
                    var blend = i === 0 ? Spine.MixBlend.First : current.mixBlend;

                    // Apply mixing from entries first.
                    var mix = current.alpha;
                    if (current.mixingFrom != null) {
                        mix *= this.ApplyMixingFrom(current, skeleton, blend);
                    } else {
                        if (current.trackTime >= current.trackEnd && current.next == null) {
                            mix = 0;
                        }
                    } // Set to setup pose the last time the entry will be applied.

                    // Apply current entry.
                    var animationLast = current.animationLast, animationTime = current.AnimationTime;
                    var timelineCount = current.animation.timelines.Count;
                    var timelines = current.animation.timelines;
                    var timelinesItems = timelines.Items;
                    if ((i === 0 && mix === 1) || blend === Spine.MixBlend.Add) {
                        for (var ii = 0; ii < timelineCount; ii = (ii + 1) | 0) {
                            var timeline = timelinesItems[ii];
                            if (Bridge.is(timeline, Spine.AttachmentTimeline)) {
                                this.ApplyAttachmentTimeline(Bridge.cast(timeline, Spine.AttachmentTimeline), skeleton, animationTime, blend, true);
                            } else {
                                timeline.Spine$Timeline$Apply(skeleton, animationLast, animationTime, events, mix, blend, Spine.MixDirection.In);
                            }
                        }
                    } else {
                        var timelineMode = current.timelineMode.Items;

                        var firstFrame = current.timelinesRotation.Count !== timelineCount << 1;
                        if (firstFrame) {
                            current.timelinesRotation.Resize(timelines.Count << 1);
                        }
                        var timelinesRotation = current.timelinesRotation.Items;

                        for (var ii1 = 0; ii1 < timelineCount; ii1 = (ii1 + 1) | 0) {
                            var timeline1 = timelinesItems[ii1];
                            var timelineBlend = timelineMode[ii1] === Spine.AnimationState.Subsequent ? blend : Spine.MixBlend.Setup;
                            var rotateTimeline = Bridge.as(timeline1, Spine.RotateTimeline);
                            if (rotateTimeline != null) {
                                Spine.AnimationState.ApplyRotateTimeline(rotateTimeline, skeleton, animationTime, mix, timelineBlend, timelinesRotation, ii1 << 1, firstFrame);
                            } else {
                                if (Bridge.is(timeline1, Spine.AttachmentTimeline)) {
                                    this.ApplyAttachmentTimeline(Bridge.cast(timeline1, Spine.AttachmentTimeline), skeleton, animationTime, blend, true);
                                } else {
                                    timeline1.Spine$Timeline$Apply(skeleton, animationLast, animationTime, events, mix, timelineBlend, Spine.MixDirection.In);
                                }
                            }
                        }
                    }
                    this.QueueEvents(current, animationTime);
                    events.Clear(false);
                    current.nextAnimationLast = animationTime;
                    current.nextTrackLast = current.trackTime;
                }

                // Set slots attachments to the setup pose, if needed. This occurs if an animation that is mixing out sets attachments so
                // subsequent timelines see any deform, but the subsequent timelines don't set an attachment (eg they are also mixing out or
                // the time is before the first key).
                var setupState = (this.unkeyedState + Spine.AnimationState.Setup) | 0;
                var slots = skeleton.slots.Items;
                for (var i1 = 0, n1 = skeleton.slots.Count; i1 < n1; i1 = (i1 + 1) | 0) {
                    var slot = slots[i1];
                    if (slot.attachmentState === setupState) {
                        var attachmentName = slot.data.attachmentName;
                        slot.Attachment = (attachmentName == null ? null : skeleton.GetAttachment(slot.data.index, attachmentName));
                    }
                }
                this.unkeyedState = (this.unkeyedState + 2) | 0; // Increasing after each use avoids the need to reset attachmentState for every slot.

                this.queue.Drain();
                return applied;
            },
            /*Spine.AnimationState.Apply end.*/

            /*Spine.AnimationState.ApplyEventTimelinesOnly start.*/
            /**
             * Version of {@link } only applying EventTimelines for lightweight off-screen updates.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {Spine.Skeleton}    skeleton
             * @return  {boolean}
             */
            ApplyEventTimelinesOnly: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ApplyEventTimelinesOnly", this ); }

                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                }

                var events = this.events;
                var applied = false;
                var tracksItems = this.tracks.Items;
                for (var i = 0, n = this.tracks.Count; i < n; i = (i + 1) | 0) {
                    var current = tracksItems[i];
                    if (current == null || current.delay > 0) {
                        continue;
                    }
                    applied = true;

                    // Apply mixing from entries first.
                    if (current.mixingFrom != null) {
                        this.ApplyMixingFromEventTimelinesOnly(current, skeleton);
                    }

                    // Apply current entry.
                    var animationLast = current.animationLast, animationTime = current.AnimationTime;
                    var timelineCount = current.animation.timelines.Count;
                    var timelines = current.animation.timelines;
                    var timelinesItems = timelines.Items;
                    for (var ii = 0; ii < timelineCount; ii = (ii + 1) | 0) {
                        var timeline = timelinesItems[ii];
                        if (Bridge.is(timeline, Spine.EventTimeline)) {
                            timeline.Spine$Timeline$Apply(skeleton, animationLast, animationTime, events, 1.0, Spine.MixBlend.Setup, Spine.MixDirection.In);
                        }
                    }
                    this.QueueEvents(current, animationTime);
                    events.Clear(false);
                    current.nextAnimationLast = animationTime;
                    current.nextTrackLast = current.trackTime;
                }

                this.queue.Drain();
                return applied;
            },
            /*Spine.AnimationState.ApplyEventTimelinesOnly end.*/

            /*Spine.AnimationState.ApplyMixingFrom start.*/
            ApplyMixingFrom: function (to, skeleton, blend) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ApplyMixingFrom", this ); }

                var from = to.mixingFrom;
                if (from.mixingFrom != null) {
                    this.ApplyMixingFrom(from, skeleton, blend);
                }

                var mix;
                if (to.mixDuration === 0) { // Single frame mix to undo mixingFrom changes.
                    mix = 1;
                    if (blend === Spine.MixBlend.First) {
                        blend = Spine.MixBlend.Setup;
                    } // Tracks > 0 are transparent and can't reset to setup pose.
                } else {
                    mix = to.mixTime / to.mixDuration;
                    if (mix > 1) {
                        mix = 1;
                    }
                    if (blend !== Spine.MixBlend.First) {
                        blend = from.mixBlend;
                    } // Track 0 ignores track mix blend.
                }

                var eventBuffer = mix < from.eventThreshold ? this.events : null;
                var attachments = mix < from.attachmentThreshold, drawOrder = mix < from.drawOrderThreshold;
                var animationLast = from.animationLast, animationTime = from.AnimationTime;
                var timelines = from.animation.timelines;
                var timelineCount = timelines.Count;
                var timelinesItems = timelines.Items;
                var alphaHold = from.alpha * to.interruptAlpha, alphaMix = alphaHold * (1 - mix);

                if (blend === Spine.MixBlend.Add) {
                    for (var i = 0; i < timelineCount; i = (i + 1) | 0) {
                        timelinesItems[i].Spine$Timeline$Apply(skeleton, animationLast, animationTime, eventBuffer, alphaMix, blend, Spine.MixDirection.Out);
                    }
                } else {
                    var timelineMode = from.timelineMode.Items;
                    var timelineHoldMix = from.timelineHoldMix.Items;

                    var firstFrame = from.timelinesRotation.Count !== timelineCount << 1;
                    if (firstFrame) {
                        from.timelinesRotation.Resize(timelines.Count << 1);
                    } // from.timelinesRotation.setSize
                    var timelinesRotation = from.timelinesRotation.Items;

                    from.totalAlpha = 0;
                    for (var i1 = 0; i1 < timelineCount; i1 = (i1 + 1) | 0) {
                        var timeline = timelinesItems[i1];
                        var direction = Spine.MixDirection.Out;
                        var timelineBlend = new Spine.MixBlend();
                        var alpha;
                        switch (timelineMode[i1]) {
                            case Spine.AnimationState.Subsequent: 
                                if (!drawOrder && Bridge.is(timeline, Spine.DrawOrderTimeline)) {
                                    continue;
                                }
                                timelineBlend = blend;
                                alpha = alphaMix;
                                break;
                            case Spine.AnimationState.First: 
                                timelineBlend = Spine.MixBlend.Setup;
                                alpha = alphaMix;
                                break;
                            case Spine.AnimationState.HoldSubsequent: 
                                timelineBlend = blend;
                                alpha = alphaHold;
                                break;
                            case Spine.AnimationState.HoldFirst: 
                                timelineBlend = Spine.MixBlend.Setup;
                                alpha = alphaHold;
                                break;
                            default:  // HoldMix
                                timelineBlend = Spine.MixBlend.Setup;
                                var holdMix = timelineHoldMix[i1];
                                alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);
                                break;
                        }
                        from.totalAlpha += alpha;
                        var rotateTimeline = Bridge.as(timeline, Spine.RotateTimeline);
                        if (rotateTimeline != null) {
                            Spine.AnimationState.ApplyRotateTimeline(rotateTimeline, skeleton, animationTime, alpha, timelineBlend, timelinesRotation, i1 << 1, firstFrame);
                        } else if (Bridge.is(timeline, Spine.AttachmentTimeline)) {
                            this.ApplyAttachmentTimeline(Bridge.cast(timeline, Spine.AttachmentTimeline), skeleton, animationTime, timelineBlend, attachments);
                        } else {
                            if (drawOrder && Bridge.is(timeline, Spine.DrawOrderTimeline) && timelineBlend === Spine.MixBlend.Setup) {
                                direction = Spine.MixDirection.In;
                            }
                            timeline.Spine$Timeline$Apply(skeleton, animationLast, animationTime, eventBuffer, alpha, timelineBlend, direction);
                        }
                    }
                }

                if (to.mixDuration > 0) {
                    this.QueueEvents(from, animationTime);
                }
                this.events.Clear(false);
                from.nextAnimationLast = animationTime;
                from.nextTrackLast = from.trackTime;

                return mix;
            },
            /*Spine.AnimationState.ApplyMixingFrom end.*/

            /*Spine.AnimationState.ApplyMixingFromEventTimelinesOnly start.*/
            /**
             * Version of {@link } only applying EventTimelines for lightweight off-screen updates.
             *
             * @instance
             * @private
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {Spine.TrackEntry}    to          
             * @param   {Spine.Skeleton}      skeleton
             * @return  {number}
             */
            ApplyMixingFromEventTimelinesOnly: function (to, skeleton) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ApplyMixingFromEventTimelinesOnly", this ); }

                var from = to.mixingFrom;
                if (from.mixingFrom != null) {
                    this.ApplyMixingFromEventTimelinesOnly(from, skeleton);
                }

                var mix;
                if (to.mixDuration === 0) { // Single frame mix to undo mixingFrom changes.
                    mix = 1;
                } else {
                    mix = to.mixTime / to.mixDuration;
                    if (mix > 1) {
                        mix = 1;
                    }
                }

                var eventBuffer = mix < from.eventThreshold ? this.events : null;
                if (eventBuffer == null) {
                    return mix;
                }

                var animationLast = from.animationLast, animationTime = from.AnimationTime;
                var timelines = from.animation.timelines;
                var timelineCount = timelines.Count;
                var timelinesItems = timelines.Items;
                for (var i = 0; i < timelineCount; i = (i + 1) | 0) {
                    var timeline = timelinesItems[i];
                    if (Bridge.is(timeline, Spine.EventTimeline)) {
                        timeline.Spine$Timeline$Apply(skeleton, animationLast, animationTime, eventBuffer, 0, Spine.MixBlend.Setup, Spine.MixDirection.Out);
                    }
                }

                if (to.mixDuration > 0) {
                    this.QueueEvents(from, animationTime);
                }
                this.events.Clear(false);
                from.nextAnimationLast = animationTime;
                from.nextTrackLast = from.trackTime;

                return mix;
            },
            /*Spine.AnimationState.ApplyMixingFromEventTimelinesOnly end.*/

            /*Spine.AnimationState.ApplyAttachmentTimeline start.*/
            
            ApplyAttachmentTimeline: function (timeline, skeleton, time, blend, attachments) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ApplyAttachmentTimeline", this ); }

                var $t;

                var slot = ($t = skeleton.slots.Items)[timeline.slotIndex];
                if (!slot.bone.active) {
                    return;
                }

                var frames = timeline.frames;
                if (time < frames[0]) { // Time is before first frame.
                    if (blend === Spine.MixBlend.Setup || blend === Spine.MixBlend.First) {
                        this.SetAttachment(skeleton, slot, slot.data.attachmentName, attachments);
                    }
                } else {
                    var frameIndex;
                    if (time >= frames[((frames.length - 1) | 0)]) {
                        frameIndex = (frames.length - 1) | 0;
                    } else {
                        frameIndex = (Spine.Animation.BinarySearch(frames, time) - 1) | 0;
                    }
                    this.SetAttachment(skeleton, slot, timeline.attachmentNames[frameIndex], attachments);
                }

                // If an attachment wasn't set (ie before the first frame or attachments is false), set the setup attachment later.
                if (slot.attachmentState <= this.unkeyedState) {
                    slot.attachmentState = (this.unkeyedState + Spine.AnimationState.Setup) | 0;
                }
            },
            /*Spine.AnimationState.ApplyAttachmentTimeline end.*/

            /*Spine.AnimationState.SetAttachment start.*/
            SetAttachment: function (skeleton, slot, attachmentName, attachments) {
if ( TRACE ) { TRACE( "Spine.AnimationState#SetAttachment", this ); }

                slot.Attachment = attachmentName == null ? null : skeleton.GetAttachment(slot.data.index, attachmentName);
                if (attachments) {
                    slot.attachmentState = (this.unkeyedState + Spine.AnimationState.Current) | 0;
                }
            },
            /*Spine.AnimationState.SetAttachment end.*/

            /*Spine.AnimationState.QueueEvents start.*/
            QueueEvents: function (entry, animationTime) {
if ( TRACE ) { TRACE( "Spine.AnimationState#QueueEvents", this ); }

                var animationStart = entry.animationStart, animationEnd = entry.animationEnd;
                var duration = animationEnd - animationStart;
                var trackLastWrapped = entry.trackLast % duration;

                // Queue events before complete.
                var events = this.events;
                var eventsItems = events.Items;
                var i = 0, n = events.Count;
                for (; i < n; i = (i + 1) | 0) {
                    var e = eventsItems[i];
                    if (e.time < trackLastWrapped) {
                        break;
                    }
                    if (e.time > animationEnd) {
                        continue;
                    } // Discard events outside animation start/end.
                    this.queue.Event(entry, e);
                }

                // Queue complete if completed a loop iteration or the animation.
                var complete = false;
                if (entry.loop) {
                    complete = duration === 0 || (trackLastWrapped > entry.trackTime % duration);
                } else {
                    complete = animationTime >= animationEnd && entry.animationLast < animationEnd;
                }
                if (complete) {
                    this.queue.Complete(entry);
                }

                // Queue events after complete.
                for (; i < n; i = (i + 1) | 0) {
                    var e1 = eventsItems[i];
                    if (e1.time < animationStart) {
                        continue;
                    } // Discard events outside animation start/end.
                    this.queue.Event(entry, eventsItems[i]);
                }
            },
            /*Spine.AnimationState.QueueEvents end.*/

            /*Spine.AnimationState.ClearTracks start.*/
            /**
             * <p>Removes all animations from all tracks, leaving skeletons in their current pose.</p><p>It may be desired to use {@link } to mix the skeletons back to the setup pose,
             rather than leaving them in their current pose.</p>
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @return  {void}
             */
            ClearTracks: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#ClearTracks", this ); }

                var oldDrainDisabled = this.queue.drainDisabled;
                this.queue.drainDisabled = true;
                for (var i = 0, n = this.tracks.Count; i < n; i = (i + 1) | 0) {
                    this.ClearTrack(i);
                }
                this.tracks.Clear();
                this.queue.drainDisabled = oldDrainDisabled;
                this.queue.Drain();
            },
            /*Spine.AnimationState.ClearTracks end.*/

            /*Spine.AnimationState.ClearTrack start.*/
            /**
             * <p>Removes all animations from the track, leaving skeletons in their current pose.</p><p>It may be desired to use {@link } to mix the skeletons back to the setup pose,
             rather than leaving them in their current pose.</p>
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}    trackIndex
             * @return  {void}
             */
            ClearTrack: function (trackIndex) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ClearTrack", this ); }

                var $t, $t1;
                if (trackIndex >= this.tracks.Count) {
                    return;
                }
                var current = ($t = this.tracks.Items)[trackIndex];
                if (current == null) {
                    return;
                }

                this.queue.End(current);

                this.DisposeNext(current);

                var entry = current;
                while (true) {
                    var from = entry.mixingFrom;
                    if (from == null) {
                        break;
                    }
                    this.queue.End(from);
                    entry.mixingFrom = null;
                    entry.mixingTo = null;
                    entry = from;
                }

                ($t1 = this.tracks.Items)[current.trackIndex] = null;

                this.queue.Drain();
            },
            /*Spine.AnimationState.ClearTrack end.*/

            /*Spine.AnimationState.SetCurrent start.*/
            /**
             * Sets the active TrackEntry for a given track number.
             *
             * @instance
             * @private
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}              index        
             * @param   {Spine.TrackEntry}    current      
             * @param   {boolean}             interrupt
             * @return  {void}
             */
            SetCurrent: function (index, current, interrupt) {
if ( TRACE ) { TRACE( "Spine.AnimationState#SetCurrent", this ); }

                var $t;
                var from = this.ExpandToIndex(index);
                ($t = this.tracks.Items)[index] = current;

                if (from != null) {
                    if (interrupt) {
                        this.queue.Interrupt(from);
                    }
                    current.mixingFrom = from;
                    from.mixingTo = current;
                    current.mixTime = 0;

                    // Store the interrupted mix percentage.
                    if (from.mixingFrom != null && from.mixDuration > 0) {
                        current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);
                    }

                    from.timelinesRotation.Clear(); // Reset rotation for mixing out, in case entry was mixed in.
                }

                this.queue.Start(current); // triggers AnimationsChanged
            },
            /*Spine.AnimationState.SetCurrent end.*/

            /*Spine.AnimationState.SetAnimation$1 start.*/
            /**
             * Sets an animation by name. <seealso cref="SetAnimation(int, Animation, bool)" />
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}              trackIndex       
             * @param   {string}              animationName    
             * @param   {boolean}             loop
             * @return  {Spine.TrackEntry}
             * @see {@link SetAnimation(int, Animation, bool)}
             */
            SetAnimation$1: function (trackIndex, animationName, loop) {
if ( TRACE ) { TRACE( "Spine.AnimationState#SetAnimation$1", this ); }

                var animation = this.data.skeletonData.FindAnimation(animationName);
                if (animation == null) {
                    throw new System.ArgumentException.$ctor3("Animation not found: " + (animationName || ""), "animationName");
                }
                return this.SetAnimation(trackIndex, animation, loop);
            },
            /*Spine.AnimationState.SetAnimation$1 end.*/

            /*Spine.AnimationState.SetAnimation start.*/
            /**
             * Sets the current animation for a track, discarding any queued animations. If the formerly current track entry was never
             applied to a skeleton, it is replaced (not mixed from).
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}              trackIndex    
             * @param   {Spine.Animation}     animation     
             * @param   {boolean}             loop          If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its
                      duration. In either case{@link } determines when the track is cleared.
             * @return  {Spine.TrackEntry}                  A track entry to allow further customization of animation playback. References to the track entry must not be kept
                      after the {@link } event occurs.
             */
            SetAnimation: function (trackIndex, animation, loop) {
if ( TRACE ) { TRACE( "Spine.AnimationState#SetAnimation", this ); }

                var $t;
                if (animation == null) {
                    throw new System.ArgumentNullException.$ctor3("animation", "animation cannot be null.");
                }
                var interrupt = true;
                var current = this.ExpandToIndex(trackIndex);
                if (current != null) {
                    if (current.nextTrackLast === -1) {
                        // Don't mix from an entry that was never applied.
                        ($t = this.tracks.Items)[trackIndex] = current.mixingFrom;
                        this.queue.Interrupt(current);
                        this.queue.End(current);
                        this.DisposeNext(current);
                        current = current.mixingFrom;
                        interrupt = false; // mixingFrom is current again, but don't interrupt it twice.
                    } else {
                        this.DisposeNext(current);
                    }
                }
                var entry = this.NewTrackEntry(trackIndex, animation, loop, current);
                this.SetCurrent(trackIndex, entry, interrupt);
                this.queue.Drain();
                return entry;
            },
            /*Spine.AnimationState.SetAnimation end.*/

            /*Spine.AnimationState.AddAnimation$1 start.*/
            /**
             * Queues an animation by name.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}              trackIndex       
             * @param   {string}              animationName    
             * @param   {boolean}             loop             
             * @param   {number}              delay
             * @return  {Spine.TrackEntry}
             * @see {@link AddAnimation(int, Animation, bool, float)}
             */
            AddAnimation$1: function (trackIndex, animationName, loop, delay) {
if ( TRACE ) { TRACE( "Spine.AnimationState#AddAnimation$1", this ); }

                var animation = this.data.skeletonData.FindAnimation(animationName);
                if (animation == null) {
                    throw new System.ArgumentException.$ctor3("Animation not found: " + (animationName || ""), "animationName");
                }
                return this.AddAnimation(trackIndex, animation, loop, delay);
            },
            /*Spine.AnimationState.AddAnimation$1 end.*/

            /*Spine.AnimationState.AddAnimation start.*/
            /**
             * Adds an animation to be played after the current or last queued animation for a track. If the track is empty, it is
             equivalent to calling {@link }.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}              trackIndex    
             * @param   {Spine.Animation}     animation     
             * @param   {boolean}             loop          
             * @param   {number}              delay         If &gt; 0, sets {@link }. If &lt;= 0, the delay set is the duration of the previous track entry
             minus any mix duration (from the {@link AnimationStateData}) plus the specified <pre><code>Delay</code></pre> (ie the mix
             ends at (<pre><code>Delay</code></pre> = 0) or before (<pre><code>Delay</code></pre> &lt; 0) the previous track entry duration). If the
             previous entry is looping, its next loop completion is used instead of its duration.
             * @return  {Spine.TrackEntry}                  A track entry to allow further customization of animation playback. References to the track entry must not be kept
             after the {@link } event occurs.
             */
            AddAnimation: function (trackIndex, animation, loop, delay) {
if ( TRACE ) { TRACE( "Spine.AnimationState#AddAnimation", this ); }

                if (animation == null) {
                    throw new System.ArgumentNullException.$ctor3("animation", "animation cannot be null.");
                }

                var last = this.ExpandToIndex(trackIndex);
                if (last != null) {
                    while (last.next != null) {
                        last = last.next;
                    }
                }

                var entry = this.NewTrackEntry(trackIndex, animation, loop, last);

                if (last == null) {
                    this.SetCurrent(trackIndex, entry, true);
                    this.queue.Drain();
                } else {
                    last.next = entry;
                    if (delay <= 0) {
                        var duration = last.animationEnd - last.animationStart;
                        if (duration !== 0) {
                            if (last.loop) {
                                delay += duration * (((1 + Bridge.Int.clip32((last.trackTime / duration))) | 0)); // Completion of next loop.
                            } else {
                                delay += Math.max(duration, last.trackTime); // After duration, else next update.
                            }
                            delay -= this.data.GetMix(last.animation, animation);
                        } else {
                            delay = last.trackTime;
                        } // Next update.
                    }
                }

                entry.delay = delay;
                return entry;
            },
            /*Spine.AnimationState.AddAnimation end.*/

            /*Spine.AnimationState.SetEmptyAnimation start.*/
            /**
             * <p>Sets an empty animation for a track, discarding any queued animations, and sets the track entry's
             {@link }. An empty animation has no timelines and serves as a placeholder for mixing in or out.</p><p>Mixing out is done by setting an empty animation with a mix duration using either {@link },
             {@link }, or {@link }. Mixing to an empty animation causes
             the previous animation to be applied less and less over the mix duration. Properties keyed in the previous animation
             transition to the value from lower tracks or to the setup pose value if no lower tracks key the property. A mix duration of
             0 still mixes out over one frame.</p><p>Mixing in is done by first setting an empty animation, then adding an animation using
             {@link } and on the returned track entry, set the
             {@link }. Mixing from an empty animation causes the new animation to be applied more and
             more over the mix duration. Properties keyed in the new animation transition from the value from lower tracks or from the
             setup pose value if no lower tracks key the property to the value keyed in the new animation.</p>
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}              trackIndex     
             * @param   {number}              mixDuration
             * @return  {Spine.TrackEntry}
             */
            SetEmptyAnimation: function (trackIndex, mixDuration) {
if ( TRACE ) { TRACE( "Spine.AnimationState#SetEmptyAnimation", this ); }

                var entry = this.SetAnimation(trackIndex, Spine.AnimationState.EmptyAnimation, false);
                entry.mixDuration = mixDuration;
                entry.trackEnd = mixDuration;
                return entry;
            },
            /*Spine.AnimationState.SetEmptyAnimation end.*/

            /*Spine.AnimationState.AddEmptyAnimation start.*/
            /**
             * Adds an empty animation to be played after the current or last queued animation for a track, and sets the track entry's
             {@link }. If the track is empty, it is equivalent to calling
             {@link }.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}              trackIndex     Track number.
             * @param   {number}              mixDuration    Mix duration.
             * @param   {number}              delay          If &gt; 0, sets {@link }. If &lt;= 0, the delay set is the duration of the previous track entry
             minus any mix duration plus the specified <pre><code>Delay</code></pre> (ie the mix ends at (<pre><code>Delay</code></pre> = 0) or
             before (<pre><code>Delay</code></pre> &lt; 0) the previous track entry duration). If the previous entry is looping, its next
             loop completion is used instead of its duration.
             * @return  {Spine.TrackEntry}                   A track entry to allow further customization of animation playback. References to the track entry must not be kept
             after the {@link } event occurs.
             * @see {@link AnimationState.SetEmptyAnimation(int, float)}
             */
            AddEmptyAnimation: function (trackIndex, mixDuration, delay) {
if ( TRACE ) { TRACE( "Spine.AnimationState#AddEmptyAnimation", this ); }

                if (delay <= 0) {
                    delay -= mixDuration;
                }
                var entry = this.AddAnimation(trackIndex, Spine.AnimationState.EmptyAnimation, false, delay);
                entry.mixDuration = mixDuration;
                entry.trackEnd = mixDuration;
                return entry;
            },
            /*Spine.AnimationState.AddEmptyAnimation end.*/

            /*Spine.AnimationState.SetEmptyAnimations start.*/
            /**
             * Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix
             duration.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}    mixDuration
             * @return  {void}
             */
            SetEmptyAnimations: function (mixDuration) {
if ( TRACE ) { TRACE( "Spine.AnimationState#SetEmptyAnimations", this ); }

                var $t;
                var oldDrainDisabled = this.queue.drainDisabled;
                this.queue.drainDisabled = true;
                for (var i = 0, n = this.tracks.Count; i < n; i = (i + 1) | 0) {
                    var current = ($t = this.tracks.Items)[i];
                    if (current != null) {
                        this.SetEmptyAnimation(current.trackIndex, mixDuration);
                    }
                }
                this.queue.drainDisabled = oldDrainDisabled;
                this.queue.Drain();
            },
            /*Spine.AnimationState.SetEmptyAnimations end.*/

            /*Spine.AnimationState.ExpandToIndex start.*/
            ExpandToIndex: function (index) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ExpandToIndex", this ); }

                var $t;
                if (index < this.tracks.Count) {
                    return ($t = this.tracks.Items)[index];
                }
                this.tracks.Resize(((index + 1) | 0));
                return null;
            },
            /*Spine.AnimationState.ExpandToIndex end.*/

            /*Spine.AnimationState.NewTrackEntry start.*/
            /**
             * Object-pooling version of new TrackEntry. Obtain an unused TrackEntry from the pool and clear/initialize its values.
             *
             * @instance
             * @private
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}              trackIndex    
             * @param   {Spine.Animation}     animation     
             * @param   {boolean}             loop          
             * @param   {Spine.TrackEntry}    last          May be null.
             * @return  {Spine.TrackEntry}
             */
            NewTrackEntry: function (trackIndex, animation, loop, last) {
if ( TRACE ) { TRACE( "Spine.AnimationState#NewTrackEntry", this ); }

                var entry = this.trackEntryPool.Obtain(); // Pooling
                entry.trackIndex = trackIndex;
                entry.animation = animation;
                entry.loop = loop;
                entry.holdPrevious = false;

                entry.eventThreshold = 0;
                entry.attachmentThreshold = 0;
                entry.drawOrderThreshold = 0;

                entry.animationStart = 0;
                entry.animationEnd = animation.Duration;
                entry.animationLast = -1;
                entry.nextAnimationLast = -1;

                entry.delay = 0;
                entry.trackTime = 0;
                entry.trackLast = -1;
                entry.nextTrackLast = -1; // nextTrackLast == -1 signifies a TrackEntry that wasn't applied yet.
                entry.trackEnd = 3.40282347E+38; // loop ? float.MaxValue : animation.Duration;
                entry.timeScale = 1;

                entry.alpha = 1;
                entry.interruptAlpha = 1;
                entry.mixTime = 0;
                entry.mixDuration = (last == null) ? 0 : this.data.GetMix(last.animation, animation);
                return entry;
            },
            /*Spine.AnimationState.NewTrackEntry end.*/

            /*Spine.AnimationState.DisposeNext start.*/
            /**
             * Dispose all track entries queued after the given TrackEntry.
             *
             * @instance
             * @private
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {Spine.TrackEntry}    entry
             * @return  {void}
             */
            DisposeNext: function (entry) {
if ( TRACE ) { TRACE( "Spine.AnimationState#DisposeNext", this ); }

                var next = entry.next;
                while (next != null) {
                    this.queue.Dispose(next);
                    next = next.next;
                }
                entry.next = null;
            },
            /*Spine.AnimationState.DisposeNext end.*/

            /*Spine.AnimationState.AnimationsChanged start.*/
            AnimationsChanged: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#AnimationsChanged", this ); }

                this.animationsChanged = false;

                // Process in the order that animations are applied.
                this.propertyIDs.clear();

                var tracksItems = this.tracks.Items;
                for (var i = 0, n = this.tracks.Count; i < n; i = (i + 1) | 0) {
                    var entry = tracksItems[i];
                    if (entry == null) {
                        continue;
                    }
                    while (entry.mixingFrom != null) {
                        entry = entry.mixingFrom;
                    }

                    do {
                        if (entry.mixingTo == null || entry.mixBlend !== Spine.MixBlend.Add) {
                            this.ComputeHold(entry);
                        }
                        entry = entry.mixingTo;
                    } while (entry != null);
                }
            },
            /*Spine.AnimationState.AnimationsChanged end.*/

            /*Spine.AnimationState.ComputeHold start.*/
            ComputeHold: function (entry) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ComputeHold", this ); }

                var $step = 0,
                    $jumpFromFinally, 
                    to, 
                    timelines, 
                    timelinesCount, 
                    timelineMode, 
                    timelineHoldMix, 
                    propertyIDs, 
                    i1, 
                    timeline, 
                    id, 
                    next, 
                    $asyncBody = Bridge.fn.bind(this, function () {
                        for (;;) {
                            $step = System.Array.min([0,1,2,3,4,5,6,7,8,9,10,11,12,14,16,17], $step);
                            switch ($step) {
                                case 0: {
                                    to = entry.mixingTo;
                                    timelines = entry.animation.timelines.Items;
                                    timelinesCount = entry.animation.timelines.Count;
                                    timelineMode = entry.timelineMode.Resize(timelinesCount).Items; //timelineMode.setSize(timelinesCount);
                                    entry.timelineHoldMix.Clear();
                                    timelineHoldMix = entry.timelineHoldMix.Resize(timelinesCount).Items; //timelineHoldMix.setSize(timelinesCount);
                                    propertyIDs = this.propertyIDs;

                                    if (to != null && to.holdPrevious) {
                                        for (var i = 0; i < timelinesCount; i = (i + 1) | 0) {
                                            timelineMode[i] = propertyIDs.add(timelines[i].Spine$Timeline$PropertyId) ? Spine.AnimationState.HoldFirst : Spine.AnimationState.HoldSubsequent;
                                        }

                                        return;
                                    }

                                    // outer:
                                    i1 = 0;
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( i1 < timelinesCount ) {
                                        $step = 2;
                                        continue;
                                    }
                                    $step = 17;
                                    continue;
                                }
                                case 2: {
                                    timeline = timelines[i1];
                                    id = timeline.Spine$Timeline$PropertyId;
                                    if (!propertyIDs.add(id)) {
                                        $step = 3;
                                        continue;
                                    } else  {
                                        $step = 4;
                                        continue;
                                    }
                                }
                                case 3: {
                                    timelineMode[i1] = Spine.AnimationState.Subsequent;
                                    $step = 14;
                                    continue;
                                }
                                case 4: {
                                    if (to == null || Bridge.is(timeline, Spine.AttachmentTimeline) || Bridge.is(timeline, Spine.DrawOrderTimeline) || Bridge.is(timeline, Spine.EventTimeline) || !to.animation.HasTimeline(id)) {
                                        $step = 5;
                                        continue;
                                    } else  {
                                        $step = 6;
                                        continue;
                                    }
                                }
                                case 5: {
                                    timelineMode[i1] = Spine.AnimationState.First;
                                    $step = 13;
                                    continue;
                                }
                                case 6: {
                                    next = to.mixingTo;
                                    $step = 7;
                                    continue;
                                }
                                case 7: {
                                    if ( next != null ) {
                                        $step = 8;
                                        continue;
                                    }
                                    $step = 12;
                                    continue;
                                }
                                case 8: {
                                    if (next.animation.HasTimeline(id)) {
                                        $step = 11;
                                        continue;
                                    }
                                    if (next.mixDuration > 0) {
                                        $step = 9;
                                        continue;
                                    } 
                                    $step = 10;
                                    continue;
                                }
                                case 9: {
                                    timelineMode[i1] = Spine.AnimationState.HoldMix;
                                    timelineHoldMix[i1] = next;
                                    $step = 15;
                                    continue;// continue outer;
                                    $step = 10;
                                    continue;
                                }
                                case 10: {
                                    $step = 12;
                                    continue;
                                }
                                case 11: {
                                    next = next.mixingTo;
                                    $step = 7;
                                    continue;
                                }
                                case 12: {
                                    timelineMode[i1] = Spine.AnimationState.HoldFirst;
                                    $step = 13;
                                    continue;
                                }

                                case 14: {

                                }

                                case 16: {
                                    i1 = (i1 + 1) | 0;
                                    $step = 1;
                                    continue;
                                }
                                case 17: {
                                    return;
                                }
                                default: {
                                    return;
                                }
                            }
                        }
                    }, arguments);

                return $asyncBody();
            },
            /*Spine.AnimationState.ComputeHold end.*/

            /*Spine.AnimationState.GetCurrent start.*/
            /**
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}              trackIndex
             * @return  {Spine.TrackEntry}                  The track entry for the animation currently playing on the track, or null if no animation is currently playing.
             */
            GetCurrent: function (trackIndex) {
if ( TRACE ) { TRACE( "Spine.AnimationState#GetCurrent", this ); }

                var $t;
                if (trackIndex >= this.tracks.Count) {
                    return null;
                }
                return ($t = this.tracks.Items)[trackIndex];
            },
            /*Spine.AnimationState.GetCurrent end.*/

            /*Spine.AnimationState.ClearListenerNotifications start.*/
            
            ClearListenerNotifications: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#ClearListenerNotifications", this ); }

                this.queue.Clear();
            },
            /*Spine.AnimationState.ClearListenerNotifications end.*/

            /*Spine.AnimationState.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#toString", this ); }

                var $t;
                var buffer = new System.Text.StringBuilder();
                for (var i = 0, n = this.tracks.Count; i < n; i = (i + 1) | 0) {
                    var entry = ($t = this.tracks.Items)[i];
                    if (entry == null) {
                        continue;
                    }
                    if (buffer.getLength() > 0) {
                        buffer.append(", ");
                    }
                    buffer.append(entry.toString());
                }
                if (buffer.getLength() === 0) {
                    return "<none>";
                }
                return buffer.toString();
            },
            /*Spine.AnimationState.toString end.*/


        },
        overloads: {
            "SetAnimation(int, string, bool)": "SetAnimation$1",
            "AddAnimation(int, string, bool, float)": "AddAnimation$1",
            "ToString()": "toString"
        }
    });
    /*Spine.AnimationState end.*/

    /*Spine.AnimationStateData start.*/
    /**
     * Stores mix (crossfade) durations to be applied when AnimationState animations are changed.
     *
     * @public
     * @class Spine.AnimationStateData
     */
    Bridge.define("Spine.AnimationStateData", {
        fields: {
            skeletonData: null,
            animationToMixTime: null,
            defaultMix: 0
        },
        props: {
            /**
             * The SkeletonData to look up animations when they are specified by name.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.AnimationStateData
             * @function SkeletonData
             * @type Spine.SkeletonData
             */
            SkeletonData: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AnimationStateData#SkeletonData#get", this ); }

                    return this.skeletonData;
                }
            },
            /**
             * The mix duration to use when no mix duration has been specifically defined between two animations.
             *
             * @instance
             * @public
             * @memberof Spine.AnimationStateData
             * @function DefaultMix
             * @type number
             */
            DefaultMix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AnimationStateData#DefaultMix#get", this ); }

                    return this.defaultMix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData#DefaultMix#set", this ); }

                    this.defaultMix = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.AnimationStateData#init", this ); }

                this.animationToMixTime = new (System.Collections.Generic.Dictionary$2(Spine.AnimationStateData.AnimationPair,System.Single)).$ctor3(Spine.AnimationStateData.AnimationPairComparer.Instance);
            },
            ctor: function (skeletonData) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData#ctor", this ); }

                this.$initialize();
                if (skeletonData == null) {
                    throw new System.ArgumentException.$ctor3("skeletonData cannot be null.", "skeletonData");
                }
                this.skeletonData = skeletonData;
            }
        },
        methods: {
            /*Spine.AnimationStateData.SetMix$1 start.*/
            /**
             * Sets a mix duration by animation names.
             *
             * @instance
             * @public
             * @this Spine.AnimationStateData
             * @memberof Spine.AnimationStateData
             * @param   {string}    fromName    
             * @param   {string}    toName      
             * @param   {number}    duration
             * @return  {void}
             */
            SetMix$1: function (fromName, toName, duration) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData#SetMix$1", this ); }

                var from = this.skeletonData.FindAnimation(fromName);
                if (from == null) {
                    throw new System.ArgumentException.$ctor3("Animation not found: " + (fromName || ""), "fromName");
                }
                var to = this.skeletonData.FindAnimation(toName);
                if (to == null) {
                    throw new System.ArgumentException.$ctor3("Animation not found: " + (toName || ""), "toName");
                }
                this.SetMix(from, to, duration);
            },
            /*Spine.AnimationStateData.SetMix$1 end.*/

            /*Spine.AnimationStateData.SetMix start.*/
            /**
             * Sets a mix duration when changing from the specified animation to the other.
             See TrackEntry.MixDuration.
             *
             * @instance
             * @public
             * @this Spine.AnimationStateData
             * @memberof Spine.AnimationStateData
             * @param   {Spine.Animation}    from        
             * @param   {Spine.Animation}    to          
             * @param   {number}             duration
             * @return  {void}
             */
            SetMix: function (from, to, duration) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData#SetMix", this ); }

                if (from == null) {
                    throw new System.ArgumentNullException.$ctor3("from", "from cannot be null.");
                }
                if (to == null) {
                    throw new System.ArgumentNullException.$ctor3("to", "to cannot be null.");
                }
                var key = new Spine.AnimationStateData.AnimationPair.$ctor1(from, to);
                this.animationToMixTime.remove(key);
                this.animationToMixTime.add(key, duration);
            },
            /*Spine.AnimationStateData.SetMix end.*/

            /*Spine.AnimationStateData.GetMix start.*/
            /**
             * The mix duration to use when changing from the specified animation to the other,
             or the DefaultMix if no mix duration has been set.
             *
             * @instance
             * @public
             * @this Spine.AnimationStateData
             * @memberof Spine.AnimationStateData
             * @param   {Spine.Animation}    from    
             * @param   {Spine.Animation}    to
             * @return  {number}
             */
            GetMix: function (from, to) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData#GetMix", this ); }

                if (from == null) {
                    throw new System.ArgumentNullException.$ctor3("from", "from cannot be null.");
                }
                if (to == null) {
                    throw new System.ArgumentNullException.$ctor3("to", "to cannot be null.");
                }
                var key = new Spine.AnimationStateData.AnimationPair.$ctor1(from, to);
                var duration = { };
                if (this.animationToMixTime.tryGetValue(key, duration)) {
                    return duration.v;
                }
                return this.defaultMix;
            },
            /*Spine.AnimationStateData.GetMix end.*/


        },
        overloads: {
            "SetMix(string, string, float)": "SetMix$1"
        }
    });
    /*Spine.AnimationStateData end.*/

    /*Spine.AnimationStateData+AnimationPair start.*/
    Bridge.define("Spine.AnimationStateData.AnimationPair", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPair#getDefaultValue", this ); }
 return new Spine.AnimationStateData.AnimationPair(); }
            }
        },
        fields: {
            a1: null,
            a2: null
        },
        ctors: {
            $ctor1: function (a1, a2) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPair#$ctor1", this ); }

                this.$initialize();
                this.a1 = a1;
                this.a2 = a2;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPair#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.AnimationStateData+AnimationPair.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPair#toString", this ); }

                return (this.a1.name || "") + "->" + (this.a2.name || "");
            },
            /*Spine.AnimationStateData+AnimationPair.toString end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPair#getHashCode", this ); }

                var h = Bridge.addHash([5472793474, this.a1, this.a2]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPair#equals", this ); }

                if (!Bridge.is(o, Spine.AnimationStateData.AnimationPair)) {
                    return false;
                }
                return Bridge.equals(this.a1, o.a1) && Bridge.equals(this.a2, o.a2);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPair#$clone", this ); }

                var s = to || new Spine.AnimationStateData.AnimationPair();
                s.a1 = this.a1;
                s.a2 = this.a2;
                return s;
            }
        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.AnimationStateData+AnimationPair end.*/

    /*Spine.AtlasRegion start.*/
    Bridge.define("Spine.AtlasRegion", {
        fields: {
            page: null,
            name: null,
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            u: 0,
            v: 0,
            u2: 0,
            v2: 0,
            offsetX: 0,
            offsetY: 0,
            originalWidth: 0,
            originalHeight: 0,
            index: 0,
            rotate: false,
            degrees: 0,
            splits: null,
            pads: null
        },
        methods: {
            /*Spine.AtlasRegion.Clone start.*/
            Clone: function () {
if ( TRACE ) { TRACE( "Spine.AtlasRegion#Clone", this ); }

                return Bridge.as(Bridge.clone(this), Spine.AtlasRegion);
            },
            /*Spine.AtlasRegion.Clone end.*/


        }
    });
    /*Spine.AtlasRegion end.*/

    /*Spine.AttachmentLoader start.*/
    Bridge.define("Spine.AttachmentLoader", {
        $kind: 3
    });
    /*Spine.AttachmentLoader end.*/

    /*Spine.AtlasPage start.*/
    Bridge.define("Spine.AtlasPage", {
        fields: {
            name: null,
            format: 0,
            minFilter: 0,
            magFilter: 0,
            uWrap: 0,
            vWrap: 0,
            rendererObject: null,
            width: 0,
            height: 0
        },
        methods: {
            /*Spine.AtlasPage.Clone start.*/
            Clone: function () {
if ( TRACE ) { TRACE( "Spine.AtlasPage#Clone", this ); }

                return Bridge.as(Bridge.clone(this), Spine.AtlasPage);
            },
            /*Spine.AtlasPage.Clone end.*/


        }
    });
    /*Spine.AtlasPage end.*/

    /*Spine.Attachment start.*/
    Bridge.define("Spine.Attachment", {
        fields: {
            Name: null
        },
        ctors: {
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.Attachment#ctor", this ); }

                this.$initialize();
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor3("name", "name cannot be null");
                }
                this.Name = name;
            }
        },
        methods: {
            /*Spine.Attachment.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Attachment#toString", this ); }

                return this.Name;
            },
            /*Spine.Attachment.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.Attachment end.*/

    /*Spine.ISlotTimeline start.*/
    /**
     * An interface for timelines which change the property of a slot.
     *
     * @abstract
     * @public
     * @class Spine.ISlotTimeline
     */
    Bridge.define("Spine.ISlotTimeline", {
        $kind: 3
    });
    /*Spine.ISlotTimeline end.*/

    /*Spine.Timeline start.*/
    /**
     * The interface for all timelines.
     *
     * @abstract
     * @public
     * @class Spine.Timeline
     */
    Bridge.define("Spine.Timeline", {
        $kind: 3
    });
    /*Spine.Timeline end.*/

    /*Spine.AttachmentType start.*/
    Bridge.define("Spine.AttachmentType", {
        $kind: 6,
        statics: {
            fields: {
                Region: 0,
                Boundingbox: 1,
                Mesh: 2,
                Linkedmesh: 3,
                Path: 4,
                Point: 5,
                Clipping: 6
            }
        }
    });
    /*Spine.AttachmentType end.*/

    /*Spine.BlendMode start.*/
    Bridge.define("Spine.BlendMode", {
        $kind: 6,
        statics: {
            fields: {
                Normal: 0,
                Additive: 1,
                Multiply: 2,
                Screen: 3
            }
        }
    });
    /*Spine.BlendMode end.*/

    /*Spine.IUpdatable start.*/
    /**
     * The interface for items updated by {@link }.
     *
     * @abstract
     * @public
     * @class Spine.IUpdatable
     */
    Bridge.define("Spine.IUpdatable", {
        $kind: 3
    });
    /*Spine.IUpdatable end.*/

    /*Spine.BoneData start.*/
    Bridge.define("Spine.BoneData", {
        fields: {
            index: 0,
            name: null,
            parent: null,
            length: 0,
            x: 0,
            y: 0,
            rotation: 0,
            scaleX: 0,
            scaleY: 0,
            shearX: 0,
            shearY: 0,
            transformMode: 0,
            skinRequired: false
        },
        props: {
            /**
             * The index of the bone in Skeleton.Bones
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.BoneData
             * @function Index
             * @type number
             */
            Index: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#Index#get", this ); }

                    return this.index;
                }
            },
            /**
             * The name of the bone, which is unique across all bones in the skeleton.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.BoneData
             * @function Name
             * @type string
             */
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#Name#get", this ); }

                    return this.name;
                }
            },
            /**
             * May be null.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.BoneData
             * @function Parent
             * @type Spine.BoneData
             */
            Parent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#Parent#get", this ); }

                    return this.parent;
                }
            },
            Length: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#Length#get", this ); }

                    return this.length;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#Length#set", this ); }

                    this.length = value;
                }
            },
            /**
             * Local X translation.
             *
             * @instance
             * @public
             * @memberof Spine.BoneData
             * @function X
             * @type number
             */
            X: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#X#get", this ); }

                    return this.x;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#X#set", this ); }

                    this.x = value;
                }
            },
            /**
             * Local Y translation.
             *
             * @instance
             * @public
             * @memberof Spine.BoneData
             * @function Y
             * @type number
             */
            Y: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#Y#get", this ); }

                    return this.y;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#Y#set", this ); }

                    this.y = value;
                }
            },
            /**
             * Local rotation.
             *
             * @instance
             * @public
             * @memberof Spine.BoneData
             * @function Rotation
             * @type number
             */
            Rotation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#Rotation#get", this ); }

                    return this.rotation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#Rotation#set", this ); }

                    this.rotation = value;
                }
            },
            /**
             * Local scaleX.
             *
             * @instance
             * @public
             * @memberof Spine.BoneData
             * @function ScaleX
             * @type number
             */
            ScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#ScaleX#get", this ); }

                    return this.scaleX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#ScaleX#set", this ); }

                    this.scaleX = value;
                }
            },
            /**
             * Local scaleY.
             *
             * @instance
             * @public
             * @memberof Spine.BoneData
             * @function ScaleY
             * @type number
             */
            ScaleY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#ScaleY#get", this ); }

                    return this.scaleY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#ScaleY#set", this ); }

                    this.scaleY = value;
                }
            },
            /**
             * Local shearX.
             *
             * @instance
             * @public
             * @memberof Spine.BoneData
             * @function ShearX
             * @type number
             */
            ShearX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#ShearX#get", this ); }

                    return this.shearX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#ShearX#set", this ); }

                    this.shearX = value;
                }
            },
            /**
             * Local shearY.
             *
             * @instance
             * @public
             * @memberof Spine.BoneData
             * @function ShearY
             * @type number
             */
            ShearY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#ShearY#get", this ); }

                    return this.shearY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#ShearY#set", this ); }

                    this.shearY = value;
                }
            },
            /**
             * The transform mode for how parent world transforms affect this bone.
             *
             * @instance
             * @public
             * @memberof Spine.BoneData
             * @function TransformMode
             * @type Spine.TransformMode
             */
            TransformMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#TransformMode#get", this ); }

                    return this.transformMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#TransformMode#set", this ); }

                    this.transformMode = value;
                }
            },
            /**
             * When true, {@link } only updates this bone if the {@link } contains this
             bone.
             *
             * @instance
             * @public
             * @memberof Spine.BoneData
             * @function SkinRequired
             * @type boolean
             * @see {@link Skin.Bones}
             */
            SkinRequired: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#SkinRequired#get", this ); }

                    return this.skinRequired;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#SkinRequired#set", this ); }

                    this.skinRequired = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#init", this ); }

                this.scaleX = 1;
                this.scaleY = 1;
                this.transformMode = Spine.TransformMode.Normal;
            },
            /**
             * @instance
             * @public
             * @this Spine.BoneData
             * @memberof Spine.BoneData
             * @param   {number}            index     
             * @param   {string}            name      
             * @param   {Spine.BoneData}    parent    May be null.
             * @return  {void}
             */
            ctor: function (index, name, parent) {
if ( TRACE ) { TRACE( "Spine.BoneData#ctor", this ); }

                this.$initialize();
                if (index < 0) {
                    throw new System.ArgumentException.$ctor3("index must be >= 0", "index");
                }
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor3("name", "name cannot be null.");
                }
                this.index = index;
                this.name = name;
                this.parent = parent;
            }
        },
        methods: {
            /*Spine.BoneData.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#toString", this ); }

                return this.name;
            },
            /*Spine.BoneData.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.BoneData end.*/

    /*Spine.BoneMatrix start.*/
    Bridge.define("Spine.BoneMatrix", {
        $kind: 4,
        statics: {
            methods: {
                /*Spine.BoneMatrix.CalculateSetupWorld:static start.*/
                /**
                 * Recursively calculates a worldspace bone matrix based on BoneData.
                 *
                 * @static
                 * @public
                 * @this Spine.BoneMatrix
                 * @memberof Spine.BoneMatrix
                 * @param   {Spine.BoneData}      boneData
                 * @return  {Spine.BoneMatrix}
                 */
                CalculateSetupWorld: function (boneData) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#CalculateSetupWorld", this ); }

                    if (boneData == null) {
                        return Bridge.getDefaultValue(Spine.BoneMatrix);
                    }

                    // End condition: isRootBone
                    if (boneData.parent == null) {
                        return Spine.BoneMatrix.GetInheritedInternal(boneData, Bridge.getDefaultValue(Spine.BoneMatrix));
                    }

                    var result = Spine.BoneMatrix.CalculateSetupWorld(boneData.parent);
                    return Spine.BoneMatrix.GetInheritedInternal(boneData, result.$clone());
                },
                /*Spine.BoneMatrix.CalculateSetupWorld:static end.*/

                /*Spine.BoneMatrix.GetInheritedInternal:static start.*/
                GetInheritedInternal: function (boneData, parentMatrix) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#GetInheritedInternal", this ); }

                    var parent = boneData.parent;
                    if (parent == null) {
                        return new Spine.BoneMatrix.$ctor2(boneData);
                    } // isRootBone

                    var pa = parentMatrix.a, pb = parentMatrix.b, pc = parentMatrix.c, pd = parentMatrix.d;
                    var result = Bridge.getDefaultValue(Spine.BoneMatrix);
                    result.x = pa * boneData.x + pb * boneData.y + parentMatrix.x;
                    result.y = pc * boneData.x + pd * boneData.y + parentMatrix.y;

                    switch (boneData.transformMode) {
                        case Spine.TransformMode.Normal: 
                            {
                                var rotationY = boneData.rotation + 90 + boneData.shearY;
                                var la = Spine.MathUtils.CosDeg(boneData.rotation + boneData.shearX) * boneData.scaleX;
                                var lb = Spine.MathUtils.CosDeg(rotationY) * boneData.scaleY;
                                var lc = Spine.MathUtils.SinDeg(boneData.rotation + boneData.shearX) * boneData.scaleX;
                                var ld = Spine.MathUtils.SinDeg(rotationY) * boneData.scaleY;
                                result.a = pa * la + pb * lc;
                                result.b = pa * lb + pb * ld;
                                result.c = pc * la + pd * lc;
                                result.d = pc * lb + pd * ld;
                                break;
                            }
                        case Spine.TransformMode.OnlyTranslation: 
                            {
                                var rotationY1 = boneData.rotation + 90 + boneData.shearY;
                                result.a = Spine.MathUtils.CosDeg(boneData.rotation + boneData.shearX) * boneData.scaleX;
                                result.b = Spine.MathUtils.CosDeg(rotationY1) * boneData.scaleY;
                                result.c = Spine.MathUtils.SinDeg(boneData.rotation + boneData.shearX) * boneData.scaleX;
                                result.d = Spine.MathUtils.SinDeg(rotationY1) * boneData.scaleY;
                                break;
                            }
                        case Spine.TransformMode.NoRotationOrReflection: 
                            {
                                var s = pa * pa + pc * pc, prx;
                                if (s > 0.0001) {
                                    s = Math.abs(pa * pd - pb * pc) / s;
                                    pb = pc * s;
                                    pd = pa * s;
                                    prx = Spine.MathUtils.Atan2(pc, pa) * Spine.MathUtils.RadDeg;
                                } else {
                                    pa = 0;
                                    pc = 0;
                                    prx = 90 - Spine.MathUtils.Atan2(pd, pb) * Spine.MathUtils.RadDeg;
                                }
                                var rx = boneData.rotation + boneData.shearX - prx;
                                var ry = boneData.rotation + boneData.shearY - prx + 90;
                                var la1 = Spine.MathUtils.CosDeg(rx) * boneData.scaleX;
                                var lb1 = Spine.MathUtils.CosDeg(ry) * boneData.scaleY;
                                var lc1 = Spine.MathUtils.SinDeg(rx) * boneData.scaleX;
                                var ld1 = Spine.MathUtils.SinDeg(ry) * boneData.scaleY;
                                result.a = pa * la1 - pb * lc1;
                                result.b = pa * lb1 - pb * ld1;
                                result.c = pc * la1 + pd * lc1;
                                result.d = pc * lb1 + pd * ld1;
                                break;
                            }
                        case Spine.TransformMode.NoScale: 
                        case Spine.TransformMode.NoScaleOrReflection: 
                            {
                                var cos = Spine.MathUtils.CosDeg(boneData.rotation), sin = Spine.MathUtils.SinDeg(boneData.rotation);
                                var za = pa * cos + pb * sin;
                                var zc = pc * cos + pd * sin;
                                var s1 = Math.sqrt(za * za + zc * zc);
                                if (s1 > 1E-05) {
                                    s1 = 1 / s1;
                                }
                                za *= s1;
                                zc *= s1;
                                s1 = Math.sqrt(za * za + zc * zc);
                                var r = 1.57079637 + Spine.MathUtils.Atan2(zc, za);
                                var zb = Spine.MathUtils.Cos(r) * s1;
                                var zd = Spine.MathUtils.Sin(r) * s1;
                                var la2 = Spine.MathUtils.CosDeg(boneData.shearX) * boneData.scaleX;
                                var lb2 = Spine.MathUtils.CosDeg(90 + boneData.shearY) * boneData.scaleY;
                                var lc2 = Spine.MathUtils.SinDeg(boneData.shearX) * boneData.scaleX;
                                var ld2 = Spine.MathUtils.SinDeg(90 + boneData.shearY) * boneData.scaleY;
                                if (boneData.transformMode !== Spine.TransformMode.NoScaleOrReflection ? pa * pd - pb * pc < 0 : false) {
                                    zb = -zb;
                                    zd = -zd;
                                }
                                result.a = za * la2 + zb * lc2;
                                result.b = za * lb2 + zb * ld2;
                                result.c = zc * la2 + zd * lc2;
                                result.d = zc * lb2 + zd * ld2;
                                break;
                            }
                    }

                    return result.$clone();
                },
                /*Spine.BoneMatrix.GetInheritedInternal:static end.*/

                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#getDefaultValue", this ); }
 return new Spine.BoneMatrix(); }
            }
        },
        fields: {
            a: 0,
            b: 0,
            c: 0,
            d: 0,
            x: 0,
            y: 0
        },
        ctors: {
            /**
             * Constructor for a local bone matrix based on Setup Pose BoneData.
             *
             * @instance
             * @public
             * @this Spine.BoneMatrix
             * @memberof Spine.BoneMatrix
             * @param   {Spine.BoneData}    boneData
             * @return  {void}
             */
            $ctor2: function (boneData) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#$ctor2", this ); }

                this.$initialize();
                var rotationY = boneData.rotation + 90 + boneData.shearY;
                var rotationX = boneData.rotation + boneData.shearX;

                this.a = Spine.MathUtils.CosDeg(rotationX) * boneData.scaleX;
                this.c = Spine.MathUtils.SinDeg(rotationX) * boneData.scaleX;
                this.b = Spine.MathUtils.CosDeg(rotationY) * boneData.scaleY;
                this.d = Spine.MathUtils.SinDeg(rotationY) * boneData.scaleY;
                this.x = boneData.x;
                this.y = boneData.y;
            },
            /**
             * Constructor for a local bone matrix based on a bone instance's current pose.
             *
             * @instance
             * @public
             * @this Spine.BoneMatrix
             * @memberof Spine.BoneMatrix
             * @param   {Spine.Bone}    bone
             * @return  {void}
             */
            $ctor1: function (bone) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#$ctor1", this ); }

                this.$initialize();
                var rotationY = bone.rotation + 90 + bone.shearY;
                var rotationX = bone.rotation + bone.shearX;

                this.a = Spine.MathUtils.CosDeg(rotationX) * bone.scaleX;
                this.c = Spine.MathUtils.SinDeg(rotationX) * bone.scaleX;
                this.b = Spine.MathUtils.CosDeg(rotationY) * bone.scaleY;
                this.d = Spine.MathUtils.SinDeg(rotationY) * bone.scaleY;
                this.x = bone.x;
                this.y = bone.y;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.BoneMatrix.TransformMatrix start.*/
            TransformMatrix: function (local) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#TransformMatrix", this ); }

                var $t;
                return ($t = new Spine.BoneMatrix.ctor(), $t.a = this.a * local.a + this.b * local.c, $t.b = this.a * local.b + this.b * local.d, $t.c = this.c * local.a + this.d * local.c, $t.d = this.c * local.b + this.d * local.d, $t.x = this.a * local.x + this.b * local.y + this.x, $t.y = this.c * local.x + this.d * local.y + this.y, $t);
            },
            /*Spine.BoneMatrix.TransformMatrix end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#getHashCode", this ); }

                var h = Bridge.addHash([3621996792, this.a, this.b, this.c, this.d, this.x, this.y]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#equals", this ); }

                if (!Bridge.is(o, Spine.BoneMatrix)) {
                    return false;
                }
                return Bridge.equals(this.a, o.a) && Bridge.equals(this.b, o.b) && Bridge.equals(this.c, o.c) && Bridge.equals(this.d, o.d) && Bridge.equals(this.x, o.x) && Bridge.equals(this.y, o.y);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#$clone", this ); }

                var s = to || new Spine.BoneMatrix();
                s.a = this.a;
                s.b = this.b;
                s.c = this.c;
                s.d = this.d;
                s.x = this.x;
                s.y = this.y;
                return s;
            }
        }
    });
    /*Spine.BoneMatrix end.*/

    /*Spine.Collections.CollectionExtensions start.*/
    /** @namespace Spine.Collections */

    /**
     * Provides extensions methods for constructing instances of {@link }.
     *
     * @static
     * @abstract
     * @public
     * @class Spine.Collections.CollectionExtensions
     */
    Bridge.define("Spine.Collections.CollectionExtensions", {
        statics: {
            methods: {
                /*Spine.Collections.CollectionExtensions.ToOrderedDictionary:static start.*/
                /**
                 * Creates a new OrderedDictionary from the given collection, using the key selector to extract the key.
                 *
                 * @static
                 * @public
                 * @this Spine.Collections.CollectionExtensions
                 * @memberof Spine.Collections.CollectionExtensions
                 * @param   {Function}                                    TSource        The type of the items in the collection.
                 * @param   {Function}                                    TKey           The type of the key.
                 * @param   {System.Collections.Generic.IEnumerable$1}    source         The items to created the OrderedDictionary from.
                 * @param   {System.Func}                                 keySelector    A delegate that can extract a key from an item in the collection.
                 * @return  {Spine.Collections.OrderedDictionary$2}                      An OrderedDictionary mapping the extracted keys to their values.
                 */
                ToOrderedDictionary: function (TSource, TKey, source, keySelector) {
if ( TRACE ) { TRACE( "Spine.Collections.CollectionExtensions#ToOrderedDictionary", this ); }

                    return Spine.Collections.CollectionExtensions.ToOrderedDictionary$1(TSource, TKey, source, keySelector, null);
                },
                /*Spine.Collections.CollectionExtensions.ToOrderedDictionary:static end.*/

                /*Spine.Collections.CollectionExtensions.ToOrderedDictionary$1:static start.*/
                /**
                 * Creates a new OrderedDictionary from the given collection, using the key selector to extract the key.
                 The key comparer is passed to the OrderedDictionary for comparing the extracted keys.
                 *
                 * @static
                 * @public
                 * @this Spine.Collections.CollectionExtensions
                 * @memberof Spine.Collections.CollectionExtensions
                 * @param   {Function}                                          TSource        The type of the items in the collection.
                 * @param   {Function}                                          TKey           The type of the key.
                 * @param   {System.Collections.Generic.IEnumerable$1}          source         The items to created the OrderedDictionary from.
                 * @param   {System.Func}                                       keySelector    A delegate that can extract a key from an item in the collection.
                 * @param   {System.Collections.Generic.IEqualityComparer$1}    comparer       The key equality comparer to use to compare keys in the dictionary.
                 * @return  {Spine.Collections.OrderedDictionary$2}                            An OrderedDictionary mapping the extracted keys to their values.
                 */
                ToOrderedDictionary$1: function (TSource, TKey, source, keySelector, comparer) {
if ( TRACE ) { TRACE( "Spine.Collections.CollectionExtensions#ToOrderedDictionary$1", this ); }

                    var $t;
                    if (source == null) {
                        throw new System.ArgumentNullException.$ctor1("source");
                    }
                    if (Bridge.staticEquals(keySelector, null)) {
                        throw new System.ArgumentNullException.$ctor1("keySelector");
                    }
                    var dictionary = new (Spine.Collections.OrderedDictionary$2(TKey,TSource)).$ctor1(comparer);
                    $t = Bridge.getEnumerator(source, TSource);
                    try {
                        while ($t.moveNext()) {
                            var item = Bridge.rValue($t.Current);
                            var key = Bridge.rValue(keySelector(Bridge.rValue(item)));
                            dictionary.add(Bridge.rValue(key), Bridge.rValue(item));
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return dictionary;
                },
                /*Spine.Collections.CollectionExtensions.ToOrderedDictionary$1:static end.*/


            }
        }
    });
    /*Spine.Collections.CollectionExtensions end.*/

    /*Spine.Collections.OrderedDictionary$2 start.*/
    /**
     * Represents a dictionary that tracks the order that items were added.
     *
     * @public
     * @class Spine.Collections.OrderedDictionary$2
     * @implements  System.Collections.Generic.IDictionary$2
     * @implements  System.Collections.Generic.IList$1
     * @param   {Function}    [name]    The type of the dictionary keys.
     * @param   {Function}    [name]    The type of the dictionary values.
     */
    Bridge.define("Spine.Collections.OrderedDictionary$2", function (TKey, TValue) { return {
        inherits: [System.Collections.Generic.IDictionary$2(TKey,TValue),System.Collections.Generic.IList$1(System.Collections.Generic.KeyValuePair$2(TKey,TValue))],
        statics: {
            fields: {
                CollectionModifiedMessage: null,
                EditReadOnlyListMessage: null,
                IndexOutOfRangeMessage: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#init", this ); }

                    this.CollectionModifiedMessage = "Collection was modified; enumeration operation may not execute.";
                    this.EditReadOnlyListMessage = "An attempt was made to edit a read-only list.";
                    this.IndexOutOfRangeMessage = "The index is negative or outside the bounds of the collection.";
                }
            }
        },
        fields: {
            dictionary: null,
            keys: null,
            values: null,
            version: 0
        },
        props: {
            /**
             * Gets the equality comparer used to compare keys.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Collections.OrderedDictionary$2
             * @function Comparer
             * @type System.Collections.Generic.IEqualityComparer$1
             */
            Comparer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#Comparer#get", this ); }

                    return this.dictionary.Comparer;
                }
            },
            /**
             * Gets the keys in the dictionary in the order they were added.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Collections.OrderedDictionary$2
             * @function Keys
             * @type Spine.Collections.OrderedDictionary$2.KeyCollection
             */
            Keys: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#Keys#get", this ); }

                    return new (Spine.Collections.OrderedDictionary$2.KeyCollection(TKey,TValue))(this.dictionary);
                }
            },
            /**
             * Gets the values in the dictionary.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Collections.OrderedDictionary$2
             * @function Values
             * @type Spine.Collections.OrderedDictionary$2.ValueCollection
             */
            Values: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#Values#get", this ); }

                    return new (Spine.Collections.OrderedDictionary$2.ValueCollection(TKey,TValue))(this.values);
                }
            },
            /**
             * Gets the number of key/value pairs in the dictionary.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Collections.OrderedDictionary$2
             * @function Count
             * @type number
             */
            Count: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#Count#get", this ); }

                    return this.dictionary.Count;
                }
            },
            System$Collections$Generic$IDictionary$2$Keys: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#System$Collections$Generic$IDictionary$2$Keys#get", this ); }

                    return this.Keys;
                }
            },
            System$Collections$Generic$IDictionary$2$Values: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#System$Collections$Generic$IDictionary$2$Values#get", this ); }

                    return this.Values;
                }
            },
            System$Collections$Generic$ICollection$1$IsReadOnly: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#System$Collections$Generic$ICollection$1$IsReadOnly#get", this ); }

                    return false;
                }
            }
        },
        alias: [
            "add", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$add",
            "containsKey", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$containsKey",
            "remove", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$remove",
            "removeAt", "System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$removeAt",
            "tryGetValue", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$tryGetValue",
            "getItem", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$getItem",
            "setItem", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$setItem",
            "clear", "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$clear",
            "Count", "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$Count",
            "GetEnumerator", ["System$Collections$Generic$IEnumerable$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$GetEnumerator", "System$Collections$Generic$IEnumerable$1$GetEnumerator"],
            "System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$indexOf", "System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$indexOf",
            "System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$insert", "System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$insert",
            "System$Collections$Generic$IList$1$getItem", "System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$getItem",
            "System$Collections$Generic$IList$1$setItem", "System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$setItem",
            "System$Collections$Generic$IDictionary$2$Keys", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$Keys",
            "System$Collections$Generic$IDictionary$2$Values", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$Values",
            "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$add", "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$add",
            "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$contains", "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$contains",
            "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$copyTo", "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$copyTo",
            "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$IsReadOnly", "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$IsReadOnly",
            "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$remove", "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$remove"
        ],
        ctors: {
            /**
             * Initializes a new instance of an OrderedDictionary.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @return  {void}
             */
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#ctor", this ); }

                Spine.Collections.OrderedDictionary$2(TKey,TValue).$ctor3.call(this, 0, null);
            },
            /**
             * Initializes a new instance of an OrderedDictionary.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @throws {System.ArgumentOutOfRangeException} The capacity is less than zero.
             * @param   {number}    capacity    The initial capacity of the dictionary.
             * @return  {void}
             */
            $ctor2: function (capacity) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#$ctor2", this ); }

                Spine.Collections.OrderedDictionary$2(TKey,TValue).$ctor3.call(this, capacity, null);
            },
            /**
             * Initializes a new instance of an OrderedDictionary.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @param   {System.Collections.Generic.IEqualityComparer$1}    comparer    The equality comparer to use to compare keys.
             * @return  {void}
             */
            $ctor1: function (comparer) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#$ctor1", this ); }

                Spine.Collections.OrderedDictionary$2(TKey,TValue).$ctor3.call(this, 0, comparer);
            },
            /**
             * Initializes a new instance of an OrderedDictionary.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @param   {number}                                            capacity    The initial capacity of the dictionary.
             * @param   {System.Collections.Generic.IEqualityComparer$1}    comparer    The equality comparer to use to compare keys.
             * @return  {void}
             */
            $ctor3: function (capacity, comparer) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#$ctor3", this ); }

                this.$initialize();
                this.dictionary = new (System.Collections.Generic.Dictionary$2(TKey,System.Int32)).$ctor5(capacity, comparer || System.Collections.Generic.EqualityComparer$1(TKey).def);
                this.keys = new (System.Collections.Generic.List$1(TKey)).$ctor2(capacity);
                this.values = new (System.Collections.Generic.List$1(TValue)).$ctor2(capacity);
            }
        },
        methods: {
            /**
             * Gets or sets the value at the given index.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @throws {System.ArgumentOutOfRangeException} The index is negative -or- beyond the length of the dictionary.
             * @param   {number}    index    The index of the value to get.
             * @return  {TValue}             The value at the given index.
             */
            getItem$1: function (index) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#getItem$1", this ); }

                return Bridge.rValue(this.values.getItem(index));
            },
            /**
             * Gets or sets the value at the given index.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @throws {System.ArgumentOutOfRangeException} The index is negative -or- beyond the length of the dictionary.
             * @param   {number}    index    The index of the value to get.
             * @param   {TValue}    value
             * @return  {void}               The value at the given index.
             */
            setItem$1: function (index, value) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#setItem$1", this ); }

                this.values.setItem(index, Bridge.rValue(value));
            },
            /**
             * Gets or sets the value associated with the given key.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @throws {System.ArgumentNullException} The key is null.
             * @throws {System.Collections.Generic.KeyNotFoundException} The key is not in the dictionary.
             * @param   {TKey}      key    The key to get the associated value by or to associate with the value.
             * @return  {TValue}           The value associated with the given key.
             */
            getItem: function (key) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#getItem", this ); }

                return Bridge.rValue(this.values.getItem(this.dictionary.getItem(Bridge.rValue(key))));
            },
            /**
             * Gets or sets the value associated with the given key.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @throws {System.ArgumentNullException} The key is null.
             * @throws {System.Collections.Generic.KeyNotFoundException} The key is not in the dictionary.
             * @param   {TKey}      key      The key to get the associated value by or to associate with the value.
             * @param   {TValue}    value
             * @return  {void}               The value associated with the given key.
             */
            setItem: function (key, value) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#setItem", this ); }

                var index = { };
                if (this.dictionary.tryGetValue(Bridge.rValue(key), index)) {
                    this.keys.setItem(index.v, Bridge.rValue(key));
                    this.values.setItem(index.v, Bridge.rValue(value));
                } else {
                    this.add(Bridge.rValue(key), Bridge.rValue(value));
                }
            },
            System$Collections$Generic$IList$1$getItem: function (index) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#System$Collections$Generic$IList$1$getItem", this ); }

                var key = Bridge.rValue(this.keys.getItem(index));
                var value = Bridge.rValue(this.values.getItem(index));
                return new (System.Collections.Generic.KeyValuePair$2(TKey,TValue)).$ctor1(Bridge.rValue(key), Bridge.rValue(value));
            },
            System$Collections$Generic$IList$1$setItem: function (index, value) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#System$Collections$Generic$IList$1$setItem", this ); }

                var $t;
                var key = Bridge.rValue(this.keys.getItem(index));
                if (($t = this.dictionary.Comparer)[Bridge.geti($t, "System$Collections$Generic$IEqualityComparer$1$" + Bridge.getTypeAlias(TKey) + "$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2")](Bridge.rValue(key), Bridge.rValue(value.key))) {
                    this.dictionary.setItem(Bridge.rValue(value.key), index);
                } else {
                    this.dictionary.add(Bridge.rValue(value.key), index); // will throw if key already exists
                    this.dictionary.remove(Bridge.rValue(key));
                }
                this.keys.setItem(index, Bridge.rValue(value.key));
                this.values.setItem(index, Bridge.rValue(value.value));
            },
            /*Spine.Collections.OrderedDictionary$2.add start.*/
            /**
             * Adds the given key/value pair to the dictionary.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @throws {System.ArgumentException} The given key already exists in the dictionary.
             * @throws {System.ArgumentNullException} The key is null.
             * @param   {TKey}      key      The key to add to the dictionary.
             * @param   {TValue}    value    The value to associated with the key.
             * @return  {void}
             */
            add: function (key, value) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#add", this ); }

                this.dictionary.add(Bridge.rValue(key), this.values.Count);
                this.keys.add(Bridge.rValue(key));
                this.values.add(Bridge.rValue(value));
                this.version = (this.version + 1) | 0;
            },
            /*Spine.Collections.OrderedDictionary$2.add end.*/

            /*Spine.Collections.OrderedDictionary$2.System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$add start.*/
            System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$add: function (item) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$add", this ); }

                this.add(Bridge.rValue(item.key), Bridge.rValue(item.value));
            },
            /*Spine.Collections.OrderedDictionary$2.System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$add end.*/

            /*Spine.Collections.OrderedDictionary$2.Insert start.*/
            /**
             * Inserts the given key/value pair at the specified index.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @throws {System.ArgumentException} The given key already exists in the dictionary.
             * @throws {System.ArgumentNullException} The key is null.
             * @throws {System.ArgumentOutOfRangeException} The index is negative -or- larger than the size of the dictionary.
             * @param   {number}    index    The index to insert the key/value pair.
             * @param   {TKey}      key      The key to insert.
             * @param   {TValue}    value    The value to insert.
             * @return  {void}
             */
            Insert: function (index, key, value) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#Insert", this ); }

                if (index < 0 || index > this.values.Count) {
                    throw new System.ArgumentOutOfRangeException.$ctor3("index", Bridge.box(index, System.Int32), Spine.Collections.OrderedDictionary$2(TKey,TValue).IndexOutOfRangeMessage);
                }
                this.dictionary.add(Bridge.rValue(key), index);
                for (var keyIndex = index; keyIndex !== this.keys.Count; keyIndex = (keyIndex + 1) | 0) {
                    var otherKey = Bridge.rValue(this.keys.getItem(keyIndex));
                    this.dictionary.setItem(Bridge.rValue(otherKey), (this.dictionary.getItem(Bridge.rValue(otherKey)) + 1) | 0);
                }
                this.keys.insert(index, Bridge.rValue(key));
                this.values.insert(index, Bridge.rValue(value));
                this.version = (this.version + 1) | 0;
            },
            /*Spine.Collections.OrderedDictionary$2.Insert end.*/

            /*Spine.Collections.OrderedDictionary$2.System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$insert start.*/
            System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$insert: function (index, item) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$insert", this ); }

                this.Insert(index, Bridge.rValue(item.key), Bridge.rValue(item.value));
            },
            /*Spine.Collections.OrderedDictionary$2.System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$insert end.*/

            /*Spine.Collections.OrderedDictionary$2.containsKey start.*/
            /**
             * Determines whether the given key exists in the dictionary.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @throws {System.ArgumentNullException} The key is null.
             * @param   {TKey}       key    The key to look for.
             * @return  {boolean}           True if the key exists in the dictionary; otherwise, false.
             */
            containsKey: function (key) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#containsKey", this ); }

                return this.dictionary.containsKey(Bridge.rValue(key));
            },
            /*Spine.Collections.OrderedDictionary$2.containsKey end.*/

            /*Spine.Collections.OrderedDictionary$2.GetKey start.*/
            /**
             * Gets the key at the given index.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @throws {System.ArgumentOutOfRangeException} The index is negative -or- larger than the number of keys.
             * @param   {number}    index    The index of the key to get.
             * @return  {TKey}               The key at the given index.
             */
            GetKey: function (index) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#GetKey", this ); }

                return Bridge.rValue(this.keys.getItem(index));
            },
            /*Spine.Collections.OrderedDictionary$2.GetKey end.*/

            /*Spine.Collections.OrderedDictionary$2.IndexOf start.*/
            /**
             * Gets the index of the given key.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @param   {TKey}      key    The key to get the index of.
             * @return  {number}           The index of the key in the dictionary -or- -1 if the key is not found.
             */
            IndexOf: function (key) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#IndexOf", this ); }

                var index = { };
                if (this.dictionary.tryGetValue(Bridge.rValue(key), index)) {
                    return index.v;
                }
                return -1;
            },
            /*Spine.Collections.OrderedDictionary$2.IndexOf end.*/

            /*Spine.Collections.OrderedDictionary$2.System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$indexOf start.*/
            System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$indexOf: function (item) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$indexOf", this ); }

                var index = { };
                if (this.dictionary.tryGetValue(Bridge.rValue(item.key), index) && Bridge.equals(this.values.getItem(index.v), item.value)) {
                    return index.v;
                }
                return -1;
            },
            /*Spine.Collections.OrderedDictionary$2.System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$indexOf end.*/

            /*Spine.Collections.OrderedDictionary$2.remove start.*/
            /**
             * Removes the key/value pair with the given key from the dictionary.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @throws {System.ArgumentNullException} The key is null.
             * @param   {TKey}       key    The key of the pair to remove.
             * @return  {boolean}           True if the key was found and the pair removed; otherwise, false.
             */
            remove: function (key) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#remove", this ); }

                var index = { };
                if (this.dictionary.tryGetValue(Bridge.rValue(key), index)) {
                    this.removeAt(index.v);
                    return true;
                }
                return false;
            },
            /*Spine.Collections.OrderedDictionary$2.remove end.*/

            /*Spine.Collections.OrderedDictionary$2.System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$remove start.*/
            System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$remove: function (item) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$remove", this ); }

                var self = this;
                if (System.Array.contains(self, item, System.Collections.Generic.KeyValuePair$2(TKey,TValue))) {
                    return this.remove(Bridge.rValue(item.key));
                }
                return false;
            },
            /*Spine.Collections.OrderedDictionary$2.System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$remove end.*/

            /*Spine.Collections.OrderedDictionary$2.removeAt start.*/
            /**
             * Removes the key/value pair at the given index.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @throws {System.ArgumentOutOfRangeException} The index is negative -or- larger than the size of the dictionary.
             * @param   {number}    index    The index of the key/value pair to remove.
             * @return  {void}
             */
            removeAt: function (index) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#removeAt", this ); }

                var key = Bridge.rValue(this.keys.getItem(index));
                for (var keyIndex = (index + 1) | 0; keyIndex < this.keys.Count; keyIndex = (keyIndex + 1) | 0) {
                    var otherKey = Bridge.rValue(this.keys.getItem(keyIndex));
                    this.dictionary.setItem(Bridge.rValue(otherKey), (this.dictionary.getItem(Bridge.rValue(otherKey)) - 1) | 0);
                }
                this.dictionary.remove(Bridge.rValue(key));
                this.keys.removeAt(index);
                this.values.removeAt(index);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.Collections.OrderedDictionary$2.removeAt end.*/

            /*Spine.Collections.OrderedDictionary$2.tryGetValue start.*/
            /**
             * Tries to get the value associated with the given key. If the key is not found,
             default(TValue) value is stored in the value.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @throws {System.ArgumentNullException} The key is null.
             * @param   {TKey}       key      The key to get the value for.
             * @param   {TValue}     value    The value used to hold the results.
             * @return  {boolean}             True if the key was found; otherwise, false.
             */
            tryGetValue: function (key, value) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#tryGetValue", this ); }

                var index = { };
                if (this.dictionary.tryGetValue(Bridge.rValue(key), index)) {
                    value.v = Bridge.rValue(this.values.getItem(index.v));
                    return true;
                }
                value.v = Bridge.getDefaultValue(TValue);
                return false;
            },
            /*Spine.Collections.OrderedDictionary$2.tryGetValue end.*/

            /*Spine.Collections.OrderedDictionary$2.clear start.*/
            /**
             * Removes all key/value pairs from the dictionary.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @return  {void}
             */
            clear: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#clear", this ); }

                this.dictionary.clear();
                this.keys.clear();
                this.values.clear();
                this.version = (this.version + 1) | 0;
            },
            /*Spine.Collections.OrderedDictionary$2.clear end.*/

            /*Spine.Collections.OrderedDictionary$2.GetEnumerator start.*/
            /**
             * Gets the key/value pairs in the dictionary in the order they were added.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @return  {System.Collections.Generic.IEnumerator$1}        An enumerator over the key/value pairs in the dictionary.
             */
            GetEnumerator: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#GetEnumerator", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    startVersion,
                    index,
                    key,
                    value,
                    $async_e;

                var $enumerator = new (Bridge.GeneratorEnumerator$1(System.Collections.Generic.KeyValuePair$2(TKey,TValue)))(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    startVersion = this.version;
                                        index = 0;
                                        $step = 1;
                                        continue;
                                }
                                case 1: {
                                    if ( index !== this.keys.Count ) {
                                            $step = 2;
                                            continue;
                                        }
                                    $step = 5;
                                    continue;
                                }
                                case 2: {
                                    key = Bridge.rValue(this.keys.getItem(index));
                                        value = Bridge.rValue(this.values.getItem(index));
                                        $enumerator.current = new (System.Collections.Generic.KeyValuePair$2(TKey,TValue)).$ctor1(Bridge.rValue(key), Bridge.rValue(value));
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    if (this.version !== startVersion) {
                                            throw new System.InvalidOperationException.$ctor1(Spine.Collections.OrderedDictionary$2(TKey,TValue).CollectionModifiedMessage);
                                        }
                                    $step = 4;
                                    continue;
                                }
                                case 4: {
                                    index = (index + 1) | 0;
                                    $step = 1;
                                    continue;
                                }
                                case 5: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Spine.Collections.OrderedDictionary$2.GetEnumerator end.*/

            /*Spine.Collections.OrderedDictionary$2.System$Collections$IEnumerable$GetEnumerator start.*/
            System$Collections$IEnumerable$GetEnumerator: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#System$Collections$IEnumerable$GetEnumerator", this ); }

                return this.GetEnumerator();
            },
            /*Spine.Collections.OrderedDictionary$2.System$Collections$IEnumerable$GetEnumerator end.*/

            /*Spine.Collections.OrderedDictionary$2.System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$contains start.*/
            System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$contains: function (item) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$contains", this ); }

                var index = { };
                if (this.dictionary.tryGetValue(Bridge.rValue(item.key), index) && Bridge.equals(this.values.getItem(index.v), item.value)) {
                    return true;
                }
                return false;
            },
            /*Spine.Collections.OrderedDictionary$2.System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$contains end.*/

            /*Spine.Collections.OrderedDictionary$2.System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$copyTo start.*/
            System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$copyTo: function (array, arrayIndex) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$copyTo", this ); }

                if (array == null) {
                    throw new System.ArgumentNullException.$ctor1("array");
                }
                if (arrayIndex < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor3("arrayIndex", Bridge.box(arrayIndex, System.Int32), Spine.Collections.OrderedDictionary$2(TKey,TValue).IndexOutOfRangeMessage);
                }
                for (var index = 0; index !== this.keys.Count && arrayIndex < array.length; index = (index + 1) | 0, arrayIndex = (arrayIndex + 1) | 0) {
                    var key = Bridge.rValue(this.keys.getItem(index));
                    var value = Bridge.rValue(this.values.getItem(index));
                    array[arrayIndex] = new (System.Collections.Generic.KeyValuePair$2(TKey,TValue)).$ctor1(Bridge.rValue(key), Bridge.rValue(value));
                }
            },
            /*Spine.Collections.OrderedDictionary$2.System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$copyTo end.*/


        },
        overloads: {
            "Add(TKey, TValue)": "add",
            "ContainsKey(TKey)": "containsKey",
            "Remove(TKey)": "remove",
            "RemoveAt(int)": "removeAt",
            "TryGetValue(TKey, TValue)": "tryGetValue",
            "Clear()": "clear"
        }
    }; });
    /*Spine.Collections.OrderedDictionary$2 end.*/

    /*Spine.Collections.OrderedDictionary$2+KeyCollection start.*/
    /**
     * Wraps the keys in an OrderDictionary.
     *
     * @public
     * @class Spine.Collections.OrderedDictionary$2.KeyCollection
     * @implements  System.Collections.Generic.ICollection$1
     */
    Bridge.define("Spine.Collections.OrderedDictionary$2.KeyCollection", function (TKey, TValue) { return {
        inherits: [System.Collections.Generic.ICollection$1(TKey)],
        $kind: 1002,
        fields: {
            dictionary: null
        },
        props: {
            /**
             * Gets the number of keys in the OrderedDictionary.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Collections.OrderedDictionary$2.KeyCollection
             * @function Count
             * @type number
             */
            Count: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.KeyCollection#Count#get", this ); }

                    return this.dictionary.Count;
                }
            },
            System$Collections$Generic$ICollection$1$IsReadOnly: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.KeyCollection#System$Collections$Generic$ICollection$1$IsReadOnly#get", this ); }

                    return true;
                }
            }
        },
        alias: [
            "copyTo", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TKey) + "$copyTo",
            "Count", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TKey) + "$Count",
            "GetEnumerator", ["System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(TKey) + "$GetEnumerator", "System$Collections$Generic$IEnumerable$1$GetEnumerator"],
            "System$Collections$Generic$ICollection$1$contains", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TKey) + "$contains",
            "System$Collections$Generic$ICollection$1$add", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TKey) + "$add",
            "System$Collections$Generic$ICollection$1$clear", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TKey) + "$clear",
            "System$Collections$Generic$ICollection$1$IsReadOnly", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TKey) + "$IsReadOnly",
            "System$Collections$Generic$ICollection$1$remove", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TKey) + "$remove"
        ],
        ctors: {
            /**
             * Initializes a new instance of a KeyCollection.
             *
             * @instance
             * @this Spine.Collections.OrderedDictionary$2.KeyCollection
             * @memberof Spine.Collections.OrderedDictionary$2.KeyCollection
             * @throws {System.ArgumentNullException} The dictionary is null.
             * @param   {System.Collections.Generic.Dictionary$2}    dictionary    The OrderedDictionary whose keys to wrap.
             * @return  {void}
             */
            ctor: function (dictionary) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.KeyCollection#ctor", this ); }

                this.$initialize();
                this.dictionary = dictionary;
            }
        },
        methods: {
            /*Spine.Collections.OrderedDictionary$2+KeyCollection.copyTo start.*/
            /**
             * Copies the keys from the OrderedDictionary to the given array, starting at the given index.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2.KeyCollection
             * @memberof Spine.Collections.OrderedDictionary$2.KeyCollection
             * @throws {System.ArgumentNullException} The array is null.
             * @throws {System.ArgumentOutOfRangeException} The arrayIndex is negative.
             * @throws {System.ArgumentException} The array, starting at the given index, is not large enough to contain all the keys.
             * @param   {Array.<TKey>}    array         The array to copy the keys to.
             * @param   {number}          arrayIndex    The index into the array to start copying the keys.
             * @return  {void}
             */
            copyTo: function (array, arrayIndex) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.KeyCollection#copyTo", this ); }

                this.dictionary.Keys.copyTo(array, arrayIndex);
            },
            /*Spine.Collections.OrderedDictionary$2+KeyCollection.copyTo end.*/

            /*Spine.Collections.OrderedDictionary$2+KeyCollection.GetEnumerator start.*/
            /**
             * Gets an enumerator over the keys in the OrderedDictionary.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2.KeyCollection
             * @memberof Spine.Collections.OrderedDictionary$2.KeyCollection
             * @return  {System.Collections.Generic.IEnumerator$1}        The enumerator.
             */
            GetEnumerator: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.KeyCollection#GetEnumerator", this ); }

                return this.dictionary.Keys.GetEnumerator().$clone();
            },
            /*Spine.Collections.OrderedDictionary$2+KeyCollection.GetEnumerator end.*/

            /*Spine.Collections.OrderedDictionary$2+KeyCollection.System$Collections$IEnumerable$GetEnumerator start.*/
            System$Collections$IEnumerable$GetEnumerator: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.KeyCollection#System$Collections$IEnumerable$GetEnumerator", this ); }

                return this.GetEnumerator();
            },
            /*Spine.Collections.OrderedDictionary$2+KeyCollection.System$Collections$IEnumerable$GetEnumerator end.*/

            /*Spine.Collections.OrderedDictionary$2+KeyCollection.System$Collections$Generic$ICollection$1$contains start.*/
            System$Collections$Generic$ICollection$1$contains: function (item) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.KeyCollection#System$Collections$Generic$ICollection$1$contains", this ); }

                return this.dictionary.containsKey(Bridge.rValue(item));
            },
            /*Spine.Collections.OrderedDictionary$2+KeyCollection.System$Collections$Generic$ICollection$1$contains end.*/

            /*Spine.Collections.OrderedDictionary$2+KeyCollection.System$Collections$Generic$ICollection$1$add start.*/
            System$Collections$Generic$ICollection$1$add: function (item) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.KeyCollection#System$Collections$Generic$ICollection$1$add", this ); }

                throw new System.NotSupportedException.$ctor1(Spine.Collections.OrderedDictionary$2(TKey,TValue).EditReadOnlyListMessage);
            },
            /*Spine.Collections.OrderedDictionary$2+KeyCollection.System$Collections$Generic$ICollection$1$add end.*/

            /*Spine.Collections.OrderedDictionary$2+KeyCollection.System$Collections$Generic$ICollection$1$clear start.*/
            System$Collections$Generic$ICollection$1$clear: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.KeyCollection#System$Collections$Generic$ICollection$1$clear", this ); }

                throw new System.NotSupportedException.$ctor1(Spine.Collections.OrderedDictionary$2(TKey,TValue).EditReadOnlyListMessage);
            },
            /*Spine.Collections.OrderedDictionary$2+KeyCollection.System$Collections$Generic$ICollection$1$clear end.*/

            /*Spine.Collections.OrderedDictionary$2+KeyCollection.System$Collections$Generic$ICollection$1$remove start.*/
            System$Collections$Generic$ICollection$1$remove: function (item) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.KeyCollection#System$Collections$Generic$ICollection$1$remove", this ); }

                throw new System.NotSupportedException.$ctor1(Spine.Collections.OrderedDictionary$2(TKey,TValue).EditReadOnlyListMessage);
            },
            /*Spine.Collections.OrderedDictionary$2+KeyCollection.System$Collections$Generic$ICollection$1$remove end.*/


        },
        overloads: {
            "CopyTo(TKey[], int)": "copyTo"
        }
    }; });
    /*Spine.Collections.OrderedDictionary$2+KeyCollection end.*/

    /*Spine.Collections.OrderedDictionary$2+ValueCollection start.*/
    /**
     * Wraps the keys in an OrderDictionary.
     *
     * @public
     * @class Spine.Collections.OrderedDictionary$2.ValueCollection
     * @implements  System.Collections.Generic.ICollection$1
     */
    Bridge.define("Spine.Collections.OrderedDictionary$2.ValueCollection", function (TKey, TValue) { return {
        inherits: [System.Collections.Generic.ICollection$1(TValue)],
        $kind: 1002,
        fields: {
            values: null
        },
        props: {
            /**
             * Gets the number of values in the OrderedDictionary.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Collections.OrderedDictionary$2.ValueCollection
             * @function Count
             * @type number
             */
            Count: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.ValueCollection#Count#get", this ); }

                    return this.values.Count;
                }
            },
            System$Collections$Generic$ICollection$1$IsReadOnly: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.ValueCollection#System$Collections$Generic$ICollection$1$IsReadOnly#get", this ); }

                    return true;
                }
            }
        },
        alias: [
            "copyTo", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TValue) + "$copyTo",
            "Count", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TValue) + "$Count",
            "GetEnumerator", ["System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(TValue) + "$GetEnumerator", "System$Collections$Generic$IEnumerable$1$GetEnumerator"],
            "System$Collections$Generic$ICollection$1$contains", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TValue) + "$contains",
            "System$Collections$Generic$ICollection$1$add", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TValue) + "$add",
            "System$Collections$Generic$ICollection$1$clear", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TValue) + "$clear",
            "System$Collections$Generic$ICollection$1$IsReadOnly", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TValue) + "$IsReadOnly",
            "System$Collections$Generic$ICollection$1$remove", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TValue) + "$remove"
        ],
        ctors: {
            /**
             * Initializes a new instance of a ValueCollection.
             *
             * @instance
             * @this Spine.Collections.OrderedDictionary$2.ValueCollection
             * @memberof Spine.Collections.OrderedDictionary$2.ValueCollection
             * @throws {System.ArgumentNullException} The dictionary is null.
             * @param   {System.Collections.Generic.List$1}    values    The OrderedDictionary whose keys to wrap.
             * @return  {void}
             */
            ctor: function (values) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.ValueCollection#ctor", this ); }

                this.$initialize();
                this.values = values;
            }
        },
        methods: {
            /*Spine.Collections.OrderedDictionary$2+ValueCollection.copyTo start.*/
            /**
             * Copies the values from the OrderedDictionary to the given array, starting at the given index.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2.ValueCollection
             * @memberof Spine.Collections.OrderedDictionary$2.ValueCollection
             * @throws {System.ArgumentNullException} The array is null.
             * @throws {System.ArgumentOutOfRangeException} The arrayIndex is negative.
             * @throws {System.ArgumentException} The array, starting at the given index, is not large enough to contain all the values.
             * @param   {Array.<TValue>}    array         The array to copy the values to.
             * @param   {number}            arrayIndex    The index into the array to start copying the values.
             * @return  {void}
             */
            copyTo: function (array, arrayIndex) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.ValueCollection#copyTo", this ); }

                this.values.copyTo(array, arrayIndex);
            },
            /*Spine.Collections.OrderedDictionary$2+ValueCollection.copyTo end.*/

            /*Spine.Collections.OrderedDictionary$2+ValueCollection.GetEnumerator start.*/
            /**
             * Gets an enumerator over the values in the OrderedDictionary.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2.ValueCollection
             * @memberof Spine.Collections.OrderedDictionary$2.ValueCollection
             * @return  {System.Collections.Generic.IEnumerator$1}        The enumerator.
             */
            GetEnumerator: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.ValueCollection#GetEnumerator", this ); }

                return this.values.GetEnumerator().$clone();
            },
            /*Spine.Collections.OrderedDictionary$2+ValueCollection.GetEnumerator end.*/

            /*Spine.Collections.OrderedDictionary$2+ValueCollection.System$Collections$IEnumerable$GetEnumerator start.*/
            System$Collections$IEnumerable$GetEnumerator: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.ValueCollection#System$Collections$IEnumerable$GetEnumerator", this ); }

                return this.GetEnumerator();
            },
            /*Spine.Collections.OrderedDictionary$2+ValueCollection.System$Collections$IEnumerable$GetEnumerator end.*/

            /*Spine.Collections.OrderedDictionary$2+ValueCollection.System$Collections$Generic$ICollection$1$contains start.*/
            System$Collections$Generic$ICollection$1$contains: function (item) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.ValueCollection#System$Collections$Generic$ICollection$1$contains", this ); }

                return this.values.contains(Bridge.rValue(item));
            },
            /*Spine.Collections.OrderedDictionary$2+ValueCollection.System$Collections$Generic$ICollection$1$contains end.*/

            /*Spine.Collections.OrderedDictionary$2+ValueCollection.System$Collections$Generic$ICollection$1$add start.*/
            System$Collections$Generic$ICollection$1$add: function (item) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.ValueCollection#System$Collections$Generic$ICollection$1$add", this ); }

                throw new System.NotSupportedException.$ctor1(Spine.Collections.OrderedDictionary$2(TKey,TValue).EditReadOnlyListMessage);
            },
            /*Spine.Collections.OrderedDictionary$2+ValueCollection.System$Collections$Generic$ICollection$1$add end.*/

            /*Spine.Collections.OrderedDictionary$2+ValueCollection.System$Collections$Generic$ICollection$1$clear start.*/
            System$Collections$Generic$ICollection$1$clear: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.ValueCollection#System$Collections$Generic$ICollection$1$clear", this ); }

                throw new System.NotSupportedException.$ctor1(Spine.Collections.OrderedDictionary$2(TKey,TValue).EditReadOnlyListMessage);
            },
            /*Spine.Collections.OrderedDictionary$2+ValueCollection.System$Collections$Generic$ICollection$1$clear end.*/

            /*Spine.Collections.OrderedDictionary$2+ValueCollection.System$Collections$Generic$ICollection$1$remove start.*/
            System$Collections$Generic$ICollection$1$remove: function (item) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.ValueCollection#System$Collections$Generic$ICollection$1$remove", this ); }

                throw new System.NotSupportedException.$ctor1(Spine.Collections.OrderedDictionary$2(TKey,TValue).EditReadOnlyListMessage);
            },
            /*Spine.Collections.OrderedDictionary$2+ValueCollection.System$Collections$Generic$ICollection$1$remove end.*/


        },
        overloads: {
            "CopyTo(TValue[], int)": "copyTo"
        }
    }; });
    /*Spine.Collections.OrderedDictionary$2+ValueCollection end.*/

    /*Spine.Collections.OrderedDictionaryDebugView$2 start.*/
    Bridge.define("Spine.Collections.OrderedDictionaryDebugView$2", function (TKey, TValue) { return {
        fields: {
            dictionary: null
        },
        props: {
            Items: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionaryDebugView$2#Items#get", this ); }

                    var $t;
                    return ($t = System.Collections.Generic.KeyValuePair$2(TKey,TValue), System.Linq.Enumerable.from(this.dictionary, $t).ToArray($t));
                }
            }
        },
        ctors: {
            ctor: function (dictionary) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionaryDebugView$2#ctor", this ); }

                this.$initialize();
                this.dictionary = dictionary;
            }
        }
    }; });
    /*Spine.Collections.OrderedDictionaryDebugView$2 end.*/

    /*Spine.ConstraintData start.*/
    /**
     * The base class for all constraint datas.
     *
     * @abstract
     * @public
     * @class Spine.ConstraintData
     */
    Bridge.define("Spine.ConstraintData", {
        fields: {
            name: null,
            order: 0,
            skinRequired: false
        },
        props: {
            /**
             * The constraint's name, which is unique across all constraints in the skeleton of the same type.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.ConstraintData
             * @function Name
             * @type string
             */
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ConstraintData#Name#get", this ); }

                    return this.name;
                }
            },
            /**
             * The ordinal of this constraint for the order a skeleton's constraints will be applied by
             {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.ConstraintData
             * @function Order
             * @type number
             */
            Order: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ConstraintData#Order#get", this ); }

                    return this.order;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.ConstraintData#Order#set", this ); }

                    this.order = value;
                }
            },
            /**
             * When true, {@link } only updates this constraint if the {@link } contains
             this constraint.
             *
             * @instance
             * @public
             * @memberof Spine.ConstraintData
             * @function SkinRequired
             * @type boolean
             * @see {@link Skin.Constraints}
             */
            SkinRequired: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ConstraintData#SkinRequired#get", this ); }

                    return this.skinRequired;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.ConstraintData#SkinRequired#set", this ); }

                    this.skinRequired = value;
                }
            }
        },
        ctors: {
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.ConstraintData#ctor", this ); }

                this.$initialize();
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor3("name", "name cannot be null.");
                }
                this.name = name;
            }
        },
        methods: {
            /*Spine.ConstraintData.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.ConstraintData#toString", this ); }

                return this.name;
            },
            /*Spine.ConstraintData.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.ConstraintData end.*/

    /*Spine.Event start.*/
    /**
     * Stores the current pose values for an Event.
     *
     * @public
     * @class Spine.Event
     */
    Bridge.define("Spine.Event", {
        fields: {
            data: null,
            time: 0,
            intValue: 0,
            floatValue: 0,
            stringValue: null,
            volume: 0,
            balance: 0
        },
        props: {
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Event#Data#get", this ); }

                    return this.data;
                }
            },
            /**
             * The animation time this event was keyed.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Event
             * @function Time
             * @type number
             */
            Time: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Event#Time#get", this ); }

                    return this.time;
                }
            },
            Int: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Event#Int#get", this ); }

                    return this.intValue;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Event#Int#set", this ); }

                    this.intValue = value;
                }
            },
            Float: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Event#Float#get", this ); }

                    return this.floatValue;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Event#Float#set", this ); }

                    this.floatValue = value;
                }
            },
            String: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Event#String#get", this ); }

                    return this.stringValue;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Event#String#set", this ); }

                    this.stringValue = value;
                }
            },
            Volume: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Event#Volume#get", this ); }

                    return this.volume;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Event#Volume#set", this ); }

                    this.volume = value;
                }
            },
            Balance: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Event#Balance#get", this ); }

                    return this.balance;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Event#Balance#set", this ); }

                    this.balance = value;
                }
            }
        },
        ctors: {
            ctor: function (time, data) {
if ( TRACE ) { TRACE( "Spine.Event#ctor", this ); }

                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                this.time = time;
                this.data = data;
            }
        },
        methods: {
            /*Spine.Event.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Event#toString", this ); }

                return this.data.Name;
            },
            /*Spine.Event.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.Event end.*/

    /*Spine.EventData start.*/
    /**
     * Stores the setup pose values for an Event.
     *
     * @public
     * @class Spine.EventData
     */
    Bridge.define("Spine.EventData", {
        fields: {
            name: null,
            Int: 0,
            Float: 0,
            String: null,
            AudioPath: null,
            Volume: 0,
            Balance: 0
        },
        props: {
            /**
             * The name of the event, which is unique across all events in the skeleton.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.EventData
             * @function Name
             * @type string
             */
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.EventData#Name#get", this ); }

                    return this.name;
                }
            }
        },
        ctors: {
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.EventData#ctor", this ); }

                this.$initialize();
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor3("name", "name cannot be null.");
                }
                this.name = name;
            }
        },
        methods: {
            /*Spine.EventData.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.EventData#toString", this ); }

                return this.Name;
            },
            /*Spine.EventData.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.EventData end.*/

    /*Spine.EventQueue start.*/
    Bridge.define("Spine.EventQueue", {
        fields: {
            eventQueueEntries: null,
            drainDisabled: false,
            state: null,
            trackEntryPool: null
        },
        events: {
            AnimationsChanged: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.EventQueue#init", this ); }

                this.eventQueueEntries = new (System.Collections.Generic.List$1(Spine.EventQueue.EventQueueEntry)).ctor();
            },
            ctor: function (state, HandleAnimationsChanged, trackEntryPool) {
if ( TRACE ) { TRACE( "Spine.EventQueue#ctor", this ); }

                this.$initialize();
                this.state = state;
                this.addAnimationsChanged(HandleAnimationsChanged);
                this.trackEntryPool = trackEntryPool;
            }
        },
        methods: {
            /*Spine.EventQueue.Start start.*/
            Start: function (entry) {
if ( TRACE ) { TRACE( "Spine.EventQueue#Start", this ); }

                this.eventQueueEntries.add(new Spine.EventQueue.EventQueueEntry.$ctor1(Spine.EventQueue.EventType.Start, entry));
                if (!Bridge.staticEquals(this.AnimationsChanged, null)) {
                    this.AnimationsChanged();
                }
            },
            /*Spine.EventQueue.Start end.*/

            /*Spine.EventQueue.Interrupt start.*/
            Interrupt: function (entry) {
if ( TRACE ) { TRACE( "Spine.EventQueue#Interrupt", this ); }

                this.eventQueueEntries.add(new Spine.EventQueue.EventQueueEntry.$ctor1(Spine.EventQueue.EventType.Interrupt, entry));
            },
            /*Spine.EventQueue.Interrupt end.*/

            /*Spine.EventQueue.End start.*/
            End: function (entry) {
if ( TRACE ) { TRACE( "Spine.EventQueue#End", this ); }

                this.eventQueueEntries.add(new Spine.EventQueue.EventQueueEntry.$ctor1(Spine.EventQueue.EventType.End, entry));
                if (!Bridge.staticEquals(this.AnimationsChanged, null)) {
                    this.AnimationsChanged();
                }
            },
            /*Spine.EventQueue.End end.*/

            /*Spine.EventQueue.Dispose start.*/
            Dispose: function (entry) {
if ( TRACE ) { TRACE( "Spine.EventQueue#Dispose", this ); }

                this.eventQueueEntries.add(new Spine.EventQueue.EventQueueEntry.$ctor1(Spine.EventQueue.EventType.Dispose, entry));
            },
            /*Spine.EventQueue.Dispose end.*/

            /*Spine.EventQueue.Complete start.*/
            Complete: function (entry) {
if ( TRACE ) { TRACE( "Spine.EventQueue#Complete", this ); }

                this.eventQueueEntries.add(new Spine.EventQueue.EventQueueEntry.$ctor1(Spine.EventQueue.EventType.Complete, entry));
            },
            /*Spine.EventQueue.Complete end.*/

            /*Spine.EventQueue.Event start.*/
            Event: function (entry, e) {
if ( TRACE ) { TRACE( "Spine.EventQueue#Event", this ); }

                this.eventQueueEntries.add(new Spine.EventQueue.EventQueueEntry.$ctor1(Spine.EventQueue.EventType.Event, entry, e));
            },
            /*Spine.EventQueue.Event end.*/

            /*Spine.EventQueue.Drain start.*/
            /**
             * Raises all events in the queue and drains the queue.
             *
             * @instance
             * @this Spine.EventQueue
             * @memberof Spine.EventQueue
             * @return  {void}
             */
            Drain: function () {
if ( TRACE ) { TRACE( "Spine.EventQueue#Drain", this ); }

                var $step = 0,
                    $jumpFromFinally, 
                    entries, 
                    state, 
                    i, 
                    queueEntry, 
                    trackEntry, 
                    $t, 
                    $asyncBody = Bridge.fn.bind(this, function () {
                        for (;;) {
                            $step = System.Array.min([0,1,2,3,4,5,6,7,8,10,11], $step);
                            switch ($step) {
                                case 0: {
                                    if (this.drainDisabled) {
                                        return;
                                    }
                                    this.drainDisabled = true;

                                    entries = this.eventQueueEntries;
                                    state = this.state;

                                    // Don't cache entries.Count so callbacks can queue their own events (eg, call SetAnimation in AnimationState_Complete).
                                    i = 0;
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( i < entries.Count ) {
                                        $step = 2;
                                        continue;
                                    }
                                    $step = 11;
                                    continue;
                                }
                                case 2: {
                                    queueEntry = entries.getItem(i).$clone();
                                    trackEntry = queueEntry.entry;

                                    $t = queueEntry.type;
                                    if ($t === Spine.EventQueue.EventType.Start) {
                                        $step = 3;
                                        continue;
                                    }
                                    else if ($t === Spine.EventQueue.EventType.Interrupt) {
                                        $step = 4;
                                        continue;
                                    }
                                    else if ($t === Spine.EventQueue.EventType.End) {
                                        $step = 5;
                                        continue;
                                    }
                                    else if ($t === Spine.EventQueue.EventType.Dispose) {
                                        $step = 6;
                                        continue;
                                    }
                                    else if ($t === Spine.EventQueue.EventType.Complete) {
                                        $step = 7;
                                        continue;
                                    }
                                    else if ($t === Spine.EventQueue.EventType.Event) {
                                        $step = 8;
                                        continue;
                                    }
                                    $step = 9;
                                    continue;
                                }
                                case 3: {
                                    trackEntry.OnStart();
                                    state.OnStart(trackEntry);
                                    $step = 9;
                                    continue;
                                }
                                case 4: {
                                    trackEntry.OnInterrupt();
                                    state.OnInterrupt(trackEntry);
                                    $step = 9;
                                    continue;
                                }
                                case 5: {
                                    trackEntry.OnEnd();
                                    state.OnEnd(trackEntry);
                                    $step = 6;
                                    continue;
                                }
                                case 6: {
                                    trackEntry.OnDispose();
                                    state.OnDispose(trackEntry);
                                    this.trackEntryPool.Free(trackEntry);
                                    $step = 9;
                                    continue;
                                }
                                case 7: {
                                    trackEntry.OnComplete();
                                    state.OnComplete(trackEntry);
                                    $step = 9;
                                    continue;
                                }
                                case 8: {
                                    trackEntry.OnEvent(queueEntry.e);
                                    state.OnEvent(trackEntry, queueEntry.e);
                                    $step = 9;
                                    continue;
                                }

                                case 10: {
                                    i = (i + 1) | 0;
                                    $step = 1;
                                    continue;
                                }
                                case 11: {
                                    this.eventQueueEntries.clear();

                                    this.drainDisabled = false;
                                    return;
                                }
                                default: {
                                    return;
                                }
                            }
                        }
                    }, arguments);

                return $asyncBody();
            },
            /*Spine.EventQueue.Drain end.*/

            /*Spine.EventQueue.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.EventQueue#Clear", this ); }

                this.eventQueueEntries.clear();
            },
            /*Spine.EventQueue.Clear end.*/


        }
    });
    /*Spine.EventQueue end.*/

    /*Spine.EventQueue+EventQueueEntry start.*/
    Bridge.define("Spine.EventQueue.EventQueueEntry", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.EventQueue.EventQueueEntry#getDefaultValue", this ); }
 return new Spine.EventQueue.EventQueueEntry(); }
            }
        },
        fields: {
            type: 0,
            entry: null,
            e: null
        },
        ctors: {
            $ctor1: function (eventType, trackEntry, e) {
if ( TRACE ) { TRACE( "Spine.EventQueue.EventQueueEntry#$ctor1", this ); }

                if (e === void 0) { e = null; }

                this.$initialize();
                this.type = eventType;
                this.entry = trackEntry;
                this.e = e;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.EventQueue.EventQueueEntry#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.EventQueue.EventQueueEntry#getHashCode", this ); }

                var h = Bridge.addHash([5412331426, this.type, this.entry, this.e]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.EventQueue.EventQueueEntry#equals", this ); }

                if (!Bridge.is(o, Spine.EventQueue.EventQueueEntry)) {
                    return false;
                }
                return Bridge.equals(this.type, o.type) && Bridge.equals(this.entry, o.entry) && Bridge.equals(this.e, o.e);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.EventQueue.EventQueueEntry#$clone", this ); }

                var s = to || new Spine.EventQueue.EventQueueEntry();
                s.type = this.type;
                s.entry = this.entry;
                s.e = this.e;
                return s;
            }
        }
    });
    /*Spine.EventQueue+EventQueueEntry end.*/

    /*Spine.EventQueue+EventType start.*/
    Bridge.define("Spine.EventQueue.EventType", {
        $kind: 1006,
        statics: {
            fields: {
                Start: 0,
                Interrupt: 1,
                End: 2,
                Dispose: 3,
                Complete: 4,
                Event: 5
            }
        }
    });
    /*Spine.EventQueue+EventType end.*/

    /*Spine.ExposedList$1 start.*/
    Bridge.define("Spine.ExposedList$1", function (T) { return {
        inherits: [System.Collections.Generic.IEnumerable$1(T)],
        statics: {
            fields: {
                DefaultCapacity: 0,
                EmptyArray: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#init", this ); }

                    this.DefaultCapacity = 4;
                    this.EmptyArray = System.Array.init(0, function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                }
            },
            methods: {
                /*Spine.ExposedList$1.CheckMatch:static start.*/
                CheckMatch: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#CheckMatch", this ); }

                    if (Bridge.staticEquals(match, null)) {
                        throw new System.ArgumentNullException.$ctor1("match");
                    }
                },
                /*Spine.ExposedList$1.CheckMatch:static end.*/


            }
        },
        fields: {
            Items: null,
            Count: 0,
            version: 0
        },
        props: {
            Capacity: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Capacity#get", this ); }

                    return this.Items.length;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Capacity#set", this ); }

                    if ((value >>> 0) < (this.Count >>> 0)) {
                        throw new System.ArgumentOutOfRangeException.ctor();
                    }

                    System.Array.resize(Bridge.ref(this, "Items"), value, function () {
                        return Bridge.getDefaultValue(T);
                    }, T);
                }
            }
        },
        alias: ["System$Collections$Generic$IEnumerable$1$GetEnumerator", "System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(T) + "$GetEnumerator"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#ctor", this ); }

                this.$initialize();
                this.Items = Spine.ExposedList$1(T).EmptyArray;
            },
            $ctor2: function (collection) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#$ctor2", this ); }

                this.$initialize();
                this.CheckCollection(collection);

                // initialize to needed size (if determinable)
                var c = Bridge.as(collection, System.Collections.Generic.ICollection$1(T));
                if (c == null) {
                    this.Items = Spine.ExposedList$1(T).EmptyArray;
                    this.AddEnumerable(collection);
                } else {
                    this.Items = System.Array.init(System.Array.getCount(c, T), function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                    this.AddCollection(c);
                }
            },
            $ctor3: function (capacity) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#$ctor3", this ); }

                this.$initialize();
                if (capacity < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("capacity");
                }
                this.Items = System.Array.init(capacity, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
            },
            $ctor1: function (data, size) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#$ctor1", this ); }

                this.$initialize();
                this.Items = data;
                this.Count = size;
            }
        },
        methods: {
            /*Spine.ExposedList$1.Add start.*/
            Add: function (item) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Add", this ); }

                // If we check to see if we need to grow before trying to grow
                // we can speed things up by 25%
                if (this.Count === this.Items.length) {
                    this.GrowIfNeeded(1);
                }
                this.Items[Bridge.identity(this.Count, ((this.Count = (this.Count + 1) | 0)))] = Bridge.rValue(item);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Add end.*/

            /*Spine.ExposedList$1.GrowIfNeeded start.*/
            GrowIfNeeded: function (addedCount) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#GrowIfNeeded", this ); }

                var minimumSize = (this.Count + addedCount) | 0;
                if (minimumSize > this.Items.length) {
                    this.Capacity = Math.max(Math.max(Bridge.Int.mul(this.Capacity, 2), Spine.ExposedList$1(T).DefaultCapacity), minimumSize);
                }
            },
            /*Spine.ExposedList$1.GrowIfNeeded end.*/

            /*Spine.ExposedList$1.Resize start.*/
            Resize: function (newSize) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Resize", this ); }

                var itemsLength = this.Items.length;
                var oldItems = this.Items;
                if (newSize > itemsLength) {
                    System.Array.resize(Bridge.ref(this, "Items"), newSize, function () {
                        return Bridge.getDefaultValue(T);
                    }, T);
                    //				var newItems = new T[newSize];
                    //				Array.Copy(oldItems, newItems, Count);
                    //				Items = newItems;
                } else if (newSize < itemsLength) {
                    // Allow nulling of T reference type to allow GC.
                    for (var i = newSize; i < itemsLength; i = (i + 1) | 0) {
                        oldItems[i] = Bridge.getDefaultValue(T);
                    }
                }
                this.Count = newSize;
                return this;
            },
            /*Spine.ExposedList$1.Resize end.*/

            /*Spine.ExposedList$1.EnsureCapacity start.*/
            EnsureCapacity: function (min) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#EnsureCapacity", this ); }

                if (this.Items.length < min) {
                    var newCapacity = this.Items.length === 0 ? Spine.ExposedList$1(T).DefaultCapacity : Bridge.Int.mul(this.Items.length, 2);
                    //if ((uint)newCapacity > Array.MaxArrayLength) newCapacity = Array.MaxArrayLength;
                    if (newCapacity < min) {
                        newCapacity = min;
                    }
                    this.Capacity = newCapacity;
                }
            },
            /*Spine.ExposedList$1.EnsureCapacity end.*/

            /*Spine.ExposedList$1.CheckRange start.*/
            CheckRange: function (index, count) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#CheckRange", this ); }

                if (index < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }

                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("count");
                }

                if ((((index >>> 0) + (count >>> 0)) >>> 0) > (this.Count >>> 0)) {
                    throw new System.ArgumentException.$ctor1("index and count exceed length of list");
                }
            },
            /*Spine.ExposedList$1.CheckRange end.*/

            /*Spine.ExposedList$1.AddCollection start.*/
            AddCollection: function (collection) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#AddCollection", this ); }

                var collectionCount = System.Array.getCount(collection, T);
                if (collectionCount === 0) {
                    return;
                }

                this.GrowIfNeeded(collectionCount);
                System.Array.copyTo(collection, this.Items, this.Count, T);
                this.Count = (this.Count + collectionCount) | 0;
            },
            /*Spine.ExposedList$1.AddCollection end.*/

            /*Spine.ExposedList$1.AddEnumerable start.*/
            AddEnumerable: function (enumerable) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#AddEnumerable", this ); }

                var $t;
                $t = Bridge.getEnumerator(enumerable, T);
                try {
                    while ($t.moveNext()) {
                        var t = Bridge.rValue($t.Current);
                        this.Add(Bridge.rValue(t));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.ExposedList$1.AddEnumerable end.*/

            /*Spine.ExposedList$1.AddRange start.*/
            AddRange: function (list) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#AddRange", this ); }

                this.CheckCollection(list);

                var collectionCount = list.Count;
                if (collectionCount === 0) {
                    return;
                }

                this.GrowIfNeeded(collectionCount);
                list.CopyTo$1(this.Items, this.Count);
                this.Count = (this.Count + collectionCount) | 0;

                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.AddRange end.*/

            /*Spine.ExposedList$1.AddRange$1 start.*/
            AddRange$1: function (collection) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#AddRange$1", this ); }

                this.CheckCollection(collection);

                var c = Bridge.as(collection, System.Collections.Generic.ICollection$1(T));
                if (c != null) {
                    this.AddCollection(c);
                } else {
                    this.AddEnumerable(collection);
                }
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.AddRange$1 end.*/

            /*Spine.ExposedList$1.BinarySearch start.*/
            BinarySearch: function (item) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#BinarySearch", this ); }

                return System.Array.binarySearch(this.Items, 0, this.Count, Bridge.rValue(item));
            },
            /*Spine.ExposedList$1.BinarySearch end.*/

            /*Spine.ExposedList$1.BinarySearch$1 start.*/
            BinarySearch$1: function (item, comparer) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#BinarySearch$1", this ); }

                return System.Array.binarySearch(this.Items, 0, this.Count, Bridge.rValue(item), comparer);
            },
            /*Spine.ExposedList$1.BinarySearch$1 end.*/

            /*Spine.ExposedList$1.BinarySearch$2 start.*/
            BinarySearch$2: function (index, count, item, comparer) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#BinarySearch$2", this ); }

                this.CheckRange(index, count);
                return System.Array.binarySearch(this.Items, index, count, Bridge.rValue(item), comparer);
            },
            /*Spine.ExposedList$1.BinarySearch$2 end.*/

            /*Spine.ExposedList$1.Clear start.*/
            Clear: function (clearArray) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Clear", this ); }

                if (clearArray === void 0) { clearArray = true; }
                if (clearArray) {
                    System.Array.fill(this.Items, function () {
                        return Bridge.getDefaultValue(T);
                    }, 0, this.Items.length);
                }

                this.Count = 0;
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Clear end.*/

            /*Spine.ExposedList$1.Contains start.*/
            Contains: function (item) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Contains", this ); }

                return System.Array.indexOfT(this.Items, Bridge.rValue(item), 0, this.Count) !== -1;
            },
            /*Spine.ExposedList$1.Contains end.*/

            /*Spine.ExposedList$1.ConvertAll start.*/
            ConvertAll: function (TOutput, converter) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#ConvertAll", this ); }

                if (Bridge.staticEquals(converter, null)) {
                    throw new System.ArgumentNullException.$ctor1("converter");
                }
                var u = new (Spine.ExposedList$1(TOutput)).$ctor3(this.Count);
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    u.Items[i] = Bridge.rValue(converter(Bridge.rValue(this.Items[i])));
                }

                u.Count = this.Count;
                return u;
            },
            /*Spine.ExposedList$1.ConvertAll end.*/

            /*Spine.ExposedList$1.CopyTo start.*/
            CopyTo: function (array) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#CopyTo", this ); }

                System.Array.copy(this.Items, 0, array, 0, this.Count);
            },
            /*Spine.ExposedList$1.CopyTo end.*/

            /*Spine.ExposedList$1.CopyTo$1 start.*/
            CopyTo$1: function (array, arrayIndex) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#CopyTo$1", this ); }

                System.Array.copy(this.Items, 0, array, arrayIndex, this.Count);
            },
            /*Spine.ExposedList$1.CopyTo$1 end.*/

            /*Spine.ExposedList$1.CopyTo$2 start.*/
            CopyTo$2: function (index, array, arrayIndex, count) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#CopyTo$2", this ); }

                this.CheckRange(index, count);
                System.Array.copy(this.Items, index, array, arrayIndex, count);
            },
            /*Spine.ExposedList$1.CopyTo$2 end.*/

            /*Spine.ExposedList$1.Exists start.*/
            Exists: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Exists", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                return this.GetIndex(0, this.Count, match) !== -1;
            },
            /*Spine.ExposedList$1.Exists end.*/

            /*Spine.ExposedList$1.Find start.*/
            Find: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Find", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                var i = this.GetIndex(0, this.Count, match);
                return (i !== -1) ? Bridge.rValue(this.Items[i]) : Bridge.getDefaultValue(T);
            },
            /*Spine.ExposedList$1.Find end.*/

            /*Spine.ExposedList$1.FindAll start.*/
            FindAll: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindAll", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                return this.FindAllList(match);
            },
            /*Spine.ExposedList$1.FindAll end.*/

            /*Spine.ExposedList$1.FindAllList start.*/
            FindAllList: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindAllList", this ); }

                var results = new (Spine.ExposedList$1(T)).ctor();
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    if (match(Bridge.rValue(this.Items[i]))) {
                        results.Add(Bridge.rValue(this.Items[i]));
                    }
                }

                return results;
            },
            /*Spine.ExposedList$1.FindAllList end.*/

            /*Spine.ExposedList$1.FindIndex$2 start.*/
            FindIndex$2: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindIndex$2", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                return this.GetIndex(0, this.Count, match);
            },
            /*Spine.ExposedList$1.FindIndex$2 end.*/

            /*Spine.ExposedList$1.FindIndex$1 start.*/
            FindIndex$1: function (startIndex, match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindIndex$1", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                this.CheckIndex(startIndex);
                return this.GetIndex(startIndex, ((this.Count - startIndex) | 0), match);
            },
            /*Spine.ExposedList$1.FindIndex$1 end.*/

            /*Spine.ExposedList$1.FindIndex start.*/
            FindIndex: function (startIndex, count, match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindIndex", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                this.CheckRange(startIndex, count);
                return this.GetIndex(startIndex, count, match);
            },
            /*Spine.ExposedList$1.FindIndex end.*/

            /*Spine.ExposedList$1.GetIndex start.*/
            GetIndex: function (startIndex, count, match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#GetIndex", this ); }

                var end = (startIndex + count) | 0;
                for (var i = startIndex; i < end; i = (i + 1) | 0) {
                    if (match(Bridge.rValue(this.Items[i]))) {
                        return i;
                    }
                }

                return -1;
            },
            /*Spine.ExposedList$1.GetIndex end.*/

            /*Spine.ExposedList$1.FindLast start.*/
            FindLast: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindLast", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                var i = this.GetLastIndex(0, this.Count, match);
                return i === -1 ? Bridge.getDefaultValue(T) : Bridge.rValue(this.Items[i]);
            },
            /*Spine.ExposedList$1.FindLast end.*/

            /*Spine.ExposedList$1.FindLastIndex$2 start.*/
            FindLastIndex$2: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindLastIndex$2", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                return this.GetLastIndex(0, this.Count, match);
            },
            /*Spine.ExposedList$1.FindLastIndex$2 end.*/

            /*Spine.ExposedList$1.FindLastIndex$1 start.*/
            FindLastIndex$1: function (startIndex, match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindLastIndex$1", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                this.CheckIndex(startIndex);
                return this.GetLastIndex(0, ((startIndex + 1) | 0), match);
            },
            /*Spine.ExposedList$1.FindLastIndex$1 end.*/

            /*Spine.ExposedList$1.FindLastIndex start.*/
            FindLastIndex: function (startIndex, count, match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindLastIndex", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                var start = (((startIndex - count) | 0) + 1) | 0;
                this.CheckRange(start, count);
                return this.GetLastIndex(start, count, match);
            },
            /*Spine.ExposedList$1.FindLastIndex end.*/

            /*Spine.ExposedList$1.GetLastIndex start.*/
            GetLastIndex: function (startIndex, count, match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#GetLastIndex", this ); }

                // unlike FindLastIndex, takes regular params for search range
                for (var i = (startIndex + count) | 0; i !== startIndex; ) {
                    if (match(Bridge.rValue(this.Items[((i = (i - 1) | 0))]))) {
                        return i;
                    }
                }
                return -1;
            },
            /*Spine.ExposedList$1.GetLastIndex end.*/

            /*Spine.ExposedList$1.ForEach start.*/
            ForEach: function (action) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#ForEach", this ); }

                if (Bridge.staticEquals(action, null)) {
                    throw new System.ArgumentNullException.$ctor1("action");
                }
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    action(Bridge.rValue(this.Items[i]));
                }
            },
            /*Spine.ExposedList$1.ForEach end.*/

            /*Spine.ExposedList$1.GetEnumerator start.*/
            GetEnumerator: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#GetEnumerator", this ); }

                return new (Spine.ExposedList$1.Enumerator(T)).$ctor1(this);
            },
            /*Spine.ExposedList$1.GetEnumerator end.*/

            /*Spine.ExposedList$1.System$Collections$Generic$IEnumerable$1$GetEnumerator start.*/
            System$Collections$Generic$IEnumerable$1$GetEnumerator: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#System$Collections$Generic$IEnumerable$1$GetEnumerator", this ); }

                return this.GetEnumerator().$clone();
            },
            /*Spine.ExposedList$1.System$Collections$Generic$IEnumerable$1$GetEnumerator end.*/

            /*Spine.ExposedList$1.System$Collections$IEnumerable$GetEnumerator start.*/
            System$Collections$IEnumerable$GetEnumerator: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#System$Collections$IEnumerable$GetEnumerator", this ); }

                return this.GetEnumerator().$clone();
            },
            /*Spine.ExposedList$1.System$Collections$IEnumerable$GetEnumerator end.*/

            /*Spine.ExposedList$1.GetRange start.*/
            GetRange: function (index, count) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#GetRange", this ); }

                this.CheckRange(index, count);
                var tmpArray = System.Array.init(count, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                System.Array.copy(this.Items, index, tmpArray, 0, count);
                return new (Spine.ExposedList$1(T)).$ctor1(tmpArray, count);
            },
            /*Spine.ExposedList$1.GetRange end.*/

            /*Spine.ExposedList$1.IndexOf start.*/
            IndexOf: function (item) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#IndexOf", this ); }

                return System.Array.indexOfT(this.Items, Bridge.rValue(item), 0, this.Count);
            },
            /*Spine.ExposedList$1.IndexOf end.*/

            /*Spine.ExposedList$1.IndexOf$1 start.*/
            IndexOf$1: function (item, index) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#IndexOf$1", this ); }

                this.CheckIndex(index);
                return System.Array.indexOfT(this.Items, Bridge.rValue(item), index, ((this.Count - index) | 0));
            },
            /*Spine.ExposedList$1.IndexOf$1 end.*/

            /*Spine.ExposedList$1.IndexOf$2 start.*/
            IndexOf$2: function (item, index, count) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#IndexOf$2", this ); }

                if (index < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }

                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("count");
                }

                if ((((index >>> 0) + (count >>> 0)) >>> 0) > (this.Count >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index and count exceed length of list");
                }

                return System.Array.indexOfT(this.Items, Bridge.rValue(item), index, count);
            },
            /*Spine.ExposedList$1.IndexOf$2 end.*/

            /*Spine.ExposedList$1.Shift start.*/
            Shift: function (start, delta) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Shift", this ); }

                if (delta < 0) {
                    start = (start - delta) | 0;
                }

                if (start < this.Count) {
                    System.Array.copy(this.Items, start, this.Items, ((start + delta) | 0), ((this.Count - start) | 0));
                }

                this.Count = (this.Count + delta) | 0;

                if (delta < 0) {
                    System.Array.fill(this.Items, function () {
                        return Bridge.getDefaultValue(T);
                    }, this.Count, ((-delta) | 0));
                }
            },
            /*Spine.ExposedList$1.Shift end.*/

            /*Spine.ExposedList$1.CheckIndex start.*/
            CheckIndex: function (index) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#CheckIndex", this ); }

                if (index < 0 || (index >>> 0) > (this.Count >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }
            },
            /*Spine.ExposedList$1.CheckIndex end.*/

            /*Spine.ExposedList$1.Insert start.*/
            Insert: function (index, item) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Insert", this ); }

                this.CheckIndex(index);
                if (this.Count === this.Items.length) {
                    this.GrowIfNeeded(1);
                }
                this.Shift(index, 1);
                this.Items[index] = Bridge.rValue(item);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Insert end.*/

            /*Spine.ExposedList$1.CheckCollection start.*/
            CheckCollection: function (collection) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#CheckCollection", this ); }

                if (collection == null) {
                    throw new System.ArgumentNullException.$ctor1("collection");
                }
            },
            /*Spine.ExposedList$1.CheckCollection end.*/

            /*Spine.ExposedList$1.InsertRange start.*/
            InsertRange: function (index, collection) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#InsertRange", this ); }

                this.CheckCollection(collection);
                this.CheckIndex(index);
                if (Bridge.referenceEquals(collection, this)) {
                    var buffer = System.Array.init(this.Count, function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                    this.CopyTo$1(buffer, 0);
                    this.GrowIfNeeded(this.Count);
                    this.Shift(index, buffer.length);
                    System.Array.copy(buffer, 0, this.Items, index, buffer.length);
                } else {
                    var c = Bridge.as(collection, System.Collections.Generic.ICollection$1(T));
                    if (c != null) {
                        this.InsertCollection(index, c);
                    } else {
                        this.InsertEnumeration(index, collection);
                    }
                }
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.InsertRange end.*/

            /*Spine.ExposedList$1.InsertCollection start.*/
            InsertCollection: function (index, collection) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#InsertCollection", this ); }

                var collectionCount = System.Array.getCount(collection, T);
                this.GrowIfNeeded(collectionCount);

                this.Shift(index, collectionCount);
                System.Array.copyTo(collection, this.Items, index, T);
            },
            /*Spine.ExposedList$1.InsertCollection end.*/

            /*Spine.ExposedList$1.InsertEnumeration start.*/
            InsertEnumeration: function (index, enumerable) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#InsertEnumeration", this ); }

                var $t;
                $t = Bridge.getEnumerator(enumerable, T);
                try {
                    while ($t.moveNext()) {
                        var t = Bridge.rValue($t.Current);
                        this.Insert(Bridge.identity(index, ((index = (index + 1) | 0))), Bridge.rValue(t));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.ExposedList$1.InsertEnumeration end.*/

            /*Spine.ExposedList$1.LastIndexOf start.*/
            LastIndexOf: function (item) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#LastIndexOf", this ); }

                return System.Array.lastIndexOfT(this.Items, Bridge.rValue(item), ((this.Count - 1) | 0), this.Count);
            },
            /*Spine.ExposedList$1.LastIndexOf end.*/

            /*Spine.ExposedList$1.LastIndexOf$1 start.*/
            LastIndexOf$1: function (item, index) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#LastIndexOf$1", this ); }

                this.CheckIndex(index);
                return System.Array.lastIndexOfT(this.Items, Bridge.rValue(item), index, ((index + 1) | 0));
            },
            /*Spine.ExposedList$1.LastIndexOf$1 end.*/

            /*Spine.ExposedList$1.LastIndexOf$2 start.*/
            LastIndexOf$2: function (item, index, count) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#LastIndexOf$2", this ); }

                if (index < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor3("index", Bridge.box(index, System.Int32), "index is negative");
                }

                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor3("count", Bridge.box(count, System.Int32), "count is negative");
                }

                if (((((index - count) | 0) + 1) | 0) < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor3("count", Bridge.box(count, System.Int32), "count is too large");
                }

                return System.Array.lastIndexOfT(this.Items, Bridge.rValue(item), index, count);
            },
            /*Spine.ExposedList$1.LastIndexOf$2 end.*/

            /*Spine.ExposedList$1.Remove start.*/
            Remove: function (item) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Remove", this ); }

                var loc = this.IndexOf(Bridge.rValue(item));
                if (loc !== -1) {
                    this.RemoveAt(loc);
                }

                return loc !== -1;
            },
            /*Spine.ExposedList$1.Remove end.*/

            /*Spine.ExposedList$1.RemoveAll start.*/
            RemoveAll: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#RemoveAll", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                var i = 0;
                var j = 0;

                // Find the first item to remove
                for (i = 0; i < this.Count; i = (i + 1) | 0) {
                    if (match(Bridge.rValue(this.Items[i]))) {
                        break;
                    }
                }

                if (i === this.Count) {
                    return 0;
                }

                this.version = (this.version + 1) | 0;

                // Remove any additional items
                for (j = (i + 1) | 0; j < this.Count; j = (j + 1) | 0) {
                    if (!match(Bridge.rValue(this.Items[j]))) {
                        this.Items[Bridge.identity(i, ((i = (i + 1) | 0)))] = Bridge.rValue(this.Items[j]);
                    }
                }
                if (((j - i) | 0) > 0) {
                    System.Array.fill(this.Items, function () {
                        return Bridge.getDefaultValue(T);
                    }, i, ((j - i) | 0));
                }

                this.Count = i;
                return (((j - i) | 0));
            },
            /*Spine.ExposedList$1.RemoveAll end.*/

            /*Spine.ExposedList$1.RemoveAt start.*/
            RemoveAt: function (index) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#RemoveAt", this ); }

                if (index < 0 || (index >>> 0) >= (this.Count >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }
                this.Shift(index, -1);
                System.Array.fill(this.Items, function () {
                    return Bridge.getDefaultValue(T);
                }, this.Count, 1);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.RemoveAt end.*/

            /*Spine.ExposedList$1.Pop start.*/
            /**
             * Pops the last item of the list. If the list is empty, Pop throws an InvalidOperationException.
             *
             * @instance
             * @public
             * @this Spine.ExposedList$1
             * @memberof Spine.ExposedList$1
             * @return  {T}
             */
            Pop: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Pop", this ); }

                if (this.Count === 0) {
                    throw new System.InvalidOperationException.$ctor1("List is empty. Nothing to pop.");
                }

                var i = (this.Count - 1) | 0;
                var item = Bridge.rValue(this.Items[i]);
                this.Items[i] = Bridge.getDefaultValue(T);
                this.Count = (this.Count - 1) | 0;
                this.version = (this.version + 1) | 0;
                return Bridge.rValue(item);
            },
            /*Spine.ExposedList$1.Pop end.*/

            /*Spine.ExposedList$1.RemoveRange start.*/
            RemoveRange: function (index, count) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#RemoveRange", this ); }

                this.CheckRange(index, count);
                if (count > 0) {
                    this.Shift(index, ((-count) | 0));
                    System.Array.fill(this.Items, function () {
                        return Bridge.getDefaultValue(T);
                    }, this.Count, count);
                    this.version = (this.version + 1) | 0;
                }
            },
            /*Spine.ExposedList$1.RemoveRange end.*/

            /*Spine.ExposedList$1.Reverse start.*/
            Reverse: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Reverse", this ); }

                System.Array.reverse(this.Items, 0, this.Count);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Reverse end.*/

            /*Spine.ExposedList$1.Reverse$1 start.*/
            Reverse$1: function (index, count) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Reverse$1", this ); }

                this.CheckRange(index, count);
                System.Array.reverse(this.Items, index, count);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Reverse$1 end.*/

            /*Spine.ExposedList$1.Sort start.*/
            Sort: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Sort", this ); }

                System.Array.sort(this.Items, 0, this.Count, new (System.Collections.Generic.Comparer$1(T))(System.Collections.Generic.Comparer$1.$default.fn));
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Sort end.*/

            /*Spine.ExposedList$1.Sort$1 start.*/
            Sort$1: function (comparer) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Sort$1", this ); }

                System.Array.sort(this.Items, 0, this.Count, comparer);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Sort$1 end.*/

            /*Spine.ExposedList$1.Sort$2 start.*/
            Sort$2: function (comparison) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Sort$2", this ); }

                System.Array.sort(this.Items, comparison);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Sort$2 end.*/

            /*Spine.ExposedList$1.Sort$3 start.*/
            Sort$3: function (index, count, comparer) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Sort$3", this ); }

                this.CheckRange(index, count);
                System.Array.sort(this.Items, index, count, comparer);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Sort$3 end.*/

            /*Spine.ExposedList$1.ToArray start.*/
            ToArray: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#ToArray", this ); }

                var t = System.Array.init(this.Count, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                System.Array.copy(this.Items, 0, t, 0, this.Count);

                return t;
            },
            /*Spine.ExposedList$1.ToArray end.*/

            /*Spine.ExposedList$1.TrimExcess start.*/
            TrimExcess: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#TrimExcess", this ); }

                this.Capacity = this.Count;
            },
            /*Spine.ExposedList$1.TrimExcess end.*/

            /*Spine.ExposedList$1.TrueForAll start.*/
            TrueForAll: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#TrueForAll", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);

                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    if (!match(Bridge.rValue(this.Items[i]))) {
                        return false;
                    }
                }

                return true;
            },
            /*Spine.ExposedList$1.TrueForAll end.*/


        },
        overloads: {
            "AddRange(IEnumerable<T>)": "AddRange$1",
            "BinarySearch(T, IComparer<T>)": "BinarySearch$1",
            "BinarySearch(int, int, T, IComparer<T>)": "BinarySearch$2",
            "CopyTo(T[], int)": "CopyTo$1",
            "CopyTo(int, T[], int, int)": "CopyTo$2",
            "FindIndex(Predicate<T>)": "FindIndex$2",
            "FindIndex(int, Predicate<T>)": "FindIndex$1",
            "FindLastIndex(Predicate<T>)": "FindLastIndex$2",
            "FindLastIndex(int, Predicate<T>)": "FindLastIndex$1",
            "IndexOf(T, int)": "IndexOf$1",
            "IndexOf(T, int, int)": "IndexOf$2",
            "LastIndexOf(T, int)": "LastIndexOf$1",
            "LastIndexOf(T, int, int)": "LastIndexOf$2",
            "Reverse(int, int)": "Reverse$1",
            "Sort(IComparer<T>)": "Sort$1",
            "Sort(Comparison<T>)": "Sort$2",
            "Sort(int, int, IComparer<T>)": "Sort$3"
        }
    }; });
    /*Spine.ExposedList$1 end.*/

    /*Spine.ExposedList$1+Enumerator start.*/
    Bridge.define("Spine.ExposedList$1.Enumerator", function (T) { return {
        inherits: [System.Collections.Generic.IEnumerator$1(T),System.IDisposable],
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#getDefaultValue", this ); }
 return new (Spine.ExposedList$1.Enumerator(T))(); }
            }
        },
        fields: {
            l: null,
            next: 0,
            ver: 0,
            current: Bridge.getDefaultValue(T)
        },
        props: {
            Current: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#Current#get", this ); }

                    return Bridge.rValue(this.current);
                }
            },
            System$Collections$IEnumerator$Current: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#System$Collections$IEnumerator$Current#get", this ); }

                    this.VerifyState();
                    if (this.next <= 0) {
                        throw new System.InvalidOperationException.ctor();
                    }
                    return this.current;
                }
            }
        },
        alias: [
            "Dispose", "System$IDisposable$Dispose",
            "moveNext", "System$Collections$IEnumerator$moveNext",
            "Current", ["System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1"]
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#init", this ); }

                this.current = Bridge.getDefaultValue(T);
            },
            $ctor1: function (l) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#$ctor1", this ); }

                Spine.ExposedList$1.Enumerator(T).ctor.call(this);
                this.l = l;
                this.ver = l.version;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.ExposedList$1+Enumerator.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#Dispose", this ); }

                this.l = null;
            },
            /*Spine.ExposedList$1+Enumerator.Dispose end.*/

            /*Spine.ExposedList$1+Enumerator.VerifyState start.*/
            VerifyState: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#VerifyState", this ); }

                if (this.l == null) {
                    throw new System.ObjectDisposedException.$ctor1(Bridge.Reflection.getTypeFullName(Spine.ExposedList$1.Enumerator(T)));
                }
                if (this.ver !== this.l.version) {
                    throw new System.InvalidOperationException.$ctor1("Collection was modified; enumeration operation may not execute.");
                }
            },
            /*Spine.ExposedList$1+Enumerator.VerifyState end.*/

            /*Spine.ExposedList$1+Enumerator.moveNext start.*/
            moveNext: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#moveNext", this ); }

                var $t;
                this.VerifyState();

                if (this.next < 0) {
                    return false;
                }

                if (this.next < this.l.Count) {
                    this.current = Bridge.rValue(($t = this.l.Items)[Bridge.identity(this.next, ((this.next = (this.next + 1) | 0)))]);
                    return true;
                }

                this.next = -1;
                return false;
            },
            /*Spine.ExposedList$1+Enumerator.moveNext end.*/

            /*Spine.ExposedList$1+Enumerator.System$Collections$IEnumerator$reset start.*/
            System$Collections$IEnumerator$reset: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#System$Collections$IEnumerator$reset", this ); }

                this.VerifyState();
                this.next = 0;
            },
            /*Spine.ExposedList$1+Enumerator.System$Collections$IEnumerator$reset end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#getHashCode", this ); }

                var h = Bridge.addHash([3788985113, this.l, this.next, this.ver, this.current]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#equals", this ); }

                if (!Bridge.is(o, Spine.ExposedList$1.Enumerator(T))) {
                    return false;
                }
                return Bridge.equals(this.l, o.l) && Bridge.equals(this.next, o.next) && Bridge.equals(this.ver, o.ver) && Bridge.equals(this.current, o.current);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#$clone", this ); }

                var s = to || new (Spine.ExposedList$1.Enumerator(T))();
                s.l = this.l;
                s.next = this.next;
                s.ver = this.ver;
                s.current = Bridge.rValue(this.current);
                return s;
            }
        },
        overloads: {
            "MoveNext()": "moveNext"
        }
    }; });
    /*Spine.ExposedList$1+Enumerator end.*/

    /*Spine.Format start.*/
    Bridge.define("Spine.Format", {
        $kind: 6,
        statics: {
            fields: {
                Alpha: 0,
                Intensity: 1,
                LuminanceAlpha: 2,
                RGB565: 3,
                RGBA4444: 4,
                RGB888: 5,
                RGBA8888: 6
            }
        }
    });
    /*Spine.Format end.*/

    /*Spine.IBoneTimeline start.*/
    /**
     * An interface for timelines which change the property of a bone.
     *
     * @abstract
     * @public
     * @class Spine.IBoneTimeline
     */
    Bridge.define("Spine.IBoneTimeline", {
        $kind: 3
    });
    /*Spine.IBoneTimeline end.*/

    /*Spine.IHasRendererObject start.*/
    Bridge.define("Spine.IHasRendererObject", {
        $kind: 3
    });
    /*Spine.IHasRendererObject end.*/

    /*Spine.IInterpolation start.*/
    Bridge.define("Spine.IInterpolation", {
        statics: {
            fields: {
                Pow2: null,
                Pow2Out: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.IInterpolation#init", this ); }

                    this.Pow2 = new Spine.Pow(2);
                    this.Pow2Out = new Spine.PowOut(2);
                }
            }
        },
        methods: {
            /*Spine.IInterpolation.Apply start.*/
            Apply: function (start, end, a) {
if ( TRACE ) { TRACE( "Spine.IInterpolation#Apply", this ); }

                return start + (end - start) * this.Apply$1(a);
            },
            /*Spine.IInterpolation.Apply end.*/


        }
    });
    /*Spine.IInterpolation end.*/

    /*Spine.Json start.*/
    Bridge.define("Spine.Json", {
        statics: {
            methods: {
                /*Spine.Json.Deserialize:static start.*/
                Deserialize: function (text) {
if ( TRACE ) { TRACE( "Spine.Json#Deserialize", this ); }

                    var parser = new SharpJson.JsonDecoder();
                    parser.parseNumbersAsFloat = true;
                    return parser.Decode(text.ReadToEnd());
                },
                /*Spine.Json.Deserialize:static end.*/


            }
        }
    });
    /*Spine.Json end.*/

    /*Spine.MathUtils start.*/
    Bridge.define("Spine.MathUtils", {
        statics: {
            fields: {
                PI: 0,
                PI2: 0,
                RadDeg: 0,
                DegRad: 0,
                random: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.MathUtils#init", this ); }

                    this.PI = 3.14159274;
                    this.PI2 = 6.28318548;
                    this.RadDeg = 57.2957764;
                    this.DegRad = 0.0174532924;
                    this.random = new System.Random.ctor();
                }
            },
            methods: {
                /*Spine.MathUtils.Sin:static start.*/
                /**
                 * Returns the sine of a given angle in radians.
                 *
                 * @static
                 * @public
                 * @this Spine.MathUtils
                 * @memberof Spine.MathUtils
                 * @param   {number}    radians
                 * @return  {number}
                 */
                Sin: function (radians) {
if ( TRACE ) { TRACE( "Spine.MathUtils#Sin", this ); }

                    return Math.sin(radians);
                },
                /*Spine.MathUtils.Sin:static end.*/

                /*Spine.MathUtils.Cos:static start.*/
                /**
                 * Returns the cosine of a given angle in radians.
                 *
                 * @static
                 * @public
                 * @this Spine.MathUtils
                 * @memberof Spine.MathUtils
                 * @param   {number}    radians
                 * @return  {number}
                 */
                Cos: function (radians) {
if ( TRACE ) { TRACE( "Spine.MathUtils#Cos", this ); }

                    return Math.cos(radians);
                },
                /*Spine.MathUtils.Cos:static end.*/

                /*Spine.MathUtils.SinDeg:static start.*/
                /**
                 * Returns the sine of a given angle in degrees.
                 *
                 * @static
                 * @public
                 * @this Spine.MathUtils
                 * @memberof Spine.MathUtils
                 * @param   {number}    degrees
                 * @return  {number}
                 */
                SinDeg: function (degrees) {
if ( TRACE ) { TRACE( "Spine.MathUtils#SinDeg", this ); }

                    return Math.sin(degrees * Spine.MathUtils.DegRad);
                },
                /*Spine.MathUtils.SinDeg:static end.*/

                /*Spine.MathUtils.CosDeg:static start.*/
                /**
                 * Returns the cosine of a given angle in degrees.
                 *
                 * @static
                 * @public
                 * @this Spine.MathUtils
                 * @memberof Spine.MathUtils
                 * @param   {number}    degrees
                 * @return  {number}
                 */
                CosDeg: function (degrees) {
if ( TRACE ) { TRACE( "Spine.MathUtils#CosDeg", this ); }

                    return Math.cos(degrees * Spine.MathUtils.DegRad);
                },
                /*Spine.MathUtils.CosDeg:static end.*/

                /*Spine.MathUtils.Atan2:static start.*/
                /**
                 * Returns the atan2 using Math.Atan2.
                 *
                 * @static
                 * @public
                 * @this Spine.MathUtils
                 * @memberof Spine.MathUtils
                 * @param   {number}    y    
                 * @param   {number}    x
                 * @return  {number}
                 */
                Atan2: function (y, x) {
if ( TRACE ) { TRACE( "Spine.MathUtils#Atan2", this ); }

                    return Math.atan2(y, x);
                },
                /*Spine.MathUtils.Atan2:static end.*/

                /*Spine.MathUtils.Clamp:static start.*/
                Clamp: function (value, min, max) {
if ( TRACE ) { TRACE( "Spine.MathUtils#Clamp", this ); }

                    if (value < min) {
                        return min;
                    }
                    if (value > max) {
                        return max;
                    }
                    return value;
                },
                /*Spine.MathUtils.Clamp:static end.*/

                /*Spine.MathUtils.RandomTriangle:static start.*/
                RandomTriangle: function (min, max) {
if ( TRACE ) { TRACE( "Spine.MathUtils#RandomTriangle", this ); }

                    return Spine.MathUtils.RandomTriangle$1(min, max, (min + max) * 0.5);
                },
                /*Spine.MathUtils.RandomTriangle:static end.*/

                /*Spine.MathUtils.RandomTriangle$1:static start.*/
                RandomTriangle$1: function (min, max, mode) {
if ( TRACE ) { TRACE( "Spine.MathUtils#RandomTriangle$1", this ); }

                    var u = Spine.MathUtils.random.NextDouble();
                    var d = max - min;
                    if (u <= (mode - min) / d) {
                        return min + Math.sqrt(u * d * (mode - min));
                    }
                    return max - Math.sqrt((1 - u) * d * (max - mode));
                },
                /*Spine.MathUtils.RandomTriangle$1:static end.*/


            }
        }
    });
    /*Spine.MathUtils end.*/

    /*Spine.MixBlend start.*/
    /**
     * Controls how a timeline is mixed with the setup or current pose.
     *
     * @public
     * @class Spine.MixBlend
     * @see {@link Timeline.Apply(Skeleton, float, float, ExposedList, float, MixBlend, MixDirection)}
     */
    Bridge.define("Spine.MixBlend", {
        $kind: 6,
        statics: {
            fields: {
                /**
                 * Transitions from the setup value to the timeline value (the current value is not used). Before the first key, the setup
                           value is set.
                 *
                 * @static
                 * @public
                 * @memberof Spine.MixBlend
                 * @constant
                 * @default 0
                 * @type Spine.MixBlend
                 */
                Setup: 0,
                /**
                 * <p>Transitions from the current value to the timeline value. Before the first key, transitions from the current value to
                 the setup value. Timelines which perform instant transitions, such as {@link } or
                 {@link }, use the setup value before the first key.</p><p><pre><code>First</code></pre> is intended for the first animations applied, not for animations layered on top of those.</p>
                 *
                 * @static
                 * @public
                 * @memberof Spine.MixBlend
                 * @constant
                 * @default 1
                 * @type Spine.MixBlend
                 */
                First: 1,
                /**
                 * <p>Transitions from the current value to the timeline value. No change is made before the first key (the current value is
                 kept until the first key).</p><p><pre><code>Replace</code></pre> is intended for animations layered on top of others, not for the first animations applied.</p>
                 *
                 * @static
                 * @public
                 * @memberof Spine.MixBlend
                 * @constant
                 * @default 2
                 * @type Spine.MixBlend
                 */
                Replace: 2,
                /**
                 * <p>Transitions from the current value to the current value plus the timeline value. No change is made before the first key
                 (the current value is kept until the first key).</p><p><pre><code>Add</code></pre> is intended for animations layered on top of others, not for the first animations applied.</p>
                 *
                 * @static
                 * @public
                 * @memberof Spine.MixBlend
                 * @constant
                 * @default 3
                 * @type Spine.MixBlend
                 */
                Add: 3
            }
        }
    });
    /*Spine.MixBlend end.*/

    /*Spine.MixDirection start.*/
    /**
     * Indicates whether a timeline's <pre><code>alpha</code></pre> is mixing out over time toward 0 (the setup or current pose value) or
     mixing in toward 1 (the timeline's value).
     *
     * @public
     * @class Spine.MixDirection
     * @see {@link Timeline.Apply(Skeleton, float, float, ExposedList, float, MixBlend, MixDirection)}
     */
    Bridge.define("Spine.MixDirection", {
        $kind: 6,
        statics: {
            fields: {
                In: 0,
                Out: 1
            }
        }
    });
    /*Spine.MixDirection end.*/

    /*Spine.Polygon start.*/
    Bridge.define("Spine.Polygon", {
        fields: {
            Vertices: null,
            Count: 0
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Polygon#ctor", this ); }

                this.$initialize();
                this.Vertices = System.Array.init(16, 0, System.Single);
            }
        }
    });
    /*Spine.Polygon end.*/

    /*Spine.Pool$1 start.*/
    Bridge.define("Spine.Pool$1", function (T) { return {
        fields: {
            max: 0,
            freeObjects: null,
            Peak: 0
        },
        props: {
            Count: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Pool$1#Count#get", this ); }

                    return this.freeObjects.Count;
                }
            }
        },
        ctors: {
            ctor: function (initialCapacity, max) {
if ( TRACE ) { TRACE( "Spine.Pool$1#ctor", this ); }

                if (initialCapacity === void 0) { initialCapacity = 16; }
                if (max === void 0) { max = 2147483647; }

                this.$initialize();
                this.freeObjects = new (System.Collections.Generic.Stack$1(T)).$ctor2(initialCapacity);
                this.max = max;
            }
        },
        methods: {
            /*Spine.Pool$1.Obtain start.*/
            Obtain: function () {
if ( TRACE ) { TRACE( "Spine.Pool$1#Obtain", this ); }

                return this.freeObjects.Count === 0 ? Bridge.createInstance(T) : this.freeObjects.Pop();
            },
            /*Spine.Pool$1.Obtain end.*/

            /*Spine.Pool$1.Free start.*/
            Free: function (obj) {
if ( TRACE ) { TRACE( "Spine.Pool$1#Free", this ); }

                if (Bridge.rValue(obj) == null) {
                    throw new System.ArgumentNullException.$ctor3("obj", "obj cannot be null");
                }
                if (this.freeObjects.Count < this.max) {
                    this.freeObjects.Push(Bridge.rValue(obj));
                    this.Peak = Math.max(this.Peak, this.freeObjects.Count);
                }
                this.Reset(Bridge.rValue(obj));
            },
            /*Spine.Pool$1.Free end.*/

            /*Spine.Pool$1.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Pool$1#Clear", this ); }

                this.freeObjects.Clear();
            },
            /*Spine.Pool$1.Clear end.*/

            /*Spine.Pool$1.Reset start.*/
            Reset: function (obj) {
if ( TRACE ) { TRACE( "Spine.Pool$1#Reset", this ); }

                var poolable = Bridge.as(Bridge.rValue(obj), Spine.Pool$1.IPoolable(T));
                if (poolable != null) {
                    poolable["Spine$Pool$1$IPoolable$" + Bridge.getTypeAlias(T) + "$Reset"]();
                }
            },
            /*Spine.Pool$1.Reset end.*/


        }
    }; });
    /*Spine.Pool$1 end.*/

    /*Spine.Pool$1+IPoolable start.*/
    Bridge.definei("Spine.Pool$1.IPoolable", function (T) { return {
        $kind: 1003
    }; });
    /*Spine.Pool$1+IPoolable end.*/

    /*Spine.PositionMode start.*/
    Bridge.define("Spine.PositionMode", {
        $kind: 6,
        statics: {
            fields: {
                Fixed: 0,
                Percent: 1
            }
        }
    });
    /*Spine.PositionMode end.*/

    /*Spine.RotateMode start.*/
    Bridge.define("Spine.RotateMode", {
        $kind: 6,
        statics: {
            fields: {
                Tangent: 0,
                Chain: 1,
                ChainScale: 2
            }
        }
    });
    /*Spine.RotateMode end.*/

    /*Spine.Skeleton start.*/
    Bridge.define("Spine.Skeleton", {
        statics: {
            methods: {
                /*Spine.Skeleton.SortReset:static start.*/
                SortReset: function (bones) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SortReset", this ); }

                    var bonesItems = bones.Items;
                    for (var i = 0, n = bones.Count; i < n; i = (i + 1) | 0) {
                        var bone = bonesItems[i];
                        if (!bone.active) {
                            continue;
                        }
                        if (bone.sorted) {
                            Spine.Skeleton.SortReset(bone.children);
                        }
                        bone.sorted = false;
                    }
                },
                /*Spine.Skeleton.SortReset:static end.*/


            }
        },
        fields: {
            data: null,
            bones: null,
            slots: null,
            drawOrder: null,
            ikConstraints: null,
            transformConstraints: null,
            pathConstraints: null,
            updateCache: null,
            updateCacheReset: null,
            skin: null,
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            time: 0,
            scaleX: 0,
            scaleY: 0,
            x: 0,
            y: 0
        },
        props: {
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#Data#get", this ); }

                    return this.data;
                }
            },
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#Bones#get", this ); }

                    return this.bones;
                }
            },
            UpdateCacheList: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#UpdateCacheList#get", this ); }

                    return this.updateCache;
                }
            },
            Slots: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#Slots#get", this ); }

                    return this.slots;
                }
            },
            DrawOrder: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#DrawOrder#get", this ); }

                    return this.drawOrder;
                }
            },
            IkConstraints: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#IkConstraints#get", this ); }

                    return this.ikConstraints;
                }
            },
            PathConstraints: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#PathConstraints#get", this ); }

                    return this.pathConstraints;
                }
            },
            TransformConstraints: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#TransformConstraints#get", this ); }

                    return this.transformConstraints;
                }
            },
            Skin: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#Skin#get", this ); }

                    return this.skin;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#Skin#set", this ); }

                    this.SetSkin(value);
                }
            },
            R: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#R#get", this ); }

                    return this.r;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#R#set", this ); }

                    this.r = value;
                }
            },
            G: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#G#get", this ); }

                    return this.g;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#G#set", this ); }

                    this.g = value;
                }
            },
            B: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#B#get", this ); }

                    return this.b;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#B#set", this ); }

                    this.b = value;
                }
            },
            A: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#A#get", this ); }

                    return this.a;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#A#set", this ); }

                    this.a = value;
                }
            },
            Time: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#Time#get", this ); }

                    return this.time;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#Time#set", this ); }

                    this.time = value;
                }
            },
            X: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#X#get", this ); }

                    return this.x;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#X#set", this ); }

                    this.x = value;
                }
            },
            Y: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#Y#get", this ); }

                    return this.y;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#Y#set", this ); }

                    this.y = value;
                }
            },
            ScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#ScaleX#get", this ); }

                    return this.scaleX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#ScaleX#set", this ); }

                    this.scaleX = value;
                }
            },
            ScaleY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#ScaleY#get", this ); }

                    return this.scaleY * (Spine.Bone.yDown ? -1 : 1);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#ScaleY#set", this ); }

                    this.scaleY = value;
                }
            },
            FlipX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#FlipX#get", this ); }

                    return this.scaleX < 0;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FlipX#set", this ); }

                    this.scaleX = value ? -1.0 : 1.0;
                }
            },
            FlipY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#FlipY#get", this ); }

                    return this.scaleY < 0;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FlipY#set", this ); }

                    this.scaleY = value ? -1.0 : 1.0;
                }
            },
            RootBone: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#RootBone#get", this ); }

                    var $t;
                    return this.bones.Count === 0 ? null : ($t = this.bones.Items)[0];
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#init", this ); }

                this.updateCache = new (Spine.ExposedList$1(Spine.IUpdatable)).ctor();
                this.updateCacheReset = new (Spine.ExposedList$1(Spine.Bone)).ctor();
                this.r = 1;
                this.g = 1;
                this.b = 1;
                this.a = 1;
                this.scaleX = 1;
                this.scaleY = 1;
            },
            ctor: function (data) {
if ( TRACE ) { TRACE( "Spine.Skeleton#ctor", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5, $t6;
                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                this.data = data;

                this.bones = new (Spine.ExposedList$1(Spine.Bone)).$ctor3(data.bones.Count);
                $t = Bridge.getEnumerator(data.bones);
                try {
                    while ($t.moveNext()) {
                        var boneData = $t.Current;
                        var bone;
                        if (boneData.parent == null) {
                            bone = new Spine.Bone(boneData, this, null);
                        } else {
                            var parent = ($t1 = this.bones.Items)[boneData.parent.index];
                            bone = new Spine.Bone(boneData, this, parent);
                            parent.children.Add(bone);
                        }
                        this.bones.Add(bone);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                this.slots = new (Spine.ExposedList$1(Spine.Slot)).$ctor3(data.slots.Count);
                this.drawOrder = new (Spine.ExposedList$1(Spine.Slot)).$ctor3(data.slots.Count);
                $t2 = Bridge.getEnumerator(data.slots);
                try {
                    while ($t2.moveNext()) {
                        var slotData = $t2.Current;
                        var bone1 = ($t3 = this.bones.Items)[slotData.boneData.index];
                        var slot = new Spine.Slot.$ctor1(slotData, bone1);
                        this.slots.Add(slot);
                        this.drawOrder.Add(slot);
                    }
                } finally {
                    if (Bridge.is($t2, System.IDisposable)) {
                        $t2.System$IDisposable$Dispose();
                    }
                }

                this.ikConstraints = new (Spine.ExposedList$1(Spine.IkConstraint)).$ctor3(data.ikConstraints.Count);
                $t4 = Bridge.getEnumerator(data.ikConstraints);
                try {
                    while ($t4.moveNext()) {
                        var ikConstraintData = $t4.Current;
                        this.ikConstraints.Add(new Spine.IkConstraint.$ctor1(ikConstraintData, this));
                    }
                } finally {
                    if (Bridge.is($t4, System.IDisposable)) {
                        $t4.System$IDisposable$Dispose();
                    }
                }

                this.transformConstraints = new (Spine.ExposedList$1(Spine.TransformConstraint)).$ctor3(data.transformConstraints.Count);
                $t5 = Bridge.getEnumerator(data.transformConstraints);
                try {
                    while ($t5.moveNext()) {
                        var transformConstraintData = $t5.Current;
                        this.transformConstraints.Add(new Spine.TransformConstraint.$ctor1(transformConstraintData, this));
                    }
                } finally {
                    if (Bridge.is($t5, System.IDisposable)) {
                        $t5.System$IDisposable$Dispose();
                    }
                }

                this.pathConstraints = new (Spine.ExposedList$1(Spine.PathConstraint)).$ctor3(data.pathConstraints.Count);
                $t6 = Bridge.getEnumerator(data.pathConstraints);
                try {
                    while ($t6.moveNext()) {
                        var pathConstraintData = $t6.Current;
                        this.pathConstraints.Add(new Spine.PathConstraint.$ctor1(pathConstraintData, this));
                    }
                } finally {
                    if (Bridge.is($t6, System.IDisposable)) {
                        $t6.System$IDisposable$Dispose();
                    }
                }

                this.UpdateCache();
                this.UpdateWorldTransform();
            }
        },
        methods: {
            /*Spine.Skeleton.UpdateCache start.*/
            /**
             * Caches information about bones and constraints. Must be called if the {@link } is modified or if bones, constraints, or
             constraints, or weighted path attachments are added or removed.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @return  {void}
             */
            UpdateCache: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#UpdateCache", this ); }

                var $step = 0,
                    $jumpFromFinally, 
                    updateCache, 
                    boneCount, 
                    bones, 
                    bone, 
                    skinBones, 
                    bone1, 
                    ikCount, 
                    transformCount, 
                    pathCount, 
                    ikConstraints, 
                    transformConstraints, 
                    pathConstraints, 
                    constraintCount, 
                    i2, 
                    ii, 
                    constraint, 
                    ii1, 
                    constraint1, 
                    ii2, 
                    constraint2, 
                    $asyncBody = Bridge.fn.bind(this, function () {
                        for (;;) {
                            $step = System.Array.min([0,1,2,3,4,5,7,8,9,10,11,13,14,15,16,17,19,20,22,23], $step);
                            switch ($step) {
                                case 0: {
                                    updateCache = this.updateCache;
                                    updateCache.Clear();
                                    this.updateCacheReset.Clear();

                                    boneCount = this.bones.Items.length;
                                    bones = this.bones;
                                    for (var i = 0; i < boneCount; i = (i + 1) | 0) {
                                        bone = bones.Items[i];
                                        bone.sorted = bone.data.skinRequired;
                                        bone.active = !bone.sorted;
                                    }
                                    if (this.skin != null) {
                                        skinBones = this.skin.bones.Items;
                                        for (var i1 = 0, n = this.skin.bones.Count; i1 < n; i1 = (i1 + 1) | 0) {
                                            bone1 = bones.Items[Bridge.cast(skinBones[i1], Spine.BoneData).index];
                                            do {
                                                bone1.sorted = false;
                                                bone1.active = true;
                                                bone1 = bone1.parent;
                                            } while (bone1 != null);
                                        }
                                    }

                                    ikCount = this.ikConstraints.Count;
                                    transformCount = this.transformConstraints.Count;
                                    pathCount = this.pathConstraints.Count;
                                    ikConstraints = this.ikConstraints;
                                    transformConstraints = this.transformConstraints;
                                    pathConstraints = this.pathConstraints;
                                    constraintCount = (((ikCount + transformCount) | 0) + pathCount) | 0;
                                    //outer:
                                    i2 = 0;
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( i2 < constraintCount ) {
                                        $step = 2;
                                        continue;
                                    }
                                    $step = 23;
                                    continue;
                                }
                                case 2: {
                                    ii = 0;
                                    $step = 3;
                                    continue;
                                }
                                case 3: {
                                    if ( ii < ikCount ) {
                                        $step = 4;
                                        continue;
                                    }
                                    $step = 8;
                                    continue;
                                }
                                case 4: {
                                    constraint = ikConstraints.Items[ii];
                                    if (constraint.data.order === i2) {
                                        $step = 5;
                                        continue;
                                    } 
                                    $step = 6;
                                    continue;
                                }
                                case 5: {
                                    this.SortIkConstraint(constraint);
                                    $step = 21;
                                    continue;//continue outer;
                                    $step = 6;
                                    continue;
                                }

                                case 7: {
                                    ii = (ii + 1) | 0;
                                    $step = 3;
                                    continue;
                                }
                                case 8: {
                                    ii1 = 0;
                                    $step = 9;
                                    continue;
                                }
                                case 9: {
                                    if ( ii1 < transformCount ) {
                                        $step = 10;
                                        continue;
                                    }
                                    $step = 14;
                                    continue;
                                }
                                case 10: {
                                    constraint1 = transformConstraints.Items[ii1];
                                    if (constraint1.data.order === i2) {
                                        $step = 11;
                                        continue;
                                    } 
                                    $step = 12;
                                    continue;
                                }
                                case 11: {
                                    this.SortTransformConstraint(constraint1);
                                    $step = 21;
                                    continue;//continue outer;
                                    $step = 12;
                                    continue;
                                }

                                case 13: {
                                    ii1 = (ii1 + 1) | 0;
                                    $step = 9;
                                    continue;
                                }
                                case 14: {
                                    ii2 = 0;
                                    $step = 15;
                                    continue;
                                }
                                case 15: {
                                    if ( ii2 < pathCount ) {
                                        $step = 16;
                                        continue;
                                    }
                                    $step = 20;
                                    continue;
                                }
                                case 16: {
                                    constraint2 = pathConstraints.Items[ii2];
                                    if (constraint2.data.order === i2) {
                                        $step = 17;
                                        continue;
                                    } 
                                    $step = 18;
                                    continue;
                                }
                                case 17: {
                                    this.SortPathConstraint(constraint2);
                                    $step = 21;
                                    continue;//continue outer;
                                    $step = 18;
                                    continue;
                                }

                                case 19: {
                                    ii2 = (ii2 + 1) | 0;
                                    $step = 15;
                                    continue;
                                }
                                case 20: {

                                }

                                case 22: {
                                    i2 = (i2 + 1) | 0;
                                    $step = 1;
                                    continue;
                                }
                                case 23: {
                                    for (var i3 = 0; i3 < boneCount; i3 = (i3 + 1) | 0) {
                                        this.SortBone(bones.Items[i3]);
                                    }
                                    return;
                                }
                                default: {
                                    return;
                                }
                            }
                        }
                    }, arguments);

                return $asyncBody();
            },
            /*Spine.Skeleton.UpdateCache end.*/

            /*Spine.Skeleton.SortIkConstraint start.*/
            SortIkConstraint: function (constraint) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SortIkConstraint", this ); }

                constraint.active = constraint.target.active && (!constraint.data.skinRequired || (this.skin != null && this.skin.constraints.Contains(constraint.data)));
                if (!constraint.active) {
                    return;
                }

                var target = constraint.target;
                this.SortBone(target);

                var constrained = constraint.bones;
                var parent = constrained.Items[0];
                this.SortBone(parent);

                if (constrained.Count > 1) {
                    var child = constrained.Items[((constrained.Count - 1) | 0)];
                    if (!this.updateCache.Contains(child)) {
                        this.updateCacheReset.Add(child);
                    }
                }

                this.updateCache.Add(constraint);

                Spine.Skeleton.SortReset(parent.children);
                constrained.Items[((constrained.Count - 1) | 0)].sorted = true;
            },
            /*Spine.Skeleton.SortIkConstraint end.*/

            /*Spine.Skeleton.SortPathConstraint start.*/
            SortPathConstraint: function (constraint) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SortPathConstraint", this ); }

                constraint.active = constraint.target.bone.active && (!constraint.data.skinRequired || (this.skin != null && this.skin.constraints.Contains(constraint.data)));
                if (!constraint.active) {
                    return;
                }

                var slot = constraint.target;
                var slotIndex = slot.data.index;
                var slotBone = slot.bone;
                if (this.skin != null) {
                    this.SortPathConstraintAttachment$1(this.skin, slotIndex, slotBone);
                }
                if (this.data.defaultSkin != null && !Bridge.referenceEquals(this.data.defaultSkin, this.skin)) {
                    this.SortPathConstraintAttachment$1(this.data.defaultSkin, slotIndex, slotBone);
                }

                var attachment = slot.attachment;
                if (Bridge.is(attachment, Spine.PathAttachment)) {
                    this.SortPathConstraintAttachment(attachment, slotBone);
                }

                var constrained = constraint.bones;
                var boneCount = constrained.Count;
                for (var i = 0; i < boneCount; i = (i + 1) | 0) {
                    this.SortBone(constrained.Items[i]);
                }

                this.updateCache.Add(constraint);

                for (var i1 = 0; i1 < boneCount; i1 = (i1 + 1) | 0) {
                    Spine.Skeleton.SortReset(constrained.Items[i1].children);
                }
                for (var i2 = 0; i2 < boneCount; i2 = (i2 + 1) | 0) {
                    constrained.Items[i2].sorted = true;
                }
            },
            /*Spine.Skeleton.SortPathConstraint end.*/

            /*Spine.Skeleton.SortTransformConstraint start.*/
            SortTransformConstraint: function (constraint) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SortTransformConstraint", this ); }

                constraint.active = constraint.target.active && (!constraint.data.skinRequired || (this.skin != null && this.skin.constraints.Contains(constraint.data)));
                if (!constraint.active) {
                    return;
                }

                this.SortBone(constraint.target);

                var constrained = constraint.bones;
                var boneCount = constrained.Count;
                if (constraint.data.local) {
                    for (var i = 0; i < boneCount; i = (i + 1) | 0) {
                        var child = constrained.Items[i];
                        this.SortBone(child.parent);
                        if (!this.updateCache.Contains(child)) {
                            this.updateCacheReset.Add(child);
                        }
                    }
                } else {
                    for (var i1 = 0; i1 < boneCount; i1 = (i1 + 1) | 0) {
                        this.SortBone(constrained.Items[i1]);
                    }
                }

                this.updateCache.Add(constraint);

                for (var i2 = 0; i2 < boneCount; i2 = (i2 + 1) | 0) {
                    Spine.Skeleton.SortReset(constrained.Items[i2].children);
                }
                for (var i3 = 0; i3 < boneCount; i3 = (i3 + 1) | 0) {
                    constrained.Items[i3].sorted = true;
                }
            },
            /*Spine.Skeleton.SortTransformConstraint end.*/

            /*Spine.Skeleton.SortPathConstraintAttachment$1 start.*/
            SortPathConstraintAttachment$1: function (skin, slotIndex, slotBone) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SortPathConstraintAttachment$1", this ); }

                var $t;
                $t = Bridge.getEnumerator(skin.Attachments.Keys);
                try {
                    while ($t.moveNext()) {
                        var entryObj = $t.Current;
                        var entry = entryObj;
                        if (entry.SlotIndex === slotIndex) {
                            this.SortPathConstraintAttachment(entry.Attachment, slotBone);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Skeleton.SortPathConstraintAttachment$1 end.*/

            /*Spine.Skeleton.SortPathConstraintAttachment start.*/
            SortPathConstraintAttachment: function (attachment, slotBone) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SortPathConstraintAttachment", this ); }

                if (!(Bridge.is(attachment, Spine.PathAttachment))) {
                    return;
                }
                var pathBones = Bridge.cast(attachment, Spine.PathAttachment).bones;
                if (pathBones == null) {
                    this.SortBone(slotBone);
                } else {
                    var bones = this.bones;
                    for (var i = 0, n = pathBones.length; i < n; ) {
                        var nn = pathBones[Bridge.identity(i, ((i = (i + 1) | 0)))];
                        nn = (nn + i) | 0;
                        while (i < nn) {
                            this.SortBone(bones.Items[pathBones[Bridge.identity(i, ((i = (i + 1) | 0)))]]);
                        }
                    }
                }
            },
            /*Spine.Skeleton.SortPathConstraintAttachment end.*/

            /*Spine.Skeleton.SortBone start.*/
            SortBone: function (bone) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SortBone", this ); }

                if (bone.sorted) {
                    return;
                }
                var parent = bone.parent;
                if (parent != null) {
                    this.SortBone(parent);
                }
                bone.sorted = true;
                this.updateCache.Add(bone);
            },
            /*Spine.Skeleton.SortBone end.*/

            /*Spine.Skeleton.UpdateWorldTransform start.*/
            /**
             * Updates the world transform for each bone and applies constraints.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @return  {void}
             */
            UpdateWorldTransform: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#UpdateWorldTransform", this ); }

                var updateCacheReset = this.updateCacheReset;
                var updateCacheResetItems = updateCacheReset.Items;
                for (var i = 0, n = updateCacheReset.Count; i < n; i = (i + 1) | 0) {
                    var bone = updateCacheResetItems[i];
                    bone.ax = bone.x;
                    bone.ay = bone.y;
                    bone.arotation = bone.rotation;
                    bone.ascaleX = bone.scaleX;
                    bone.ascaleY = bone.scaleY;
                    bone.ashearX = bone.shearX;
                    bone.ashearY = bone.shearY;
                    bone.appliedValid = true;
                }
                var updateItems = this.updateCache.Items;
                for (var i1 = 0, n1 = this.updateCache.Count; i1 < n1; i1 = (i1 + 1) | 0) {
                    updateItems[i1].Spine$IUpdatable$Update();
                }
            },
            /*Spine.Skeleton.UpdateWorldTransform end.*/

            /*Spine.Skeleton.UpdateWorldTransform$1 start.*/
            /**
             * Temporarily sets the root bone as a child of the specified bone, then updates the world transform for each bone and applies
             all constraints.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {Spine.Bone}    parent
             * @return  {void}
             */
            UpdateWorldTransform$1: function (parent) {
if ( TRACE ) { TRACE( "Spine.Skeleton#UpdateWorldTransform$1", this ); }

                // This partial update avoids computing the world transform for constrained bones when 1) the bone is not updated
                // before the constraint, 2) the constraint only needs to access the applied local transform, and 3) the constraint calls
                // updateWorldTransform.
                var updateCacheReset = this.updateCacheReset;
                var updateCacheResetItems = updateCacheReset.Items;
                for (var i = 0, n = updateCacheReset.Count; i < n; i = (i + 1) | 0) {
                    var bone = updateCacheResetItems[i];
                    bone.ax = bone.x;
                    bone.ay = bone.y;
                    bone.arotation = bone.rotation;
                    bone.ascaleX = bone.scaleX;
                    bone.ascaleY = bone.scaleY;
                    bone.ashearX = bone.shearX;
                    bone.ashearY = bone.shearY;
                    bone.appliedValid = true;
                }

                // Apply the parent bone transform to the root bone. The root bone always inherits scale, rotation and reflection.
                var rootBone = this.RootBone;
                var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;
                rootBone.worldX = pa * this.x + pb * this.y + parent.worldX;
                rootBone.worldY = pc * this.x + pd * this.y + parent.worldY;

                var rotationY = rootBone.rotation + 90 + rootBone.shearY;
                var la = Spine.MathUtils.CosDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;
                var lb = Spine.MathUtils.CosDeg(rotationY) * rootBone.scaleY;
                var lc = Spine.MathUtils.SinDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;
                var ld = Spine.MathUtils.SinDeg(rotationY) * rootBone.scaleY;
                rootBone.a = (pa * la + pb * lc) * this.scaleX;
                rootBone.b = (pa * lb + pb * ld) * this.scaleX;
                rootBone.c = (pc * la + pd * lc) * this.scaleY;
                rootBone.d = (pc * lb + pd * ld) * this.scaleY;

                // Update everything except root bone.
                var updateCache = this.updateCache;
                var updateCacheItems = updateCache.Items;
                for (var i1 = 0, n1 = updateCache.Count; i1 < n1; i1 = (i1 + 1) | 0) {
                    var updatable = updateCacheItems[i1];
                    if (!Bridge.referenceEquals(updatable, rootBone)) {
                        updatable.Spine$IUpdatable$Update();
                    }
                }
            },
            /*Spine.Skeleton.UpdateWorldTransform$1 end.*/

            /*Spine.Skeleton.SetToSetupPose start.*/
            /**
             * Sets the bones, constraints, and slots to their setup pose values.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @return  {void}
             */
            SetToSetupPose: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#SetToSetupPose", this ); }

                this.SetBonesToSetupPose();
                this.SetSlotsToSetupPose();
            },
            /*Spine.Skeleton.SetToSetupPose end.*/

            /*Spine.Skeleton.SetBonesToSetupPose start.*/
            /**
             * Sets the bones and constraints to their setup pose values.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @return  {void}
             */
            SetBonesToSetupPose: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#SetBonesToSetupPose", this ); }

                var bonesItems = this.bones.Items;
                for (var i = 0, n = this.bones.Count; i < n; i = (i + 1) | 0) {
                    bonesItems[i].SetToSetupPose();
                }

                var ikConstraintsItems = this.ikConstraints.Items;
                for (var i1 = 0, n1 = this.ikConstraints.Count; i1 < n1; i1 = (i1 + 1) | 0) {
                    var constraint = ikConstraintsItems[i1];
                    constraint.mix = constraint.data.mix;
                    constraint.softness = constraint.data.softness;
                    constraint.bendDirection = constraint.data.bendDirection;
                    constraint.compress = constraint.data.compress;
                    constraint.stretch = constraint.data.stretch;
                }

                var transformConstraintsItems = this.transformConstraints.Items;
                for (var i2 = 0, n2 = this.transformConstraints.Count; i2 < n2; i2 = (i2 + 1) | 0) {
                    var constraint1 = transformConstraintsItems[i2];
                    var constraintData = constraint1.data;
                    constraint1.rotateMix = constraintData.rotateMix;
                    constraint1.translateMix = constraintData.translateMix;
                    constraint1.scaleMix = constraintData.scaleMix;
                    constraint1.shearMix = constraintData.shearMix;
                }

                var pathConstraintItems = this.pathConstraints.Items;
                for (var i3 = 0, n3 = this.pathConstraints.Count; i3 < n3; i3 = (i3 + 1) | 0) {
                    var constraint2 = pathConstraintItems[i3];
                    var constraintData1 = constraint2.data;
                    constraint2.position = constraintData1.position;
                    constraint2.spacing = constraintData1.spacing;
                    constraint2.rotateMix = constraintData1.rotateMix;
                    constraint2.translateMix = constraintData1.translateMix;
                }
            },
            /*Spine.Skeleton.SetBonesToSetupPose end.*/

            /*Spine.Skeleton.SetSlotsToSetupPose start.*/
            SetSlotsToSetupPose: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#SetSlotsToSetupPose", this ); }

                var slots = this.slots;
                var slotsItems = slots.Items;
                this.drawOrder.Clear();
                for (var i = 0, n = slots.Count; i < n; i = (i + 1) | 0) {
                    this.drawOrder.Add(slotsItems[i]);
                }

                for (var i1 = 0, n1 = slots.Count; i1 < n1; i1 = (i1 + 1) | 0) {
                    slotsItems[i1].SetToSetupPose();
                }
            },
            /*Spine.Skeleton.SetSlotsToSetupPose end.*/

            /*Spine.Skeleton.FindBone start.*/
            /**
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {string}        boneName
             * @return  {Spine.Bone}                May be null.
             */
            FindBone: function (boneName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FindBone", this ); }

                if (boneName == null) {
                    throw new System.ArgumentNullException.$ctor3("boneName", "boneName cannot be null.");
                }
                var bones = this.bones;
                var bonesItems = bones.Items;
                for (var i = 0, n = bones.Count; i < n; i = (i + 1) | 0) {
                    var bone = bonesItems[i];
                    if (Bridge.referenceEquals(bone.data.name, boneName)) {
                        return bone;
                    }
                }
                return null;
            },
            /*Spine.Skeleton.FindBone end.*/

            /*Spine.Skeleton.FindBoneIndex start.*/
            /**
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {string}    boneName
             * @return  {number}                -1 if the bone was not found.
             */
            FindBoneIndex: function (boneName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FindBoneIndex", this ); }

                if (boneName == null) {
                    throw new System.ArgumentNullException.$ctor3("boneName", "boneName cannot be null.");
                }
                var bones = this.bones;
                var bonesItems = bones.Items;
                for (var i = 0, n = bones.Count; i < n; i = (i + 1) | 0) {
                    if (Bridge.referenceEquals(bonesItems[i].data.name, boneName)) {
                        return i;
                    }
                }
                return -1;
            },
            /*Spine.Skeleton.FindBoneIndex end.*/

            /*Spine.Skeleton.FindSlot start.*/
            /**
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {string}        slotName
             * @return  {Spine.Slot}                May be null.
             */
            FindSlot: function (slotName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FindSlot", this ); }

                if (slotName == null) {
                    throw new System.ArgumentNullException.$ctor3("slotName", "slotName cannot be null.");
                }
                var slots = this.slots;
                var slotsItems = slots.Items;
                for (var i = 0, n = slots.Count; i < n; i = (i + 1) | 0) {
                    var slot = slotsItems[i];
                    if (Bridge.referenceEquals(slot.data.name, slotName)) {
                        return slot;
                    }
                }
                return null;
            },
            /*Spine.Skeleton.FindSlot end.*/

            /*Spine.Skeleton.FindSlotIndex start.*/
            /**
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {string}    slotName
             * @return  {number}                -1 if the bone was not found.
             */
            FindSlotIndex: function (slotName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FindSlotIndex", this ); }

                if (slotName == null) {
                    throw new System.ArgumentNullException.$ctor3("slotName", "slotName cannot be null.");
                }
                var slots = this.slots;
                var slotsItems = slots.Items;
                for (var i = 0, n = slots.Count; i < n; i = (i + 1) | 0) {
                    if (System.String.equals(slotsItems[i].data.name, slotName)) {
                        return i;
                    }
                }
                return -1;
            },
            /*Spine.Skeleton.FindSlotIndex end.*/

            /*Spine.Skeleton.SetSkin$1 start.*/
            /**
             * Sets a skin by name (see SetSkin).
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {string}    skinName
             * @return  {void}
             */
            SetSkin$1: function (skinName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SetSkin$1", this ); }

                var foundSkin = this.data.FindSkin(skinName);
                if (foundSkin == null) {
                    throw new System.ArgumentException.$ctor3("Skin not found: " + (skinName || ""), "skinName");
                }
                this.SetSkin(foundSkin);
            },
            /*Spine.Skeleton.SetSkin$1 end.*/

            /*Spine.Skeleton.SetSkin start.*/
            /**
             * <p>Sets the skin used to look up attachments before looking in the {@link }. If the
             skin is changed, {@link } is called.</p><p>Attachments from the new skin are attached if the corresponding attachment from the old skin was attached.
             If there was no old skin, each slot's setup mode attachment is attached from the new skin.</p><p>After changing the skin, the visible attachments can be reset to those attached in the setup pose by calling
             {@link }.
             Also, often {@link } is called before the next time the
             skeleton is rendered to allow any attachment keys in the current animation(s) to hide or show attachments from the new skin.</p>
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {Spine.Skin}    newSkin    May be null.
             * @return  {void}
             */
            SetSkin: function (newSkin) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SetSkin", this ); }

                if (Bridge.referenceEquals(newSkin, this.skin)) {
                    return;
                }
                if (newSkin != null) {
                    if (this.skin != null) {
                        newSkin.AttachAll(this, this.skin);
                    } else {
                        var slots = this.slots;
                        for (var i = 0, n = slots.Count; i < n; i = (i + 1) | 0) {
                            var slot = slots.Items[i];
                            var name = slot.data.attachmentName;
                            if (name != null) {
                                var attachment = newSkin.GetAttachment(i, name);
                                if (attachment != null) {
                                    slot.Attachment = attachment;
                                }
                            }
                        }
                    }
                }
                this.skin = newSkin;
                this.UpdateCache();
            },
            /*Spine.Skeleton.SetSkin end.*/

            /*Spine.Skeleton.GetAttachment$1 start.*/
            /**
             * Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot name and attachment name.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {string}              slotName          
             * @param   {string}              attachmentName
             * @return  {Spine.Attachment}                      May be null.
             */
            GetAttachment$1: function (slotName, attachmentName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#GetAttachment$1", this ); }

                return this.GetAttachment(this.data.FindSlotIndex(slotName), attachmentName);
            },
            /*Spine.Skeleton.GetAttachment$1 end.*/

            /*Spine.Skeleton.GetAttachment start.*/
            /**
             * Finds an attachment by looking in the skin and skeletonData.defaultSkin using the slot index and attachment name.First the skin is checked and if the attachment was not found, the default skin is checked.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {number}              slotIndex         
             * @param   {string}              attachmentName
             * @return  {Spine.Attachment}                      May be null.
             */
            GetAttachment: function (slotIndex, attachmentName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#GetAttachment", this ); }

                if (attachmentName == null) {
                    throw new System.ArgumentNullException.$ctor3("attachmentName", "attachmentName cannot be null.");
                }
                if (this.skin != null) {
                    var attachment = this.skin.GetAttachment(slotIndex, attachmentName);
                    if (attachment != null) {
                        return attachment;
                    }
                }
                return this.data.defaultSkin != null ? this.data.defaultSkin.GetAttachment(slotIndex, attachmentName) : null;
            },
            /*Spine.Skeleton.GetAttachment end.*/

            /*Spine.Skeleton.SetAttachment start.*/
            /**
             * A convenience method to set an attachment by finding the slot with FindSlot, finding the attachment with GetAttachment, then setting the slot's slot.Attachment.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {string}    slotName          
             * @param   {string}    attachmentName    May be null to clear the slot's attachment.
             * @return  {void}
             */
            SetAttachment: function (slotName, attachmentName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SetAttachment", this ); }

                if (slotName == null) {
                    throw new System.ArgumentNullException.$ctor3("slotName", "slotName cannot be null.");
                }
                var slots = this.slots;
                for (var i = 0, n = slots.Count; i < n; i = (i + 1) | 0) {
                    var slot = slots.Items[i];
                    if (Bridge.referenceEquals(slot.data.name, slotName)) {
                        var attachment = null;
                        if (attachmentName != null) {
                            attachment = this.GetAttachment(i, attachmentName);
                            if (attachment == null) {
                                throw new System.Exception("Attachment not found: " + (attachmentName || "") + ", for slot: " + (slotName || ""));
                            }
                        }
                        slot.Attachment = attachment;
                        return;
                    }
                }
                throw new System.Exception("Slot not found: " + (slotName || ""));
            },
            /*Spine.Skeleton.SetAttachment end.*/

            /*Spine.Skeleton.FindIkConstraint start.*/
            /**
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {string}                constraintName
             * @return  {Spine.IkConstraint}                      May be null.
             */
            FindIkConstraint: function (constraintName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FindIkConstraint", this ); }

                if (constraintName == null) {
                    throw new System.ArgumentNullException.$ctor3("constraintName", "constraintName cannot be null.");
                }
                var ikConstraints = this.ikConstraints;
                for (var i = 0, n = ikConstraints.Count; i < n; i = (i + 1) | 0) {
                    var ikConstraint = ikConstraints.Items[i];
                    if (Bridge.referenceEquals(ikConstraint.data.name, constraintName)) {
                        return ikConstraint;
                    }
                }
                return null;
            },
            /*Spine.Skeleton.FindIkConstraint end.*/

            /*Spine.Skeleton.FindTransformConstraint start.*/
            /**
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {string}                       constraintName
             * @return  {Spine.TransformConstraint}                      May be null.
             */
            FindTransformConstraint: function (constraintName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FindTransformConstraint", this ); }

                if (constraintName == null) {
                    throw new System.ArgumentNullException.$ctor3("constraintName", "constraintName cannot be null.");
                }
                var transformConstraints = this.transformConstraints;
                for (var i = 0, n = transformConstraints.Count; i < n; i = (i + 1) | 0) {
                    var transformConstraint = transformConstraints.Items[i];
                    if (Bridge.referenceEquals(transformConstraint.data.Name, constraintName)) {
                        return transformConstraint;
                    }
                }
                return null;
            },
            /*Spine.Skeleton.FindTransformConstraint end.*/

            /*Spine.Skeleton.FindPathConstraint start.*/
            /**
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {string}                  constraintName
             * @return  {Spine.PathConstraint}                      May be null.
             */
            FindPathConstraint: function (constraintName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FindPathConstraint", this ); }

                if (constraintName == null) {
                    throw new System.ArgumentNullException.$ctor3("constraintName", "constraintName cannot be null.");
                }
                var pathConstraints = this.pathConstraints;
                for (var i = 0, n = pathConstraints.Count; i < n; i = (i + 1) | 0) {
                    var constraint = pathConstraints.Items[i];
                    if (System.String.equals(constraint.data.Name, constraintName)) {
                        return constraint;
                    }
                }
                return null;
            },
            /*Spine.Skeleton.FindPathConstraint end.*/

            /*Spine.Skeleton.Update start.*/
            Update: function (delta) {
if ( TRACE ) { TRACE( "Spine.Skeleton#Update", this ); }

                this.time += delta;
            },
            /*Spine.Skeleton.Update end.*/

            /*Spine.Skeleton.GetBounds start.*/
            /**
             * Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {System.Single}    x               The horizontal distance between the skeleton origin and the left side of the AABB.
             * @param   {System.Single}    y               The vertical distance between the skeleton origin and the bottom side of the AABB.
             * @param   {System.Single}    width           The width of the AABB
             * @param   {System.Single}    height          The height of the AABB.
             * @param   {System.Single}    vertexBuffer    Reference to hold a float[]. May be a null reference. This method will assign it a new float[] with the appropriate size as needed.
             * @return  {void}
             */
            GetBounds: function (x, y, width, height, vertexBuffer) {
if ( TRACE ) { TRACE( "Spine.Skeleton#GetBounds", this ); }

                var temp = vertexBuffer.v;
                temp = temp || System.Array.init(8, 0, System.Single);
                var drawOrderItems = this.drawOrder.Items;
                var minX = 2147483647, minY = 2147483647, maxX = -2147483648, maxY = -2147483648;
                for (var i = 0, n = drawOrderItems.length; i < n; i = (i + 1) | 0) {
                    var slot = drawOrderItems[i];
                    if (!slot.bone.active) {
                        continue;
                    }
                    var verticesLength = 0;
                    var vertices = null;
                    var attachment = slot.attachment;
                    var regionAttachment = Bridge.as(attachment, Spine.RegionAttachment);
                    if (regionAttachment != null) {
                        verticesLength = 8;
                        vertices = temp;
                        if (vertices.length < 8) {
                            vertices = (temp = System.Array.init(8, 0, System.Single));
                        }
                        regionAttachment.ComputeWorldVertices(slot.bone, temp, 0);
                    } else {
                        var meshAttachment = Bridge.as(attachment, Spine.MeshAttachment);
                        if (meshAttachment != null) {
                            var mesh = meshAttachment;
                            verticesLength = mesh.WorldVerticesLength;
                            vertices = temp;
                            if (vertices.length < verticesLength) {
                                vertices = (temp = System.Array.init(verticesLength, 0, System.Single));
                            }
                            mesh.ComputeWorldVertices(slot, 0, verticesLength, temp, 0);
                        }
                    }

                    if (vertices != null) {
                        for (var ii = 0; ii < verticesLength; ii = (ii + 2) | 0) {
                            var vx = vertices[ii], vy = vertices[((ii + 1) | 0)];
                            minX = Math.min(minX, vx);
                            minY = Math.min(minY, vy);
                            maxX = Math.max(maxX, vx);
                            maxY = Math.max(maxY, vy);
                        }
                    }
                }
                x.v = minX;
                y.v = minY;
                width.v = maxX - minX;
                height.v = maxY - minY;
                vertexBuffer.v = temp;
            },
            /*Spine.Skeleton.GetBounds end.*/


        },
        overloads: {
            "SortPathConstraintAttachment(Skin, int, Bone)": "SortPathConstraintAttachment$1",
            "UpdateWorldTransform(Bone)": "UpdateWorldTransform$1",
            "SetSkin(string)": "SetSkin$1",
            "GetAttachment(string, string)": "GetAttachment$1"
        }
    });
    /*Spine.Skeleton end.*/

    /*Spine.SkeletonBinary start.*/
    Bridge.define("Spine.SkeletonBinary", {
        statics: {
            fields: {
                BONE_ROTATE: 0,
                BONE_TRANSLATE: 0,
                BONE_SCALE: 0,
                BONE_SHEAR: 0,
                SLOT_ATTACHMENT: 0,
                SLOT_COLOR: 0,
                SLOT_TWO_COLOR: 0,
                PATH_POSITION: 0,
                PATH_SPACING: 0,
                PATH_MIX: 0,
                CURVE_LINEAR: 0,
                CURVE_STEPPED: 0,
                CURVE_BEZIER: 0,
                TransformModeValues: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#init", this ); }

                    this.BONE_ROTATE = 0;
                    this.BONE_TRANSLATE = 1;
                    this.BONE_SCALE = 2;
                    this.BONE_SHEAR = 3;
                    this.SLOT_ATTACHMENT = 0;
                    this.SLOT_COLOR = 1;
                    this.SLOT_TWO_COLOR = 2;
                    this.PATH_POSITION = 0;
                    this.PATH_SPACING = 1;
                    this.PATH_MIX = 2;
                    this.CURVE_LINEAR = 0;
                    this.CURVE_STEPPED = 1;
                    this.CURVE_BEZIER = 2;
                    this.TransformModeValues = System.Array.init([
                        Spine.TransformMode.Normal, 
                        Spine.TransformMode.OnlyTranslation, 
                        Spine.TransformMode.NoRotationOrReflection, 
                        Spine.TransformMode.NoScale, 
                        Spine.TransformMode.NoScaleOrReflection
                    ], Spine.TransformMode);
                }
            },
            methods: {
                /*Spine.SkeletonBinary.GetVersionString:static start.*/
                /**
                 * Returns the version string of binary skeleton data.
                 *
                 * @static
                 * @public
                 * @this Spine.SkeletonBinary
                 * @memberof Spine.SkeletonBinary
                 * @param   {System.IO.Stream}    file
                 * @return  {string}
                 */
                GetVersionString: function (file) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#GetVersionString", this ); }

                    if (file == null) {
                        throw new System.ArgumentNullException.$ctor1("file");
                    }

                    var input = new Spine.SkeletonBinary.SkeletonInput(file);
                    return input.GetVersionString();
                },
                /*Spine.SkeletonBinary.GetVersionString:static end.*/


            }
        },
        fields: {
            Scale: 0,
            attachmentLoader: null,
            linkedMeshes: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#init", this ); }

                this.linkedMeshes = new (System.Collections.Generic.List$1(Spine.SkeletonJson.LinkedMesh)).ctor();
            },
            ctor: function (atlasArray) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ctor", this ); }

                if (atlasArray === void 0) { atlasArray = []; }

                Spine.SkeletonBinary.$ctor1.call(this, new Spine.AtlasAttachmentLoader(atlasArray));
            },
            $ctor1: function (attachmentLoader) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#$ctor1", this ); }

                this.$initialize();
                if (attachmentLoader == null) {
                    throw new System.ArgumentNullException.$ctor1("attachmentLoader");
                }
                this.attachmentLoader = attachmentLoader;
                this.Scale = 1;
            }
        },
        methods: {
            /*Spine.SkeletonBinary.ReadSkeletonData$1 start.*/
            ReadSkeletonData$1: function (path) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadSkeletonData$1", this ); }

                var input = new System.IO.FileStream.$ctor2(path, 3, System.IO.FileAccess.Read, 1);
                try {
                    var skeletonData = this.ReadSkeletonData(input);
                    skeletonData.name = System.IO.Path.GetFileNameWithoutExtension(path);
                    return skeletonData;
                }
                finally {
                    if (Bridge.hasValue(input)) {
                        input.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.SkeletonBinary.ReadSkeletonData$1 end.*/

            /*Spine.SkeletonBinary.ReadSkeletonData start.*/
            ReadSkeletonData: function (file) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadSkeletonData", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7;
                if (file == null) {
                    throw new System.ArgumentNullException.$ctor1("file");
                }
                var scale = this.Scale;

                var skeletonData = new Spine.SkeletonData();
                var input = new Spine.SkeletonBinary.SkeletonInput(file);

                skeletonData.hash = input.ReadString();
                if (skeletonData.hash.length === 0) {
                    skeletonData.hash = null;
                }
                skeletonData.version = input.ReadString();
                if (skeletonData.version.length === 0) {
                    skeletonData.version = null;
                }
                if (Bridge.referenceEquals("3.8.75", skeletonData.version)) {
                    throw new System.Exception("Unsupported skeleton data, please export with a newer version of Spine.");
                }
                skeletonData.x = input.ReadFloat();
                skeletonData.y = input.ReadFloat();
                skeletonData.width = input.ReadFloat();
                skeletonData.height = input.ReadFloat();

                var nonessential = input.ReadBoolean();

                if (nonessential) {
                    skeletonData.fps = input.ReadFloat();

                    skeletonData.imagesPath = input.ReadString();
                    if (System.String.isNullOrEmpty(skeletonData.imagesPath)) {
                        skeletonData.imagesPath = null;
                    }

                    skeletonData.audioPath = input.ReadString();
                    if (System.String.isNullOrEmpty(skeletonData.audioPath)) {
                        skeletonData.audioPath = null;
                    }
                }

                var n;
                var o;

                // Strings.
                input.strings = new (Spine.ExposedList$1(System.String)).$ctor3((n = input.ReadInt$1(true)));
                o = input.strings.Resize(n).Items;
                for (var i = 0; i < n; i = (i + 1) | 0) {
                    o[i] = input.ReadString();
                }

                // Bones.
                o = skeletonData.bones.Resize((n = input.ReadInt$1(true))).Items;
                for (var i1 = 0; i1 < n; i1 = (i1 + 1) | 0) {
                    var name = input.ReadString();
                    var parent = i1 === 0 ? null : ($t = skeletonData.bones.Items)[input.ReadInt$1(true)];
                    var data = new Spine.BoneData(i1, name, parent);
                    data.rotation = input.ReadFloat();
                    data.x = input.ReadFloat() * scale;
                    data.y = input.ReadFloat() * scale;
                    data.scaleX = input.ReadFloat();
                    data.scaleY = input.ReadFloat();
                    data.shearX = input.ReadFloat();
                    data.shearY = input.ReadFloat();
                    data.length = input.ReadFloat() * scale;
                    data.transformMode = Spine.SkeletonBinary.TransformModeValues[input.ReadInt$1(true)];
                    data.skinRequired = input.ReadBoolean();
                    if (nonessential) {
                        input.ReadInt();
                    } // Skip bone color.
                    o[i1] = data;
                }

                // Slots.
                o = skeletonData.slots.Resize((n = input.ReadInt$1(true))).Items;
                for (var i2 = 0; i2 < n; i2 = (i2 + 1) | 0) {
                    var slotName = input.ReadString();
                    var boneData = ($t1 = skeletonData.bones.Items)[input.ReadInt$1(true)];
                    var slotData = new Spine.SlotData(i2, slotName, boneData);
                    var color = input.ReadInt();
                    slotData.r = ((System.Int64(color).and(System.Int64(4278190080))).shr(24)) / 255.0;
                    slotData.g = ((color & 16711680) >> 16) / 255.0;
                    slotData.b = ((color & 65280) >> 8) / 255.0;
                    slotData.a = ((color & 255)) / 255.0;

                    var darkColor = input.ReadInt(); // 0x00rrggbb
                    if (darkColor !== -1) {
                        slotData.hasSecondColor = true;
                        slotData.r2 = ((darkColor & 16711680) >> 16) / 255.0;
                        slotData.g2 = ((darkColor & 65280) >> 8) / 255.0;
                        slotData.b2 = ((darkColor & 255)) / 255.0;
                    }

                    slotData.attachmentName = input.ReadStringRef();
                    slotData.blendMode = input.ReadInt$1(true);
                    o[i2] = slotData;
                }

                // IK constraints.
                o = skeletonData.ikConstraints.Resize((n = input.ReadInt$1(true))).Items;
                for (var i3 = 0, nn; i3 < n; i3 = (i3 + 1) | 0) {
                    var data1 = new Spine.IkConstraintData(input.ReadString());
                    data1.order = input.ReadInt$1(true);
                    data1.skinRequired = input.ReadBoolean();
                    var bones = data1.bones.Resize((nn = input.ReadInt$1(true))).Items;
                    for (var ii = 0; ii < nn; ii = (ii + 1) | 0) {
                        bones[ii] = ($t2 = skeletonData.bones.Items)[input.ReadInt$1(true)];
                    }
                    data1.target = ($t3 = skeletonData.bones.Items)[input.ReadInt$1(true)];
                    data1.mix = input.ReadFloat();
                    data1.softness = input.ReadFloat() * scale;
                    data1.bendDirection = input.ReadSByte();
                    data1.compress = input.ReadBoolean();
                    data1.stretch = input.ReadBoolean();
                    data1.uniform = input.ReadBoolean();
                    o[i3] = data1;
                }

                // Transform constraints.
                o = skeletonData.transformConstraints.Resize((n = input.ReadInt$1(true))).Items;
                for (var i4 = 0, nn1; i4 < n; i4 = (i4 + 1) | 0) {
                    var data2 = new Spine.TransformConstraintData(input.ReadString());
                    data2.order = input.ReadInt$1(true);
                    data2.skinRequired = input.ReadBoolean();
                    var bones1 = data2.bones.Resize((nn1 = input.ReadInt$1(true))).Items;
                    for (var ii1 = 0; ii1 < nn1; ii1 = (ii1 + 1) | 0) {
                        bones1[ii1] = ($t4 = skeletonData.bones.Items)[input.ReadInt$1(true)];
                    }
                    data2.target = ($t5 = skeletonData.bones.Items)[input.ReadInt$1(true)];
                    data2.local = input.ReadBoolean();
                    data2.relative = input.ReadBoolean();
                    data2.offsetRotation = input.ReadFloat();
                    data2.offsetX = input.ReadFloat() * scale;
                    data2.offsetY = input.ReadFloat() * scale;
                    data2.offsetScaleX = input.ReadFloat();
                    data2.offsetScaleY = input.ReadFloat();
                    data2.offsetShearY = input.ReadFloat();
                    data2.rotateMix = input.ReadFloat();
                    data2.translateMix = input.ReadFloat();
                    data2.scaleMix = input.ReadFloat();
                    data2.shearMix = input.ReadFloat();
                    o[i4] = data2;
                }

                // Path constraints
                o = skeletonData.pathConstraints.Resize((n = input.ReadInt$1(true))).Items;
                for (var i5 = 0, nn2; i5 < n; i5 = (i5 + 1) | 0) {
                    var data3 = new Spine.PathConstraintData(input.ReadString());
                    data3.order = input.ReadInt$1(true);
                    data3.skinRequired = input.ReadBoolean();
                    var bones2 = data3.bones.Resize((nn2 = input.ReadInt$1(true))).Items;
                    for (var ii2 = 0; ii2 < nn2; ii2 = (ii2 + 1) | 0) {
                        bones2[ii2] = ($t6 = skeletonData.bones.Items)[input.ReadInt$1(true)];
                    }
                    data3.target = ($t7 = skeletonData.slots.Items)[input.ReadInt$1(true)];
                    data3.positionMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Array.get(System.Enum.getValues(Spine.PositionMode), input.ReadInt$1(true)), Spine.PositionMode), System.Int32));
                    data3.spacingMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Array.get(System.Enum.getValues(Spine.SpacingMode), input.ReadInt$1(true)), Spine.SpacingMode), System.Int32));
                    data3.rotateMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Array.get(System.Enum.getValues(Spine.RotateMode), input.ReadInt$1(true)), Spine.RotateMode), System.Int32));
                    data3.offsetRotation = input.ReadFloat();
                    data3.position = input.ReadFloat();
                    if (data3.positionMode === Spine.PositionMode.Fixed) {
                        data3.position *= scale;
                    }
                    data3.spacing = input.ReadFloat();
                    if (data3.spacingMode === Spine.SpacingMode.Length || data3.spacingMode === Spine.SpacingMode.Fixed) {
                        data3.spacing *= scale;
                    }
                    data3.rotateMix = input.ReadFloat();
                    data3.translateMix = input.ReadFloat();
                    o[i5] = data3;
                }

                // Default skin.
                var defaultSkin = this.ReadSkin(input, skeletonData, true, nonessential);
                if (defaultSkin != null) {
                    skeletonData.defaultSkin = defaultSkin;
                    skeletonData.skins.Add(defaultSkin);
                }

                // Skins.
                {
                    var i6 = skeletonData.skins.Count;
                    o = skeletonData.skins.Resize((n = (i6 + input.ReadInt$1(true)) | 0)).Items;
                    for (; i6 < n; i6 = (i6 + 1) | 0) {
                        o[i6] = this.ReadSkin(input, skeletonData, false, nonessential);
                    }
                }

                // Linked meshes.
                n = this.linkedMeshes.Count;
                for (var i7 = 0; i7 < n; i7 = (i7 + 1) | 0) {
                    var linkedMesh = this.linkedMeshes.getItem(i7);
                    var skin = linkedMesh.skin == null ? skeletonData.DefaultSkin : skeletonData.FindSkin(linkedMesh.skin);
                    if (skin == null) {
                        throw new System.Exception("Skin not found: " + (linkedMesh.skin || ""));
                    }
                    var parent1 = skin.GetAttachment(linkedMesh.slotIndex, linkedMesh.parent);
                    if (parent1 == null) {
                        throw new System.Exception("Parent mesh not found: " + (linkedMesh.parent || ""));
                    }
                    linkedMesh.mesh.DeformAttachment = linkedMesh.inheritDeform ? Bridge.cast(parent1, Spine.VertexAttachment) : linkedMesh.mesh;
                    linkedMesh.mesh.ParentMesh = Bridge.cast(parent1, Spine.MeshAttachment);
                    linkedMesh.mesh.UpdateUVs();
                }
                this.linkedMeshes.clear();

                // Events.
                o = skeletonData.events.Resize((n = input.ReadInt$1(true))).Items;
                for (var i8 = 0; i8 < n; i8 = (i8 + 1) | 0) {
                    var data4 = new Spine.EventData(input.ReadStringRef());
                    data4.Int = input.ReadInt$1(false);
                    data4.Float = input.ReadFloat();
                    data4.String = input.ReadString();
                    data4.AudioPath = input.ReadString();
                    if (data4.AudioPath != null) {
                        data4.Volume = input.ReadFloat();
                        data4.Balance = input.ReadFloat();
                    }
                    o[i8] = data4;
                }

                // Animations.
                o = skeletonData.animations.Resize((n = input.ReadInt$1(true))).Items;
                for (var i9 = 0; i9 < n; i9 = (i9 + 1) | 0) {
                    o[i9] = this.ReadAnimation(input.ReadString(), input, skeletonData);
                }

                return skeletonData;
            },
            /*Spine.SkeletonBinary.ReadSkeletonData end.*/

            /*Spine.SkeletonBinary.ReadSkin start.*/
            /**
             * @instance
             * @private
             * @this Spine.SkeletonBinary
             * @memberof Spine.SkeletonBinary
             * @param   {Spine.SkeletonBinary.SkeletonInput}    input           
             * @param   {Spine.SkeletonData}                    skeletonData    
             * @param   {boolean}                               defaultSkin     
             * @param   {boolean}                               nonessential
             * @return  {Spine.Skin}                                            May be null.
             */
            ReadSkin: function (input, skeletonData, defaultSkin, nonessential) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadSkin", this ); }

                var $t, $t1, $t2, $t3;

                var skin;
                var slotCount;

                if (defaultSkin) {
                    slotCount = input.ReadInt$1(true);
                    if (slotCount === 0) {
                        return null;
                    }
                    skin = new Spine.Skin("default");
                } else {
                    skin = new Spine.Skin(input.ReadStringRef());
                    var bones = skin.bones.Resize(input.ReadInt$1(true)).Items;
                    for (var i = 0, n = skin.bones.Count; i < n; i = (i + 1) | 0) {
                        bones[i] = ($t = skeletonData.bones.Items)[input.ReadInt$1(true)];
                    }

                    for (var i1 = 0, n1 = input.ReadInt$1(true); i1 < n1; i1 = (i1 + 1) | 0) {
                        skin.constraints.Add(($t1 = skeletonData.ikConstraints.Items)[input.ReadInt$1(true)]);
                    }
                    for (var i2 = 0, n2 = input.ReadInt$1(true); i2 < n2; i2 = (i2 + 1) | 0) {
                        skin.constraints.Add(($t2 = skeletonData.transformConstraints.Items)[input.ReadInt$1(true)]);
                    }
                    for (var i3 = 0, n3 = input.ReadInt$1(true); i3 < n3; i3 = (i3 + 1) | 0) {
                        skin.constraints.Add(($t3 = skeletonData.pathConstraints.Items)[input.ReadInt$1(true)]);
                    }
                    skin.constraints.TrimExcess();
                    slotCount = input.ReadInt$1(true);
                }
                for (var i4 = 0; i4 < slotCount; i4 = (i4 + 1) | 0) {
                    var slotIndex = input.ReadInt$1(true);
                    for (var ii = 0, nn = input.ReadInt$1(true); ii < nn; ii = (ii + 1) | 0) {
                        var name = input.ReadStringRef();
                        var attachment = this.ReadAttachment(input, skeletonData, skin, slotIndex, name, nonessential);
                        if (attachment != null) {
                            skin.SetAttachment(slotIndex, name, attachment);
                        }
                    }
                }
                return skin;
            },
            /*Spine.SkeletonBinary.ReadSkin end.*/

            /*Spine.SkeletonBinary.ReadAttachment start.*/
            ReadAttachment: function (input, skeletonData, skin, slotIndex, attachmentName, nonessential) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadAttachment", this ); }

                var $t;

                var scale = this.Scale;

                var name = input.ReadStringRef();
                if (name == null) {
                    name = attachmentName;
                }

                var type = input.ReadByte();
                switch (type) {
                    case Spine.AttachmentType.Region: 
                        {
                            var path = input.ReadStringRef();
                            var rotation = input.ReadFloat();
                            var x = input.ReadFloat();
                            var y = input.ReadFloat();
                            var scaleX = input.ReadFloat();
                            var scaleY = input.ReadFloat();
                            var width = input.ReadFloat();
                            var height = input.ReadFloat();
                            var color = input.ReadInt();

                            if (path == null) {
                                path = name;
                            }
                            var region = this.attachmentLoader.Spine$AttachmentLoader$NewRegionAttachment(skin, name, path);
                            if (region == null) {
                                return null;
                            }
                            region.Path = path;
                            region.x = x * scale;
                            region.y = y * scale;
                            region.scaleX = scaleX;
                            region.scaleY = scaleY;
                            region.rotation = rotation;
                            region.width = width * scale;
                            region.height = height * scale;
                            region.r = ((System.Int64(color).and(System.Int64(4278190080))).shr(24)) / 255.0;
                            region.g = ((color & 16711680) >> 16) / 255.0;
                            region.b = ((color & 65280) >> 8) / 255.0;
                            region.a = ((color & 255)) / 255.0;
                            region.UpdateOffset();
                            return region;
                        }
                    case Spine.AttachmentType.Boundingbox: 
                        {
                            var vertexCount = input.ReadInt$1(true);
                            var vertices = this.ReadVertices(input, vertexCount);
                            if (nonessential) {
                                input.ReadInt();
                            } //int color = nonessential ? input.ReadInt() : 0; // Avoid unused local warning.

                            var box = this.attachmentLoader.Spine$AttachmentLoader$NewBoundingBoxAttachment(skin, name);
                            if (box == null) {
                                return null;
                            }
                            box.worldVerticesLength = vertexCount << 1;
                            box.vertices = vertices.vertices;
                            box.bones = vertices.bones;
                            // skipped porting: if (nonessential) Color.rgba8888ToColor(box.getColor(), color);
                            return box;
                        }
                    case Spine.AttachmentType.Mesh: 
                        {
                            var path1 = input.ReadStringRef();
                            var color1 = input.ReadInt();
                            var vertexCount1 = input.ReadInt$1(true);
                            var uvs = this.ReadFloatArray(input, vertexCount1 << 1, 1);
                            var triangles = this.ReadShortArray(input);
                            var vertices1 = this.ReadVertices(input, vertexCount1);
                            var hullLength = input.ReadInt$1(true);
                            var edges = null;
                            var width1 = 0, height1 = 0;
                            if (nonessential) {
                                edges = this.ReadShortArray(input);
                                width1 = input.ReadFloat();
                                height1 = input.ReadFloat();
                            }

                            if (path1 == null) {
                                path1 = name;
                            }
                            var mesh = this.attachmentLoader.Spine$AttachmentLoader$NewMeshAttachment(skin, name, path1);
                            if (mesh == null) {
                                return null;
                            }
                            mesh.Path = path1;
                            mesh.r = ((System.Int64(color1).and(System.Int64(4278190080))).shr(24)) / 255.0;
                            mesh.g = ((color1 & 16711680) >> 16) / 255.0;
                            mesh.b = ((color1 & 65280) >> 8) / 255.0;
                            mesh.a = ((color1 & 255)) / 255.0;
                            mesh.bones = vertices1.bones;
                            mesh.vertices = vertices1.vertices;
                            mesh.WorldVerticesLength = vertexCount1 << 1;
                            mesh.triangles = triangles;
                            mesh.regionUVs = uvs;
                            mesh.UpdateUVs();
                            mesh.HullLength = hullLength << 1;
                            if (nonessential) {
                                mesh.Edges = edges;
                                mesh.Width = width1 * scale;
                                mesh.Height = height1 * scale;
                            }
                            return mesh;
                        }
                    case Spine.AttachmentType.Linkedmesh: 
                        {
                            var path2 = input.ReadStringRef();
                            var color2 = input.ReadInt();
                            var skinName = input.ReadStringRef();
                            var parent = input.ReadStringRef();
                            var inheritDeform = input.ReadBoolean();
                            var width2 = 0, height2 = 0;
                            if (nonessential) {
                                width2 = input.ReadFloat();
                                height2 = input.ReadFloat();
                            }

                            if (path2 == null) {
                                path2 = name;
                            }
                            var mesh1 = this.attachmentLoader.Spine$AttachmentLoader$NewMeshAttachment(skin, name, path2);
                            if (mesh1 == null) {
                                return null;
                            }
                            mesh1.Path = path2;
                            mesh1.r = ((System.Int64(color2).and(System.Int64(4278190080))).shr(24)) / 255.0;
                            mesh1.g = ((color2 & 16711680) >> 16) / 255.0;
                            mesh1.b = ((color2 & 65280) >> 8) / 255.0;
                            mesh1.a = ((color2 & 255)) / 255.0;
                            if (nonessential) {
                                mesh1.Width = width2 * scale;
                                mesh1.Height = height2 * scale;
                            }
                            this.linkedMeshes.add(new Spine.SkeletonJson.LinkedMesh(mesh1, skinName, slotIndex, parent, inheritDeform));
                            return mesh1;
                        }
                    case Spine.AttachmentType.Path: 
                        {
                            var closed = input.ReadBoolean();
                            var constantSpeed = input.ReadBoolean();
                            var vertexCount2 = input.ReadInt$1(true);
                            var vertices2 = this.ReadVertices(input, vertexCount2);
                            var lengths = System.Array.init(((Bridge.Int.div(vertexCount2, 3)) | 0), 0, System.Single);
                            for (var i = 0, n = lengths.length; i < n; i = (i + 1) | 0) {
                                lengths[i] = input.ReadFloat() * scale;
                            }
                            if (nonessential) {
                                input.ReadInt();
                            } //int color = nonessential ? input.ReadInt() : 0;

                            var path3 = this.attachmentLoader.Spine$AttachmentLoader$NewPathAttachment(skin, name);
                            if (path3 == null) {
                                return null;
                            }
                            path3.closed = closed;
                            path3.constantSpeed = constantSpeed;
                            path3.worldVerticesLength = vertexCount2 << 1;
                            path3.vertices = vertices2.vertices;
                            path3.bones = vertices2.bones;
                            path3.lengths = lengths;
                            // skipped porting: if (nonessential) Color.rgba8888ToColor(path.getColor(), color);
                            return path3;
                        }
                    case Spine.AttachmentType.Point: 
                        {
                            var rotation1 = input.ReadFloat();
                            var x1 = input.ReadFloat();
                            var y1 = input.ReadFloat();
                            if (nonessential) {
                                input.ReadInt();
                            } //int color = nonessential ? input.ReadInt() : 0;

                            var point = this.attachmentLoader.Spine$AttachmentLoader$NewPointAttachment(skin, name);
                            if (point == null) {
                                return null;
                            }
                            point.x = x1 * scale;
                            point.y = y1 * scale;
                            point.rotation = rotation1;
                            // skipped porting: if (nonessential) point.color = color;
                            return point;
                        }
                    case Spine.AttachmentType.Clipping: 
                        {
                            var endSlotIndex = input.ReadInt$1(true);
                            var vertexCount3 = input.ReadInt$1(true);
                            var vertices3 = this.ReadVertices(input, vertexCount3);
                            if (nonessential) {
                                input.ReadInt();
                            }

                            var clip = this.attachmentLoader.Spine$AttachmentLoader$NewClippingAttachment(skin, name);
                            if (clip == null) {
                                return null;
                            }
                            clip.EndSlot = ($t = skeletonData.slots.Items)[endSlotIndex];
                            clip.worldVerticesLength = vertexCount3 << 1;
                            clip.vertices = vertices3.vertices;
                            clip.bones = vertices3.bones;
                            // skipped porting: if (nonessential) Color.rgba8888ToColor(clip.getColor(), color);
                            return clip;
                        }
                }
                return null;
            },
            /*Spine.SkeletonBinary.ReadAttachment end.*/

            /*Spine.SkeletonBinary.ReadVertices start.*/
            ReadVertices: function (input, vertexCount) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadVertices", this ); }

                var scale = this.Scale;
                var verticesLength = vertexCount << 1;
                var vertices = new Spine.SkeletonBinary.Vertices();
                if (!input.ReadBoolean()) {
                    vertices.vertices = this.ReadFloatArray(input, verticesLength, scale);
                    return vertices;
                }
                var weights = new (Spine.ExposedList$1(System.Single)).$ctor3(Bridge.Int.mul(Bridge.Int.mul(verticesLength, 3), 3));
                var bonesArray = new (Spine.ExposedList$1(System.Int32)).$ctor3(Bridge.Int.mul(verticesLength, 3));
                for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                    var boneCount = input.ReadInt$1(true);
                    bonesArray.Add(boneCount);
                    for (var ii = 0; ii < boneCount; ii = (ii + 1) | 0) {
                        bonesArray.Add(input.ReadInt$1(true));
                        weights.Add(input.ReadFloat() * scale);
                        weights.Add(input.ReadFloat() * scale);
                        weights.Add(input.ReadFloat());
                    }
                }

                vertices.vertices = weights.ToArray();
                vertices.bones = bonesArray.ToArray();
                return vertices;
            },
            /*Spine.SkeletonBinary.ReadVertices end.*/

            /*Spine.SkeletonBinary.ReadFloatArray start.*/
            ReadFloatArray: function (input, n, scale) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadFloatArray", this ); }

                var array = System.Array.init(n, 0, System.Single);
                if (scale === 1) {
                    for (var i = 0; i < n; i = (i + 1) | 0) {
                        array[i] = input.ReadFloat();
                    }
                } else {
                    for (var i1 = 0; i1 < n; i1 = (i1 + 1) | 0) {
                        array[i1] = input.ReadFloat() * scale;
                    }
                }
                return array;
            },
            /*Spine.SkeletonBinary.ReadFloatArray end.*/

            /*Spine.SkeletonBinary.ReadShortArray start.*/
            ReadShortArray: function (input) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadShortArray", this ); }

                var n = input.ReadInt$1(true);
                var array = System.Array.init(n, 0, System.Int32);
                for (var i = 0; i < n; i = (i + 1) | 0) {
                    array[i] = (input.ReadByte() << 8) | input.ReadByte();
                }
                return array;
            },
            /*Spine.SkeletonBinary.ReadShortArray end.*/

            /*Spine.SkeletonBinary.ReadAnimation start.*/
            ReadAnimation: function (name, input, skeletonData) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadAnimation", this ); }

                var $t, $t1, $t2, $t3;
                var timelines = new (Spine.ExposedList$1(Spine.Timeline)).$ctor3(32);
                var scale = this.Scale;
                var duration = 0;

                // Slot timelines.
                for (var i = 0, n = input.ReadInt$1(true); i < n; i = (i + 1) | 0) {
                    var slotIndex = input.ReadInt$1(true);
                    for (var ii = 0, nn = input.ReadInt$1(true); ii < nn; ii = (ii + 1) | 0) {
                        var timelineType = input.ReadByte();
                        var frameCount = input.ReadInt$1(true);
                        switch (timelineType) {
                            case Spine.SkeletonBinary.SLOT_ATTACHMENT: 
                                {
                                    var timeline = new Spine.AttachmentTimeline(frameCount);
                                    timeline.slotIndex = slotIndex;
                                    for (var frameIndex = 0; frameIndex < frameCount; frameIndex = (frameIndex + 1) | 0) {
                                        timeline.SetFrame(frameIndex, input.ReadFloat(), input.ReadStringRef());
                                    }
                                    timelines.Add(timeline);
                                    duration = Math.max(duration, timeline.frames[((frameCount - 1) | 0)]);
                                    break;
                                }
                            case Spine.SkeletonBinary.SLOT_COLOR: 
                                {
                                    var timeline1 = new Spine.ColorTimeline(frameCount);
                                    timeline1.slotIndex = slotIndex;
                                    for (var frameIndex1 = 0; frameIndex1 < frameCount; frameIndex1 = (frameIndex1 + 1) | 0) {
                                        var time = input.ReadFloat();
                                        var color = input.ReadInt();
                                        var r = ((System.Int64(color).and(System.Int64(4278190080))).shr(24)) / 255.0;
                                        var g = ((color & 16711680) >> 16) / 255.0;
                                        var b = ((color & 65280) >> 8) / 255.0;
                                        var a = ((color & 255)) / 255.0;
                                        timeline1.SetFrame(frameIndex1, time, r, g, b, a);
                                        if (frameIndex1 < ((frameCount - 1) | 0)) {
                                            this.ReadCurve(input, frameIndex1, timeline1);
                                        }
                                    }
                                    timelines.Add(timeline1);
                                    duration = Math.max(duration, timeline1.frames[Bridge.Int.mul((((frameCount - 1) | 0)), Spine.ColorTimeline.ENTRIES)]);
                                    break;
                                }
                            case Spine.SkeletonBinary.SLOT_TWO_COLOR: 
                                {
                                    var timeline2 = new Spine.TwoColorTimeline(frameCount);
                                    timeline2.slotIndex = slotIndex;
                                    for (var frameIndex2 = 0; frameIndex2 < frameCount; frameIndex2 = (frameIndex2 + 1) | 0) {
                                        var time1 = input.ReadFloat();
                                        var color1 = input.ReadInt();
                                        var r1 = ((System.Int64(color1).and(System.Int64(4278190080))).shr(24)) / 255.0;
                                        var g1 = ((color1 & 16711680) >> 16) / 255.0;
                                        var b1 = ((color1 & 65280) >> 8) / 255.0;
                                        var a1 = ((color1 & 255)) / 255.0;
                                        var color2 = input.ReadInt(); // 0x00rrggbb
                                        var r2 = ((color2 & 16711680) >> 16) / 255.0;
                                        var g2 = ((color2 & 65280) >> 8) / 255.0;
                                        var b2 = ((color2 & 255)) / 255.0;

                                        timeline2.SetFrame(frameIndex2, time1, r1, g1, b1, a1, r2, g2, b2);
                                        if (frameIndex2 < ((frameCount - 1) | 0)) {
                                            this.ReadCurve(input, frameIndex2, timeline2);
                                        }
                                    }
                                    timelines.Add(timeline2);
                                    duration = Math.max(duration, timeline2.frames[Bridge.Int.mul((((frameCount - 1) | 0)), Spine.TwoColorTimeline.ENTRIES)]);
                                    break;
                                }
                        }
                    }
                }

                // Bone timelines.
                for (var i1 = 0, n1 = input.ReadInt$1(true); i1 < n1; i1 = (i1 + 1) | 0) {
                    var boneIndex = input.ReadInt$1(true);
                    for (var ii1 = 0, nn1 = input.ReadInt$1(true); ii1 < nn1; ii1 = (ii1 + 1) | 0) {
                        var timelineType1 = input.ReadByte();
                        var frameCount1 = input.ReadInt$1(true);
                        switch (timelineType1) {
                            case Spine.SkeletonBinary.BONE_ROTATE: 
                                {
                                    var timeline3 = new Spine.RotateTimeline(frameCount1);
                                    timeline3.boneIndex = boneIndex;
                                    for (var frameIndex3 = 0; frameIndex3 < frameCount1; frameIndex3 = (frameIndex3 + 1) | 0) {
                                        timeline3.SetFrame(frameIndex3, input.ReadFloat(), input.ReadFloat());
                                        if (frameIndex3 < ((frameCount1 - 1) | 0)) {
                                            this.ReadCurve(input, frameIndex3, timeline3);
                                        }
                                    }
                                    timelines.Add(timeline3);
                                    duration = Math.max(duration, timeline3.frames[Bridge.Int.mul((((frameCount1 - 1) | 0)), Spine.RotateTimeline.ENTRIES)]);
                                    break;
                                }
                            case Spine.SkeletonBinary.BONE_TRANSLATE: 
                            case Spine.SkeletonBinary.BONE_SCALE: 
                            case Spine.SkeletonBinary.BONE_SHEAR: 
                                {
                                    var timeline4;
                                    var timelineScale = 1;
                                    if (timelineType1 === Spine.SkeletonBinary.BONE_SCALE) {
                                        timeline4 = new Spine.ScaleTimeline(frameCount1);
                                    } else {
                                        if (timelineType1 === Spine.SkeletonBinary.BONE_SHEAR) {
                                            timeline4 = new Spine.ShearTimeline(frameCount1);
                                        } else {
                                            timeline4 = new Spine.TranslateTimeline(frameCount1);
                                            timelineScale = scale;
                                        }
                                    }
                                    timeline4.boneIndex = boneIndex;
                                    for (var frameIndex4 = 0; frameIndex4 < frameCount1; frameIndex4 = (frameIndex4 + 1) | 0) {
                                        timeline4.SetFrame(frameIndex4, input.ReadFloat(), input.ReadFloat() * timelineScale, input.ReadFloat() * timelineScale);
                                        if (frameIndex4 < ((frameCount1 - 1) | 0)) {
                                            this.ReadCurve(input, frameIndex4, timeline4);
                                        }
                                    }
                                    timelines.Add(timeline4);
                                    duration = Math.max(duration, timeline4.frames[Bridge.Int.mul((((frameCount1 - 1) | 0)), Spine.TranslateTimeline.ENTRIES)]);
                                    break;
                                }
                        }
                    }
                }

                // IK constraint timelines.
                for (var i2 = 0, n2 = input.ReadInt$1(true); i2 < n2; i2 = (i2 + 1) | 0) {
                    var index = input.ReadInt$1(true);
                    var frameCount2 = input.ReadInt$1(true);
                    var timeline5 = ($t = new Spine.IkConstraintTimeline(frameCount2), $t.ikConstraintIndex = index, $t);
                    for (var frameIndex5 = 0; frameIndex5 < frameCount2; frameIndex5 = (frameIndex5 + 1) | 0) {
                        timeline5.SetFrame(frameIndex5, input.ReadFloat(), input.ReadFloat(), input.ReadFloat() * scale, input.ReadSByte(), input.ReadBoolean(), input.ReadBoolean());
                        if (frameIndex5 < ((frameCount2 - 1) | 0)) {
                            this.ReadCurve(input, frameIndex5, timeline5);
                        }
                    }
                    timelines.Add(timeline5);
                    duration = Math.max(duration, timeline5.frames[Bridge.Int.mul((((frameCount2 - 1) | 0)), Spine.IkConstraintTimeline.ENTRIES)]);
                }

                // Transform constraint timelines.
                for (var i3 = 0, n3 = input.ReadInt$1(true); i3 < n3; i3 = (i3 + 1) | 0) {
                    var index1 = input.ReadInt$1(true);
                    var frameCount3 = input.ReadInt$1(true);
                    var timeline6 = new Spine.TransformConstraintTimeline(frameCount3);
                    timeline6.transformConstraintIndex = index1;
                    for (var frameIndex6 = 0; frameIndex6 < frameCount3; frameIndex6 = (frameIndex6 + 1) | 0) {
                        timeline6.SetFrame(frameIndex6, input.ReadFloat(), input.ReadFloat(), input.ReadFloat(), input.ReadFloat(), input.ReadFloat());
                        if (frameIndex6 < ((frameCount3 - 1) | 0)) {
                            this.ReadCurve(input, frameIndex6, timeline6);
                        }
                    }
                    timelines.Add(timeline6);
                    duration = Math.max(duration, timeline6.frames[Bridge.Int.mul((((frameCount3 - 1) | 0)), Spine.TransformConstraintTimeline.ENTRIES)]);
                }

                // Path constraint timelines.
                for (var i4 = 0, n4 = input.ReadInt$1(true); i4 < n4; i4 = (i4 + 1) | 0) {
                    var index2 = input.ReadInt$1(true);
                    var data = ($t = skeletonData.pathConstraints.Items)[index2];
                    for (var ii2 = 0, nn2 = input.ReadInt$1(true); ii2 < nn2; ii2 = (ii2 + 1) | 0) {
                        var timelineType2 = input.ReadSByte();
                        var frameCount4 = input.ReadInt$1(true);
                        switch (timelineType2) {
                            case Spine.SkeletonBinary.PATH_POSITION: 
                            case Spine.SkeletonBinary.PATH_SPACING: 
                                {
                                    var timeline7;
                                    var timelineScale1 = 1;
                                    if (timelineType2 === Spine.SkeletonBinary.PATH_SPACING) {
                                        timeline7 = new Spine.PathConstraintSpacingTimeline(frameCount4);
                                        if (data.spacingMode === Spine.SpacingMode.Length || data.spacingMode === Spine.SpacingMode.Fixed) {
                                            timelineScale1 = scale;
                                        }
                                    } else {
                                        timeline7 = new Spine.PathConstraintPositionTimeline(frameCount4);
                                        if (data.positionMode === Spine.PositionMode.Fixed) {
                                            timelineScale1 = scale;
                                        }
                                    }
                                    timeline7.pathConstraintIndex = index2;
                                    for (var frameIndex7 = 0; frameIndex7 < frameCount4; frameIndex7 = (frameIndex7 + 1) | 0) {
                                        timeline7.SetFrame(frameIndex7, input.ReadFloat(), input.ReadFloat() * timelineScale1);
                                        if (frameIndex7 < ((frameCount4 - 1) | 0)) {
                                            this.ReadCurve(input, frameIndex7, timeline7);
                                        }
                                    }
                                    timelines.Add(timeline7);
                                    duration = Math.max(duration, timeline7.frames[Bridge.Int.mul((((frameCount4 - 1) | 0)), Spine.PathConstraintPositionTimeline.ENTRIES)]);
                                    break;
                                }
                            case Spine.SkeletonBinary.PATH_MIX: 
                                {
                                    var timeline8 = new Spine.PathConstraintMixTimeline(frameCount4);
                                    timeline8.pathConstraintIndex = index2;
                                    for (var frameIndex8 = 0; frameIndex8 < frameCount4; frameIndex8 = (frameIndex8 + 1) | 0) {
                                        timeline8.SetFrame(frameIndex8, input.ReadFloat(), input.ReadFloat(), input.ReadFloat());
                                        if (frameIndex8 < ((frameCount4 - 1) | 0)) {
                                            this.ReadCurve(input, frameIndex8, timeline8);
                                        }
                                    }
                                    timelines.Add(timeline8);
                                    duration = Math.max(duration, timeline8.frames[Bridge.Int.mul((((frameCount4 - 1) | 0)), Spine.PathConstraintMixTimeline.ENTRIES)]);
                                    break;
                                }
                        }
                    }
                }

                // Deform timelines.
                for (var i5 = 0, n5 = input.ReadInt$1(true); i5 < n5; i5 = (i5 + 1) | 0) {
                    var skin = ($t1 = skeletonData.skins.Items)[input.ReadInt$1(true)];
                    for (var ii3 = 0, nn3 = input.ReadInt$1(true); ii3 < nn3; ii3 = (ii3 + 1) | 0) {
                        var slotIndex1 = input.ReadInt$1(true);
                        for (var iii = 0, nnn = input.ReadInt$1(true); iii < nnn; iii = (iii + 1) | 0) {
                            var attachment = Bridge.cast(skin.GetAttachment(slotIndex1, input.ReadStringRef()), Spine.VertexAttachment);
                            var weighted = attachment.bones != null;
                            var vertices = attachment.vertices;
                            var deformLength = weighted ? Bridge.Int.mul(((Bridge.Int.div(vertices.length, 3)) | 0), 2) : vertices.length;

                            var frameCount5 = input.ReadInt$1(true);
                            var timeline9 = new Spine.DeformTimeline(frameCount5);
                            timeline9.slotIndex = slotIndex1;
                            timeline9.attachment = attachment;

                            for (var frameIndex9 = 0; frameIndex9 < frameCount5; frameIndex9 = (frameIndex9 + 1) | 0) {
                                var time2 = input.ReadFloat();
                                var deform;
                                var end = input.ReadInt$1(true);
                                if (end === 0) {
                                    deform = weighted ? System.Array.init(deformLength, 0, System.Single) : vertices;
                                } else {
                                    deform = System.Array.init(deformLength, 0, System.Single);
                                    var start = input.ReadInt$1(true);
                                    end = (end + start) | 0;
                                    if (scale === 1) {
                                        for (var v = start; v < end; v = (v + 1) | 0) {
                                            deform[v] = input.ReadFloat();
                                        }
                                    } else {
                                        for (var v1 = start; v1 < end; v1 = (v1 + 1) | 0) {
                                            deform[v1] = input.ReadFloat() * scale;
                                        }
                                    }
                                    if (!weighted) {
                                        for (var v2 = 0, vn = deform.length; v2 < vn; v2 = (v2 + 1) | 0) {
                                            deform[v2] += vertices[v2];
                                        }
                                    }
                                }

                                timeline9.SetFrame(frameIndex9, time2, deform);
                                if (frameIndex9 < ((frameCount5 - 1) | 0)) {
                                    this.ReadCurve(input, frameIndex9, timeline9);
                                }
                            }
                            timelines.Add(timeline9);
                            duration = Math.max(duration, timeline9.frames[((frameCount5 - 1) | 0)]);
                        }
                    }
                }

                // Draw order timeline.
                var drawOrderCount = input.ReadInt$1(true);
                if (drawOrderCount > 0) {
                    var timeline10 = new Spine.DrawOrderTimeline(drawOrderCount);
                    var slotCount = skeletonData.slots.Count;
                    for (var i6 = 0; i6 < drawOrderCount; i6 = (i6 + 1) | 0) {
                        var time3 = input.ReadFloat();
                        var offsetCount = input.ReadInt$1(true);
                        var drawOrder = System.Array.init(slotCount, 0, System.Int32);
                        for (var ii4 = (slotCount - 1) | 0; ii4 >= 0; ii4 = (ii4 - 1) | 0) {
                            drawOrder[ii4] = -1;
                        }
                        var unchanged = System.Array.init(((slotCount - offsetCount) | 0), 0, System.Int32);
                        var originalIndex = 0, unchangedIndex = 0;
                        for (var ii5 = 0; ii5 < offsetCount; ii5 = (ii5 + 1) | 0) {
                            var slotIndex2 = input.ReadInt$1(true);
                            // Collect unchanged items.
                            while (originalIndex !== slotIndex2) {
                                unchanged[Bridge.identity(unchangedIndex, ((unchangedIndex = (unchangedIndex + 1) | 0)))] = Bridge.identity(originalIndex, ((originalIndex = (originalIndex + 1) | 0)));
                            }
                            // Set changed items.
                            drawOrder[((originalIndex + input.ReadInt$1(true)) | 0)] = Bridge.identity(originalIndex, ((originalIndex = (originalIndex + 1) | 0)));
                        }
                        // Collect remaining unchanged items.
                        while (originalIndex < slotCount) {
                            unchanged[Bridge.identity(unchangedIndex, ((unchangedIndex = (unchangedIndex + 1) | 0)))] = Bridge.identity(originalIndex, ((originalIndex = (originalIndex + 1) | 0)));
                        }
                        // Fill in unchanged items.
                        for (var ii6 = (slotCount - 1) | 0; ii6 >= 0; ii6 = (ii6 - 1) | 0) {
                            if (drawOrder[ii6] === -1) {
                                drawOrder[ii6] = unchanged[((unchangedIndex = (unchangedIndex - 1) | 0))];
                            }
                        }
                        timeline10.SetFrame(i6, time3, drawOrder);
                    }
                    timelines.Add(timeline10);
                    duration = Math.max(duration, timeline10.frames[((drawOrderCount - 1) | 0)]);
                }

                // Event timeline.
                var eventCount = input.ReadInt$1(true);
                if (eventCount > 0) {
                    var timeline11 = new Spine.EventTimeline(eventCount);
                    for (var i7 = 0; i7 < eventCount; i7 = (i7 + 1) | 0) {
                        var time4 = input.ReadFloat();
                        var eventData = ($t2 = skeletonData.events.Items)[input.ReadInt$1(true)];
                        var e = ($t3 = new Spine.Event(time4, eventData), $t3.Int = input.ReadInt$1(false), $t3.Float = input.ReadFloat(), $t3.String = input.ReadBoolean() ? input.ReadString() : eventData.String, $t3);
                        if (e.data.AudioPath != null) {
                            e.volume = input.ReadFloat();
                            e.balance = input.ReadFloat();
                        }
                        timeline11.SetFrame(i7, e);
                    }
                    timelines.Add(timeline11);
                    duration = Math.max(duration, timeline11.frames[((eventCount - 1) | 0)]);
                }

                timelines.TrimExcess();
                return new Spine.Animation(name, timelines, duration);
            },
            /*Spine.SkeletonBinary.ReadAnimation end.*/

            /*Spine.SkeletonBinary.ReadCurve start.*/
            ReadCurve: function (input, frameIndex, timeline) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadCurve", this ); }

                switch (input.ReadByte()) {
                    case Spine.SkeletonBinary.CURVE_STEPPED: 
                        timeline.SetStepped(frameIndex);
                        break;
                    case Spine.SkeletonBinary.CURVE_BEZIER: 
                        timeline.SetCurve(frameIndex, input.ReadFloat(), input.ReadFloat(), input.ReadFloat(), input.ReadFloat());
                        break;
                }
            },
            /*Spine.SkeletonBinary.ReadCurve end.*/


        },
        overloads: {
            "ReadSkeletonData(String)": "ReadSkeletonData$1"
        }
    });
    /*Spine.SkeletonBinary end.*/

    /*Spine.SkeletonBinary+SkeletonInput start.*/
    Bridge.define("Spine.SkeletonBinary.SkeletonInput", {
        $kind: 1002,
        fields: {
            chars: null,
            bytesBigEndian: null,
            strings: null,
            input: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#init", this ); }

                this.chars = System.Array.init(32, 0, System.Byte);
                this.bytesBigEndian = System.Array.init(4, 0, System.Byte);
            },
            ctor: function (input) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ctor", this ); }

                this.$initialize();
                this.input = input;
            }
        },
        methods: {
            /*Spine.SkeletonBinary+SkeletonInput.ReadByte start.*/
            ReadByte: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadByte", this ); }

                return ((this.input.ReadByte()) & 255);
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadByte end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadSByte start.*/
            ReadSByte: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadSByte", this ); }

                var value = this.input.ReadByte();
                if (value === -1) {
                    throw new System.IO.EndOfStreamException.ctor();
                }
                return Bridge.Int.sxb(value & 255);
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadSByte end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadBoolean start.*/
            ReadBoolean: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadBoolean", this ); }

                return this.input.ReadByte() !== 0;
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadBoolean end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadFloat start.*/
            ReadFloat: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadFloat", this ); }

                this.input.Read(this.bytesBigEndian, 0, 4);
                this.chars[3] = this.bytesBigEndian[0];
                this.chars[2] = this.bytesBigEndian[1];
                this.chars[1] = this.bytesBigEndian[2];
                this.chars[0] = this.bytesBigEndian[3];
                return System.BitConverter.toSingle(this.chars, 0);
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadFloat end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadInt start.*/
            ReadInt: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadInt", this ); }

                this.input.Read(this.bytesBigEndian, 0, 4);
                return (((((((this.bytesBigEndian[0] << 24) + (this.bytesBigEndian[1] << 16)) | 0) + (this.bytesBigEndian[2] << 8)) | 0) + this.bytesBigEndian[3]) | 0);
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadInt end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadInt$1 start.*/
            ReadInt$1: function (optimizePositive) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadInt$1", this ); }

                var b = this.input.ReadByte();
                var result = b & 127;
                if ((b & 128) !== 0) {
                    b = this.input.ReadByte();
                    result = result | ((b & 127) << 7);
                    if ((b & 128) !== 0) {
                        b = this.input.ReadByte();
                        result = result | ((b & 127) << 14);
                        if ((b & 128) !== 0) {
                            b = this.input.ReadByte();
                            result = result | ((b & 127) << 21);
                            if ((b & 128) !== 0) {
                                result = result | ((this.input.ReadByte() & 127) << 28);
                            }
                        }
                    }
                }
                return optimizePositive ? result : ((result >> 1) ^ ((-(result & 1)) | 0));
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadInt$1 end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadString start.*/
            ReadString: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadString", this ); }

                var byteCount = this.ReadInt$1(true);
                switch (byteCount) {
                    case 0: 
                        return null;
                    case 1: 
                        return "";
                }
                byteCount = (byteCount - 1) | 0;
                var buffer = this.chars;
                if (buffer.length < byteCount) {
                    buffer = System.Array.init(byteCount, 0, System.Byte);
                }
                this.ReadFully(buffer, 0, byteCount);
                return System.Text.Encoding.UTF8.GetString$1(buffer, 0, byteCount);
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadString end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadStringRef start.*/
            /**
             * @instance
             * @public
             * @this Spine.SkeletonBinary.SkeletonInput
             * @memberof Spine.SkeletonBinary.SkeletonInput
             * @return  {string}
             */
            ReadStringRef: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadStringRef", this ); }

                var $t;
                var index = this.ReadInt$1(true);
                return index === 0 ? null : ($t = this.strings.Items)[((index - 1) | 0)];
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadStringRef end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadFully start.*/
            ReadFully: function (buffer, offset, length) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadFully", this ); }

                while (length > 0) {
                    var count = this.input.Read(buffer, offset, length);
                    if (count <= 0) {
                        throw new System.IO.EndOfStreamException.ctor();
                    }
                    offset = (offset + count) | 0;
                    length = (length - count) | 0;
                }
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadFully end.*/

            /*Spine.SkeletonBinary+SkeletonInput.GetVersionString start.*/
            /**
             * Returns the version string of binary skeleton data.
             *
             * @instance
             * @public
             * @this Spine.SkeletonBinary.SkeletonInput
             * @memberof Spine.SkeletonBinary.SkeletonInput
             * @return  {string}
             */
            GetVersionString: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#GetVersionString", this ); }

                var $t;
                try {
                    // Hash.
                    var byteCount = this.ReadInt$1(true);
                    if (byteCount > 1) {
                        ($t = this.input).Position = $t.Position.add(System.Int64(byteCount - 1));
                    }

                    // Version.
                    byteCount = this.ReadInt$1(true);
                    if (byteCount > 1) {
                        byteCount = (byteCount - 1) | 0;
                        var buffer = System.Array.init(byteCount, 0, System.Byte);
                        this.ReadFully(buffer, 0, byteCount);
                        return System.Text.Encoding.UTF8.GetString$1(buffer, 0, byteCount);
                    }

                    throw new System.ArgumentException.$ctor3("Stream does not contain a valid binary Skeleton Data.", "input");
                } catch (e) {
                    e = System.Exception.create(e);
                    throw new System.ArgumentException.$ctor3(System.String.concat("Stream does not contain a valid binary Skeleton Data.\n", e), "input");
                }
            },
            /*Spine.SkeletonBinary+SkeletonInput.GetVersionString end.*/


        },
        overloads: {
            "ReadInt(bool)": "ReadInt$1"
        }
    });
    /*Spine.SkeletonBinary+SkeletonInput end.*/

    /*Spine.SkeletonBinary+Vertices start.*/
    Bridge.define("Spine.SkeletonBinary.Vertices", {
        $kind: 1002,
        fields: {
            bones: null,
            vertices: null
        }
    });
    /*Spine.SkeletonBinary+Vertices end.*/

    /*Spine.SkeletonBounds start.*/
    /**
     * Collects each BoundingBoxAttachment that is visible and computes the world vertices for its polygon.
     The polygon vertices are provided along with convenience methods for doing hit detection.
     *
     * @public
     * @class Spine.SkeletonBounds
     */
    Bridge.define("Spine.SkeletonBounds", {
        fields: {
            polygonPool: null,
            minX: 0,
            minY: 0,
            maxX: 0,
            maxY: 0,
            BoundingBoxes: null,
            Polygons: null
        },
        props: {
            MinX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#MinX#get", this ); }

                    return this.minX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#MinX#set", this ); }

                    this.minX = value;
                }
            },
            MinY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#MinY#get", this ); }

                    return this.minY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#MinY#set", this ); }

                    this.minY = value;
                }
            },
            MaxX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#MaxX#get", this ); }

                    return this.maxX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#MaxX#set", this ); }

                    this.maxX = value;
                }
            },
            MaxY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#MaxY#get", this ); }

                    return this.maxY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#MaxY#set", this ); }

                    this.maxY = value;
                }
            },
            Width: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#Width#get", this ); }

                    return this.maxX - this.minX;
                }
            },
            Height: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#Height#get", this ); }

                    return this.maxY - this.minY;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#init", this ); }

                this.polygonPool = new (Spine.ExposedList$1(Spine.Polygon)).ctor();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#ctor", this ); }

                this.$initialize();
                this.BoundingBoxes = new (Spine.ExposedList$1(Spine.BoundingBoxAttachment)).ctor();
                this.Polygons = new (Spine.ExposedList$1(Spine.Polygon)).ctor();
            }
        },
        methods: {
            /*Spine.SkeletonBounds.Update start.*/
            /**
             * Clears any previous polygons, finds all visible bounding box attachments,
             and computes the world vertices for each bounding box's polygon.
             *
             * @instance
             * @public
             * @this Spine.SkeletonBounds
             * @memberof Spine.SkeletonBounds
             * @param   {Spine.Skeleton}    skeleton      The skeleton.
             * @param   {boolean}           updateAabb    If true, the axis aligned bounding box containing all the polygons is computed.
             If false, the SkeletonBounds AABB methods will always return true.
             * @return  {void}
             */
            Update: function (skeleton, updateAabb) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#Update", this ); }

                var $t;
                var boundingBoxes = this.BoundingBoxes;
                var polygons = this.Polygons;
                var slots = skeleton.slots;
                var slotCount = slots.Count;

                boundingBoxes.Clear();
                for (var i = 0, n = polygons.Count; i < n; i = (i + 1) | 0) {
                    this.polygonPool.Add(polygons.Items[i]);
                }
                polygons.Clear();

                for (var i1 = 0; i1 < slotCount; i1 = (i1 + 1) | 0) {
                    var slot = slots.Items[i1];
                    if (!slot.bone.active) {
                        continue;
                    }
                    var boundingBox = Bridge.as(slot.attachment, Spine.BoundingBoxAttachment);
                    if (boundingBox == null) {
                        continue;
                    }
                    boundingBoxes.Add(boundingBox);

                    var polygon = null;
                    var poolCount = this.polygonPool.Count;
                    if (poolCount > 0) {
                        polygon = ($t = this.polygonPool.Items)[((poolCount - 1) | 0)];
                        this.polygonPool.RemoveAt(((poolCount - 1) | 0));
                    } else {
                        polygon = new Spine.Polygon();
                    }
                    polygons.Add(polygon);

                    var count = boundingBox.worldVerticesLength;
                    polygon.Count = count;
                    if (polygon.Vertices.length < count) {
                        polygon.Vertices = System.Array.init(count, 0, System.Single);
                    }
                    boundingBox.ComputeWorldVertices$1(slot, polygon.Vertices);
                }

                if (updateAabb) {
                    this.AabbCompute();
                } else {
                    this.minX = -2147483648;
                    this.minY = -2147483648;
                    this.maxX = 2147483647;
                    this.maxY = 2147483647;
                }
            },
            /*Spine.SkeletonBounds.Update end.*/

            /*Spine.SkeletonBounds.AabbCompute start.*/
            AabbCompute: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#AabbCompute", this ); }

                var minX = 2147483647, minY = 2147483647, maxX = -2147483648, maxY = -2147483648;
                var polygons = this.Polygons;
                for (var i = 0, n = polygons.Count; i < n; i = (i + 1) | 0) {
                    var polygon = polygons.Items[i];
                    var vertices = polygon.Vertices;
                    for (var ii = 0, nn = polygon.Count; ii < nn; ii = (ii + 2) | 0) {
                        var x = vertices[ii];
                        var y = vertices[((ii + 1) | 0)];
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                    }
                }
                this.minX = minX;
                this.minY = minY;
                this.maxX = maxX;
                this.maxY = maxY;
            },
            /*Spine.SkeletonBounds.AabbCompute end.*/

            /*Spine.SkeletonBounds.AabbContainsPoint start.*/
            /**
             * Returns true if the axis aligned bounding box contains the point.
             *
             * @instance
             * @public
             * @this Spine.SkeletonBounds
             * @memberof Spine.SkeletonBounds
             * @param   {number}     x    
             * @param   {number}     y
             * @return  {boolean}
             */
            AabbContainsPoint: function (x, y) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#AabbContainsPoint", this ); }

                return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;
            },
            /*Spine.SkeletonBounds.AabbContainsPoint end.*/

            /*Spine.SkeletonBounds.AabbIntersectsSegment start.*/
            /**
             * Returns true if the axis aligned bounding box intersects the line segment.
             *
             * @instance
             * @public
             * @this Spine.SkeletonBounds
             * @memberof Spine.SkeletonBounds
             * @param   {number}     x1    
             * @param   {number}     y1    
             * @param   {number}     x2    
             * @param   {number}     y2
             * @return  {boolean}
             */
            AabbIntersectsSegment: function (x1, y1, x2, y2) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#AabbIntersectsSegment", this ); }

                var minX = this.minX;
                var minY = this.minY;
                var maxX = this.maxX;
                var maxY = this.maxY;
                if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY)) {
                    return false;
                }
                var m = (y2 - y1) / (x2 - x1);
                var y = m * (minX - x1) + y1;
                if (y > minY && y < maxY) {
                    return true;
                }
                y = m * (maxX - x1) + y1;
                if (y > minY && y < maxY) {
                    return true;
                }
                var x = (minY - y1) / m + x1;
                if (x > minX && x < maxX) {
                    return true;
                }
                x = (maxY - y1) / m + x1;
                if (x > minX && x < maxX) {
                    return true;
                }
                return false;
            },
            /*Spine.SkeletonBounds.AabbIntersectsSegment end.*/

            /*Spine.SkeletonBounds.AabbIntersectsSkeleton start.*/
            /**
             * Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds.
             *
             * @instance
             * @public
             * @this Spine.SkeletonBounds
             * @memberof Spine.SkeletonBounds
             * @param   {Spine.SkeletonBounds}    bounds
             * @return  {boolean}
             */
            AabbIntersectsSkeleton: function (bounds) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#AabbIntersectsSkeleton", this ); }

                return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;
            },
            /*Spine.SkeletonBounds.AabbIntersectsSkeleton end.*/

            /*Spine.SkeletonBounds.ContainsPoint$1 start.*/
            /**
             * Returns true if the polygon contains the point.
             *
             * @instance
             * @public
             * @this Spine.SkeletonBounds
             * @memberof Spine.SkeletonBounds
             * @param   {Spine.Polygon}    polygon    
             * @param   {number}           x          
             * @param   {number}           y
             * @return  {boolean}
             */
            ContainsPoint$1: function (polygon, x, y) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#ContainsPoint$1", this ); }

                var vertices = polygon.Vertices;
                var nn = polygon.Count;

                var prevIndex = (nn - 2) | 0;
                var inside = false;
                for (var ii = 0; ii < nn; ii = (ii + 2) | 0) {
                    var vertexY = vertices[((ii + 1) | 0)];
                    var prevY = vertices[((prevIndex + 1) | 0)];
                    if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {
                        var vertexX = vertices[ii];
                        if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x) {
                            inside = !inside;
                        }
                    }
                    prevIndex = ii;
                }
                return inside;
            },
            /*Spine.SkeletonBounds.ContainsPoint$1 end.*/

            /*Spine.SkeletonBounds.ContainsPoint start.*/
            /**
             * Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more
             efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true.
             *
             * @instance
             * @public
             * @this Spine.SkeletonBounds
             * @memberof Spine.SkeletonBounds
             * @param   {number}                         x    
             * @param   {number}                         y
             * @return  {Spine.BoundingBoxAttachment}
             */
            ContainsPoint: function (x, y) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#ContainsPoint", this ); }

                var $t;
                var polygons = this.Polygons;
                for (var i = 0, n = polygons.Count; i < n; i = (i + 1) | 0) {
                    if (this.ContainsPoint$1(polygons.Items[i], x, y)) {
                        return ($t = this.BoundingBoxes.Items)[i];
                    }
                }
                return null;
            },
            /*Spine.SkeletonBounds.ContainsPoint end.*/

            /*Spine.SkeletonBounds.IntersectsSegment start.*/
            /**
             * Returns the first bounding box attachment that contains the line segment, or null. When doing many checks, it is usually
             more efficient to only call this method if {@link #aabbIntersectsSegment(float, float, float, float)} returns true.
             *
             * @instance
             * @public
             * @this Spine.SkeletonBounds
             * @memberof Spine.SkeletonBounds
             * @param   {number}                         x1    
             * @param   {number}                         y1    
             * @param   {number}                         x2    
             * @param   {number}                         y2
             * @return  {Spine.BoundingBoxAttachment}
             */
            IntersectsSegment: function (x1, y1, x2, y2) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#IntersectsSegment", this ); }

                var $t;
                var polygons = this.Polygons;
                for (var i = 0, n = polygons.Count; i < n; i = (i + 1) | 0) {
                    if (this.IntersectsSegment$1(polygons.Items[i], x1, y1, x2, y2)) {
                        return ($t = this.BoundingBoxes.Items)[i];
                    }
                }
                return null;
            },
            /*Spine.SkeletonBounds.IntersectsSegment end.*/

            /*Spine.SkeletonBounds.IntersectsSegment$1 start.*/
            /**
             * Returns true if the polygon contains the line segment.
             *
             * @instance
             * @public
             * @this Spine.SkeletonBounds
             * @memberof Spine.SkeletonBounds
             * @param   {Spine.Polygon}    polygon    
             * @param   {number}           x1         
             * @param   {number}           y1         
             * @param   {number}           x2         
             * @param   {number}           y2
             * @return  {boolean}
             */
            IntersectsSegment$1: function (polygon, x1, y1, x2, y2) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#IntersectsSegment$1", this ); }

                var vertices = polygon.Vertices;
                var nn = polygon.Count;

                var width12 = x1 - x2, height12 = y1 - y2;
                var det1 = x1 * y2 - y1 * x2;
                var x3 = vertices[((nn - 2) | 0)], y3 = vertices[((nn - 1) | 0)];
                for (var ii = 0; ii < nn; ii = (ii + 2) | 0) {
                    var x4 = vertices[ii], y4 = vertices[((ii + 1) | 0)];
                    var det2 = x3 * y4 - y3 * x4;
                    var width34 = x3 - x4, height34 = y3 - y4;
                    var det3 = width12 * height34 - height12 * width34;
                    var x = (det1 * width34 - width12 * det2) / det3;
                    if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {
                        var y = (det1 * height34 - height12 * det2) / det3;
                        if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) {
                            return true;
                        }
                    }
                    x3 = x4;
                    y3 = y4;
                }
                return false;
            },
            /*Spine.SkeletonBounds.IntersectsSegment$1 end.*/

            /*Spine.SkeletonBounds.GetPolygon start.*/
            GetPolygon: function (attachment) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#GetPolygon", this ); }

                var $t;
                var index = this.BoundingBoxes.IndexOf(attachment);
                return index === -1 ? null : ($t = this.Polygons.Items)[index];
            },
            /*Spine.SkeletonBounds.GetPolygon end.*/


        },
        overloads: {
            "ContainsPoint(Polygon, float, float)": "ContainsPoint$1",
            "IntersectsSegment(Polygon, float, float, float, float)": "IntersectsSegment$1"
        }
    });
    /*Spine.SkeletonBounds end.*/

    /*Spine.SkeletonClipping start.*/
    Bridge.define("Spine.SkeletonClipping", {
        statics: {
            methods: {
                /*Spine.SkeletonClipping.MakeClockwise:static start.*/
                MakeClockwise: function (polygon) {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#MakeClockwise", this ); }

                    var vertices = polygon.Items;
                    var verticeslength = polygon.Count;

                    var area = vertices[((verticeslength - 2) | 0)] * vertices[1] - vertices[0] * vertices[((verticeslength - 1) | 0)], p1x, p1y, p2x, p2y;
                    for (var i = 0, n = (verticeslength - 3) | 0; i < n; i = (i + 2) | 0) {
                        p1x = vertices[i];
                        p1y = vertices[((i + 1) | 0)];
                        p2x = vertices[((i + 2) | 0)];
                        p2y = vertices[((i + 3) | 0)];
                        area += p1x * p2y - p2x * p1y;
                    }
                    if (area < 0) {
                        return;
                    }

                    for (var i1 = 0, lastX = (verticeslength - 2) | 0, n1 = verticeslength >> 1; i1 < n1; i1 = (i1 + 2) | 0) {
                        var x = vertices[i1], y = vertices[((i1 + 1) | 0)];
                        var other = (lastX - i1) | 0;
                        vertices[i1] = vertices[other];
                        vertices[((i1 + 1) | 0)] = vertices[((other + 1) | 0)];
                        vertices[other] = x;
                        vertices[((other + 1) | 0)] = y;
                    }
                },
                /*Spine.SkeletonClipping.MakeClockwise:static end.*/


            }
        },
        fields: {
            triangulator: null,
            clippingPolygon: null,
            clipOutput: null,
            clippedVertices: null,
            clippedTriangles: null,
            clippedUVs: null,
            scratch: null,
            clipAttachment: null,
            clippingPolygons: null
        },
        props: {
            ClippedVertices: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#ClippedVertices#get", this ); }

                    return this.clippedVertices;
                }
            },
            ClippedTriangles: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#ClippedTriangles#get", this ); }

                    return this.clippedTriangles;
                }
            },
            ClippedUVs: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#ClippedUVs#get", this ); }

                    return this.clippedUVs;
                }
            },
            IsClipping: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#IsClipping#get", this ); }

                    return this.clipAttachment != null;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#init", this ); }

                this.triangulator = new Spine.Triangulator();
                this.clippingPolygon = new (Spine.ExposedList$1(System.Single)).ctor();
                this.clipOutput = new (Spine.ExposedList$1(System.Single)).$ctor3(128);
                this.clippedVertices = new (Spine.ExposedList$1(System.Single)).$ctor3(128);
                this.clippedTriangles = new (Spine.ExposedList$1(System.Int32)).$ctor3(128);
                this.clippedUVs = new (Spine.ExposedList$1(System.Single)).$ctor3(128);
                this.scratch = new (Spine.ExposedList$1(System.Single)).ctor();
            }
        },
        methods: {
            /*Spine.SkeletonClipping.ClipStart start.*/
            ClipStart: function (slot, clip) {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#ClipStart", this ); }

                var $t;
                if (this.clipAttachment != null) {
                    return 0;
                }
                this.clipAttachment = clip;

                var n = clip.worldVerticesLength;
                var vertices = this.clippingPolygon.Resize(n).Items;
                clip.ComputeWorldVertices(slot, 0, n, vertices, 0, 2);
                Spine.SkeletonClipping.MakeClockwise(this.clippingPolygon);
                this.clippingPolygons = this.triangulator.Decompose(this.clippingPolygon, this.triangulator.Triangulate(this.clippingPolygon));
                $t = Bridge.getEnumerator(this.clippingPolygons);
                try {
                    while ($t.moveNext()) {
                        var polygon = $t.Current;
                        Spine.SkeletonClipping.MakeClockwise(polygon);
                        polygon.Add(polygon.Items[0]);
                        polygon.Add(polygon.Items[1]);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return this.clippingPolygons.Count;
            },
            /*Spine.SkeletonClipping.ClipStart end.*/

            /*Spine.SkeletonClipping.ClipEnd$1 start.*/
            ClipEnd$1: function (slot) {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#ClipEnd$1", this ); }

                if (this.clipAttachment != null && Bridge.referenceEquals(this.clipAttachment.endSlot, slot.data)) {
                    this.ClipEnd();
                }
            },
            /*Spine.SkeletonClipping.ClipEnd$1 end.*/

            /*Spine.SkeletonClipping.ClipEnd start.*/
            ClipEnd: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#ClipEnd", this ); }

                if (this.clipAttachment == null) {
                    return;
                }
                this.clipAttachment = null;
                this.clippingPolygons = null;
                this.clippedVertices.Clear();
                this.clippedTriangles.Clear();
                this.clippingPolygon.Clear();
            },
            /*Spine.SkeletonClipping.ClipEnd end.*/

            /*Spine.SkeletonClipping.ClipTriangles start.*/
            ClipTriangles: function (vertices, verticesLength, triangles, trianglesLength, uvs) {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#ClipTriangles", this ); }

                var clipOutput = this.clipOutput, clippedVertices = this.clippedVertices;
                var clippedTriangles = this.clippedTriangles;
                var polygons = this.clippingPolygons.Items;
                var polygonsCount = this.clippingPolygons.Count;

                var index = 0;
                clippedVertices.Clear();
                this.clippedUVs.Clear();
                clippedTriangles.Clear();
                //outer:
                for (var i = 0; i < trianglesLength; i = (i + 3) | 0) {
                    var vertexOffset = triangles[i] << 1;
                    var x1 = vertices[vertexOffset], y1 = vertices[((vertexOffset + 1) | 0)];
                    var u1 = uvs[vertexOffset], v1 = uvs[((vertexOffset + 1) | 0)];

                    vertexOffset = triangles[((i + 1) | 0)] << 1;
                    var x2 = vertices[vertexOffset], y2 = vertices[((vertexOffset + 1) | 0)];
                    var u2 = uvs[vertexOffset], v2 = uvs[((vertexOffset + 1) | 0)];

                    vertexOffset = triangles[((i + 2) | 0)] << 1;
                    var x3 = vertices[vertexOffset], y3 = vertices[((vertexOffset + 1) | 0)];
                    var u3 = uvs[vertexOffset], v3 = uvs[((vertexOffset + 1) | 0)];

                    for (var p = 0; p < polygonsCount; p = (p + 1) | 0) {
                        var s = clippedVertices.Count;
                        if (this.Clip(x1, y1, x2, y2, x3, y3, polygons[p], clipOutput)) {
                            var clipOutputLength = clipOutput.Count;
                            if (clipOutputLength === 0) {
                                continue;
                            }
                            var d0 = y2 - y3, d1 = x3 - x2, d2 = x1 - x3, d4 = y3 - y1;
                            var d = 1 / (d0 * d2 + d1 * (y1 - y3));

                            var clipOutputCount = clipOutputLength >> 1;
                            var clipOutputItems = clipOutput.Items;
                            var clippedVerticesItems = clippedVertices.Resize(((s + Bridge.Int.mul(clipOutputCount, 2)) | 0)).Items;
                            var clippedUVsItems = this.clippedUVs.Resize(((s + Bridge.Int.mul(clipOutputCount, 2)) | 0)).Items;
                            for (var ii = 0; ii < clipOutputLength; ii = (ii + 2) | 0) {
                                var x = clipOutputItems[ii], y = clipOutputItems[((ii + 1) | 0)];
                                clippedVerticesItems[s] = x;
                                clippedVerticesItems[((s + 1) | 0)] = y;
                                var c0 = x - x3, c1 = y - y3;
                                var a = (d0 * c0 + d1 * c1) * d;
                                var b = (d4 * c0 + d2 * c1) * d;
                                var c = 1 - a - b;
                                clippedUVsItems[s] = u1 * a + u2 * b + u3 * c;
                                clippedUVsItems[((s + 1) | 0)] = v1 * a + v2 * b + v3 * c;
                                s = (s + 2) | 0;
                            }

                            s = clippedTriangles.Count;
                            var clippedTrianglesItems = clippedTriangles.Resize(((s + Bridge.Int.mul(3, (((clipOutputCount - 2) | 0)))) | 0)).Items;
                            clipOutputCount = (clipOutputCount - 1) | 0;
                            for (var ii1 = 1; ii1 < clipOutputCount; ii1 = (ii1 + 1) | 0) {
                                clippedTrianglesItems[s] = index;
                                clippedTrianglesItems[((s + 1) | 0)] = (index + ii1) | 0;
                                clippedTrianglesItems[((s + 2) | 0)] = (((index + ii1) | 0) + 1) | 0;
                                s = (s + 3) | 0;
                            }
                            index = (index + (((clipOutputCount + 1) | 0))) | 0;
                        } else {
                            var clippedVerticesItems1 = clippedVertices.Resize(((s + 6) | 0)).Items;
                            var clippedUVsItems1 = this.clippedUVs.Resize(((s + 6) | 0)).Items;
                            clippedVerticesItems1[s] = x1;
                            clippedVerticesItems1[((s + 1) | 0)] = y1;
                            clippedVerticesItems1[((s + 2) | 0)] = x2;
                            clippedVerticesItems1[((s + 3) | 0)] = y2;
                            clippedVerticesItems1[((s + 4) | 0)] = x3;
                            clippedVerticesItems1[((s + 5) | 0)] = y3;

                            clippedUVsItems1[s] = u1;
                            clippedUVsItems1[((s + 1) | 0)] = v1;
                            clippedUVsItems1[((s + 2) | 0)] = u2;
                            clippedUVsItems1[((s + 3) | 0)] = v2;
                            clippedUVsItems1[((s + 4) | 0)] = u3;
                            clippedUVsItems1[((s + 5) | 0)] = v3;

                            s = clippedTriangles.Count;
                            var clippedTrianglesItems1 = clippedTriangles.Resize(((s + 3) | 0)).Items;
                            clippedTrianglesItems1[s] = index;
                            clippedTrianglesItems1[((s + 1) | 0)] = (index + 1) | 0;
                            clippedTrianglesItems1[((s + 2) | 0)] = (index + 2) | 0;
                            index = (index + 3) | 0;
                            break; //continue outer;
                        }
                    }
                }

            },
            /*Spine.SkeletonClipping.ClipTriangles end.*/

            /*Spine.SkeletonClipping.Clip start.*/
            Clip: function (x1, y1, x2, y2, x3, y3, clippingArea, output) {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#Clip", this ); }

                var originalOutput = output;
                var clipped = false;

                // Avoid copy at the end.
                var input = null;
                if (clippingArea.Count % 4 >= 2) {
                    input = output;
                    output = this.scratch;
                } else {
                    input = this.scratch;
                }

                input.Clear();
                input.Add(x1);
                input.Add(y1);
                input.Add(x2);
                input.Add(y2);
                input.Add(x3);
                input.Add(y3);
                input.Add(x1);
                input.Add(y1);
                output.Clear();

                var clippingVertices = clippingArea.Items;
                var clippingVerticesLast = (clippingArea.Count - 4) | 0;
                for (var i = 0; ; i = (i + 2) | 0) {
                    var edgeX = clippingVertices[i], edgeY = clippingVertices[((i + 1) | 0)];
                    var edgeX2 = clippingVertices[((i + 2) | 0)], edgeY2 = clippingVertices[((i + 3) | 0)];
                    var deltaX = edgeX - edgeX2, deltaY = edgeY - edgeY2;

                    var inputVertices = input.Items;
                    var inputVerticesLength = (input.Count - 2) | 0, outputStart = output.Count;
                    for (var ii = 0; ii < inputVerticesLength; ii = (ii + 2) | 0) {
                        var inputX = inputVertices[ii], inputY = inputVertices[((ii + 1) | 0)];
                        var inputX2 = inputVertices[((ii + 2) | 0)], inputY2 = inputVertices[((ii + 3) | 0)];
                        var side2 = deltaX * (inputY2 - edgeY2) - deltaY * (inputX2 - edgeX2) > 0;
                        if (deltaX * (inputY - edgeY2) - deltaY * (inputX - edgeX2) > 0) {
                            if (side2) { // v1 inside, v2 inside
                                output.Add(inputX2);
                                output.Add(inputY2);
                                continue;
                            }
                            // v1 inside, v2 outside
                            var c0 = inputY2 - inputY, c2 = inputX2 - inputX;
                            var s = c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY);
                            if (Math.abs(s) > 1E-06) {
                                var ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / s;
                                output.Add(edgeX + (edgeX2 - edgeX) * ua);
                                output.Add(edgeY + (edgeY2 - edgeY) * ua);
                            } else {
                                output.Add(edgeX);
                                output.Add(edgeY);
                            }
                        } else if (side2) { // v1 outside, v2 inside
                            var c01 = inputY2 - inputY, c21 = inputX2 - inputX;
                            var s1 = c01 * (edgeX2 - edgeX) - c21 * (edgeY2 - edgeY);
                            if (Math.abs(s1) > 1E-06) {
                                var ua1 = (c21 * (edgeY - inputY) - c01 * (edgeX - inputX)) / s1;
                                output.Add(edgeX + (edgeX2 - edgeX) * ua1);
                                output.Add(edgeY + (edgeY2 - edgeY) * ua1);
                            } else {
                                output.Add(edgeX);
                                output.Add(edgeY);
                            }
                            output.Add(inputX2);
                            output.Add(inputY2);
                        }
                        clipped = true;
                    }

                    if (outputStart === output.Count) { // All edges outside.
                        originalOutput.Clear();
                        return true;
                    }

                    output.Add(output.Items[0]);
                    output.Add(output.Items[1]);

                    if (i === clippingVerticesLast) {
                        break;
                    }
                    var temp = output;
                    output = input;
                    output.Clear();
                    input = temp;
                }

                if (!Bridge.referenceEquals(originalOutput, output)) {
                    originalOutput.Clear();
                    for (var i1 = 0, n = (output.Count - 2) | 0; i1 < n; i1 = (i1 + 1) | 0) {
                        originalOutput.Add(output.Items[i1]);
                    }
                } else {
                    originalOutput.Resize(((originalOutput.Count - 2) | 0));
                }

                return clipped;
            },
            /*Spine.SkeletonClipping.Clip end.*/


        },
        overloads: {
            "ClipEnd(Slot)": "ClipEnd$1"
        }
    });
    /*Spine.SkeletonClipping end.*/

    /*Spine.SkeletonData start.*/
    /**
     * Stores the setup pose and all of the stateless data for a skeleton.
     *
     * @public
     * @class Spine.SkeletonData
     */
    Bridge.define("Spine.SkeletonData", {
        fields: {
            name: null,
            bones: null,
            slots: null,
            skins: null,
            defaultSkin: null,
            events: null,
            animations: null,
            ikConstraints: null,
            transformConstraints: null,
            pathConstraints: null,
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            version: null,
            hash: null,
            fps: 0,
            imagesPath: null,
            audioPath: null
        },
        props: {
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Name#get", this ); }

                    return this.name;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Name#set", this ); }

                    this.name = value;
                }
            },
            /**
             * The skeleton's bones, sorted parent first. The root bone is always the first bone.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.SkeletonData
             * @function Bones
             * @type Spine.ExposedList$1
             */
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Bones#get", this ); }

                    return this.bones;
                }
            },
            Slots: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Slots#get", this ); }

                    return this.slots;
                }
            },
            /**
             * All skins, including the default skin.
             *
             * @instance
             * @public
             * @memberof Spine.SkeletonData
             * @function Skins
             * @type Spine.ExposedList$1
             */
            Skins: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Skins#get", this ); }

                    return this.skins;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Skins#set", this ); }

                    this.skins = value;
                }
            },
            /**
             * The skeleton's default skin.
             By default this skin contains all attachments that were not in a skin in Spine.
             *
             * @instance
             * @public
             * @memberof Spine.SkeletonData
             * @function DefaultSkin
             * @type Spine.Skin
             */
            DefaultSkin: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#DefaultSkin#get", this ); }

                    return this.defaultSkin;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#DefaultSkin#set", this ); }

                    this.defaultSkin = value;
                }
            },
            Events: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Events#get", this ); }

                    return this.events;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Events#set", this ); }

                    this.events = value;
                }
            },
            Animations: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Animations#get", this ); }

                    return this.animations;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Animations#set", this ); }

                    this.animations = value;
                }
            },
            IkConstraints: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#IkConstraints#get", this ); }

                    return this.ikConstraints;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#IkConstraints#set", this ); }

                    this.ikConstraints = value;
                }
            },
            TransformConstraints: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#TransformConstraints#get", this ); }

                    return this.transformConstraints;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#TransformConstraints#set", this ); }

                    this.transformConstraints = value;
                }
            },
            PathConstraints: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#PathConstraints#get", this ); }

                    return this.pathConstraints;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#PathConstraints#set", this ); }

                    this.pathConstraints = value;
                }
            },
            X: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#X#get", this ); }

                    return this.x;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#X#set", this ); }

                    this.x = value;
                }
            },
            Y: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Y#get", this ); }

                    return this.y;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Y#set", this ); }

                    this.y = value;
                }
            },
            Width: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Width#get", this ); }

                    return this.width;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Width#set", this ); }

                    this.width = value;
                }
            },
            Height: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Height#get", this ); }

                    return this.height;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Height#set", this ); }

                    this.height = value;
                }
            },
            /**
             * The Spine version used to export this data, or null.
             *
             * @instance
             * @public
             * @memberof Spine.SkeletonData
             * @function Version
             * @type string
             */
            Version: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Version#get", this ); }

                    return this.version;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Version#set", this ); }

                    this.version = value;
                }
            },
            Hash: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Hash#get", this ); }

                    return this.hash;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Hash#set", this ); }

                    this.hash = value;
                }
            },
            /**
             * The path to the images directory as defined in Spine. Available only when nonessential data was exported. May be null
             *
             * @instance
             * @public
             * @memberof Spine.SkeletonData
             * @function ImagesPath
             * @type string
             */
            ImagesPath: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#ImagesPath#get", this ); }

                    return this.imagesPath;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#ImagesPath#set", this ); }

                    this.imagesPath = value;
                }
            },
            /**
             * The path to the audio directory defined in Spine. Available only when nonessential data was exported. May be null.
             *
             * @instance
             * @public
             * @memberof Spine.SkeletonData
             * @function AudioPath
             * @type string
             */
            AudioPath: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#AudioPath#get", this ); }

                    return this.audioPath;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#AudioPath#set", this ); }

                    this.audioPath = value;
                }
            },
            /**
             * The dopesheet FPS in Spine. Available only when nonessential data was exported.
             *
             * @instance
             * @public
             * @memberof Spine.SkeletonData
             * @function Fps
             * @type number
             */
            Fps: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Fps#get", this ); }

                    return this.fps;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Fps#set", this ); }

                    this.fps = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#init", this ); }

                this.bones = new (Spine.ExposedList$1(Spine.BoneData)).ctor();
                this.slots = new (Spine.ExposedList$1(Spine.SlotData)).ctor();
                this.skins = new (Spine.ExposedList$1(Spine.Skin)).ctor();
                this.events = new (Spine.ExposedList$1(Spine.EventData)).ctor();
                this.animations = new (Spine.ExposedList$1(Spine.Animation)).ctor();
                this.ikConstraints = new (Spine.ExposedList$1(Spine.IkConstraintData)).ctor();
                this.transformConstraints = new (Spine.ExposedList$1(Spine.TransformConstraintData)).ctor();
                this.pathConstraints = new (Spine.ExposedList$1(Spine.PathConstraintData)).ctor();
            }
        },
        methods: {
            /*Spine.SkeletonData.FindBone start.*/
            /**
             * Finds a bone by comparing each bone's name.
             It is more efficient to cache the results of this method than to call it multiple times.
             *
             * @instance
             * @public
             * @this Spine.SkeletonData
             * @memberof Spine.SkeletonData
             * @param   {string}            boneName
             * @return  {Spine.BoneData}                May be null.
             */
            FindBone: function (boneName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindBone", this ); }

                if (boneName == null) {
                    throw new System.ArgumentNullException.$ctor3("boneName", "boneName cannot be null.");
                }
                var bones = this.bones;
                var bonesItems = bones.Items;
                for (var i = 0, n = bones.Count; i < n; i = (i + 1) | 0) {
                    var bone = bonesItems[i];
                    if (Bridge.referenceEquals(bone.name, boneName)) {
                        return bone;
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindBone end.*/

            /*Spine.SkeletonData.FindBoneIndex start.*/
            /**
             * @instance
             * @public
             * @this Spine.SkeletonData
             * @memberof Spine.SkeletonData
             * @param   {string}    boneName
             * @return  {number}                -1 if the bone was not found.
             */
            FindBoneIndex: function (boneName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindBoneIndex", this ); }

                if (boneName == null) {
                    throw new System.ArgumentNullException.$ctor3("boneName", "boneName cannot be null.");
                }
                var bones = this.bones;
                var bonesItems = bones.Items;
                for (var i = 0, n = bones.Count; i < n; i = (i + 1) | 0) {
                    if (Bridge.referenceEquals(bonesItems[i].name, boneName)) {
                        return i;
                    }
                }
                return -1;
            },
            /*Spine.SkeletonData.FindBoneIndex end.*/

            /*Spine.SkeletonData.FindSlot start.*/
            /**
             * @instance
             * @public
             * @this Spine.SkeletonData
             * @memberof Spine.SkeletonData
             * @param   {string}            slotName
             * @return  {Spine.SlotData}                May be null.
             */
            FindSlot: function (slotName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindSlot", this ); }

                if (slotName == null) {
                    throw new System.ArgumentNullException.$ctor3("slotName", "slotName cannot be null.");
                }
                var slots = this.slots;
                for (var i = 0, n = slots.Count; i < n; i = (i + 1) | 0) {
                    var slot = slots.Items[i];
                    if (Bridge.referenceEquals(slot.name, slotName)) {
                        return slot;
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindSlot end.*/

            /*Spine.SkeletonData.FindSlotIndex start.*/
            /**
             * @instance
             * @public
             * @this Spine.SkeletonData
             * @memberof Spine.SkeletonData
             * @param   {string}    slotName
             * @return  {number}                -1 if the slot was not found.
             */
            FindSlotIndex: function (slotName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindSlotIndex", this ); }

                if (slotName == null) {
                    throw new System.ArgumentNullException.$ctor3("slotName", "slotName cannot be null.");
                }
                var slots = this.slots;
                for (var i = 0, n = slots.Count; i < n; i = (i + 1) | 0) {
                    if (Bridge.referenceEquals(slots.Items[i].name, slotName)) {
                        return i;
                    }
                }
                return -1;
            },
            /*Spine.SkeletonData.FindSlotIndex end.*/

            /*Spine.SkeletonData.FindSkin start.*/
            /**
             * @instance
             * @public
             * @this Spine.SkeletonData
             * @memberof Spine.SkeletonData
             * @param   {string}        skinName
             * @return  {Spine.Skin}                May be null.
             */
            FindSkin: function (skinName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindSkin", this ); }

                var $t;
                if (skinName == null) {
                    throw new System.ArgumentNullException.$ctor3("skinName", "skinName cannot be null.");
                }
                $t = Bridge.getEnumerator(this.skins);
                try {
                    while ($t.moveNext()) {
                        var skin = $t.Current;
                        if (Bridge.referenceEquals(skin.name, skinName)) {
                            return skin;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindSkin end.*/

            /*Spine.SkeletonData.FindEvent start.*/
            /**
             * @instance
             * @public
             * @this Spine.SkeletonData
             * @memberof Spine.SkeletonData
             * @param   {string}             eventDataName
             * @return  {Spine.EventData}                     May be null.
             */
            FindEvent: function (eventDataName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindEvent", this ); }

                var $t;
                if (eventDataName == null) {
                    throw new System.ArgumentNullException.$ctor3("eventDataName", "eventDataName cannot be null.");
                }
                $t = Bridge.getEnumerator(this.events);
                try {
                    while ($t.moveNext()) {
                        var eventData = $t.Current;
                        if (Bridge.referenceEquals(eventData.name, eventDataName)) {
                            return eventData;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindEvent end.*/

            /*Spine.SkeletonData.FindAnimation start.*/
            /**
             * @instance
             * @public
             * @this Spine.SkeletonData
             * @memberof Spine.SkeletonData
             * @param   {string}             animationName
             * @return  {Spine.Animation}                     May be null.
             */
            FindAnimation: function (animationName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindAnimation", this ); }

                if (animationName == null) {
                    throw new System.ArgumentNullException.$ctor3("animationName", "animationName cannot be null.");
                }
                var animations = this.animations;
                for (var i = 0, n = animations.Count; i < n; i = (i + 1) | 0) {
                    var animation = animations.Items[i];
                    if (Bridge.referenceEquals(animation.name, animationName)) {
                        return animation;
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindAnimation end.*/

            /*Spine.SkeletonData.FindIkConstraint start.*/
            /**
             * @instance
             * @public
             * @this Spine.SkeletonData
             * @memberof Spine.SkeletonData
             * @param   {string}                    constraintName
             * @return  {Spine.IkConstraintData}                      May be null.
             */
            FindIkConstraint: function (constraintName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindIkConstraint", this ); }

                if (constraintName == null) {
                    throw new System.ArgumentNullException.$ctor3("constraintName", "constraintName cannot be null.");
                }
                var ikConstraints = this.ikConstraints;
                for (var i = 0, n = ikConstraints.Count; i < n; i = (i + 1) | 0) {
                    var ikConstraint = ikConstraints.Items[i];
                    if (Bridge.referenceEquals(ikConstraint.name, constraintName)) {
                        return ikConstraint;
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindIkConstraint end.*/

            /*Spine.SkeletonData.FindTransformConstraint start.*/
            /**
             * @instance
             * @public
             * @this Spine.SkeletonData
             * @memberof Spine.SkeletonData
             * @param   {string}                           constraintName
             * @return  {Spine.TransformConstraintData}                      May be null.
             */
            FindTransformConstraint: function (constraintName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindTransformConstraint", this ); }

                if (constraintName == null) {
                    throw new System.ArgumentNullException.$ctor3("constraintName", "constraintName cannot be null.");
                }
                var transformConstraints = this.transformConstraints;
                for (var i = 0, n = transformConstraints.Count; i < n; i = (i + 1) | 0) {
                    var transformConstraint = transformConstraints.Items[i];
                    if (Bridge.referenceEquals(transformConstraint.name, constraintName)) {
                        return transformConstraint;
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindTransformConstraint end.*/

            /*Spine.SkeletonData.FindPathConstraint start.*/
            /**
             * @instance
             * @public
             * @this Spine.SkeletonData
             * @memberof Spine.SkeletonData
             * @param   {string}                      constraintName
             * @return  {Spine.PathConstraintData}                      May be null.
             */
            FindPathConstraint: function (constraintName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindPathConstraint", this ); }

                if (constraintName == null) {
                    throw new System.ArgumentNullException.$ctor3("constraintName", "constraintName cannot be null.");
                }
                var pathConstraints = this.pathConstraints;
                for (var i = 0, n = pathConstraints.Count; i < n; i = (i + 1) | 0) {
                    var constraint = pathConstraints.Items[i];
                    if (System.String.equals(constraint.name, constraintName)) {
                        return constraint;
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindPathConstraint end.*/

            /*Spine.SkeletonData.FindPathConstraintIndex start.*/
            /**
             * @instance
             * @public
             * @this Spine.SkeletonData
             * @memberof Spine.SkeletonData
             * @param   {string}    pathConstraintName
             * @return  {number}                          -1 if the path constraint was not found.
             */
            FindPathConstraintIndex: function (pathConstraintName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindPathConstraintIndex", this ); }

                if (pathConstraintName == null) {
                    throw new System.ArgumentNullException.$ctor3("pathConstraintName", "pathConstraintName cannot be null.");
                }
                var pathConstraints = this.pathConstraints;
                for (var i = 0, n = pathConstraints.Count; i < n; i = (i + 1) | 0) {
                    if (System.String.equals(pathConstraints.Items[i].name, pathConstraintName)) {
                        return i;
                    }
                }
                return -1;
            },
            /*Spine.SkeletonData.FindPathConstraintIndex end.*/

            /*Spine.SkeletonData.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#toString", this ); }

                var $t;
                return ($t = this.name, $t != null ? $t : Bridge.toString(this));
            },
            /*Spine.SkeletonData.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.SkeletonData end.*/

    /*Spine.SkeletonJson start.*/
    Bridge.define("Spine.SkeletonJson", {
        statics: {
            methods: {
                /*Spine.SkeletonJson.ReadCurve:static start.*/
                ReadCurve: function (valueMap, timeline, frameIndex) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ReadCurve", this ); }

                    if (!valueMap.containsKey("curve")) {
                        return;
                    }
                    var curveObject = valueMap.getItem("curve");
                    if (Bridge.is(curveObject, System.String)) {
                        timeline.SetStepped(frameIndex);
                    } else {
                        timeline.SetCurve(frameIndex, System.Nullable.getValue(Bridge.cast(Bridge.unbox(curveObject, System.Single), System.Single)), Spine.SkeletonJson.GetFloat(valueMap, "c2", 0), Spine.SkeletonJson.GetFloat(valueMap, "c3", 1), Spine.SkeletonJson.GetFloat(valueMap, "c4", 1));
                    }
                },
                /*Spine.SkeletonJson.ReadCurve:static end.*/

                /*Spine.SkeletonJson.GetFloatArray:static start.*/
                GetFloatArray: function (map, name, scale) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#GetFloatArray", this ); }

                    var list = Bridge.cast(map.getItem(name), System.Collections.Generic.List$1(System.Object));
                    var values = System.Array.init(list.Count, 0, System.Single);
                    if (scale === 1) {
                        for (var i = 0, n = list.Count; i < n; i = (i + 1) | 0) {
                            values[i] = System.Nullable.getValue(Bridge.cast(Bridge.unbox(list.getItem(i), System.Single), System.Single));
                        }
                    } else {
                        for (var i1 = 0, n1 = list.Count; i1 < n1; i1 = (i1 + 1) | 0) {
                            values[i1] = System.Nullable.getValue(Bridge.cast(Bridge.unbox(list.getItem(i1), System.Single), System.Single)) * scale;
                        }
                    }
                    return values;
                },
                /*Spine.SkeletonJson.GetFloatArray:static end.*/

                /*Spine.SkeletonJson.GetIntArray:static start.*/
                GetIntArray: function (map, name) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#GetIntArray", this ); }

                    var list = Bridge.cast(map.getItem(name), System.Collections.Generic.List$1(System.Object));
                    var values = System.Array.init(list.Count, 0, System.Int32);
                    for (var i = 0, n = list.Count; i < n; i = (i + 1) | 0) {
                        values[i] = Bridge.Int.clip32(System.Nullable.getValue(Bridge.cast(Bridge.unbox(list.getItem(i), System.Single), System.Single)));
                    }
                    return values;
                },
                /*Spine.SkeletonJson.GetIntArray:static end.*/

                /*Spine.SkeletonJson.GetFloat:static start.*/
                GetFloat: function (map, name, defaultValue) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#GetFloat", this ); }

                    if (!map.containsKey(name)) {
                        return defaultValue;
                    }
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(map.getItem(name), System.Single), System.Single));
                },
                /*Spine.SkeletonJson.GetFloat:static end.*/

                /*Spine.SkeletonJson.GetInt:static start.*/
                GetInt: function (map, name, defaultValue) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#GetInt", this ); }

                    if (!map.containsKey(name)) {
                        return defaultValue;
                    }
                    return Bridge.Int.clip32(System.Nullable.getValue(Bridge.cast(Bridge.unbox(map.getItem(name), System.Single), System.Single)));
                },
                /*Spine.SkeletonJson.GetInt:static end.*/

                /*Spine.SkeletonJson.GetBoolean:static start.*/
                GetBoolean: function (map, name, defaultValue) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#GetBoolean", this ); }

                    if (!map.containsKey(name)) {
                        return defaultValue;
                    }
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(map.getItem(name), System.Boolean), System.Boolean));
                },
                /*Spine.SkeletonJson.GetBoolean:static end.*/

                /*Spine.SkeletonJson.GetString:static start.*/
                GetString: function (map, name, defaultValue) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#GetString", this ); }

                    if (!map.containsKey(name)) {
                        return defaultValue;
                    }
                    return Bridge.cast(map.getItem(name), System.String);
                },
                /*Spine.SkeletonJson.GetString:static end.*/

                /*Spine.SkeletonJson.ToColor:static start.*/
                ToColor: function (hexString, colorIndex, expectedLength) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ToColor", this ); }

                    if (expectedLength === void 0) { expectedLength = 8; }
                    if (hexString.length !== expectedLength) {
                        throw new System.ArgumentException.$ctor3("Color hexidecimal length must be " + expectedLength + ", recieved: " + (hexString || ""), "hexString");
                    }
                    return System.Convert.toNumberInBase(hexString.substr(Bridge.Int.mul(colorIndex, 2), 2), 16, 9) / 255.0;
                },
                /*Spine.SkeletonJson.ToColor:static end.*/


            }
        },
        fields: {
            Scale: 0,
            attachmentLoader: null,
            linkedMeshes: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#init", this ); }

                this.linkedMeshes = new (System.Collections.Generic.List$1(Spine.SkeletonJson.LinkedMesh)).ctor();
            },
            ctor: function (atlasArray) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ctor", this ); }

                if (atlasArray === void 0) { atlasArray = []; }

                Spine.SkeletonJson.$ctor1.call(this, new Spine.AtlasAttachmentLoader(atlasArray));
            },
            $ctor1: function (attachmentLoader) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#$ctor1", this ); }

                this.$initialize();
                if (attachmentLoader == null) {
                    throw new System.ArgumentNullException.$ctor3("attachmentLoader", "attachmentLoader cannot be null.");
                }
                this.attachmentLoader = attachmentLoader;
                this.Scale = 1;
            }
        },
        methods: {
            /*Spine.SkeletonJson.ReadSkeletonData$1 start.*/
            ReadSkeletonData$1: function (path) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ReadSkeletonData$1", this ); }

                var reader = new System.IO.StreamReader.$ctor1(new System.IO.FileStream.$ctor2(path, 3, System.IO.FileAccess.Read, 1));
                try {
                    var skeletonData = this.ReadSkeletonData(reader);
                    skeletonData.name = System.IO.Path.GetFileNameWithoutExtension(path);
                    return skeletonData;
                }
                finally {
                    if (Bridge.hasValue(reader)) {
                        reader.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.SkeletonJson.ReadSkeletonData$1 end.*/

            /*Spine.SkeletonJson.ReadSkeletonData start.*/
            ReadSkeletonData: function (reader) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ReadSkeletonData", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16;
                if (reader == null) {
                    throw new System.ArgumentNullException.$ctor3("reader", "reader cannot be null.");
                }

                var scale = this.Scale;
                var skeletonData = new Spine.SkeletonData();

                var root = Bridge.as(Spine.Json.Deserialize(reader), System.Collections.Generic.Dictionary$2(System.String,System.Object));
                if (root == null) {
                    throw new System.Exception("Invalid JSON.");
                }

                // Skeleton.
                if (root.containsKey("skeleton")) {
                    var skeletonMap = Bridge.cast(root.getItem("skeleton"), System.Collections.Generic.Dictionary$2(System.String,System.Object));
                    skeletonData.hash = Bridge.cast(skeletonMap.getItem("hash"), System.String);
                    skeletonData.version = Bridge.cast(skeletonMap.getItem("spine"), System.String);
                    if (Bridge.referenceEquals("3.8.75", skeletonData.version)) {
                        throw new System.Exception("Unsupported skeleton data, please export with a newer version of Spine.");
                    }
                    skeletonData.x = Spine.SkeletonJson.GetFloat(skeletonMap, "x", 0);
                    skeletonData.y = Spine.SkeletonJson.GetFloat(skeletonMap, "y", 0);
                    skeletonData.width = Spine.SkeletonJson.GetFloat(skeletonMap, "width", 0);
                    skeletonData.height = Spine.SkeletonJson.GetFloat(skeletonMap, "height", 0);
                    skeletonData.fps = Spine.SkeletonJson.GetFloat(skeletonMap, "fps", 30);
                    skeletonData.imagesPath = Spine.SkeletonJson.GetString(skeletonMap, "images", null);
                    skeletonData.audioPath = Spine.SkeletonJson.GetString(skeletonMap, "audio", null);
                }

                // Bones.
                if (root.containsKey("bones")) {
                    $t = Bridge.getEnumerator(Bridge.cast(root.getItem("bones"), System.Collections.Generic.List$1(System.Object)));
                    try {
                        while ($t.moveNext()) {
                            var boneMap = Bridge.cast($t.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var parent = null;
                            if (boneMap.containsKey("parent")) {
                                parent = skeletonData.FindBone(Bridge.cast(boneMap.getItem("parent"), System.String));
                                if (parent == null) {
                                    throw new System.Exception(System.String.concat("Parent bone not found: ", boneMap.getItem("parent")));
                                }
                            }
                            var data = new Spine.BoneData(skeletonData.Bones.Count, Bridge.cast(boneMap.getItem("name"), System.String), parent);
                            data.length = Spine.SkeletonJson.GetFloat(boneMap, "length", 0) * scale;
                            data.x = Spine.SkeletonJson.GetFloat(boneMap, "x", 0) * scale;
                            data.y = Spine.SkeletonJson.GetFloat(boneMap, "y", 0) * scale;
                            data.rotation = Spine.SkeletonJson.GetFloat(boneMap, "rotation", 0);
                            data.scaleX = Spine.SkeletonJson.GetFloat(boneMap, "scaleX", 1);
                            data.scaleY = Spine.SkeletonJson.GetFloat(boneMap, "scaleY", 1);
                            data.shearX = Spine.SkeletonJson.GetFloat(boneMap, "shearX", 0);
                            data.shearY = Spine.SkeletonJson.GetFloat(boneMap, "shearY", 0);

                            var tm = Spine.SkeletonJson.GetString(boneMap, "transform", System.Enum.toString(Spine.TransformMode, Spine.TransformMode.Normal));
                            data.transformMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.TransformMode, tm, true), Spine.TransformMode), System.Int32));
                            data.skinRequired = Spine.SkeletonJson.GetBoolean(boneMap, "skin", false);

                            skeletonData.bones.Add(data);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                // Slots.
                if (root.containsKey("slots")) {
                    $t1 = Bridge.getEnumerator(Bridge.cast(root.getItem("slots"), System.Collections.Generic.List$1(System.Object)));
                    try {
                        while ($t1.moveNext()) {
                            var slotMap = Bridge.cast($t1.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var slotName = Bridge.cast(slotMap.getItem("name"), System.String);
                            var boneName = Bridge.cast(slotMap.getItem("bone"), System.String);
                            var boneData = skeletonData.FindBone(boneName);
                            if (boneData == null) {
                                throw new System.Exception("Slot bone not found: " + (boneName || ""));
                            }
                            var data1 = new Spine.SlotData(skeletonData.Slots.Count, slotName, boneData);

                            if (slotMap.containsKey("color")) {
                                var color = Bridge.cast(slotMap.getItem("color"), System.String);
                                data1.r = Spine.SkeletonJson.ToColor(color, 0);
                                data1.g = Spine.SkeletonJson.ToColor(color, 1);
                                data1.b = Spine.SkeletonJson.ToColor(color, 2);
                                data1.a = Spine.SkeletonJson.ToColor(color, 3);
                            }

                            if (slotMap.containsKey("dark")) {
                                var color2 = Bridge.cast(slotMap.getItem("dark"), System.String);
                                data1.r2 = Spine.SkeletonJson.ToColor(color2, 0, 6); // expectedLength = 6. ie. "RRGGBB"
                                data1.g2 = Spine.SkeletonJson.ToColor(color2, 1, 6);
                                data1.b2 = Spine.SkeletonJson.ToColor(color2, 2, 6);
                                data1.hasSecondColor = true;
                            }

                            data1.attachmentName = Spine.SkeletonJson.GetString(slotMap, "attachment", null);
                            if (slotMap.containsKey("blend")) {
                                data1.blendMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.BlendMode, Bridge.cast(slotMap.getItem("blend"), System.String), true), Spine.BlendMode), System.Int32));
                            } else {
                                data1.blendMode = Spine.BlendMode.Normal;
                            }
                            skeletonData.slots.Add(data1);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                }

                // IK constraints.
                if (root.containsKey("ik")) {
                    $t2 = Bridge.getEnumerator(Bridge.cast(root.getItem("ik"), System.Collections.Generic.List$1(System.Object)));
                    try {
                        while ($t2.moveNext()) {
                            var constraintMap = Bridge.cast($t2.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var data2 = new Spine.IkConstraintData(Bridge.cast(constraintMap.getItem("name"), System.String));
                            data2.order = Spine.SkeletonJson.GetInt(constraintMap, "order", 0);
                            data2.skinRequired = Spine.SkeletonJson.GetBoolean(constraintMap, "skin", false);

                            if (constraintMap.containsKey("bones")) {
                                $t3 = Bridge.getEnumerator(Bridge.cast(constraintMap.getItem("bones"), System.Collections.Generic.List$1(System.Object)));
                                try {
                                    while ($t3.moveNext()) {
                                        var boneName1 = Bridge.cast($t3.Current, System.String);
                                        var bone = skeletonData.FindBone(boneName1);
                                        if (bone == null) {
                                            throw new System.Exception("IK bone not found: " + (boneName1 || ""));
                                        }
                                        data2.bones.Add(bone);
                                    }
                                } finally {
                                    if (Bridge.is($t3, System.IDisposable)) {
                                        $t3.System$IDisposable$Dispose();
                                    }
                                }
                            }

                            var targetName = Bridge.cast(constraintMap.getItem("target"), System.String);
                            data2.target = skeletonData.FindBone(targetName);
                            if (data2.target == null) {
                                throw new System.Exception("IK target bone not found: " + (targetName || ""));
                            }
                            data2.mix = Spine.SkeletonJson.GetFloat(constraintMap, "mix", 1);
                            data2.softness = Spine.SkeletonJson.GetFloat(constraintMap, "softness", 0) * scale;
                            data2.bendDirection = Spine.SkeletonJson.GetBoolean(constraintMap, "bendPositive", true) ? 1 : -1;
                            data2.compress = Spine.SkeletonJson.GetBoolean(constraintMap, "compress", false);
                            data2.stretch = Spine.SkeletonJson.GetBoolean(constraintMap, "stretch", false);
                            data2.uniform = Spine.SkeletonJson.GetBoolean(constraintMap, "uniform", false);

                            skeletonData.ikConstraints.Add(data2);
                        }
                    } finally {
                        if (Bridge.is($t2, System.IDisposable)) {
                            $t2.System$IDisposable$Dispose();
                        }
                    }
                }

                // Transform constraints.
                if (root.containsKey("transform")) {
                    $t4 = Bridge.getEnumerator(Bridge.cast(root.getItem("transform"), System.Collections.Generic.List$1(System.Object)));
                    try {
                        while ($t4.moveNext()) {
                            var constraintMap1 = Bridge.cast($t4.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var data3 = new Spine.TransformConstraintData(Bridge.cast(constraintMap1.getItem("name"), System.String));
                            data3.order = Spine.SkeletonJson.GetInt(constraintMap1, "order", 0);
                            data3.skinRequired = Spine.SkeletonJson.GetBoolean(constraintMap1, "skin", false);

                            if (constraintMap1.containsKey("bones")) {
                                $t5 = Bridge.getEnumerator(Bridge.cast(constraintMap1.getItem("bones"), System.Collections.Generic.List$1(System.Object)));
                                try {
                                    while ($t5.moveNext()) {
                                        var boneName2 = Bridge.cast($t5.Current, System.String);
                                        var bone1 = skeletonData.FindBone(boneName2);
                                        if (bone1 == null) {
                                            throw new System.Exception("Transform constraint bone not found: " + (boneName2 || ""));
                                        }
                                        data3.bones.Add(bone1);
                                    }
                                } finally {
                                    if (Bridge.is($t5, System.IDisposable)) {
                                        $t5.System$IDisposable$Dispose();
                                    }
                                }
                            }

                            var targetName1 = Bridge.cast(constraintMap1.getItem("target"), System.String);
                            data3.target = skeletonData.FindBone(targetName1);
                            if (data3.target == null) {
                                throw new System.Exception("Transform constraint target bone not found: " + (targetName1 || ""));
                            }

                            data3.local = Spine.SkeletonJson.GetBoolean(constraintMap1, "local", false);
                            data3.relative = Spine.SkeletonJson.GetBoolean(constraintMap1, "relative", false);

                            data3.offsetRotation = Spine.SkeletonJson.GetFloat(constraintMap1, "rotation", 0);
                            data3.offsetX = Spine.SkeletonJson.GetFloat(constraintMap1, "x", 0) * scale;
                            data3.offsetY = Spine.SkeletonJson.GetFloat(constraintMap1, "y", 0) * scale;
                            data3.offsetScaleX = Spine.SkeletonJson.GetFloat(constraintMap1, "scaleX", 0);
                            data3.offsetScaleY = Spine.SkeletonJson.GetFloat(constraintMap1, "scaleY", 0);
                            data3.offsetShearY = Spine.SkeletonJson.GetFloat(constraintMap1, "shearY", 0);

                            data3.rotateMix = Spine.SkeletonJson.GetFloat(constraintMap1, "rotateMix", 1);
                            data3.translateMix = Spine.SkeletonJson.GetFloat(constraintMap1, "translateMix", 1);
                            data3.scaleMix = Spine.SkeletonJson.GetFloat(constraintMap1, "scaleMix", 1);
                            data3.shearMix = Spine.SkeletonJson.GetFloat(constraintMap1, "shearMix", 1);

                            skeletonData.transformConstraints.Add(data3);
                        }
                    } finally {
                        if (Bridge.is($t4, System.IDisposable)) {
                            $t4.System$IDisposable$Dispose();
                        }
                    }
                }

                // Path constraints.
                if (root.containsKey("path")) {
                    $t6 = Bridge.getEnumerator(Bridge.cast(root.getItem("path"), System.Collections.Generic.List$1(System.Object)));
                    try {
                        while ($t6.moveNext()) {
                            var constraintMap2 = Bridge.cast($t6.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var data4 = new Spine.PathConstraintData(Bridge.cast(constraintMap2.getItem("name"), System.String));
                            data4.order = Spine.SkeletonJson.GetInt(constraintMap2, "order", 0);
                            data4.skinRequired = Spine.SkeletonJson.GetBoolean(constraintMap2, "skin", false);

                            if (constraintMap2.containsKey("bones")) {
                                $t7 = Bridge.getEnumerator(Bridge.cast(constraintMap2.getItem("bones"), System.Collections.Generic.List$1(System.Object)));
                                try {
                                    while ($t7.moveNext()) {
                                        var boneName3 = Bridge.cast($t7.Current, System.String);
                                        var bone2 = skeletonData.FindBone(boneName3);
                                        if (bone2 == null) {
                                            throw new System.Exception("Path bone not found: " + (boneName3 || ""));
                                        }
                                        data4.bones.Add(bone2);
                                    }
                                } finally {
                                    if (Bridge.is($t7, System.IDisposable)) {
                                        $t7.System$IDisposable$Dispose();
                                    }
                                }
                            }

                            var targetName2 = Bridge.cast(constraintMap2.getItem("target"), System.String);
                            data4.target = skeletonData.FindSlot(targetName2);
                            if (data4.target == null) {
                                throw new System.Exception("Path target slot not found: " + (targetName2 || ""));
                            }

                            data4.positionMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.PositionMode, Spine.SkeletonJson.GetString(constraintMap2, "positionMode", "percent"), true), Spine.PositionMode), System.Int32));
                            data4.spacingMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.SpacingMode, Spine.SkeletonJson.GetString(constraintMap2, "spacingMode", "length"), true), Spine.SpacingMode), System.Int32));
                            data4.rotateMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.RotateMode, Spine.SkeletonJson.GetString(constraintMap2, "rotateMode", "tangent"), true), Spine.RotateMode), System.Int32));
                            data4.offsetRotation = Spine.SkeletonJson.GetFloat(constraintMap2, "rotation", 0);
                            data4.position = Spine.SkeletonJson.GetFloat(constraintMap2, "position", 0);
                            if (data4.positionMode === Spine.PositionMode.Fixed) {
                                data4.position *= scale;
                            }
                            data4.spacing = Spine.SkeletonJson.GetFloat(constraintMap2, "spacing", 0);
                            if (data4.spacingMode === Spine.SpacingMode.Length || data4.spacingMode === Spine.SpacingMode.Fixed) {
                                data4.spacing *= scale;
                            }
                            data4.rotateMix = Spine.SkeletonJson.GetFloat(constraintMap2, "rotateMix", 1);
                            data4.translateMix = Spine.SkeletonJson.GetFloat(constraintMap2, "translateMix", 1);

                            skeletonData.pathConstraints.Add(data4);
                        }
                    } finally {
                        if (Bridge.is($t6, System.IDisposable)) {
                            $t6.System$IDisposable$Dispose();
                        }
                    }
                }

                // Skins.
                if (root.containsKey("skins")) {
                    $t8 = Bridge.getEnumerator(Bridge.cast(root.getItem("skins"), System.Collections.Generic.List$1(System.Object)));
                    try {
                        while ($t8.moveNext()) {
                            var skinMap = Bridge.cast($t8.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var skin = new Spine.Skin(Bridge.cast(skinMap.getItem("name"), System.String));
                            if (skinMap.containsKey("bones")) {
                                $t9 = Bridge.getEnumerator(Bridge.cast(skinMap.getItem("bones"), System.Collections.Generic.List$1(System.Object)));
                                try {
                                    while ($t9.moveNext()) {
                                        var entryName = Bridge.cast($t9.Current, System.String);
                                        var bone3 = skeletonData.FindBone(entryName);
                                        if (bone3 == null) {
                                            throw new System.Exception("Skin bone not found: " + (entryName || ""));
                                        }
                                        skin.bones.Add(bone3);
                                    }
                                } finally {
                                    if (Bridge.is($t9, System.IDisposable)) {
                                        $t9.System$IDisposable$Dispose();
                                    }
                                }
                            }
                            if (skinMap.containsKey("ik")) {
                                $t10 = Bridge.getEnumerator(Bridge.cast(skinMap.getItem("ik"), System.Collections.Generic.List$1(System.Object)));
                                try {
                                    while ($t10.moveNext()) {
                                        var entryName1 = Bridge.cast($t10.Current, System.String);
                                        var constraint = skeletonData.FindIkConstraint(entryName1);
                                        if (constraint == null) {
                                            throw new System.Exception("Skin IK constraint not found: " + (entryName1 || ""));
                                        }
                                        skin.constraints.Add(constraint);
                                    }
                                } finally {
                                    if (Bridge.is($t10, System.IDisposable)) {
                                        $t10.System$IDisposable$Dispose();
                                    }
                                }
                            }
                            if (skinMap.containsKey("transform")) {
                                $t11 = Bridge.getEnumerator(Bridge.cast(skinMap.getItem("transform"), System.Collections.Generic.List$1(System.Object)));
                                try {
                                    while ($t11.moveNext()) {
                                        var entryName2 = Bridge.cast($t11.Current, System.String);
                                        var constraint1 = skeletonData.FindTransformConstraint(entryName2);
                                        if (constraint1 == null) {
                                            throw new System.Exception("Skin transform constraint not found: " + (entryName2 || ""));
                                        }
                                        skin.constraints.Add(constraint1);
                                    }
                                } finally {
                                    if (Bridge.is($t11, System.IDisposable)) {
                                        $t11.System$IDisposable$Dispose();
                                    }
                                }
                            }
                            if (skinMap.containsKey("path")) {
                                $t12 = Bridge.getEnumerator(Bridge.cast(skinMap.getItem("path"), System.Collections.Generic.List$1(System.Object)));
                                try {
                                    while ($t12.moveNext()) {
                                        var entryName3 = Bridge.cast($t12.Current, System.String);
                                        var constraint2 = skeletonData.FindPathConstraint(entryName3);
                                        if (constraint2 == null) {
                                            throw new System.Exception("Skin path constraint not found: " + (entryName3 || ""));
                                        }
                                        skin.constraints.Add(constraint2);
                                    }
                                } finally {
                                    if (Bridge.is($t12, System.IDisposable)) {
                                        $t12.System$IDisposable$Dispose();
                                    }
                                }
                            }
                            if (skinMap.containsKey("attachments")) {
                                $t13 = Bridge.getEnumerator(Bridge.cast(skinMap.getItem("attachments"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                                try {
                                    while ($t13.moveNext()) {
                                        var slotEntry = $t13.Current;
                                        var slotIndex = skeletonData.FindSlotIndex(slotEntry.key);
                                        $t14 = Bridge.getEnumerator(Bridge.cast(slotEntry.value, System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                                        try {
                                            while ($t14.moveNext()) {
                                                var entry = $t14.Current;
                                                try {
                                                    var attachment = this.ReadAttachment(Bridge.cast(entry.value, System.Collections.Generic.Dictionary$2(System.String,System.Object)), skin, slotIndex, entry.key, skeletonData);
                                                    if (attachment != null) {
                                                        skin.SetAttachment(slotIndex, entry.key, attachment);
                                                    }
                                                } catch (e) {
                                                    e = System.Exception.create(e);
                                                    throw new System.Exception(System.String.concat("Error reading attachment: " + (entry.key || "") + ", skin: ", skin), e);
                                                }
                                            }
                                        } finally {
                                            if (Bridge.is($t14, System.IDisposable)) {
                                                $t14.System$IDisposable$Dispose();
                                            }
                                        }
                                    }
                                } finally {
                                    if (Bridge.is($t13, System.IDisposable)) {
                                        $t13.System$IDisposable$Dispose();
                                    }
                                }
                            }
                            skeletonData.skins.Add(skin);
                            if (Bridge.referenceEquals(skin.name, "default")) {
                                skeletonData.defaultSkin = skin;
                            }
                        }
                    } finally {
                        if (Bridge.is($t8, System.IDisposable)) {
                            $t8.System$IDisposable$Dispose();
                        }
                    }
                }

                // Linked meshes.
                for (var i = 0, n = this.linkedMeshes.Count; i < n; i = (i + 1) | 0) {
                    var linkedMesh = this.linkedMeshes.getItem(i);
                    var skin1 = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.FindSkin(linkedMesh.skin);
                    if (skin1 == null) {
                        throw new System.Exception("Slot not found: " + (linkedMesh.skin || ""));
                    }
                    var parent1 = skin1.GetAttachment(linkedMesh.slotIndex, linkedMesh.parent);
                    if (parent1 == null) {
                        throw new System.Exception("Parent mesh not found: " + (linkedMesh.parent || ""));
                    }
                    linkedMesh.mesh.DeformAttachment = linkedMesh.inheritDeform ? Bridge.cast(parent1, Spine.VertexAttachment) : linkedMesh.mesh;
                    linkedMesh.mesh.ParentMesh = Bridge.cast(parent1, Spine.MeshAttachment);
                    linkedMesh.mesh.UpdateUVs();
                }
                this.linkedMeshes.clear();

                // Events.
                if (root.containsKey("events")) {
                    $t15 = Bridge.getEnumerator(Bridge.cast(root.getItem("events"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t15.moveNext()) {
                            var entry1 = $t15.Current;
                            var entryMap = Bridge.cast(entry1.value, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var data5 = new Spine.EventData(entry1.key);
                            data5.Int = Spine.SkeletonJson.GetInt(entryMap, "int", 0);
                            data5.Float = Spine.SkeletonJson.GetFloat(entryMap, "float", 0);
                            data5.String = Spine.SkeletonJson.GetString(entryMap, "string", "");
                            data5.AudioPath = Spine.SkeletonJson.GetString(entryMap, "audio", null);
                            if (data5.AudioPath != null) {
                                data5.Volume = Spine.SkeletonJson.GetFloat(entryMap, "volume", 1);
                                data5.Balance = Spine.SkeletonJson.GetFloat(entryMap, "balance", 0);
                            }
                            skeletonData.events.Add(data5);
                        }
                    } finally {
                        if (Bridge.is($t15, System.IDisposable)) {
                            $t15.System$IDisposable$Dispose();
                        }
                    }
                }

                // Animations.
                if (root.containsKey("animations")) {
                    $t16 = Bridge.getEnumerator(Bridge.cast(root.getItem("animations"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t16.moveNext()) {
                            var entry2 = $t16.Current;
                            try {
                                this.ReadAnimation(Bridge.cast(entry2.value, System.Collections.Generic.Dictionary$2(System.String,System.Object)), entry2.key, skeletonData);
                            } catch (e1) {
                                e1 = System.Exception.create(e1);
                                throw new System.Exception("Error reading animation: " + (entry2.key || ""), e1);
                            }
                        }
                    } finally {
                        if (Bridge.is($t16, System.IDisposable)) {
                            $t16.System$IDisposable$Dispose();
                        }
                    }
                }

                skeletonData.bones.TrimExcess();
                skeletonData.slots.TrimExcess();
                skeletonData.skins.TrimExcess();
                skeletonData.events.TrimExcess();
                skeletonData.animations.TrimExcess();
                skeletonData.ikConstraints.TrimExcess();
                return skeletonData;
            },
            /*Spine.SkeletonJson.ReadSkeletonData end.*/

            /*Spine.SkeletonJson.ReadAttachment start.*/
            ReadAttachment: function (map, skin, slotIndex, name, skeletonData) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ReadAttachment", this ); }

                var scale = this.Scale;
                name = Spine.SkeletonJson.GetString(map, "name", name);

                var typeName = Spine.SkeletonJson.GetString(map, "type", "region");
                var type = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.AttachmentType, typeName, true), Spine.AttachmentType), System.Int32));

                var path = Spine.SkeletonJson.GetString(map, "path", name);

                switch (type) {
                    case Spine.AttachmentType.Region: 
                        var region = this.attachmentLoader.Spine$AttachmentLoader$NewRegionAttachment(skin, name, path);
                        if (region == null) {
                            return null;
                        }
                        region.Path = path;
                        region.x = Spine.SkeletonJson.GetFloat(map, "x", 0) * scale;
                        region.y = Spine.SkeletonJson.GetFloat(map, "y", 0) * scale;
                        region.scaleX = Spine.SkeletonJson.GetFloat(map, "scaleX", 1);
                        region.scaleY = Spine.SkeletonJson.GetFloat(map, "scaleY", 1);
                        region.rotation = Spine.SkeletonJson.GetFloat(map, "rotation", 0);
                        region.width = Spine.SkeletonJson.GetFloat(map, "width", 32) * scale;
                        region.height = Spine.SkeletonJson.GetFloat(map, "height", 32) * scale;
                        if (map.containsKey("color")) {
                            var color = Bridge.cast(map.getItem("color"), System.String);
                            region.r = Spine.SkeletonJson.ToColor(color, 0);
                            region.g = Spine.SkeletonJson.ToColor(color, 1);
                            region.b = Spine.SkeletonJson.ToColor(color, 2);
                            region.a = Spine.SkeletonJson.ToColor(color, 3);
                        }
                        region.UpdateOffset();
                        return region;
                    case Spine.AttachmentType.Boundingbox: 
                        var box = this.attachmentLoader.Spine$AttachmentLoader$NewBoundingBoxAttachment(skin, name);
                        if (box == null) {
                            return null;
                        }
                        this.ReadVertices(map, box, Spine.SkeletonJson.GetInt(map, "vertexCount", 0) << 1);
                        return box;
                    case Spine.AttachmentType.Mesh: 
                    case Spine.AttachmentType.Linkedmesh: 
                        {
                            var mesh = this.attachmentLoader.Spine$AttachmentLoader$NewMeshAttachment(skin, name, path);
                            if (mesh == null) {
                                return null;
                            }
                            mesh.Path = path;

                            if (map.containsKey("color")) {
                                var color1 = Bridge.cast(map.getItem("color"), System.String);
                                mesh.r = Spine.SkeletonJson.ToColor(color1, 0);
                                mesh.g = Spine.SkeletonJson.ToColor(color1, 1);
                                mesh.b = Spine.SkeletonJson.ToColor(color1, 2);
                                mesh.a = Spine.SkeletonJson.ToColor(color1, 3);
                            }

                            mesh.Width = Spine.SkeletonJson.GetFloat(map, "width", 0) * scale;
                            mesh.Height = Spine.SkeletonJson.GetFloat(map, "height", 0) * scale;

                            var parent = Spine.SkeletonJson.GetString(map, "parent", null);
                            if (parent != null) {
                                this.linkedMeshes.add(new Spine.SkeletonJson.LinkedMesh(mesh, Spine.SkeletonJson.GetString(map, "skin", null), slotIndex, parent, Spine.SkeletonJson.GetBoolean(map, "deform", true)));
                                return mesh;
                            }

                            var uvs = Spine.SkeletonJson.GetFloatArray(map, "uvs", 1);
                            this.ReadVertices(map, mesh, uvs.length);
                            mesh.triangles = Spine.SkeletonJson.GetIntArray(map, "triangles");
                            mesh.regionUVs = uvs;
                            mesh.UpdateUVs();

                            if (map.containsKey("hull")) {
                                mesh.HullLength = Bridge.Int.mul(Spine.SkeletonJson.GetInt(map, "hull", 0), 2);
                            }
                            if (map.containsKey("edges")) {
                                mesh.Edges = Spine.SkeletonJson.GetIntArray(map, "edges");
                            }
                            return mesh;
                        }
                    case Spine.AttachmentType.Path: 
                        {
                            var pathAttachment = this.attachmentLoader.Spine$AttachmentLoader$NewPathAttachment(skin, name);
                            if (pathAttachment == null) {
                                return null;
                            }
                            pathAttachment.closed = Spine.SkeletonJson.GetBoolean(map, "closed", false);
                            pathAttachment.constantSpeed = Spine.SkeletonJson.GetBoolean(map, "constantSpeed", true);

                            var vertexCount = Spine.SkeletonJson.GetInt(map, "vertexCount", 0);
                            this.ReadVertices(map, pathAttachment, vertexCount << 1);

                            // potential BOZO see Java impl
                            pathAttachment.lengths = Spine.SkeletonJson.GetFloatArray(map, "lengths", scale);
                            return pathAttachment;
                        }
                    case Spine.AttachmentType.Point: 
                        {
                            var point = this.attachmentLoader.Spine$AttachmentLoader$NewPointAttachment(skin, name);
                            if (point == null) {
                                return null;
                            }
                            point.x = Spine.SkeletonJson.GetFloat(map, "x", 0) * scale;
                            point.y = Spine.SkeletonJson.GetFloat(map, "y", 0) * scale;
                            point.rotation = Spine.SkeletonJson.GetFloat(map, "rotation", 0);

                            //string color = GetString(map, "color", null);
                            //if (color != null) point.color = color;
                            return point;
                        }
                    case Spine.AttachmentType.Clipping: 
                        {
                            var clip = this.attachmentLoader.Spine$AttachmentLoader$NewClippingAttachment(skin, name);
                            if (clip == null) {
                                return null;
                            }

                            var end = Spine.SkeletonJson.GetString(map, "end", null);
                            if (end != null) {
                                var slot = skeletonData.FindSlot(end);
                                if (slot == null) {
                                    throw new System.Exception("Clipping end slot not found: " + (end || ""));
                                }
                                clip.EndSlot = slot;
                            }

                            this.ReadVertices(map, clip, Spine.SkeletonJson.GetInt(map, "vertexCount", 0) << 1);

                            //string color = GetString(map, "color", null);
                            // if (color != null) clip.color = color;
                            return clip;
                        }
                }
                return null;
            },
            /*Spine.SkeletonJson.ReadAttachment end.*/

            /*Spine.SkeletonJson.ReadVertices start.*/
            ReadVertices: function (map, attachment, verticesLength) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ReadVertices", this ); }

                attachment.WorldVerticesLength = verticesLength;
                var vertices = Spine.SkeletonJson.GetFloatArray(map, "vertices", 1);
                var scale = this.Scale;
                if (verticesLength === vertices.length) {
                    if (scale !== 1) {
                        for (var i = 0; i < vertices.length; i = (i + 1) | 0) {
                            vertices[i] *= scale;
                        }
                    }
                    attachment.vertices = vertices;
                    return;
                }
                var weights = new (Spine.ExposedList$1(System.Single)).$ctor3(Bridge.Int.mul(Bridge.Int.mul(verticesLength, 3), 3));
                var bones = new (Spine.ExposedList$1(System.Int32)).$ctor3(Bridge.Int.mul(verticesLength, 3));
                for (var i1 = 0, n = vertices.length; i1 < n; ) {
                    var boneCount = Bridge.Int.clip32(vertices[Bridge.identity(i1, ((i1 = (i1 + 1) | 0)))]);
                    bones.Add(boneCount);
                    for (var nn = (i1 + Bridge.Int.mul(boneCount, 4)) | 0; i1 < nn; i1 = (i1 + 4) | 0) {
                        bones.Add(Bridge.Int.clip32(vertices[i1]));
                        weights.Add(vertices[((i1 + 1) | 0)] * this.Scale);
                        weights.Add(vertices[((i1 + 2) | 0)] * this.Scale);
                        weights.Add(vertices[((i1 + 3) | 0)]);
                    }
                }
                attachment.bones = bones.ToArray();
                attachment.vertices = weights.ToArray();
            },
            /*Spine.SkeletonJson.ReadVertices end.*/

            /*Spine.SkeletonJson.ReadAnimation start.*/
            ReadAnimation: function (map, name, skeletonData) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ReadAnimation", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21, $t22, $t23, $t24, $t25;
                var scale = this.Scale;
                var timelines = new (Spine.ExposedList$1(Spine.Timeline)).ctor();
                var duration = 0;

                // Slot timelines.
                if (map.containsKey("slots")) {
                    $t = Bridge.getEnumerator(Bridge.cast(map.getItem("slots"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t.moveNext()) {
                            var entry = $t.Current;
                            var slotName = entry.key;
                            var slotIndex = skeletonData.FindSlotIndex(slotName);
                            var timelineMap = Bridge.cast(entry.value, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            $t1 = Bridge.getEnumerator(timelineMap);
                            try {
                                while ($t1.moveNext()) {
                                    var timelineEntry = $t1.Current;
                                    var values = Bridge.cast(timelineEntry.value, System.Collections.Generic.List$1(System.Object));
                                    var timelineName = timelineEntry.key;
                                    if (Bridge.referenceEquals(timelineName, "attachment")) {
                                        var timeline = new Spine.AttachmentTimeline(values.Count);
                                        timeline.slotIndex = slotIndex;

                                        var frameIndex = 0;
                                        $t2 = Bridge.getEnumerator(values);
                                        try {
                                            while ($t2.moveNext()) {
                                                var valueMap = Bridge.cast($t2.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                var time = Spine.SkeletonJson.GetFloat(valueMap, "time", 0);
                                                timeline.SetFrame(Bridge.identity(frameIndex, ((frameIndex = (frameIndex + 1) | 0))), time, Bridge.cast(valueMap.getItem("name"), System.String));
                                            }
                                        } finally {
                                            if (Bridge.is($t2, System.IDisposable)) {
                                                $t2.System$IDisposable$Dispose();
                                            }
                                        }
                                        timelines.Add(timeline);
                                        duration = Math.max(duration, timeline.frames[((timeline.FrameCount - 1) | 0)]);

                                    } else if (Bridge.referenceEquals(timelineName, "color")) {
                                        var timeline1 = new Spine.ColorTimeline(values.Count);
                                        timeline1.slotIndex = slotIndex;

                                        var frameIndex1 = 0;
                                        $t3 = Bridge.getEnumerator(values);
                                        try {
                                            while ($t3.moveNext()) {
                                                var valueMap1 = Bridge.cast($t3.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                var time1 = Spine.SkeletonJson.GetFloat(valueMap1, "time", 0);
                                                var c = Bridge.cast(valueMap1.getItem("color"), System.String);
                                                timeline1.SetFrame(frameIndex1, time1, Spine.SkeletonJson.ToColor(c, 0), Spine.SkeletonJson.ToColor(c, 1), Spine.SkeletonJson.ToColor(c, 2), Spine.SkeletonJson.ToColor(c, 3));
                                                Spine.SkeletonJson.ReadCurve(valueMap1, timeline1, frameIndex1);
                                                frameIndex1 = (frameIndex1 + 1) | 0;
                                            }
                                        } finally {
                                            if (Bridge.is($t3, System.IDisposable)) {
                                                $t3.System$IDisposable$Dispose();
                                            }
                                        }
                                        timelines.Add(timeline1);
                                        duration = Math.max(duration, timeline1.frames[Bridge.Int.mul((((timeline1.FrameCount - 1) | 0)), Spine.ColorTimeline.ENTRIES)]);

                                    } else if (Bridge.referenceEquals(timelineName, "twoColor")) {
                                        var timeline2 = new Spine.TwoColorTimeline(values.Count);
                                        timeline2.slotIndex = slotIndex;

                                        var frameIndex2 = 0;
                                        $t4 = Bridge.getEnumerator(values);
                                        try {
                                            while ($t4.moveNext()) {
                                                var valueMap2 = Bridge.cast($t4.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                var time2 = Spine.SkeletonJson.GetFloat(valueMap2, "time", 0);
                                                var light = Bridge.cast(valueMap2.getItem("light"), System.String);
                                                var dark = Bridge.cast(valueMap2.getItem("dark"), System.String);
                                                timeline2.SetFrame(frameIndex2, time2, Spine.SkeletonJson.ToColor(light, 0), Spine.SkeletonJson.ToColor(light, 1), Spine.SkeletonJson.ToColor(light, 2), Spine.SkeletonJson.ToColor(light, 3), Spine.SkeletonJson.ToColor(dark, 0, 6), Spine.SkeletonJson.ToColor(dark, 1, 6), Spine.SkeletonJson.ToColor(dark, 2, 6));
                                                Spine.SkeletonJson.ReadCurve(valueMap2, timeline2, frameIndex2);
                                                frameIndex2 = (frameIndex2 + 1) | 0;
                                            }
                                        } finally {
                                            if (Bridge.is($t4, System.IDisposable)) {
                                                $t4.System$IDisposable$Dispose();
                                            }
                                        }
                                        timelines.Add(timeline2);
                                        duration = Math.max(duration, timeline2.frames[Bridge.Int.mul((((timeline2.FrameCount - 1) | 0)), Spine.TwoColorTimeline.ENTRIES)]);

                                    } else {
                                        throw new System.Exception("Invalid timeline type for a slot: " + (timelineName || "") + " (" + (slotName || "") + ")");
                                    }
                                }
                            } finally {
                                if (Bridge.is($t1, System.IDisposable)) {
                                    $t1.System$IDisposable$Dispose();
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                // Bone timelines.
                if (map.containsKey("bones")) {
                    $t5 = Bridge.getEnumerator(Bridge.cast(map.getItem("bones"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t5.moveNext()) {
                            var entry1 = $t5.Current;
                            var boneName = entry1.key;
                            var boneIndex = skeletonData.FindBoneIndex(boneName);
                            if (boneIndex === -1) {
                                throw new System.Exception("Bone not found: " + (boneName || ""));
                            }
                            var timelineMap1 = Bridge.cast(entry1.value, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            $t6 = Bridge.getEnumerator(timelineMap1);
                            try {
                                while ($t6.moveNext()) {
                                    var timelineEntry1 = $t6.Current;
                                    var values1 = Bridge.cast(timelineEntry1.value, System.Collections.Generic.List$1(System.Object));
                                    var timelineName1 = timelineEntry1.key;
                                    if (Bridge.referenceEquals(timelineName1, "rotate")) {
                                        var timeline3 = new Spine.RotateTimeline(values1.Count);
                                        timeline3.boneIndex = boneIndex;

                                        var frameIndex3 = 0;
                                        $t7 = Bridge.getEnumerator(values1);
                                        try {
                                            while ($t7.moveNext()) {
                                                var valueMap3 = Bridge.cast($t7.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                timeline3.SetFrame(frameIndex3, Spine.SkeletonJson.GetFloat(valueMap3, "time", 0), Spine.SkeletonJson.GetFloat(valueMap3, "angle", 0));
                                                Spine.SkeletonJson.ReadCurve(valueMap3, timeline3, frameIndex3);
                                                frameIndex3 = (frameIndex3 + 1) | 0;
                                            }
                                        } finally {
                                            if (Bridge.is($t7, System.IDisposable)) {
                                                $t7.System$IDisposable$Dispose();
                                            }
                                        }
                                        timelines.Add(timeline3);
                                        duration = Math.max(duration, timeline3.frames[Bridge.Int.mul((((timeline3.FrameCount - 1) | 0)), Spine.RotateTimeline.ENTRIES)]);

                                    } else if (Bridge.referenceEquals(timelineName1, "translate") || Bridge.referenceEquals(timelineName1, "scale") || Bridge.referenceEquals(timelineName1, "shear")) {
                                        var timeline4;
                                        var timelineScale = 1, defaultValue = 0;
                                        if (Bridge.referenceEquals(timelineName1, "scale")) {
                                            timeline4 = new Spine.ScaleTimeline(values1.Count);
                                            defaultValue = 1;
                                        } else if (Bridge.referenceEquals(timelineName1, "shear")) {
                                            timeline4 = new Spine.ShearTimeline(values1.Count);
                                        } else {
                                            timeline4 = new Spine.TranslateTimeline(values1.Count);
                                            timelineScale = scale;
                                        }
                                        timeline4.boneIndex = boneIndex;

                                        var frameIndex4 = 0;
                                        $t8 = Bridge.getEnumerator(values1);
                                        try {
                                            while ($t8.moveNext()) {
                                                var valueMap4 = Bridge.cast($t8.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                var time3 = Spine.SkeletonJson.GetFloat(valueMap4, "time", 0);
                                                var x = Spine.SkeletonJson.GetFloat(valueMap4, "x", defaultValue);
                                                var y = Spine.SkeletonJson.GetFloat(valueMap4, "y", defaultValue);
                                                timeline4.SetFrame(frameIndex4, time3, x * timelineScale, y * timelineScale);
                                                Spine.SkeletonJson.ReadCurve(valueMap4, timeline4, frameIndex4);
                                                frameIndex4 = (frameIndex4 + 1) | 0;
                                            }
                                        } finally {
                                            if (Bridge.is($t8, System.IDisposable)) {
                                                $t8.System$IDisposable$Dispose();
                                            }
                                        }
                                        timelines.Add(timeline4);
                                        duration = Math.max(duration, timeline4.frames[Bridge.Int.mul((((timeline4.FrameCount - 1) | 0)), Spine.TranslateTimeline.ENTRIES)]);

                                    } else {
                                        throw new System.Exception("Invalid timeline type for a bone: " + (timelineName1 || "") + " (" + (boneName || "") + ")");
                                    }
                                }
                            } finally {
                                if (Bridge.is($t6, System.IDisposable)) {
                                    $t6.System$IDisposable$Dispose();
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t5, System.IDisposable)) {
                            $t5.System$IDisposable$Dispose();
                        }
                    }
                }

                // IK constraint timelines.
                if (map.containsKey("ik")) {
                    $t9 = Bridge.getEnumerator(Bridge.cast(map.getItem("ik"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t9.moveNext()) {
                            var constraintMap = $t9.Current;
                            var constraint = skeletonData.FindIkConstraint(constraintMap.key);
                            var values2 = Bridge.cast(constraintMap.value, System.Collections.Generic.List$1(System.Object));
                            var timeline5 = new Spine.IkConstraintTimeline(values2.Count);
                            timeline5.ikConstraintIndex = skeletonData.ikConstraints.IndexOf(constraint);
                            var frameIndex5 = 0;
                            $t10 = Bridge.getEnumerator(values2);
                            try {
                                while ($t10.moveNext()) {
                                    var valueMap5 = Bridge.cast($t10.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                    timeline5.SetFrame(frameIndex5, Spine.SkeletonJson.GetFloat(valueMap5, "time", 0), Spine.SkeletonJson.GetFloat(valueMap5, "mix", 1), Spine.SkeletonJson.GetFloat(valueMap5, "softness", 0) * scale, Spine.SkeletonJson.GetBoolean(valueMap5, "bendPositive", true) ? 1 : -1, Spine.SkeletonJson.GetBoolean(valueMap5, "compress", false), Spine.SkeletonJson.GetBoolean(valueMap5, "stretch", false));
                                    Spine.SkeletonJson.ReadCurve(valueMap5, timeline5, frameIndex5);
                                    frameIndex5 = (frameIndex5 + 1) | 0;
                                }
                            } finally {
                                if (Bridge.is($t10, System.IDisposable)) {
                                    $t10.System$IDisposable$Dispose();
                                }
                            }
                            timelines.Add(timeline5);
                            duration = Math.max(duration, timeline5.frames[Bridge.Int.mul((((timeline5.FrameCount - 1) | 0)), Spine.IkConstraintTimeline.ENTRIES)]);
                        }
                    } finally {
                        if (Bridge.is($t9, System.IDisposable)) {
                            $t9.System$IDisposable$Dispose();
                        }
                    }
                }

                // Transform constraint timelines.
                if (map.containsKey("transform")) {
                    $t11 = Bridge.getEnumerator(Bridge.cast(map.getItem("transform"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t11.moveNext()) {
                            var constraintMap1 = $t11.Current;
                            var constraint1 = skeletonData.FindTransformConstraint(constraintMap1.key);
                            var values3 = Bridge.cast(constraintMap1.value, System.Collections.Generic.List$1(System.Object));
                            var timeline6 = new Spine.TransformConstraintTimeline(values3.Count);
                            timeline6.transformConstraintIndex = skeletonData.transformConstraints.IndexOf(constraint1);
                            var frameIndex6 = 0;
                            $t12 = Bridge.getEnumerator(values3);
                            try {
                                while ($t12.moveNext()) {
                                    var valueMap6 = Bridge.cast($t12.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                    timeline6.SetFrame(frameIndex6, Spine.SkeletonJson.GetFloat(valueMap6, "time", 0), Spine.SkeletonJson.GetFloat(valueMap6, "rotateMix", 1), Spine.SkeletonJson.GetFloat(valueMap6, "translateMix", 1), Spine.SkeletonJson.GetFloat(valueMap6, "scaleMix", 1), Spine.SkeletonJson.GetFloat(valueMap6, "shearMix", 1));
                                    Spine.SkeletonJson.ReadCurve(valueMap6, timeline6, frameIndex6);
                                    frameIndex6 = (frameIndex6 + 1) | 0;
                                }
                            } finally {
                                if (Bridge.is($t12, System.IDisposable)) {
                                    $t12.System$IDisposable$Dispose();
                                }
                            }
                            timelines.Add(timeline6);
                            duration = Math.max(duration, timeline6.frames[Bridge.Int.mul((((timeline6.FrameCount - 1) | 0)), Spine.TransformConstraintTimeline.ENTRIES)]);
                        }
                    } finally {
                        if (Bridge.is($t11, System.IDisposable)) {
                            $t11.System$IDisposable$Dispose();
                        }
                    }
                }

                // Path constraint timelines.
                if (map.containsKey("path")) {
                    $t13 = Bridge.getEnumerator(Bridge.cast(map.getItem("path"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t13.moveNext()) {
                            var constraintMap2 = $t13.Current;
                            var index = skeletonData.FindPathConstraintIndex(constraintMap2.key);
                            if (index === -1) {
                                throw new System.Exception("Path constraint not found: " + (constraintMap2.key || ""));
                            }
                            var data = ($t14 = skeletonData.pathConstraints.Items)[index];
                            var timelineMap2 = Bridge.cast(constraintMap2.value, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            $t15 = Bridge.getEnumerator(timelineMap2);
                            try {
                                while ($t15.moveNext()) {
                                    var timelineEntry2 = $t15.Current;
                                    var values4 = Bridge.cast(timelineEntry2.value, System.Collections.Generic.List$1(System.Object));
                                    var timelineName2 = timelineEntry2.key;
                                    if (Bridge.referenceEquals(timelineName2, "position") || Bridge.referenceEquals(timelineName2, "spacing")) {
                                        var timeline7;
                                        var timelineScale1 = 1;
                                        if (Bridge.referenceEquals(timelineName2, "spacing")) {
                                            timeline7 = new Spine.PathConstraintSpacingTimeline(values4.Count);
                                            if (data.spacingMode === Spine.SpacingMode.Length || data.spacingMode === Spine.SpacingMode.Fixed) {
                                                timelineScale1 = scale;
                                            }
                                        } else {
                                            timeline7 = new Spine.PathConstraintPositionTimeline(values4.Count);
                                            if (data.positionMode === Spine.PositionMode.Fixed) {
                                                timelineScale1 = scale;
                                            }
                                        }
                                        timeline7.pathConstraintIndex = index;
                                        var frameIndex7 = 0;
                                        $t16 = Bridge.getEnumerator(values4);
                                        try {
                                            while ($t16.moveNext()) {
                                                var valueMap7 = Bridge.cast($t16.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                timeline7.SetFrame(frameIndex7, Spine.SkeletonJson.GetFloat(valueMap7, "time", 0), Spine.SkeletonJson.GetFloat(valueMap7, timelineName2, 0) * timelineScale1);
                                                Spine.SkeletonJson.ReadCurve(valueMap7, timeline7, frameIndex7);
                                                frameIndex7 = (frameIndex7 + 1) | 0;
                                            }
                                        } finally {
                                            if (Bridge.is($t16, System.IDisposable)) {
                                                $t16.System$IDisposable$Dispose();
                                            }
                                        }
                                        timelines.Add(timeline7);
                                        duration = Math.max(duration, timeline7.frames[Bridge.Int.mul((((timeline7.FrameCount - 1) | 0)), Spine.PathConstraintPositionTimeline.ENTRIES)]);
                                    } else if (Bridge.referenceEquals(timelineName2, "mix")) {
                                        var timeline8 = new Spine.PathConstraintMixTimeline(values4.Count);
                                        timeline8.pathConstraintIndex = index;
                                        var frameIndex8 = 0;
                                        $t17 = Bridge.getEnumerator(values4);
                                        try {
                                            while ($t17.moveNext()) {
                                                var valueMap8 = Bridge.cast($t17.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                timeline8.SetFrame(frameIndex8, Spine.SkeletonJson.GetFloat(valueMap8, "time", 0), Spine.SkeletonJson.GetFloat(valueMap8, "rotateMix", 1), Spine.SkeletonJson.GetFloat(valueMap8, "translateMix", 1));
                                                Spine.SkeletonJson.ReadCurve(valueMap8, timeline8, frameIndex8);
                                                frameIndex8 = (frameIndex8 + 1) | 0;
                                            }
                                        } finally {
                                            if (Bridge.is($t17, System.IDisposable)) {
                                                $t17.System$IDisposable$Dispose();
                                            }
                                        }
                                        timelines.Add(timeline8);
                                        duration = Math.max(duration, timeline8.frames[Bridge.Int.mul((((timeline8.FrameCount - 1) | 0)), Spine.PathConstraintMixTimeline.ENTRIES)]);
                                    }
                                }
                            } finally {
                                if (Bridge.is($t15, System.IDisposable)) {
                                    $t15.System$IDisposable$Dispose();
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t13, System.IDisposable)) {
                            $t13.System$IDisposable$Dispose();
                        }
                    }
                }

                // Deform timelines.
                if (map.containsKey("deform")) {
                    $t18 = Bridge.getEnumerator(Bridge.cast(map.getItem("deform"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t18.moveNext()) {
                            var deformMap = $t18.Current;
                            var skin = skeletonData.FindSkin(deformMap.key);
                            $t19 = Bridge.getEnumerator(Bridge.cast(deformMap.value, System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                            try {
                                while ($t19.moveNext()) {
                                    var slotMap = $t19.Current;
                                    var slotIndex1 = skeletonData.FindSlotIndex(slotMap.key);
                                    if (slotIndex1 === -1) {
                                        throw new System.Exception("Slot not found: " + (slotMap.key || ""));
                                    }
                                    $t20 = Bridge.getEnumerator(Bridge.cast(slotMap.value, System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                                    try {
                                        while ($t20.moveNext()) {
                                            var timelineMap3 = $t20.Current;
                                            var values5 = Bridge.cast(timelineMap3.value, System.Collections.Generic.List$1(System.Object));
                                            var attachment = Bridge.cast(skin.GetAttachment(slotIndex1, timelineMap3.key), Spine.VertexAttachment);
                                            if (attachment == null) {
                                                throw new System.Exception("Deform attachment not found: " + (timelineMap3.key || ""));
                                            }
                                            var weighted = attachment.bones != null;
                                            var vertices = attachment.vertices;
                                            var deformLength = weighted ? Bridge.Int.mul(((Bridge.Int.div(vertices.length, 3)) | 0), 2) : vertices.length;

                                            var timeline9 = new Spine.DeformTimeline(values5.Count);
                                            timeline9.slotIndex = slotIndex1;
                                            timeline9.attachment = attachment;

                                            var frameIndex9 = 0;
                                            $t21 = Bridge.getEnumerator(values5);
                                            try {
                                                while ($t21.moveNext()) {
                                                    var valueMap9 = Bridge.cast($t21.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                    var deform;
                                                    if (!valueMap9.containsKey("vertices")) {
                                                        deform = weighted ? System.Array.init(deformLength, 0, System.Single) : vertices;
                                                    } else {
                                                        deform = System.Array.init(deformLength, 0, System.Single);
                                                        var start = Spine.SkeletonJson.GetInt(valueMap9, "offset", 0);
                                                        var verticesValue = Spine.SkeletonJson.GetFloatArray(valueMap9, "vertices", 1);
                                                        System.Array.copy(verticesValue, 0, deform, start, verticesValue.length);
                                                        if (scale !== 1) {
                                                            for (var i = start, n = (i + verticesValue.length) | 0; i < n; i = (i + 1) | 0) {
                                                                deform[i] *= scale;
                                                            }
                                                        }

                                                        if (!weighted) {
                                                            for (var i1 = 0; i1 < deformLength; i1 = (i1 + 1) | 0) {
                                                                deform[i1] += vertices[i1];
                                                            }
                                                        }
                                                    }

                                                    timeline9.SetFrame(frameIndex9, Spine.SkeletonJson.GetFloat(valueMap9, "time", 0), deform);
                                                    Spine.SkeletonJson.ReadCurve(valueMap9, timeline9, frameIndex9);
                                                    frameIndex9 = (frameIndex9 + 1) | 0;
                                                }
                                            } finally {
                                                if (Bridge.is($t21, System.IDisposable)) {
                                                    $t21.System$IDisposable$Dispose();
                                                }
                                            }
                                            timelines.Add(timeline9);
                                            duration = Math.max(duration, timeline9.frames[((timeline9.FrameCount - 1) | 0)]);
                                        }
                                    } finally {
                                        if (Bridge.is($t20, System.IDisposable)) {
                                            $t20.System$IDisposable$Dispose();
                                        }
                                    }
                                }
                            } finally {
                                if (Bridge.is($t19, System.IDisposable)) {
                                    $t19.System$IDisposable$Dispose();
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t18, System.IDisposable)) {
                            $t18.System$IDisposable$Dispose();
                        }
                    }
                }

                // Draw order timeline.
                if (map.containsKey("drawOrder") || map.containsKey("draworder")) {
                    var values6 = Bridge.cast(map.getItem(map.containsKey("drawOrder") ? "drawOrder" : "draworder"), System.Collections.Generic.List$1(System.Object));
                    var timeline10 = new Spine.DrawOrderTimeline(values6.Count);
                    var slotCount = skeletonData.slots.Count;
                    var frameIndex10 = 0;
                    $t22 = Bridge.getEnumerator(values6);
                    try {
                        while ($t22.moveNext()) {
                            var drawOrderMap = Bridge.cast($t22.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var drawOrder = null;
                            if (drawOrderMap.containsKey("offsets")) {
                                drawOrder = System.Array.init(slotCount, 0, System.Int32);
                                for (var i2 = (slotCount - 1) | 0; i2 >= 0; i2 = (i2 - 1) | 0) {
                                    drawOrder[i2] = -1;
                                }
                                var offsets = Bridge.cast(drawOrderMap.getItem("offsets"), System.Collections.Generic.List$1(System.Object));
                                var unchanged = System.Array.init(((slotCount - offsets.Count) | 0), 0, System.Int32);
                                var originalIndex = 0, unchangedIndex = 0;
                                $t23 = Bridge.getEnumerator(offsets);
                                try {
                                    while ($t23.moveNext()) {
                                        var offsetMap = Bridge.cast($t23.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                        var slotIndex2 = skeletonData.FindSlotIndex(Bridge.cast(offsetMap.getItem("slot"), System.String));
                                        if (slotIndex2 === -1) {
                                            throw new System.Exception(System.String.concat("Slot not found: ", offsetMap.getItem("slot")));
                                        }
                                        // Collect unchanged items.
                                        while (originalIndex !== slotIndex2) {
                                            unchanged[Bridge.identity(unchangedIndex, ((unchangedIndex = (unchangedIndex + 1) | 0)))] = Bridge.identity(originalIndex, ((originalIndex = (originalIndex + 1) | 0)));
                                        }
                                        // Set changed items.
                                        var index1 = (originalIndex + Bridge.Int.clip32(System.Nullable.getValue(Bridge.cast(Bridge.unbox(offsetMap.getItem("offset"), System.Single), System.Single)))) | 0;
                                        drawOrder[index1] = Bridge.identity(originalIndex, ((originalIndex = (originalIndex + 1) | 0)));
                                    }
                                } finally {
                                    if (Bridge.is($t23, System.IDisposable)) {
                                        $t23.System$IDisposable$Dispose();
                                    }
                                }
                                // Collect remaining unchanged items.
                                while (originalIndex < slotCount) {
                                    unchanged[Bridge.identity(unchangedIndex, ((unchangedIndex = (unchangedIndex + 1) | 0)))] = Bridge.identity(originalIndex, ((originalIndex = (originalIndex + 1) | 0)));
                                }
                                // Fill in unchanged items.
                                for (var i3 = (slotCount - 1) | 0; i3 >= 0; i3 = (i3 - 1) | 0) {
                                    if (drawOrder[i3] === -1) {
                                        drawOrder[i3] = unchanged[((unchangedIndex = (unchangedIndex - 1) | 0))];
                                    }
                                }
                            }
                            timeline10.SetFrame(Bridge.identity(frameIndex10, ((frameIndex10 = (frameIndex10 + 1) | 0))), Spine.SkeletonJson.GetFloat(drawOrderMap, "time", 0), drawOrder);
                        }
                    } finally {
                        if (Bridge.is($t22, System.IDisposable)) {
                            $t22.System$IDisposable$Dispose();
                        }
                    }
                    timelines.Add(timeline10);
                    duration = Math.max(duration, timeline10.frames[((timeline10.FrameCount - 1) | 0)]);
                }

                // Event timeline.
                if (map.containsKey("events")) {
                    var eventsMap = Bridge.cast(map.getItem("events"), System.Collections.Generic.List$1(System.Object));
                    var timeline11 = new Spine.EventTimeline(eventsMap.Count);
                    var frameIndex11 = 0;
                    $t24 = Bridge.getEnumerator(eventsMap);
                    try {
                        while ($t24.moveNext()) {
                            var eventMap = Bridge.cast($t24.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var eventData = skeletonData.FindEvent(Bridge.cast(eventMap.getItem("name"), System.String));
                            if (eventData == null) {
                                throw new System.Exception(System.String.concat("Event not found: ", eventMap.getItem("name")));
                            }
                            var e = ($t25 = new Spine.Event(Spine.SkeletonJson.GetFloat(eventMap, "time", 0), eventData), $t25.intValue = Spine.SkeletonJson.GetInt(eventMap, "int", eventData.Int), $t25.floatValue = Spine.SkeletonJson.GetFloat(eventMap, "float", eventData.Float), $t25.stringValue = Spine.SkeletonJson.GetString(eventMap, "string", eventData.String), $t25);
                            if (e.data.AudioPath != null) {
                                e.volume = Spine.SkeletonJson.GetFloat(eventMap, "volume", eventData.Volume);
                                e.balance = Spine.SkeletonJson.GetFloat(eventMap, "balance", eventData.Balance);
                            }
                            timeline11.SetFrame(Bridge.identity(frameIndex11, ((frameIndex11 = (frameIndex11 + 1) | 0))), e);
                        }
                    } finally {
                        if (Bridge.is($t24, System.IDisposable)) {
                            $t24.System$IDisposable$Dispose();
                        }
                    }
                    timelines.Add(timeline11);
                    duration = Math.max(duration, timeline11.frames[((timeline11.FrameCount - 1) | 0)]);
                }

                timelines.TrimExcess();
                skeletonData.animations.Add(new Spine.Animation(name, timelines, duration));
            },
            /*Spine.SkeletonJson.ReadAnimation end.*/


        },
        overloads: {
            "ReadSkeletonData(string)": "ReadSkeletonData$1"
        }
    });
    /*Spine.SkeletonJson end.*/

    /*Spine.SkeletonJson+LinkedMesh start.*/
    Bridge.define("Spine.SkeletonJson.LinkedMesh", {
        $kind: 1002,
        fields: {
            parent: null,
            skin: null,
            slotIndex: 0,
            mesh: null,
            inheritDeform: false
        },
        ctors: {
            ctor: function (mesh, skin, slotIndex, parent, inheritDeform) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson.LinkedMesh#ctor", this ); }

                this.$initialize();
                this.mesh = mesh;
                this.skin = skin;
                this.slotIndex = slotIndex;
                this.parent = parent;
                this.inheritDeform = inheritDeform;
            }
        }
    });
    /*Spine.SkeletonJson+LinkedMesh end.*/

    /*Spine.Skin start.*/
    /**
     * Stores attachments by slot index and attachment name.
     <p>See SkeletonData {@link }, Skeleton {@link }, and
     <a href="http://esotericsoftware.com/spine-runtime-skins">Runtime skins</a> in the Spine Runtimes Guide.</p>
     *
     * @public
     * @class Spine.Skin
     */
    Bridge.define("Spine.Skin", {
        fields: {
            name: null,
            attachments: null,
            bones: null,
            constraints: null
        },
        props: {
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skin#Name#get", this ); }

                    return this.name;
                }
            },
            Attachments: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skin#Attachments#get", this ); }

                    return this.attachments;
                }
            },
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skin#Bones#get", this ); }

                    return this.bones;
                }
            },
            Constraints: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skin#Constraints#get", this ); }

                    return this.constraints;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Skin#init", this ); }

                this.attachments = new (Spine.Collections.OrderedDictionary$2(Spine.Skin.SkinEntry,Spine.Attachment)).$ctor1(Spine.Skin.SkinEntryComparer.Instance);
                this.bones = new (Spine.ExposedList$1(Spine.BoneData)).ctor();
                this.constraints = new (Spine.ExposedList$1(Spine.ConstraintData)).ctor();
            },
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.Skin#ctor", this ); }

                this.$initialize();
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor3("name", "name cannot be null.");
                }
                this.name = name;
            }
        },
        methods: {
            /*Spine.Skin.SetAttachment start.*/
            /**
             * Adds an attachment to the skin for the specified slot index and name.
             If the name already exists for the slot, the previous value is replaced.
             *
             * @instance
             * @public
             * @this Spine.Skin
             * @memberof Spine.Skin
             * @param   {number}              slotIndex     
             * @param   {string}              name          
             * @param   {Spine.Attachment}    attachment
             * @return  {void}
             */
            SetAttachment: function (slotIndex, name, attachment) {
if ( TRACE ) { TRACE( "Spine.Skin#SetAttachment", this ); }

                if (attachment == null) {
                    throw new System.ArgumentNullException.$ctor3("attachment", "attachment cannot be null.");
                }
                if (slotIndex < 0) {
                    throw new System.ArgumentNullException.$ctor3("slotIndex", "slotIndex must be >= 0.");
                }
                this.attachments.setItem(new Spine.Skin.SkinEntry.$ctor1(slotIndex, name, attachment), attachment);
            },
            /*Spine.Skin.SetAttachment end.*/

            /*Spine.Skin.AddSkin start.*/
            /**
             * Adds all attachments, bones, and constraints from the specified skin to this skin.
             *
             * @instance
             * @public
             * @this Spine.Skin
             * @memberof Spine.Skin
             * @param   {Spine.Skin}    skin
             * @return  {void}
             */
            AddSkin: function (skin) {
if ( TRACE ) { TRACE( "Spine.Skin#AddSkin", this ); }

                var $t, $t1, $t2;
                $t = Bridge.getEnumerator(skin.bones);
                try {
                    while ($t.moveNext()) {
                        var data = $t.Current;
                        if (!this.bones.Contains(data)) {
                            this.bones.Add(data);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                $t1 = Bridge.getEnumerator(skin.constraints);
                try {
                    while ($t1.moveNext()) {
                        var data1 = $t1.Current;
                        if (!this.constraints.Contains(data1)) {
                            this.constraints.Add(data1);
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                $t2 = Bridge.getEnumerator(skin.attachments.Keys);
                try {
                    while ($t2.moveNext()) {
                        var entry = $t2.Current;
                        this.SetAttachment(entry.SlotIndex, entry.Name, entry.Attachment);
                    }
                } finally {
                    if (Bridge.is($t2, System.IDisposable)) {
                        $t2.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Skin.AddSkin end.*/

            /*Spine.Skin.CopySkin start.*/
            /**
             * Adds all attachments from the specified skin to this skin. Attachments are deep copied.
             *
             * @instance
             * @public
             * @this Spine.Skin
             * @memberof Spine.Skin
             * @param   {Spine.Skin}    skin
             * @return  {void}
             */
            CopySkin: function (skin) {
if ( TRACE ) { TRACE( "Spine.Skin#CopySkin", this ); }

                var $t, $t1, $t2;
                $t = Bridge.getEnumerator(skin.bones);
                try {
                    while ($t.moveNext()) {
                        var data = $t.Current;
                        if (!this.bones.Contains(data)) {
                            this.bones.Add(data);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                $t1 = Bridge.getEnumerator(skin.constraints);
                try {
                    while ($t1.moveNext()) {
                        var data1 = $t1.Current;
                        if (!this.constraints.Contains(data1)) {
                            this.constraints.Add(data1);
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                $t2 = Bridge.getEnumerator(skin.attachments.Keys);
                try {
                    while ($t2.moveNext()) {
                        var entry = $t2.Current;
                        if (Bridge.is(entry.Attachment, Spine.MeshAttachment)) {
                            this.SetAttachment(entry.SlotIndex, entry.Name, entry.Attachment != null ? Bridge.cast(entry.Attachment, Spine.MeshAttachment).NewLinkedMesh() : null);
                        } else {
                            this.SetAttachment(entry.SlotIndex, entry.Name, entry.Attachment != null ? entry.Attachment.Copy() : null);
                        }
                    }
                } finally {
                    if (Bridge.is($t2, System.IDisposable)) {
                        $t2.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Skin.CopySkin end.*/

            /*Spine.Skin.GetAttachment start.*/
            /**
             * Returns the attachment for the specified slot index and name, or null.
             *
             * @instance
             * @public
             * @this Spine.Skin
             * @memberof Spine.Skin
             * @param   {number}              slotIndex    
             * @param   {string}              name
             * @return  {Spine.Attachment}                 May be null.
             */
            GetAttachment: function (slotIndex, name) {
if ( TRACE ) { TRACE( "Spine.Skin#GetAttachment", this ); }

                var lookup = new Spine.Skin.SkinEntry.$ctor1(slotIndex, name, null);
                var attachment = { v : null };
                var containsKey = this.attachments.tryGetValue(lookup, attachment);
                return containsKey ? attachment.v : null;
            },
            /*Spine.Skin.GetAttachment end.*/

            /*Spine.Skin.RemoveAttachment start.*/
            /**
             * Removes the attachment in the skin for the specified slot index and name, if any.
             *
             * @instance
             * @public
             * @this Spine.Skin
             * @memberof Spine.Skin
             * @param   {number}    slotIndex    
             * @param   {string}    name
             * @return  {void}
             */
            RemoveAttachment: function (slotIndex, name) {
if ( TRACE ) { TRACE( "Spine.Skin#RemoveAttachment", this ); }

                if (slotIndex < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("slotIndex", "slotIndex must be >= 0");
                }
                var lookup = new Spine.Skin.SkinEntry.$ctor1(slotIndex, name, null);
                this.attachments.remove(lookup);
            },
            /*Spine.Skin.RemoveAttachment end.*/

            /*Spine.Skin.GetAttachments start.*/
            /**
             * Returns all attachments contained in this skin.
             *
             * @instance
             * @public
             * @this Spine.Skin
             * @memberof Spine.Skin
             * @return  {System.Collections.Generic.ICollection$1}
             */
            GetAttachments: function () {
if ( TRACE ) { TRACE( "Spine.Skin#GetAttachments", this ); }

                return this.attachments.Keys;
            },
            /*Spine.Skin.GetAttachments end.*/

            /*Spine.Skin.GetAttachments$1 start.*/
            
            GetAttachments$1: function (slotIndex, attachments) {
if ( TRACE ) { TRACE( "Spine.Skin#GetAttachments$1", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.attachments.Keys);
                try {
                    while ($t.moveNext()) {
                        var entry = $t.Current;
                        if (entry.SlotIndex === slotIndex) {
                            attachments.add(entry);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Skin.GetAttachments$1 end.*/

            /*Spine.Skin.Clear start.*/
            /**
             * Clears all attachments, bones, and constraints.
             *
             * @instance
             * @public
             * @this Spine.Skin
             * @memberof Spine.Skin
             * @return  {void}
             */
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Skin#Clear", this ); }

                this.attachments.clear();
                this.bones.Clear();
                this.constraints.Clear();
            },
            /*Spine.Skin.Clear end.*/

            /*Spine.Skin.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Skin#toString", this ); }

                return this.name;
            },
            /*Spine.Skin.toString end.*/

            /*Spine.Skin.AttachAll start.*/
            /**
             * Attach all attachments from this skin if the corresponding attachment from the old skin is currently attached.
             *
             * @instance
             * @this Spine.Skin
             * @memberof Spine.Skin
             * @param   {Spine.Skeleton}    skeleton    
             * @param   {Spine.Skin}        oldSkin
             * @return  {void}
             */
            AttachAll: function (skeleton, oldSkin) {
if ( TRACE ) { TRACE( "Spine.Skin#AttachAll", this ); }

                var $t, $t1;
                $t = Bridge.getEnumerator(oldSkin.attachments.Keys);
                try {
                    while ($t.moveNext()) {
                        var entry = $t.Current;
                        var slotIndex = entry.SlotIndex;
                        var slot = ($t1 = skeleton.slots.Items)[slotIndex];
                        if (Bridge.referenceEquals(slot.Attachment, entry.Attachment)) {
                            var attachment = this.GetAttachment(slotIndex, entry.Name);
                            if (attachment != null) {
                                slot.Attachment = attachment;
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Skin.AttachAll end.*/


        },
        overloads: {
            "GetAttachments(int, List<SkinEntry>)": "GetAttachments$1",
            "ToString()": "toString"
        }
    });
    /*Spine.Skin end.*/

    /*Spine.Skin+SkinEntry start.*/
    /**
     * Stores an entry in the skin consisting of the slot index, name, and attachment.
     *
     * @public
     * @class Spine.Skin.SkinEntry
     */
    Bridge.define("Spine.Skin.SkinEntry", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#getDefaultValue", this ); }
 return new Spine.Skin.SkinEntry(); }
            }
        },
        fields: {
            slotIndex: 0,
            name: null,
            attachment: null,
            hashCode: 0
        },
        props: {
            SlotIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#SlotIndex#get", this ); }

                    return this.slotIndex;
                }
            },
            /**
             * The name the attachment is associated with, equivalent to the skin placeholder name in the Spine editor.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Skin.SkinEntry
             * @function Name
             * @type string
             */
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#Name#get", this ); }

                    return this.name;
                }
            },
            Attachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#Attachment#get", this ); }

                    return this.attachment;
                }
            }
        },
        ctors: {
            $ctor1: function (slotIndex, name, attachment) {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#$ctor1", this ); }

                this.$initialize();
                this.slotIndex = slotIndex;
                this.name = name;
                this.attachment = attachment;
                this.hashCode = (Bridge.getHashCode(this.name) + Bridge.Int.mul(this.slotIndex, 37)) | 0;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#getHashCode", this ); }

                var h = Bridge.addHash([3772635665, this.slotIndex, this.name, this.attachment, this.hashCode]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#equals", this ); }

                if (!Bridge.is(o, Spine.Skin.SkinEntry)) {
                    return false;
                }
                return Bridge.equals(this.slotIndex, o.slotIndex) && Bridge.equals(this.name, o.name) && Bridge.equals(this.attachment, o.attachment) && Bridge.equals(this.hashCode, o.hashCode);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#$clone", this ); }

                var s = to || new Spine.Skin.SkinEntry();
                s.slotIndex = this.slotIndex;
                s.name = this.name;
                s.attachment = this.attachment;
                s.hashCode = this.hashCode;
                return s;
            }
        }
    });
    /*Spine.Skin+SkinEntry end.*/

    /*Spine.Slot start.*/
    /**
     * Stores a slot's current pose. Slots organize attachments for {@link Skeleton#drawOrder} purposes and provide a place to store
     state for an attachment.State cannot be stored in an attachment itself because attachments are stateless and may be shared
     across multiple skeletons.
     *
     * @public
     * @class Spine.Slot
     */
    Bridge.define("Spine.Slot", {
        fields: {
            data: null,
            bone: null,
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            r2: 0,
            g2: 0,
            b2: 0,
            hasSecondColor: false,
            attachment: null,
            attachmentTime: 0,
            deform: null,
            attachmentState: 0
        },
        props: {
            /**
             * The slot's setup pose data.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Slot
             * @function Data
             * @type Spine.SlotData
             */
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#Data#get", this ); }

                    return this.data;
                }
            },
            /**
             * The bone this slot belongs to.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Slot
             * @function Bone
             * @type Spine.Bone
             */
            Bone: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#Bone#get", this ); }

                    return this.bone;
                }
            },
            /**
             * The skeleton this slot belongs to.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Slot
             * @function Skeleton
             * @type Spine.Skeleton
             */
            Skeleton: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#Skeleton#get", this ); }

                    return this.bone.skeleton;
                }
            },
            /**
             * The color used to tint the slot's attachment. If {@link } is set, this is used as the light color for two
             color tinting.
             *
             * @instance
             * @public
             * @memberof Spine.Slot
             * @function R
             * @type number
             */
            R: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#R#get", this ); }

                    return this.r;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#R#set", this ); }

                    this.r = value;
                }
            },
            /**
             * The color used to tint the slot's attachment. If {@link } is set, this is used as the light color for two
             color tinting.
             *
             * @instance
             * @public
             * @memberof Spine.Slot
             * @function G
             * @type number
             */
            G: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#G#get", this ); }

                    return this.g;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#G#set", this ); }

                    this.g = value;
                }
            },
            /**
             * The color used to tint the slot's attachment. If {@link } is set, this is used as the light color for two
             color tinting.
             *
             * @instance
             * @public
             * @memberof Spine.Slot
             * @function B
             * @type number
             */
            B: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#B#get", this ); }

                    return this.b;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#B#set", this ); }

                    this.b = value;
                }
            },
            /**
             * The color used to tint the slot's attachment. If {@link } is set, this is used as the light color for two
             color tinting.
             *
             * @instance
             * @public
             * @memberof Spine.Slot
             * @function A
             * @type number
             */
            A: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#A#get", this ); }

                    return this.a;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#A#set", this ); }

                    this.a = value;
                }
            },
            /**
             * The dark color used to tint the slot's attachment for two color tinting, ignored if two color tinting is not used.
             *
             * @instance
             * @public
             * @memberof Spine.Slot
             * @function R2
             * @type number
             * @see {@link HasSecondColor}
             */
            R2: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#R2#get", this ); }

                    return this.r2;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#R2#set", this ); }

                    this.r2 = value;
                }
            },
            /**
             * The dark color used to tint the slot's attachment for two color tinting, ignored if two color tinting is not used.
             *
             * @instance
             * @public
             * @memberof Spine.Slot
             * @function G2
             * @type number
             * @see {@link HasSecondColor}
             */
            G2: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#G2#get", this ); }

                    return this.g2;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#G2#set", this ); }

                    this.g2 = value;
                }
            },
            /**
             * The dark color used to tint the slot's attachment for two color tinting, ignored if two color tinting is not used.
             *
             * @instance
             * @public
             * @memberof Spine.Slot
             * @function B2
             * @type number
             * @see {@link HasSecondColor}
             */
            B2: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#B2#get", this ); }

                    return this.b2;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#B2#set", this ); }

                    this.b2 = value;
                }
            },
            /**
             * Whether R2 G2 B2 are used to tint the slot's attachment for two color tinting. False if two color tinting is not used.
             *
             * @instance
             * @public
             * @memberof Spine.Slot
             * @function HasSecondColor
             * @type boolean
             */
            HasSecondColor: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#HasSecondColor#get", this ); }

                    return this.data.hasSecondColor;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#HasSecondColor#set", this ); }

                    this.data.hasSecondColor = value;
                }
            },
            Attachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#Attachment#get", this ); }

                    return this.attachment;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#Attachment#set", this ); }

                    if (Bridge.referenceEquals(this.attachment, value)) {
                        return;
                    }
                    this.attachment = value;
                    this.attachmentTime = this.bone.skeleton.time;
                    this.deform.Clear(false);
                }
            },
            /**
             * The time that has elapsed since the last time the attachment was set or cleared. Relies on Skeleton
             {@link }
             *
             * @instance
             * @public
             * @memberof Spine.Slot
             * @function AttachmentTime
             * @type number
             */
            AttachmentTime: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#AttachmentTime#get", this ); }

                    return this.bone.skeleton.time - this.attachmentTime;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#AttachmentTime#set", this ); }

                    this.attachmentTime = this.bone.skeleton.time - value;
                }
            },
            /**
             * Vertices to deform the slot's attachment. For an unweighted mesh, the entries are local positions for each vertex. For a
             weighted mesh, the entries are an offset for each vertex which will be added to the mesh's local vertex positions.
             <p />
             See {@link } and {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.Slot
             * @function Deform
             * @type Spine.ExposedList$1
             */
            Deform: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#Deform#get", this ); }

                    return this.deform;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#Deform#set", this ); }

                    if (this.deform == null) {
                        throw new System.ArgumentNullException.$ctor3("deform", "deform cannot be null.");
                    }
                    this.deform = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Slot#init", this ); }

                this.deform = new (Spine.ExposedList$1(System.Single)).ctor();
            },
            $ctor1: function (data, bone) {
if ( TRACE ) { TRACE( "Spine.Slot#$ctor1", this ); }

                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                if (bone == null) {
                    throw new System.ArgumentNullException.$ctor3("bone", "bone cannot be null.");
                }
                this.data = data;
                this.bone = bone;

                // darkColor = data.darkColor == null ? null : new Color();
                if (data.hasSecondColor) {
                    this.r2 = (this.g2 = (this.b2 = 0));
                }

                this.SetToSetupPose();
            },
            /**
             * Copy constructor.
             *
             * @instance
             * @public
             * @this Spine.Slot
             * @memberof Spine.Slot
             * @param   {Spine.Slot}    slot    
             * @param   {Spine.Bone}    bone
             * @return  {void}
             */
            ctor: function (slot, bone) {
if ( TRACE ) { TRACE( "Spine.Slot#ctor", this ); }

                this.$initialize();
                if (slot == null) {
                    throw new System.ArgumentNullException.$ctor3("slot", "slot cannot be null.");
                }
                if (bone == null) {
                    throw new System.ArgumentNullException.$ctor3("bone", "bone cannot be null.");
                }
                this.data = slot.data;
                this.bone = bone;
                this.r = slot.r;
                this.g = slot.g;
                this.b = slot.b;
                this.a = slot.a;

                // darkColor = slot.darkColor == null ? null : new Color(slot.darkColor);
                if (slot.hasSecondColor) {
                    this.r2 = slot.r2;
                    this.g2 = slot.g2;
                    this.b2 = slot.b2;
                } else {
                    this.r2 = (this.g2 = (this.b2 = 0));
                }
                this.hasSecondColor = slot.hasSecondColor;

                this.attachment = slot.attachment;
                this.attachmentTime = slot.attachmentTime;
                this.deform.AddRange(slot.deform);
            }
        },
        methods: {
            /*Spine.Slot.ClampColor start.*/
            ClampColor: function () {
if ( TRACE ) { TRACE( "Spine.Slot#ClampColor", this ); }

                this.r = Spine.MathUtils.Clamp(this.r, 0, 1);
                this.g = Spine.MathUtils.Clamp(this.g, 0, 1);
                this.b = Spine.MathUtils.Clamp(this.b, 0, 1);
                this.a = Spine.MathUtils.Clamp(this.a, 0, 1);
            },
            /*Spine.Slot.ClampColor end.*/

            /*Spine.Slot.ClampSecondColor start.*/
            ClampSecondColor: function () {
if ( TRACE ) { TRACE( "Spine.Slot#ClampSecondColor", this ); }

                this.r2 = Spine.MathUtils.Clamp(this.r2, 0, 1);
                this.g2 = Spine.MathUtils.Clamp(this.g2, 0, 1);
                this.b2 = Spine.MathUtils.Clamp(this.b2, 0, 1);
            },
            /*Spine.Slot.ClampSecondColor end.*/

            /*Spine.Slot.SetToSetupPose start.*/
            /**
             * Sets this slot to the setup pose.
             *
             * @instance
             * @public
             * @this Spine.Slot
             * @memberof Spine.Slot
             * @return  {void}
             */
            SetToSetupPose: function () {
if ( TRACE ) { TRACE( "Spine.Slot#SetToSetupPose", this ); }

                this.r = this.data.r;
                this.g = this.data.g;
                this.b = this.data.b;
                this.a = this.data.a;

                // if (darkColor != null) darkColor.set(data.darkColor);
                if (this.HasSecondColor) {
                    this.r2 = this.data.r2;
                    this.g2 = this.data.g2;
                    this.b2 = this.data.b2;
                }

                if (this.data.attachmentName == null) {
                    this.Attachment = null;
                } else {
                    this.attachment = null;
                    this.Attachment = this.bone.skeleton.GetAttachment(this.data.index, this.data.attachmentName);
                }
            },
            /*Spine.Slot.SetToSetupPose end.*/

            /*Spine.Slot.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Slot#toString", this ); }

                return this.data.name;
            },
            /*Spine.Slot.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.Slot end.*/

    /*Spine.SlotData start.*/
    Bridge.define("Spine.SlotData", {
        fields: {
            index: 0,
            name: null,
            boneData: null,
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            r2: 0,
            g2: 0,
            b2: 0,
            hasSecondColor: false,
            attachmentName: null,
            blendMode: 0
        },
        props: {
            /**
             * The index of the slot in {@link }.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.SlotData
             * @function Index
             * @type number
             */
            Index: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#Index#get", this ); }

                    return this.index;
                }
            },
            /**
             * The name of the slot, which is unique across all slots in the skeleton.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.SlotData
             * @function Name
             * @type string
             */
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#Name#get", this ); }

                    return this.name;
                }
            },
            /**
             * The bone this slot belongs to.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.SlotData
             * @function BoneData
             * @type Spine.BoneData
             */
            BoneData: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#BoneData#get", this ); }

                    return this.boneData;
                }
            },
            R: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#R#get", this ); }

                    return this.r;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#R#set", this ); }

                    this.r = value;
                }
            },
            G: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#G#get", this ); }

                    return this.g;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#G#set", this ); }

                    this.g = value;
                }
            },
            B: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#B#get", this ); }

                    return this.b;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#B#set", this ); }

                    this.b = value;
                }
            },
            A: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#A#get", this ); }

                    return this.a;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#A#set", this ); }

                    this.a = value;
                }
            },
            R2: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#R2#get", this ); }

                    return this.r2;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#R2#set", this ); }

                    this.r2 = value;
                }
            },
            G2: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#G2#get", this ); }

                    return this.g2;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#G2#set", this ); }

                    this.g2 = value;
                }
            },
            B2: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#B2#get", this ); }

                    return this.b2;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#B2#set", this ); }

                    this.b2 = value;
                }
            },
            HasSecondColor: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#HasSecondColor#get", this ); }

                    return this.hasSecondColor;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#HasSecondColor#set", this ); }

                    this.hasSecondColor = value;
                }
            },
            /**
             * The name of the attachment that is visible for this slot in the setup pose, or null if no attachment is visible.
             *
             * @instance
             * @public
             * @memberof Spine.SlotData
             * @function AttachmentName
             * @type string
             */
            AttachmentName: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#AttachmentName#get", this ); }

                    return this.attachmentName;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#AttachmentName#set", this ); }

                    this.attachmentName = value;
                }
            },
            /**
             * The blend mode for drawing the slot's attachment.
             *
             * @instance
             * @public
             * @memberof Spine.SlotData
             * @function BlendMode
             * @type Spine.BlendMode
             */
            BlendMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#BlendMode#get", this ); }

                    return this.blendMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#BlendMode#set", this ); }

                    this.blendMode = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#init", this ); }

                this.r = 1;
                this.g = 1;
                this.b = 1;
                this.a = 1;
                this.r2 = 0;
                this.g2 = 0;
                this.b2 = 0;
                this.hasSecondColor = false;
            },
            ctor: function (index, name, boneData) {
if ( TRACE ) { TRACE( "Spine.SlotData#ctor", this ); }

                this.$initialize();
                if (index < 0) {
                    throw new System.ArgumentException.$ctor3("index must be >= 0.", "index");
                }
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor3("name", "name cannot be null.");
                }
                if (boneData == null) {
                    throw new System.ArgumentNullException.$ctor3("boneData", "boneData cannot be null.");
                }
                this.index = index;
                this.name = name;
                this.boneData = boneData;
            }
        },
        methods: {
            /*Spine.SlotData.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#toString", this ); }

                return this.name;
            },
            /*Spine.SlotData.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.SlotData end.*/

    /*Spine.SpacingMode start.*/
    Bridge.define("Spine.SpacingMode", {
        $kind: 6,
        statics: {
            fields: {
                Length: 0,
                Fixed: 1,
                Percent: 2
            }
        }
    });
    /*Spine.SpacingMode end.*/

    /*Spine.SpineSkeletonExtensions start.*/
    Bridge.define("Spine.SpineSkeletonExtensions", {
        statics: {
            methods: {
                /*Spine.SpineSkeletonExtensions.IsWeighted:static start.*/
                IsWeighted: function (va) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#IsWeighted", this ); }

                    return va.bones != null && va.bones.length > 0;
                },
                /*Spine.SpineSkeletonExtensions.IsWeighted:static end.*/

                /*Spine.SpineSkeletonExtensions.IsRenderable:static start.*/
                IsRenderable: function (a) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#IsRenderable", this ); }

                    return Bridge.is(a, Spine.IHasRendererObject);
                },
                /*Spine.SpineSkeletonExtensions.IsRenderable:static end.*/

                /*Spine.SpineSkeletonExtensions.InheritsRotation:static start.*/
                InheritsRotation: function (mode) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#InheritsRotation", this ); }

                    var RotationBit = 0;
                    return (System.Int64(mode).and(System.Int64((1)))).equals(System.Int64(0));
                },
                /*Spine.SpineSkeletonExtensions.InheritsRotation:static end.*/

                /*Spine.SpineSkeletonExtensions.InheritsScale:static start.*/
                InheritsScale: function (mode) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#InheritsScale", this ); }

                    var ScaleBit = 1;
                    return (System.Int64(mode).and(System.Int64((2)))).equals(System.Int64(0));
                },
                /*Spine.SpineSkeletonExtensions.InheritsScale:static end.*/

                /*Spine.SpineSkeletonExtensions.SetPropertyToSetupPose:static start.*/
                SetPropertyToSetupPose: function (skeleton, propertyID) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#SetPropertyToSetupPose", this ); }

                    var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11;
                    var tt = propertyID >> 24;
                    var timelineType = tt;
                    var i = (propertyID - (tt << 24)) | 0;

                    var bone;
                    var ikc;
                    var pc;

                    switch (timelineType) {
                        case Spine.TimelineType.Rotate: 
                            bone = ($t = skeleton.bones.Items)[i];
                            bone.rotation = bone.data.rotation;
                            break;
                        case Spine.TimelineType.Translate: 
                            bone = ($t1 = skeleton.bones.Items)[i];
                            bone.x = bone.data.x;
                            bone.y = bone.data.y;
                            break;
                        case Spine.TimelineType.Scale: 
                            bone = ($t2 = skeleton.bones.Items)[i];
                            bone.scaleX = bone.data.scaleX;
                            bone.scaleY = bone.data.scaleY;
                            break;
                        case Spine.TimelineType.Shear: 
                            bone = ($t3 = skeleton.bones.Items)[i];
                            bone.shearX = bone.data.shearX;
                            bone.shearY = bone.data.shearY;
                            break;
                        case Spine.TimelineType.Attachment: 
                            Spine.SpineSkeletonExtensions.SetSlotAttachmentToSetupPose(skeleton, i);
                            break;
                        case Spine.TimelineType.Color: 
                            Spine.SpineSkeletonExtensions.SetColorToSetupPose(($t4 = skeleton.slots.Items)[i]);
                            break;
                        case Spine.TimelineType.TwoColor: 
                            Spine.SpineSkeletonExtensions.SetColorToSetupPose(($t5 = skeleton.slots.Items)[i]);
                            break;
                        case Spine.TimelineType.Deform: 
                            ($t6 = skeleton.slots.Items)[i].Deform.Clear();
                            break;
                        case Spine.TimelineType.DrawOrder: 
                            Spine.SpineSkeletonExtensions.SetDrawOrderToSetupPose(skeleton);
                            break;
                        case Spine.TimelineType.IkConstraint: 
                            ikc = ($t7 = skeleton.ikConstraints.Items)[i];
                            ikc.mix = ikc.data.mix;
                            ikc.softness = ikc.data.softness;
                            ikc.bendDirection = ikc.data.bendDirection;
                            ikc.stretch = ikc.data.stretch;
                            break;
                        case Spine.TimelineType.TransformConstraint: 
                            var tc = ($t8 = skeleton.transformConstraints.Items)[i];
                            var tcData = tc.data;
                            tc.rotateMix = tcData.rotateMix;
                            tc.translateMix = tcData.translateMix;
                            tc.scaleMix = tcData.scaleMix;
                            tc.shearMix = tcData.shearMix;
                            break;
                        case Spine.TimelineType.PathConstraintPosition: 
                            pc = ($t9 = skeleton.pathConstraints.Items)[i];
                            pc.position = pc.data.position;
                            break;
                        case Spine.TimelineType.PathConstraintSpacing: 
                            pc = ($t10 = skeleton.pathConstraints.Items)[i];
                            pc.spacing = pc.data.spacing;
                            break;
                        case Spine.TimelineType.PathConstraintMix: 
                            pc = ($t11 = skeleton.pathConstraints.Items)[i];
                            pc.rotateMix = pc.data.rotateMix;
                            pc.translateMix = pc.data.translateMix;
                            break;
                    }
                },
                /*Spine.SpineSkeletonExtensions.SetPropertyToSetupPose:static end.*/

                /*Spine.SpineSkeletonExtensions.SetDrawOrderToSetupPose:static start.*/
                /**
                 * Resets the DrawOrder to the Setup Pose's draw order
                 *
                 * @static
                 * @public
                 * @this Spine.SpineSkeletonExtensions
                 * @memberof Spine.SpineSkeletonExtensions
                 * @param   {Spine.Skeleton}    skeleton
                 * @return  {void}
                 */
                SetDrawOrderToSetupPose: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#SetDrawOrderToSetupPose", this ); }

                    var slotsItems = skeleton.slots.Items;
                    var n = skeleton.slots.Count;

                    var drawOrder = skeleton.drawOrder;
                    drawOrder.Clear(false);
                    drawOrder.EnsureCapacity(n);
                    drawOrder.Count = n;
                    System.Array.copy(slotsItems, 0, drawOrder.Items, 0, n);
                },
                /*Spine.SpineSkeletonExtensions.SetDrawOrderToSetupPose:static end.*/

                /*Spine.SpineSkeletonExtensions.SetSlotAttachmentsToSetupPose:static start.*/
                /**
                 * Resets all the slots on the skeleton to their Setup Pose attachments but does not reset slot colors.
                 *
                 * @static
                 * @public
                 * @this Spine.SpineSkeletonExtensions
                 * @memberof Spine.SpineSkeletonExtensions
                 * @param   {Spine.Skeleton}    skeleton
                 * @return  {void}
                 */
                SetSlotAttachmentsToSetupPose: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#SetSlotAttachmentsToSetupPose", this ); }

                    var slotsItems = skeleton.slots.Items;
                    for (var i = 0; i < skeleton.slots.Count; i = (i + 1) | 0) {
                        var slot = slotsItems[i];
                        var attachmentName = slot.data.attachmentName;
                        slot.Attachment = System.String.isNullOrEmpty(attachmentName) ? null : skeleton.GetAttachment(i, attachmentName);
                    }
                },
                /*Spine.SpineSkeletonExtensions.SetSlotAttachmentsToSetupPose:static end.*/

                /*Spine.SpineSkeletonExtensions.SetColorToSetupPose:static start.*/
                /**
                 * Resets the color of a slot to Setup Pose value.
                 *
                 * @static
                 * @public
                 * @this Spine.SpineSkeletonExtensions
                 * @memberof Spine.SpineSkeletonExtensions
                 * @param   {Spine.Slot}    slot
                 * @return  {void}
                 */
                SetColorToSetupPose: function (slot) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#SetColorToSetupPose", this ); }

                    slot.r = slot.data.r;
                    slot.g = slot.data.g;
                    slot.b = slot.data.b;
                    slot.a = slot.data.a;
                    slot.r2 = slot.data.r2;
                    slot.g2 = slot.data.g2;
                    slot.b2 = slot.data.b2;
                },
                /*Spine.SpineSkeletonExtensions.SetColorToSetupPose:static end.*/

                /*Spine.SpineSkeletonExtensions.SetAttachmentToSetupPose:static start.*/
                /**
                 * Sets a slot's attachment to setup pose. If you have the slotIndex, Skeleton.SetSlotAttachmentToSetupPose is faster.
                 *
                 * @static
                 * @public
                 * @this Spine.SpineSkeletonExtensions
                 * @memberof Spine.SpineSkeletonExtensions
                 * @param   {Spine.Slot}    slot
                 * @return  {void}
                 */
                SetAttachmentToSetupPose: function (slot) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#SetAttachmentToSetupPose", this ); }

                    var slotData = slot.data;
                    slot.Attachment = slot.bone.skeleton.GetAttachment$1(slotData.name, slotData.attachmentName);
                },
                /*Spine.SpineSkeletonExtensions.SetAttachmentToSetupPose:static end.*/

                /*Spine.SpineSkeletonExtensions.SetSlotAttachmentToSetupPose:static start.*/
                /**
                 * Resets the attachment of slot at a given slotIndex to setup pose. This is faster than Slot.SetAttachmentToSetupPose.
                 *
                 * @static
                 * @public
                 * @this Spine.SpineSkeletonExtensions
                 * @memberof Spine.SpineSkeletonExtensions
                 * @param   {Spine.Skeleton}    skeleton     
                 * @param   {number}            slotIndex
                 * @return  {void}
                 */
                SetSlotAttachmentToSetupPose: function (skeleton, slotIndex) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#SetSlotAttachmentToSetupPose", this ); }

                    var $t;
                    var slot = ($t = skeleton.slots.Items)[slotIndex];
                    var attachmentName = slot.data.attachmentName;
                    if (System.String.isNullOrEmpty(attachmentName)) {
                        slot.Attachment = null;
                    } else {
                        var attachment = skeleton.GetAttachment(slotIndex, attachmentName);
                        slot.Attachment = attachment;
                    }
                },
                /*Spine.SpineSkeletonExtensions.SetSlotAttachmentToSetupPose:static end.*/

                /*Spine.SpineSkeletonExtensions.SetKeyedItemsToSetupPose:static start.*/
                /**
                 * Resets Skeleton parts to Setup Pose according to a Spine.Animation's keyed items.
                 *
                 * @static
                 * @public
                 * @this Spine.SpineSkeletonExtensions
                 * @memberof Spine.SpineSkeletonExtensions
                 * @param   {Spine.Animation}    animation    
                 * @param   {Spine.Skeleton}     skeleton
                 * @return  {void}
                 */
                SetKeyedItemsToSetupPose: function (animation, skeleton) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#SetKeyedItemsToSetupPose", this ); }

                    animation.Apply(skeleton, 0, 0, false, null, 0, Spine.MixBlend.Setup, Spine.MixDirection.Out);
                },
                /*Spine.SpineSkeletonExtensions.SetKeyedItemsToSetupPose:static end.*/

                /*Spine.SpineSkeletonExtensions.AllowImmediateQueue:static start.*/
                AllowImmediateQueue: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#AllowImmediateQueue", this ); }

                    if (trackEntry.nextTrackLast < 0) {
                        trackEntry.nextTrackLast = 0;
                    }
                },
                /*Spine.SpineSkeletonExtensions.AllowImmediateQueue:static end.*/


            }
        }
    });
    /*Spine.SpineSkeletonExtensions end.*/

    /*Spine.TextureFilter start.*/
    Bridge.define("Spine.TextureFilter", {
        $kind: 6,
        statics: {
            fields: {
                Nearest: 0,
                Linear: 1,
                MipMap: 2,
                MipMapNearestNearest: 3,
                MipMapLinearNearest: 4,
                MipMapNearestLinear: 5,
                MipMapLinearLinear: 6
            }
        }
    });
    /*Spine.TextureFilter end.*/

    /*Spine.TextureLoader start.*/
    Bridge.define("Spine.TextureLoader", {
        $kind: 3
    });
    /*Spine.TextureLoader end.*/

    /*Spine.TextureWrap start.*/
    Bridge.define("Spine.TextureWrap", {
        $kind: 6,
        statics: {
            fields: {
                MirroredRepeat: 0,
                ClampToEdge: 1,
                Repeat: 2
            }
        }
    });
    /*Spine.TextureWrap end.*/

    /*Spine.TimelineType start.*/
    Bridge.define("Spine.TimelineType", {
        $kind: 6,
        statics: {
            fields: {
                Rotate: 0,
                Translate: 1,
                Scale: 2,
                Shear: 3,
                Attachment: 4,
                Color: 5,
                Deform: 6,
                Event: 7,
                DrawOrder: 8,
                IkConstraint: 9,
                TransformConstraint: 10,
                PathConstraintPosition: 11,
                PathConstraintSpacing: 12,
                PathConstraintMix: 13,
                TwoColor: 14
            }
        }
    });
    /*Spine.TimelineType end.*/

    /*Spine.TransformMode start.*/
    Bridge.define("Spine.TransformMode", {
        $kind: 6,
        statics: {
            fields: {
                Normal: 0,
                OnlyTranslation: 7,
                NoRotationOrReflection: 1,
                NoScale: 2,
                NoScaleOrReflection: 6
            }
        },
        $flags: true
    });
    /*Spine.TransformMode end.*/

    /*Spine.Triangulator start.*/
    Bridge.define("Spine.Triangulator", {
        statics: {
            methods: {
                /*Spine.Triangulator.IsConcave:static start.*/
                IsConcave: function (index, vertexCount, vertices, indices) {
if ( TRACE ) { TRACE( "Spine.Triangulator#IsConcave", this ); }

                    var previous = indices[(((((vertexCount + index) | 0) - 1) | 0)) % vertexCount] << 1;
                    var current = indices[index] << 1;
                    var next = indices[(((index + 1) | 0)) % vertexCount] << 1;
                    return !Spine.Triangulator.PositiveArea(vertices[previous], vertices[((previous + 1) | 0)], vertices[current], vertices[((current + 1) | 0)], vertices[next], vertices[((next + 1) | 0)]);
                },
                /*Spine.Triangulator.IsConcave:static end.*/

                /*Spine.Triangulator.PositiveArea:static start.*/
                PositiveArea: function (p1x, p1y, p2x, p2y, p3x, p3y) {
if ( TRACE ) { TRACE( "Spine.Triangulator#PositiveArea", this ); }

                    return p1x * (p3y - p2y) + p2x * (p1y - p3y) + p3x * (p2y - p1y) >= 0;
                },
                /*Spine.Triangulator.PositiveArea:static end.*/

                /*Spine.Triangulator.Winding:static start.*/
                Winding: function (p1x, p1y, p2x, p2y, p3x, p3y) {
if ( TRACE ) { TRACE( "Spine.Triangulator#Winding", this ); }

                    var px = p2x - p1x, py = p2y - p1y;
                    return p3x * py - p3y * px + px * p1y - p1x * py >= 0 ? 1 : -1;
                },
                /*Spine.Triangulator.Winding:static end.*/


            }
        },
        fields: {
            convexPolygons: null,
            convexPolygonsIndices: null,
            indicesArray: null,
            isConcaveArray: null,
            triangles: null,
            polygonPool: null,
            polygonIndicesPool: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Triangulator#init", this ); }

                this.convexPolygons = new (Spine.ExposedList$1(Spine.ExposedList$1(System.Single))).ctor();
                this.convexPolygonsIndices = new (Spine.ExposedList$1(Spine.ExposedList$1(System.Int32))).ctor();
                this.indicesArray = new (Spine.ExposedList$1(System.Int32)).ctor();
                this.isConcaveArray = new (Spine.ExposedList$1(System.Boolean)).ctor();
                this.triangles = new (Spine.ExposedList$1(System.Int32)).ctor();
                this.polygonPool = new (Spine.Pool$1(Spine.ExposedList$1(System.Single)))();
                this.polygonIndicesPool = new (Spine.Pool$1(Spine.ExposedList$1(System.Int32)))();
            }
        },
        methods: {
            /*Spine.Triangulator.Triangulate start.*/
            Triangulate: function (verticesArray) {
if ( TRACE ) { TRACE( "Spine.Triangulator#Triangulate", this ); }

                var $step = 0,
                    $jumpFromFinally, 
                    vertices, 
                    vertexCount, 
                    indicesArray, 
                    indices, 
                    isConcaveArray, 
                    isConcave, 
                    triangles, 
                    previous, 
                    i2, 
                    next, 
                    p1, 
                    p2, 
                    p3, 
                    p1x, 
                    p1y, 
                    p2x, 
                    p2y, 
                    p3x, 
                    p3y, 
                    ii, 
                    v, 
                    vx, 
                    vy, 
                    previousIndex, 
                    nextIndex, 
                    $asyncBody = Bridge.fn.bind(this, function () {
                        for (;;) {
                            $step = System.Array.min([0,1,2,3,4,5,6,7,8,9,10,11,14,15,16,17,18,19], $step);
                            switch ($step) {
                                case 0: {
                                    vertices = verticesArray.Items;
                                    vertexCount = verticesArray.Count >> 1;

                                    indicesArray = this.indicesArray;
                                    indicesArray.Clear();
                                    indices = indicesArray.Resize(vertexCount).Items;
                                    for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                                        indices[i] = i;
                                    }

                                    isConcaveArray = this.isConcaveArray;
                                    isConcave = isConcaveArray.Resize(vertexCount).Items;
                                    for (var i1 = 0, n = vertexCount; i1 < n; i1 = (i1 + 1) | 0) {
                                        isConcave[i1] = Spine.Triangulator.IsConcave(i1, vertexCount, vertices, indices);
                                    }

                                    triangles = this.triangles;
                                    triangles.Clear();
                                    triangles.EnsureCapacity(Math.max(0, ((vertexCount - 2) | 0)) << 2);
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( vertexCount > 3 ) {
                                        $step = 2;
                                        continue;
                                    } 
                                    $step = 19;
                                    continue;
                                }
                                case 2: {
                                    // Find ear tip.
                                    previous = (vertexCount - 1) | 0;
                                    i2 = 0;
                                    next = 1;

                                    // outer:
                                    $step = 3;
                                    continue;
                                }
                                case 3: {
                                    if ( true ) {
                                        $step = 4;
                                        continue;
                                    } 
                                    $step = 18;
                                    continue;
                                }
                                case 4: {
                                    if (!isConcave[i2]) {
                                        $step = 5;
                                        continue;
                                    } 
                                    $step = 16;
                                    continue;
                                }
                                case 5: {
                                    p1 = indices[previous] << 1;
                                    p2 = indices[i2] << 1;
                                    p3 = indices[next] << 1;
                                    p1x = vertices[p1];
                                    p1y = vertices[((p1 + 1) | 0)];
                                    p2x = vertices[p2];
                                    p2y = vertices[((p2 + 1) | 0)];
                                    p3x = vertices[p3];
                                    p3y = vertices[((p3 + 1) | 0)];
                                    ii = (((next + 1) | 0)) % vertexCount;
                                    $step = 6;
                                    continue;
                                }
                                case 6: {
                                    if ( ii !== previous ) {
                                        $step = 7;
                                        continue;
                                    }
                                    $step = 15;
                                    continue;
                                }
                                case 7: {
                                    if (!isConcave[ii]) {
                                        $step = 14;
                                        continue;
                                    }
                                    v = indices[ii] << 1;
                                    vx = vertices[v];
                                    vy = vertices[((v + 1) | 0)];
                                    if (Spine.Triangulator.PositiveArea(p3x, p3y, p1x, p1y, vx, vy)) {
                                        $step = 8;
                                        continue;
                                    } 
                                    $step = 13;
                                    continue;
                                }
                                case 8: {
                                    if (Spine.Triangulator.PositiveArea(p1x, p1y, p2x, p2y, vx, vy)) {
                                        $step = 9;
                                        continue;
                                    } 
                                    $step = 12;
                                    continue;
                                }
                                case 9: {
                                    if (Spine.Triangulator.PositiveArea(p2x, p2y, p3x, p3y, vx, vy)) {
                                        $step = 10;
                                        continue;
                                    } 
                                    $step = 11;
                                    continue;
                                }
                                case 10: {
                                    $step = 17;
                                    continue;
                                }
                                case 11: {
                                    // break outer;
                                    $step = 12;
                                    continue;
                                }


                                case 14: {
                                    ii = (((ii + 1) | 0)) % vertexCount;
                                    $step = 6;
                                    continue;
                                }
                                case 15: {
                                    $step = 18;
                                    continue;
                                }
                                case 16: {

                                }
                                case 17: {
                                    if (next === 0) {
                                        do {
                                            if (!isConcave[i2]) {
                                                break;
                                            }
                                            i2 = (i2 - 1) | 0;
                                        } while (i2 > 0);
                                        $step = 18;
                                        continue;
                                    }

                                    previous = i2;
                                    i2 = next;
                                    next = (((next + 1) | 0)) % vertexCount;

                                    $step = 3;
                                    continue;
                                }
                                case 18: {
                                    // Cut ear tip.
                                    triangles.Add(indices[(((((vertexCount + i2) | 0) - 1) | 0)) % vertexCount]);
                                    triangles.Add(indices[i2]);
                                    triangles.Add(indices[(((i2 + 1) | 0)) % vertexCount]);
                                    indicesArray.RemoveAt(i2);
                                    isConcaveArray.RemoveAt(i2);
                                    vertexCount = (vertexCount - 1) | 0;

                                    previousIndex = (((((vertexCount + i2) | 0) - 1) | 0)) % vertexCount;
                                    nextIndex = i2 === vertexCount ? 0 : i2;
                                    isConcave[previousIndex] = Spine.Triangulator.IsConcave(previousIndex, vertexCount, vertices, indices);
                                    isConcave[nextIndex] = Spine.Triangulator.IsConcave(nextIndex, vertexCount, vertices, indices);

                                    $step = 1;
                                    continue;
                                }
                                case 19: {
                                    if (vertexCount === 3) {
                                        triangles.Add(indices[2]);
                                        triangles.Add(indices[0]);
                                        triangles.Add(indices[1]);
                                    }

                                    return triangles;
                                }
                                default: {
                                    return;
                                }
                            }
                        }
                    }, arguments);

                return $asyncBody();
            },
            /*Spine.Triangulator.Triangulate end.*/

            /*Spine.Triangulator.Decompose start.*/
            Decompose: function (verticesArray, triangles) {
if ( TRACE ) { TRACE( "Spine.Triangulator#Decompose", this ); }

                var vertices = verticesArray.Items;
                var convexPolygons = this.convexPolygons;
                for (var i = 0, n = convexPolygons.Count; i < n; i = (i + 1) | 0) {
                    this.polygonPool.Free(convexPolygons.Items[i]);
                }
                convexPolygons.Clear();

                var convexPolygonsIndices = this.convexPolygonsIndices;
                for (var i1 = 0, n1 = convexPolygonsIndices.Count; i1 < n1; i1 = (i1 + 1) | 0) {
                    this.polygonIndicesPool.Free(convexPolygonsIndices.Items[i1]);
                }
                convexPolygonsIndices.Clear();

                var polygonIndices = this.polygonIndicesPool.Obtain();
                polygonIndices.Clear();

                var polygon = this.polygonPool.Obtain();
                polygon.Clear();

                // Merge subsequent triangles if they form a triangle fan.
                var fanBaseIndex = -1, lastWinding = 0;
                var trianglesItems = triangles.Items;
                for (var i2 = 0, n2 = triangles.Count; i2 < n2; i2 = (i2 + 3) | 0) {
                    var t1 = trianglesItems[i2] << 1, t2 = trianglesItems[((i2 + 1) | 0)] << 1, t3 = trianglesItems[((i2 + 2) | 0)] << 1;
                    var x1 = vertices[t1], y1 = vertices[((t1 + 1) | 0)];
                    var x2 = vertices[t2], y2 = vertices[((t2 + 1) | 0)];
                    var x3 = vertices[t3], y3 = vertices[((t3 + 1) | 0)];

                    // If the base of the last triangle is the same as this triangle, check if they form a convex polygon (triangle fan).
                    var merged = false;
                    if (fanBaseIndex === t1) {
                        var o = (polygon.Count - 4) | 0;
                        var p = polygon.Items;
                        var winding1 = Spine.Triangulator.Winding(p[o], p[((o + 1) | 0)], p[((o + 2) | 0)], p[((o + 3) | 0)], x3, y3);
                        var winding2 = Spine.Triangulator.Winding(x3, y3, p[0], p[1], p[2], p[3]);
                        if (winding1 === lastWinding && winding2 === lastWinding) {
                            polygon.Add(x3);
                            polygon.Add(y3);
                            polygonIndices.Add(t3);
                            merged = true;
                        }
                    }

                    // Otherwise make this triangle the new base.
                    if (!merged) {
                        if (polygon.Count > 0) {
                            convexPolygons.Add(polygon);
                            convexPolygonsIndices.Add(polygonIndices);
                        } else {
                            this.polygonPool.Free(polygon);
                            this.polygonIndicesPool.Free(polygonIndices);
                        }
                        polygon = this.polygonPool.Obtain();
                        polygon.Clear();
                        polygon.Add(x1);
                        polygon.Add(y1);
                        polygon.Add(x2);
                        polygon.Add(y2);
                        polygon.Add(x3);
                        polygon.Add(y3);
                        polygonIndices = this.polygonIndicesPool.Obtain();
                        polygonIndices.Clear();
                        polygonIndices.Add(t1);
                        polygonIndices.Add(t2);
                        polygonIndices.Add(t3);
                        lastWinding = Spine.Triangulator.Winding(x1, y1, x2, y2, x3, y3);
                        fanBaseIndex = t1;
                    }
                }

                if (polygon.Count > 0) {
                    convexPolygons.Add(polygon);
                    convexPolygonsIndices.Add(polygonIndices);
                }

                // Go through the list of polygons and try to merge the remaining triangles with the found triangle fans.
                for (var i3 = 0, n3 = convexPolygons.Count; i3 < n3; i3 = (i3 + 1) | 0) {
                    polygonIndices = convexPolygonsIndices.Items[i3];
                    if (polygonIndices.Count === 0) {
                        continue;
                    }
                    var firstIndex = polygonIndices.Items[0];
                    var lastIndex = polygonIndices.Items[((polygonIndices.Count - 1) | 0)];

                    polygon = convexPolygons.Items[i3];
                    var o1 = (polygon.Count - 4) | 0;
                    var p1 = polygon.Items;
                    var prevPrevX = p1[o1], prevPrevY = p1[((o1 + 1) | 0)];
                    var prevX = p1[((o1 + 2) | 0)], prevY = p1[((o1 + 3) | 0)];
                    var firstX = p1[0], firstY = p1[1];
                    var secondX = p1[2], secondY = p1[3];
                    var winding = Spine.Triangulator.Winding(prevPrevX, prevPrevY, prevX, prevY, firstX, firstY);

                    for (var ii = 0; ii < n3; ii = (ii + 1) | 0) {
                        if (ii === i3) {
                            continue;
                        }
                        var otherIndices = convexPolygonsIndices.Items[ii];
                        if (otherIndices.Count !== 3) {
                            continue;
                        }
                        var otherFirstIndex = otherIndices.Items[0];
                        var otherSecondIndex = otherIndices.Items[1];
                        var otherLastIndex = otherIndices.Items[2];

                        var otherPoly = convexPolygons.Items[ii];
                        var x31 = otherPoly.Items[((otherPoly.Count - 2) | 0)], y31 = otherPoly.Items[((otherPoly.Count - 1) | 0)];

                        if (otherFirstIndex !== firstIndex || otherSecondIndex !== lastIndex) {
                            continue;
                        }
                        var winding11 = Spine.Triangulator.Winding(prevPrevX, prevPrevY, prevX, prevY, x31, y31);
                        var winding21 = Spine.Triangulator.Winding(x31, y31, firstX, firstY, secondX, secondY);
                        if (winding11 === winding && winding21 === winding) {
                            otherPoly.Clear();
                            otherIndices.Clear();
                            polygon.Add(x31);
                            polygon.Add(y31);
                            polygonIndices.Add(otherLastIndex);
                            prevPrevX = prevX;
                            prevPrevY = prevY;
                            prevX = x31;
                            prevY = y31;
                            ii = 0;
                        }
                    }
                }

                // Remove empty polygons that resulted from the merge step above.
                for (var i4 = (convexPolygons.Count - 1) | 0; i4 >= 0; i4 = (i4 - 1) | 0) {
                    polygon = convexPolygons.Items[i4];
                    if (polygon.Count === 0) {
                        convexPolygons.RemoveAt(i4);
                        this.polygonPool.Free(polygon);
                        polygonIndices = convexPolygonsIndices.Items[i4];
                        convexPolygonsIndices.RemoveAt(i4);
                        this.polygonIndicesPool.Free(polygonIndices);
                    }
                }

                return convexPolygons;
            },
            /*Spine.Triangulator.Decompose end.*/


        }
    });
    /*Spine.Triangulator end.*/

    /*Spine.Unity.ActivateBasedOnFlipDirection start.*/
    /** @namespace Spine.Unity */

    /**
     * Utility component to support flipping of 2D hinge chains (chains of HingeJoint2D objects) along
     with the parent skeleton by activating the respective mirrored versions of the hinge chain.
     Note: This component is automatically attached when calling "Create Hinge Chain 2D" at {@link },
     do not attempt to use this component for other purposes.
     *
     * @public
     * @class Spine.Unity.ActivateBasedOnFlipDirection
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.ActivateBasedOnFlipDirection", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonRenderer: null,
            skeletonGraphic: null,
            activeOnNormalX: null,
            activeOnFlippedX: null,
            jointsNormalX: null,
            jointsFlippedX: null,
            skeletonComponent: null,
            wasFlippedXBefore: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#init", this ); }

                this.wasFlippedXBefore = false;
            }
        },
        methods: {
            /*Spine.Unity.ActivateBasedOnFlipDirection.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#Start", this ); }

                this.jointsNormalX = this.activeOnNormalX.GetComponentsInChildren(UnityEngine.HingeJoint2D);
                this.jointsFlippedX = this.activeOnFlippedX.GetComponentsInChildren(UnityEngine.HingeJoint2D);
                this.skeletonComponent = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) ? Bridge.cast(this.skeletonRenderer, Spine.Unity.ISkeletonComponent) : Bridge.cast(this.skeletonGraphic, Spine.Unity.ISkeletonComponent);
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.Start end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#FixedUpdate", this ); }

                var isFlippedX = (this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.ScaleX < 0);
                if (isFlippedX !== this.wasFlippedXBefore) {
                    this.HandleFlip(isFlippedX);
                }
                this.wasFlippedXBefore = isFlippedX;
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.FixedUpdate end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.HandleFlip start.*/
            HandleFlip: function (isFlippedX) {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#HandleFlip", this ); }

                var gameObjectToActivate = isFlippedX ? this.activeOnFlippedX : this.activeOnNormalX;
                var gameObjectToDeactivate = isFlippedX ? this.activeOnNormalX : this.activeOnFlippedX;

                gameObjectToActivate.SetActive(true);
                gameObjectToDeactivate.SetActive(false);

                this.ResetJointPositions(isFlippedX ? this.jointsFlippedX : this.jointsNormalX);
                this.ResetJointPositions(isFlippedX ? this.jointsNormalX : this.jointsFlippedX);
                this.CompensateMovementAfterFlipX(gameObjectToActivate.transform, gameObjectToDeactivate.transform);
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.HandleFlip end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.ResetJointPositions start.*/
            ResetJointPositions: function (joints) {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#ResetJointPositions", this ); }

                for (var i = 0; i < joints.length; i = (i + 1) | 0) {
                    var joint = joints[i];
                    var parent = joint.connectedBody.transform;
                    joint.transform.position = parent.TransformPoint$1(UnityEngine.Vector3.FromVector2(joint.connectedAnchor));
                }
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.ResetJointPositions end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.CompensateMovementAfterFlipX start.*/
            CompensateMovementAfterFlipX: function (toActivate, toDeactivate) {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#CompensateMovementAfterFlipX", this ); }

                var targetLocation = toDeactivate.GetChild(0);
                var currentLocation = toActivate.GetChild(0);
                toActivate.position = toActivate.position.$clone().add( targetLocation.position.$clone().sub( currentLocation.position ) );
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.CompensateMovementAfterFlipX end.*/


        }
    });
    /*Spine.Unity.ActivateBasedOnFlipDirection end.*/

    /*Spine.Unity.IHasSkeletonDataAsset start.*/
    /**
     * Holds a reference to a SkeletonDataAsset.
     *
     * @abstract
     * @public
     * @class Spine.Unity.IHasSkeletonDataAsset
     */
    Bridge.define("Spine.Unity.IHasSkeletonDataAsset", {
        $kind: 3
    });
    /*Spine.Unity.IHasSkeletonDataAsset end.*/

    /*Spine.Unity.AnimationTools.TimelineExtensions start.*/
    Bridge.define("Spine.Unity.AnimationTools.TimelineExtensions", {
        statics: {
            methods: {
                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate:static start.*/
                /**
                 * Evaluates the resulting value of a TranslateTimeline at a given time.
                 SkeletonData can be accessed from Skeleton.Data or from SkeletonDataAsset.GetSkeletonData.
                 If no SkeletonData is given, values are computed relative to setup pose instead of local-absolute.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {Spine.TranslateTimeline}    timeline        
                 * @param   {number}                     time            
                 * @param   {Spine.SkeletonData}         skeletonData
                 * @return  {UnityEngine.Vector2}
                 */
                Evaluate: function (timeline, time, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#Evaluate", this ); }

                    var $t;
                    if (skeletonData === void 0) { skeletonData = null; }
                    var PREV_TIME = -3, PREV_X = -2, PREV_Y = -1;
                    var X = 1, Y = 2;

                    var frames = timeline.frames;
                    if (time < frames[0]) {
                        return pc.Vec2.ZERO.clone();
                    }

                    var x, y;
                    if (time >= frames[((frames.length - Spine.TranslateTimeline.ENTRIES) | 0)]) { // Time is after last frame.
                        x = frames[((frames.length + PREV_X) | 0)];
                        y = frames[((frames.length + PREV_Y) | 0)];
                    } else {
                        // Interpolate between the previous frame and the current frame.
                        var frame = Spine.Animation.BinarySearch$1(frames, time, Spine.TranslateTimeline.ENTRIES);
                        x = frames[((frame + PREV_X) | 0)];
                        y = frames[((frame + PREV_Y) | 0)];
                        var frameTime = frames[frame];
                        var percent = timeline.GetCurvePercent(((((Bridge.Int.div(frame, Spine.TranslateTimeline.ENTRIES)) | 0) - 1) | 0), 1 - (time - frameTime) / (frames[((frame + PREV_TIME) | 0)] - frameTime));

                        x += (frames[((frame + X) | 0)] - x) * percent;
                        y += (frames[((frame + Y) | 0)] - y) * percent;
                    }

                    var xy = new pc.Vec2( x, y );
                    if (skeletonData == null) {
                        return xy.$clone();
                    } else {
                        var boneData = ($t = skeletonData.bones.Items)[timeline.boneIndex];
                        return xy.$clone().add( new pc.Vec2( boneData.x, boneData.y ) );
                    }
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone:static start.*/
                /**
                 * Gets the translate timeline for a given boneIndex.
                 You can get the boneIndex using SkeletonData.FindBoneIndex.
                 The root bone is always boneIndex 0.
                 This will return null if a TranslateTimeline is not found.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {Spine.Animation}            a            
                 * @param   {number}                     boneIndex
                 * @return  {Spine.TranslateTimeline}
                 */
                FindTranslateTimelineForBone: function (a, boneIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#FindTranslateTimelineForBone", this ); }

                    var $t;
                    $t = Bridge.getEnumerator(a.timelines);
                    try {
                        while ($t.moveNext()) {
                            var timeline = $t.Current;
                            if ((Bridge.getType(timeline).prototype instanceof Spine.TranslateTimeline)) {
                                continue;
                            }

                            var translateTimeline = Bridge.as(timeline, Spine.TranslateTimeline);
                            if (translateTimeline != null && translateTimeline.boneIndex === boneIndex) {
                                return translateTimeline;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return null;
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone:static end.*/


            }
        }
    });
    /*Spine.Unity.AnimationTools.TimelineExtensions end.*/

    /*Spine.Unity.AtlasAssetBase start.*/
    Bridge.define("Spine.Unity.AtlasAssetBase", {
        inherits: [UnityEngine.ScriptableObject]
    });
    /*Spine.Unity.AtlasAssetBase end.*/

    /*Spine.Unity.AttachmentTools.AtlasUtilities start.*/
    Bridge.define("Spine.Unity.AttachmentTools.AtlasUtilities", {
        statics: {
            fields: {
                SpineTextureFormat: 0,
                DefaultMipmapBias: 0,
                UseMipMaps: false,
                DefaultScale: 0,
                NonrenderingRegion: 0,
                existingRegions: null,
                regionIndices: null,
                texturesToPack: null,
                originalRegions: null,
                repackedRegions: null,
                repackedAttachments: null,
                texturesToPackAtParam: null,
                CachedRegionTextures: null,
                CachedRegionTexturesList: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#init", this ); }

                    this.SpineTextureFormat = UnityEngine.TextureFormat.RGBA32;
                    this.DefaultMipmapBias = -0.5;
                    this.UseMipMaps = false;
                    this.DefaultScale = 0.01;
                    this.NonrenderingRegion = -1;
                    this.existingRegions = new (System.Collections.Generic.Dictionary$2(Spine.AtlasRegion,System.Int32)).ctor();
                    this.regionIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    this.texturesToPack = new (System.Collections.Generic.List$1(UnityEngine.Texture2D)).ctor();
                    this.originalRegions = new (System.Collections.Generic.List$1(Spine.AtlasRegion)).ctor();
                    this.repackedRegions = new (System.Collections.Generic.List$1(Spine.AtlasRegion)).ctor();
                    this.repackedAttachments = new (System.Collections.Generic.List$1(Spine.Attachment)).ctor();
                    this.texturesToPackAtParam = System.Array.init(1, null, System.Collections.Generic.List$1(UnityEngine.Texture2D));
                    this.CachedRegionTextures = new (System.Collections.Generic.Dictionary$2(Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey,UnityEngine.Texture2D)).ctor();
                    this.CachedRegionTexturesList = new (System.Collections.Generic.List$1(UnityEngine.Texture2D)).ctor();
                }
            },
            methods: {
                /*Spine.Unity.AttachmentTools.AtlasUtilities.Init:static start.*/
                Init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#Init", this ); }

                    // handle disabled domain reload
                    Spine.Unity.AttachmentTools.AtlasUtilities.ClearCache();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.Init:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$2:static start.*/
                ToAtlasRegion$2: function (t, materialPropertySource, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$2", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    return Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$3(t, materialPropertySource.shader, scale, materialPropertySource);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$2:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$3:static start.*/
                ToAtlasRegion$3: function (t, shader, scale, materialPropertySource) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$3", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    var material = new UnityEngine.Material.$ctor2(shader);
                    if (materialPropertySource != null) {
                        material.CopyPropertiesFromMaterial(materialPropertySource);
                        material.shaderKeywords = materialPropertySource.shaderKeywords;
                    }

                    material.mainTexture = t;
                    var page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material);

                    var width = t.width;
                    var height = t.height;

                    var region = new Spine.AtlasRegion();
                    region.name = t.name;
                    region.index = -1;
                    region.rotate = false;

                    // World space units
                    var boundsMin = pc.Vec2.ZERO.clone(), boundsMax = new pc.Vec2( width, height ).scale( scale );

                    // Texture space/pixel units
                    region.width = Bridge.Int.clip32(width);
                    region.originalWidth = Bridge.Int.clip32(width);
                    region.height = Bridge.Int.clip32(height);
                    region.originalHeight = Bridge.Int.clip32(height);
                    region.offsetX = width * (0.5 - Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp(boundsMin.x, boundsMax.x, 0));
                    region.offsetY = height * (0.5 - Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp(boundsMin.y, boundsMax.y, 0));

                    // Use the full area of the texture.
                    region.u = 0;
                    region.v = 1;
                    region.u2 = 1;
                    region.v2 = 0;
                    region.x = 0;
                    region.y = 0;

                    region.page = page;

                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$3:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion:static start.*/
                /**
                 * Creates a Spine.AtlasRegion from a UnityEngine.Sprite.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Sprite}    s       
                 * @param   {Spine.AtlasPage}       page
                 * @return  {Spine.AtlasRegion}
                 */
                ToAtlasRegion: function (s, page) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion", this ); }

                    if (page == null) {
                        throw new System.ArgumentNullException.$ctor3("page", "page cannot be null. AtlasPage determines which texture region belongs and how it should be rendered. You can use material.ToSpineAtlasPage() to get a shareable AtlasPage from a Material, or use the sprite.ToAtlasRegion(material) overload.");
                    }
                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4(s);
                    region.page = page;
                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$1:static start.*/
                /**
                 * Creates a Spine.AtlasRegion from a UnityEngine.Sprite. This creates a new AtlasPage object for every AtlasRegion you create. You can centralize Material control by creating a shared atlas page using Material.ToSpineAtlasPage and using the sprite.ToAtlasRegion(AtlasPage) overload.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Sprite}      s           
                 * @param   {UnityEngine.Material}    material
                 * @return  {Spine.AtlasRegion}
                 */
                ToAtlasRegion$1: function (s, material) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$1", this ); }

                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4(s);
                    region.page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material);
                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4:static start.*/
                ToAtlasRegion$4: function (s, isolatedTexture) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$4", this ); }

                    if (isolatedTexture === void 0) { isolatedTexture = false; }
                    var region = new Spine.AtlasRegion();
                    region.name = s.name;
                    region.index = -1;
                    region.rotate = s.packed && s.packingRotation !== UnityEngine.SpritePackingRotation.None;

                    // World space units
                    var bounds = s.bounds;
                    var boundsMin = UnityEngine.Vector2.FromVector3(bounds.min.$clone()), boundsMax = UnityEngine.Vector2.FromVector3(bounds.max.$clone());

                    // Texture space/pixel units
                    var spineRect = Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect(s.rect, s.texture.height);
                    region.width = Bridge.Int.clip32(spineRect.width);
                    region.originalWidth = Bridge.Int.clip32(spineRect.width);
                    region.height = Bridge.Int.clip32(spineRect.height);
                    region.originalHeight = Bridge.Int.clip32(spineRect.height);
                    region.offsetX = spineRect.width * (0.5 - Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp(boundsMin.x, boundsMax.x, 0));
                    region.offsetY = spineRect.height * (0.5 - Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp(boundsMin.y, boundsMax.y, 0));

                    if (isolatedTexture) {
                        region.u = 0;
                        region.v = 1;
                        region.u2 = 1;
                        region.v2 = 0;
                        region.x = 0;
                        region.y = 0;
                    } else {
                        var tex = s.texture;
                        var uvRect = Spine.Unity.AttachmentTools.AtlasUtilities.TextureRectToUVRect(s.textureRect.$clone(), tex.width, tex.height);
                        region.u = uvRect.xMin;
                        region.v = uvRect.yMax;
                        region.u2 = uvRect.xMax;
                        region.v2 = uvRect.yMin;
                        region.x = Bridge.Int.clip32(spineRect.x);
                        region.y = Bridge.Int.clip32(spineRect.y);
                    }

                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$2:static start.*/
                /**
                 * Creates a Spine.AtlasRegion that uses a premultiplied alpha duplicate of the Sprite's texture data.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Texture2D}        t                         
                 * @param   {UnityEngine.Material}         materialPropertySource    
                 * @param   {UnityEngine.TextureFormat}    textureFormat             
                 * @param   {boolean}                      mipmaps
                 * @return  {Spine.AtlasRegion}
                 */
                ToAtlasRegionPMAClone$2: function (t, materialPropertySource, textureFormat, mipmaps) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$2", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    return Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$3(t, materialPropertySource.shader, textureFormat, mipmaps, materialPropertySource);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$2:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$3:static start.*/
                /**
                 * Creates a Spine.AtlasRegion that uses a premultiplied alpha duplicate of the Sprite's texture data.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Texture2D}        t                         
                 * @param   {UnityEngine.Shader}           shader                    
                 * @param   {UnityEngine.TextureFormat}    textureFormat             
                 * @param   {boolean}                      mipmaps                   
                 * @param   {UnityEngine.Material}         materialPropertySource
                 * @return  {Spine.AtlasRegion}
                 */
                ToAtlasRegionPMAClone$3: function (t, shader, textureFormat, mipmaps, materialPropertySource) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$3", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    var material = new UnityEngine.Material.$ctor2(shader);
                    if (materialPropertySource != null) {
                        material.CopyPropertiesFromMaterial(materialPropertySource);
                        material.shaderKeywords = materialPropertySource.shaderKeywords;
                    }
                    var newTexture = Spine.Unity.AttachmentTools.AtlasUtilities.GetClone(t, textureFormat, mipmaps, false, true);

                    newTexture.name = (t.name || "") + "-pma-";
                    material.name = (t.name || "") + (shader.name || "");

                    material.mainTexture = newTexture;
                    var page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material);

                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$3(newTexture, shader);
                    region.page = page;

                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$3:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone:static start.*/
                ToAtlasRegionPMAClone: function (s, materialPropertySource, textureFormat, mipmaps) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    return Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$1(s, materialPropertySource.shader, textureFormat, mipmaps, materialPropertySource);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$1:static start.*/
                /**
                 * Creates a Spine.AtlasRegion that uses a premultiplied alpha duplicate of the Sprite's texture data.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Sprite}           s                         
                 * @param   {UnityEngine.Shader}           shader                    
                 * @param   {UnityEngine.TextureFormat}    textureFormat             
                 * @param   {boolean}                      mipmaps                   
                 * @param   {UnityEngine.Material}         materialPropertySource
                 * @return  {Spine.AtlasRegion}
                 */
                ToAtlasRegionPMAClone$1: function (s, shader, textureFormat, mipmaps, materialPropertySource) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$1", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    var material = new UnityEngine.Material.$ctor2(shader);
                    if (materialPropertySource != null) {
                        material.CopyPropertiesFromMaterial(materialPropertySource);
                        material.shaderKeywords = materialPropertySource.shaderKeywords;
                    }

                    var tex = Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture$1(s, textureFormat, mipmaps, false, true);
                    tex.name = (s.name || "") + "-pma-";
                    material.name = (tex.name || "") + (shader.name || "");

                    material.mainTexture = tex;
                    var page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material);

                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4(s, true);
                    region.page = page;

                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage:static start.*/
                /**
                 * Creates a new Spine.AtlasPage from a UnityEngine.Material. If the material has a preassigned texture, the page width and height will be set.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Material}    m
                 * @return  {Spine.AtlasPage}
                 */
                ToSpineAtlasPage: function (m) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToSpineAtlasPage", this ); }

                    var $t;
                    var newPage = ($t = new Spine.AtlasPage(), $t.rendererObject = m, $t.name = m.name, $t);

                    var t = m.mainTexture;
                    if (t != null) {
                        newPage.width = t.width;
                        newPage.height = t.height;
                    }

                    return newPage;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments:static start.*/
                /**
                 * Fills the outputAttachments list with new attachment objects based on the attachments in sourceAttachments,
                 but mapped to a new single texture using the same material.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {System.Collections.Generic.List$1}    sourceAttachments            The list of attachments to be repacked.
                 * @param   {System.Collections.Generic.List$1}    outputAttachments            The List(Attachment) to populate with the newly created Attachment objects.
                 * @param   {UnityEngine.Material}                 materialPropertySource       May be null. If no Material property source is provided, no special
                 * @param   {UnityEngine.Material}                 outputMaterial               
                 * @param   {UnityEngine.Texture2D}                outputTexture                
                 * @param   {number}                               maxAtlasSize                 
                 * @param   {number}                               padding                      
                 * @param   {UnityEngine.TextureFormat}            textureFormat                
                 * @param   {boolean}                              mipmaps                      
                 * @param   {string}                               newAssetName                 
                 * @param   {boolean}                              clearCache                   When set to <pre><code>true</code></pre>, {@link } is called after
                 repacking to clear the texture cache. See remarks for additional info.
                 * @param   {boolean}                              useOriginalNonrenderables
                 * @return  {void}
                 */
                GetRepackedAttachments: function (sourceAttachments, outputAttachments, materialPropertySource, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, newAssetName, clearCache, useOriginalNonrenderables) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedAttachments", this ); }

                    if (maxAtlasSize === void 0) { maxAtlasSize = 1024; }
                    if (padding === void 0) { padding = 2; }
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (newAssetName === void 0) { newAssetName = "Repacked Attachments"; }
                    if (clearCache === void 0) { clearCache = false; }
                    if (useOriginalNonrenderables === void 0) { useOriginalNonrenderables = true; }
                    if (sourceAttachments == null) {
                        throw new System.ArgumentNullException.$ctor1("sourceAttachments");
                    }
                    if (outputAttachments == null) {
                        throw new System.ArgumentNullException.$ctor1("outputAttachments");
                    }

                    // Use shared lists to detect and use shared regions.
                    Spine.Unity.AttachmentTools.AtlasUtilities.existingRegions.clear();
                    Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.clear();
                    Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPack.clear();
                    Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.clear();

                    outputAttachments.clear();
                    outputAttachments.AddRange(sourceAttachments);

                    var newRegionIndex = 0;
                    for (var i = 0, n = sourceAttachments.Count; i < n; i = (i + 1) | 0) {
                        var originalAttachment = sourceAttachments.getItem(i);

                        if (Spine.Unity.AttachmentTools.AtlasUtilities.IsRenderable(originalAttachment)) {
                            var newAttachment = Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetCopy(originalAttachment, true);
                            var region = Spine.Unity.AttachmentTools.AttachmentRegionExtensions.GetRegion(newAttachment);
                            var existingIndex = { };
                            if (Spine.Unity.AttachmentTools.AtlasUtilities.existingRegions.tryGetValue(region, existingIndex)) {
                                Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.add(existingIndex.v); // Store the region index for the eventual new attachment.
                            } else {
                                Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.add(region);
                                Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPack.add(Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture(region, textureFormat, mipmaps)); // Add the texture to the PackTextures argument
                                Spine.Unity.AttachmentTools.AtlasUtilities.existingRegions.add(region, newRegionIndex); // Add the region to the dictionary of known regions
                                Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.add(newRegionIndex); // Store the region index for the eventual new attachment.
                                newRegionIndex = (newRegionIndex + 1) | 0;
                            }

                            outputAttachments.setItem(i, newAttachment);
                        } else {
                            outputAttachments.setItem(i, useOriginalNonrenderables ? originalAttachment : Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetCopy(originalAttachment, true));
                            Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.add(Spine.Unity.AttachmentTools.AtlasUtilities.NonrenderingRegion); // Output attachments pairs with regionIndexes list 1:1. Pad with a sentinel if the attachment doesn't have a region.
                        }
                    }

                    // Fill a new texture with the collected attachment textures.
                    var newTexture = new UnityEngine.Texture2D.$ctor2(maxAtlasSize, maxAtlasSize, textureFormat, mipmaps);
                    newTexture.mipMapBias = Spine.Unity.AttachmentTools.AtlasUtilities.DefaultMipmapBias;
                    newTexture.name = newAssetName;
                    // Copy settings
                    if (Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPack.Count > 0) {
                        var sourceTexture = Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPack.getItem(0);
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom(newTexture, sourceTexture);
                    }
                    var rects = newTexture.PackTextures(Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPack.ToArray(), padding, maxAtlasSize);

                    // Rehydrate the repacked textures as a Material, Spine atlas and Spine.AtlasAttachments
                    var shader = materialPropertySource == null ? UnityEngine.Shader.Find("Spine/Skeleton") : materialPropertySource.shader;
                    var newMaterial = new UnityEngine.Material.$ctor2(shader);
                    if (materialPropertySource != null) {
                        newMaterial.CopyPropertiesFromMaterial(materialPropertySource);
                        newMaterial.shaderKeywords = materialPropertySource.shaderKeywords;
                    }

                    newMaterial.name = newAssetName;
                    newMaterial.mainTexture = newTexture;
                    var page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(newMaterial);
                    page.name = newAssetName;

                    Spine.Unity.AttachmentTools.AtlasUtilities.repackedRegions.clear();
                    for (var i1 = 0, n1 = Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.Count; i1 < n1; i1 = (i1 + 1) | 0) {
                        var oldRegion = Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.getItem(i1);
                        var newRegion = Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToAtlasRegion(rects[i1].$clone(), oldRegion, page);
                        Spine.Unity.AttachmentTools.AtlasUtilities.repackedRegions.add(newRegion);
                    }

                    // Map the cloned attachments to the repacked atlas.
                    for (var i2 = 0, n2 = outputAttachments.Count; i2 < n2; i2 = (i2 + 1) | 0) {
                        var a = outputAttachments.getItem(i2);
                        if (Spine.Unity.AttachmentTools.AtlasUtilities.IsRenderable(a)) {
                            Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRegion(a, Spine.Unity.AttachmentTools.AtlasUtilities.repackedRegions.getItem(Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.getItem(i2)));
                        }
                    }

                    // Clean up.
                    if (clearCache) {
                        Spine.Unity.AttachmentTools.AtlasUtilities.ClearCache();
                    }

                    outputTexture.v = newTexture;
                    outputMaterial.v = newMaterial;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin:static start.*/
                /**
                 * Creates and populates a duplicate skin with cloned attachments that are backed by a new packed texture atlas
                 comprised of all the regions from the original skin.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.Skin}                           o                                     
                 * @param   {string}                               newName                               
                 * @param   {UnityEngine.Material}                 materialPropertySource                
                 * @param   {UnityEngine.Material}                 outputMaterial                        
                 * @param   {UnityEngine.Texture2D}                outputTexture                         
                 * @param   {number}                               maxAtlasSize                          
                 * @param   {number}                               padding                               
                 * @param   {UnityEngine.TextureFormat}            textureFormat                         
                 * @param   {boolean}                              mipmaps                               
                 * @param   {boolean}                              useOriginalNonrenderables             
                 * @param   {boolean}                              clearCache                            When set to <pre><code>true</code></pre>, {@link } is called after
                 repacking to clear the texture cache. See remarks for additional info.
                 * @param   {Array.<number>}                       additionalTexturePropertyIDsToCopy    Optional additional textures (such as normal maps) to copy while repacking.
                 To copy e.g. the main texture and normal maps, pass 'new int[] { Shader.PropertyToID("_BumpMap") }' at this parameter.
                 * @param   {Array.<UnityEngine.Texture2D>}        additionalOutputTextures              When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be filled with the resulting repacked texture for every property,
                 just as the main repacked texture is assigned to <pre><code>outputTexture</code></pre>.
                 * @param   {Array.<UnityEngine.TextureFormat>}    additionalTextureFormats              When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be used as <pre><code>TextureFormat</code></pre> at the Texture at the respective property.
                 When <pre><code>additionalTextureFormats</code></pre> is <pre><code>null</code></pre> or when its array size is smaller,
                 <pre><code>textureFormat</code></pre> is used where there exists no corresponding array item.
                 * @param   {Array.<boolean>}                      additionalTextureIsLinear             When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be used to determine whether <pre><code>linear</code></pre> or <pre><code>sRGB</code></pre> color space is used at the
                 Texture at the respective property. When <pre><code>additionalTextureIsLinear</code></pre> is <pre><code>null</code></pre>, <pre><code>linear</code></pre> color space
                 is assumed at every additional Texture element.
                 When e.g. packing the main texture and normal maps, pass 'new bool[] { true }' at this parameter, because normal maps use
                 linear color space.
                 * @return  {Spine.Skin}
                 */
                GetRepackedSkin: function (o, newName, materialPropertySource, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, useOriginalNonrenderables, clearCache, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedSkin", this ); }

                    if (maxAtlasSize === void 0) { maxAtlasSize = 1024; }
                    if (padding === void 0) { padding = 2; }
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (useOriginalNonrenderables === void 0) { useOriginalNonrenderables = true; }
                    if (clearCache === void 0) { clearCache = false; }
                    if (additionalTexturePropertyIDsToCopy === void 0) { additionalTexturePropertyIDsToCopy = null; }
                    if (additionalOutputTextures === void 0) { additionalOutputTextures = null; }
                    if (additionalTextureFormats === void 0) { additionalTextureFormats = null; }
                    if (additionalTextureIsLinear === void 0) { additionalTextureIsLinear = null; }

                    return Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin$1(o, newName, materialPropertySource.shader, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, materialPropertySource, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin$1:static start.*/
                /**
                 * Creates and populates a duplicate skin with cloned attachments that are backed by a new packed texture atlas
                 comprised of all the regions from the original skin.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.Skin}                           o                                     
                 * @param   {string}                               newName                               
                 * @param   {UnityEngine.Shader}                   shader                                
                 * @param   {UnityEngine.Material}                 outputMaterial                        
                 * @param   {UnityEngine.Texture2D}                outputTexture                         
                 * @param   {number}                               maxAtlasSize                          
                 * @param   {number}                               padding                               
                 * @param   {UnityEngine.TextureFormat}            textureFormat                         
                 * @param   {boolean}                              mipmaps                               
                 * @param   {UnityEngine.Material}                 materialPropertySource                
                 * @param   {boolean}                              clearCache                            
                 * @param   {boolean}                              useOriginalNonrenderables             
                 * @param   {Array.<number>}                       additionalTexturePropertyIDsToCopy    
                 * @param   {Array.<UnityEngine.Texture2D>}        additionalOutputTextures              
                 * @param   {Array.<UnityEngine.TextureFormat>}    additionalTextureFormats              
                 * @param   {Array.<boolean>}                      additionalTextureIsLinear
                 * @return  {Spine.Skin}
                 */
                GetRepackedSkin$1: function (o, newName, shader, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, materialPropertySource, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedSkin$1", this ); }

                    var $t;
                    if (maxAtlasSize === void 0) { maxAtlasSize = 1024; }
                    if (padding === void 0) { padding = 2; }
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    if (clearCache === void 0) { clearCache = false; }
                    if (useOriginalNonrenderables === void 0) { useOriginalNonrenderables = true; }
                    if (additionalTexturePropertyIDsToCopy === void 0) { additionalTexturePropertyIDsToCopy = null; }
                    if (additionalOutputTextures === void 0) { additionalOutputTextures = null; }
                    if (additionalTextureFormats === void 0) { additionalTextureFormats = null; }
                    if (additionalTextureIsLinear === void 0) { additionalTextureIsLinear = null; }

                    outputTexture.v = null;
                    if (additionalTexturePropertyIDsToCopy != null && additionalTextureIsLinear == null) {
                        additionalTextureIsLinear = System.Array.init(additionalTexturePropertyIDsToCopy.length, false, System.Boolean);
                        for (var i = 0; i < additionalTextureIsLinear.length; i = (i + 1) | 0) {
                            additionalTextureIsLinear[i] = true;
                        }
                    }

                    if (o == null) {
                        throw new System.NullReferenceException.$ctor1("Skin was null");
                    }
                    var skinAttachments = o.Attachments;
                    var newSkin = new Spine.Skin(newName);

                    newSkin.bones.AddRange(o.bones);
                    newSkin.constraints.AddRange(o.constraints);

                    // Use these to detect and use shared regions.
                    Spine.Unity.AttachmentTools.AtlasUtilities.existingRegions.clear();
                    Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.clear();

                    // Collect all textures from the attachments of the original skin.
                    Spine.Unity.AttachmentTools.AtlasUtilities.repackedAttachments.clear();
                    var numTextureParamsToRepack = (1 + (additionalTexturePropertyIDsToCopy == null ? 0 : additionalTexturePropertyIDsToCopy.length)) | 0;
                    additionalOutputTextures = (additionalTexturePropertyIDsToCopy == null ? null : System.Array.init(additionalTexturePropertyIDsToCopy.length, null, UnityEngine.Texture2D));
                    if (Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam.length < numTextureParamsToRepack) {
                        System.Array.resize(Bridge.ref(Spine.Unity.AttachmentTools.AtlasUtilities, "texturesToPackAtParam"), numTextureParamsToRepack, null, System.Collections.Generic.List$1(UnityEngine.Texture2D));
                    }
                    for (var i1 = 0; i1 < numTextureParamsToRepack; i1 = (i1 + 1) | 0) {
                        if (Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[i1] != null) {
                            Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[i1].clear();
                        } else {
                            Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[i1] = new (System.Collections.Generic.List$1(UnityEngine.Texture2D)).ctor();
                        }
                    }
                    Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.clear();
                    var newRegionIndex = 0;

                    $t = Bridge.getEnumerator(skinAttachments);
                    try {
                        while ($t.moveNext()) {
                            var skinEntry = $t.Current;
                            var originalKey = skinEntry.key;
                            var originalAttachment = skinEntry.value;

                            var newAttachment;
                            if (Spine.Unity.AttachmentTools.AtlasUtilities.IsRenderable(originalAttachment)) {
                                newAttachment = Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetCopy(originalAttachment, true);
                                var region = Spine.Unity.AttachmentTools.AttachmentRegionExtensions.GetRegion(newAttachment);
                                var existingIndex = { };
                                if (Spine.Unity.AttachmentTools.AtlasUtilities.existingRegions.tryGetValue(region, existingIndex)) {
                                    Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.add(existingIndex.v); // Store the region index for the eventual new attachment.
                                } else {
                                    Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.add(region);
                                    for (var i2 = 0; i2 < numTextureParamsToRepack; i2 = (i2 + 1) | 0) {
                                        var regionTexture = (i2 === 0 ? Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture(region, textureFormat, mipmaps) : Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture(region, (additionalTextureFormats != null && ((i2 - 1) | 0) < additionalTextureFormats.length) ? additionalTextureFormats[((i2 - 1) | 0)] : textureFormat, mipmaps, additionalTexturePropertyIDsToCopy[((i2 - 1) | 0)], additionalTextureIsLinear[((i2 - 1) | 0)]));
                                        Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[i2].add(regionTexture); // Add the texture to the PackTextures argument
                                    }
                                    Spine.Unity.AttachmentTools.AtlasUtilities.existingRegions.add(region, newRegionIndex); // Add the region to the dictionary of known regions
                                    Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.add(newRegionIndex); // Store the region index for the eventual new attachment.
                                    newRegionIndex = (newRegionIndex + 1) | 0;
                                }

                                Spine.Unity.AttachmentTools.AtlasUtilities.repackedAttachments.add(newAttachment);
                                newSkin.SetAttachment(originalKey.SlotIndex, originalKey.Name, newAttachment);
                            } else {
                                newSkin.SetAttachment(originalKey.SlotIndex, originalKey.Name, useOriginalNonrenderables ? originalAttachment : Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetCopy(originalAttachment, true));
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    // Rehydrate the repacked textures as a Material, Spine atlas and Spine.AtlasAttachments
                    var newMaterial = new UnityEngine.Material.$ctor2(shader);
                    if (materialPropertySource != null) {
                        newMaterial.CopyPropertiesFromMaterial(materialPropertySource);
                        newMaterial.shaderKeywords = materialPropertySource.shaderKeywords;
                    }
                    newMaterial.name = newName;

                    var rects = null;
                    for (var i3 = 0; i3 < numTextureParamsToRepack; i3 = (i3 + 1) | 0) {
                        // Fill a new texture with the collected attachment textures.
                        var newTexture = new UnityEngine.Texture2D.$ctor2(maxAtlasSize, maxAtlasSize, (i3 > 0 && additionalTextureFormats != null && ((i3 - 1) | 0) < additionalTextureFormats.length) ? additionalTextureFormats[((i3 - 1) | 0)] : textureFormat, mipmaps, (i3 > 0) ? additionalTextureIsLinear[((i3 - 1) | 0)] : false);
                        newTexture.mipMapBias = Spine.Unity.AttachmentTools.AtlasUtilities.DefaultMipmapBias;
                        var texturesToPack = Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[i3];
                        if (texturesToPack.Count > 0) {
                            var sourceTexture = texturesToPack.getItem(0);
                            Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom(newTexture, sourceTexture);
                        }
                        newTexture.name = newName;
                        var rectsForTexParam = newTexture.PackTextures(texturesToPack.ToArray(), padding, maxAtlasSize);
                        if (i3 === 0) {
                            rects = rectsForTexParam;
                            newMaterial.mainTexture = newTexture;
                            outputTexture.v = newTexture;
                        } else {
                            newMaterial.SetTexture(additionalTexturePropertyIDsToCopy[((i3 - 1) | 0)], newTexture);
                            additionalOutputTextures[((i3 - 1) | 0)] = newTexture;
                        }
                    }

                    var page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(newMaterial);
                    page.name = newName;

                    Spine.Unity.AttachmentTools.AtlasUtilities.repackedRegions.clear();
                    for (var i4 = 0, n = Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.Count; i4 < n; i4 = (i4 + 1) | 0) {
                        var oldRegion = Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.getItem(i4);
                        var newRegion = Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToAtlasRegion(rects[i4].$clone(), oldRegion, page);
                        Spine.Unity.AttachmentTools.AtlasUtilities.repackedRegions.add(newRegion);
                    }

                    // Map the cloned attachments to the repacked atlas.
                    for (var i5 = 0, n1 = Spine.Unity.AttachmentTools.AtlasUtilities.repackedAttachments.Count; i5 < n1; i5 = (i5 + 1) | 0) {
                        var a = Spine.Unity.AttachmentTools.AtlasUtilities.repackedAttachments.getItem(i5);
                        if (Spine.Unity.AttachmentTools.AtlasUtilities.IsRenderable(a)) {
                            Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRegion(a, Spine.Unity.AttachmentTools.AtlasUtilities.repackedRegions.getItem(Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.getItem(i5)));
                        }
                    }

                    // Clean up.
                    if (clearCache) {
                        Spine.Unity.AttachmentTools.AtlasUtilities.ClearCache();
                    }

                    outputMaterial.v = newMaterial;
                    return newSkin;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToSprite:static start.*/
                ToSprite: function (ar, pixelsPerUnit) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToSprite", this ); }

                    if (pixelsPerUnit === void 0) { pixelsPerUnit = 100.0; }
                    return UnityEngine.Sprite.Create$1(Spine.Unity.AttachmentTools.AtlasUtilities.GetMainTexture(ar), Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect(ar), new pc.Vec2( 0.5, 0.5 ), pixelsPerUnit);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToSprite:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ClearCache:static start.*/
                /**
                 * Frees up textures cached by repacking and remapping operations.
                 Calling {@link } with parameter <pre><code>premultiplyAlpha=true</code></pre>,
                 {@link } or {@link } will cache textures for later re-use,
                	which might steadily increase the texture memory footprint when used excessively.
                	You can clear this Texture cache by calling {@link }.
                 You may also want to call <pre><code>Resources.UnloadUnusedAssets()</code></pre> after that. Be aware that while this cleanup
                 frees up memory, it is also a costly operation and will likely cause a spike in the framerate.
                 Thus it is recommended to perform costly repacking and cleanup operations after e.g. a character customization
                 screen has been exited, and if required additionally after a certain number of <pre><code>GetRemappedClone()</code></pre> calls.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @return  {void}
                 */
                ClearCache: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ClearCache", this ); }

                    var $t;
                    $t = Bridge.getEnumerator(Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTexturesList);
                    try {
                        while ($t.moveNext()) {
                            var t = $t.Current;
                            UnityEngine.Object.Destroy(t);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTextures.clear();
                    Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTexturesList.clear();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ClearCache:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture:static start.*/
                /**
                 * Creates a new Texture2D object based on an AtlasRegion.
                 If applyImmediately is true, Texture2D.Apply is called immediately after the Texture2D is filled with data.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}            ar                   
                 * @param   {UnityEngine.TextureFormat}    textureFormat        
                 * @param   {boolean}                      mipmaps              
                 * @param   {number}                       texturePropertyId    
                 * @param   {boolean}                      linear               
                 * @param   {boolean}                      applyPMA
                 * @return  {UnityEngine.Texture2D}
                 */
                ToTexture: function (ar, textureFormat, mipmaps, texturePropertyId, linear, applyPMA) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToTexture", this ); }

                    var $t, $t1, $t2;
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (texturePropertyId === void 0) { texturePropertyId = 0; }
                    if (linear === void 0) { linear = false; }
                    if (applyPMA === void 0) { applyPMA = false; }

                    var output = { };

                    var cacheKey = new Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey.$ctor1(texturePropertyId, ar);
                    Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTextures.tryGetValue(cacheKey.$clone(), output);
                    if (output.v == null) {
                        var sourceTexture = texturePropertyId === 0 ? Spine.Unity.AttachmentTools.AtlasUtilities.GetMainTexture(ar) : Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture(ar, texturePropertyId);
                        var r = Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect(ar);
                        // Compensate any image resizing due to Texture 'Max Size' import settings.
                        // sourceTexture.width returns the resized image dimensions, at least in newer Unity versions.
                        if (sourceTexture.width < ar.page.width) {
                            var scaleX = (sourceTexture.width) / (ar.page.width);
                            var scaleY = (sourceTexture.height) / (ar.page.height);
                            var scale = new pc.Vec2( scaleX, scaleY );
                            r = new UnityEngine.Rect.$ctor3(($t = r.position, new pc.Vec2( $t.x * scale.x, $t.y * scale.y )), ($t1 = r.size, new pc.Vec2( $t1.x * scale.x, $t1.y * scale.y )));
                        }

                        var width = Bridge.Int.clip32(r.width);
                        var height = Bridge.Int.clip32(r.height);
                        output.v = ($t2 = new UnityEngine.Texture2D.$ctor2(width, height, textureFormat, mipmaps, linear), $t2.name = ar.name, $t2);
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom(output.v, sourceTexture);
                        if (applyPMA) {
                            Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA(sourceTexture, r.$clone(), output.v);
                        } else {
                            Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture(sourceTexture, r.$clone(), output.v);
                        }
                        Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTextures.add(cacheKey.$clone(), output.v);
                        Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTexturesList.add(output.v);
                    }

                    return output.v;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture$1:static start.*/
                ToTexture$1: function (s, textureFormat, mipmaps, linear, applyPMA) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToTexture$1", this ); }

                    var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7;
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (linear === void 0) { linear = false; }
                    if (applyPMA === void 0) { applyPMA = false; }

                    var spriteTexture = s.texture;
                    var r = new UnityEngine.Rect();
                    if (!s.packed || s.packingMode === UnityEngine.SpritePackingMode.Rectangle) {
                        r = s.textureRect.$clone();
                    } else {
                        r = new UnityEngine.Rect.ctor();
                        r.xMin = Math.min(($t = s.uv)[0].x, ($t1 = s.uv)[1].x) * spriteTexture.width;
                        r.xMax = Math.max(($t2 = s.uv)[0].x, ($t3 = s.uv)[1].x) * spriteTexture.width;
                        r.yMin = Math.min(($t4 = s.uv)[0].y, ($t5 = s.uv)[2].y) * spriteTexture.height;
                        r.yMax = Math.max(($t6 = s.uv)[0].y, ($t7 = s.uv)[2].y) * spriteTexture.height;
                    }
                    var newTexture = new UnityEngine.Texture2D.$ctor2(Bridge.Int.clip32(r.width), Bridge.Int.clip32(r.height), textureFormat, mipmaps, linear);
                    Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom(newTexture, spriteTexture);
                    if (applyPMA) {
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA(spriteTexture, r.$clone(), newTexture);
                    } else {
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture(spriteTexture, r.$clone(), newTexture);
                    }
                    return newTexture;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetClone:static start.*/
                GetClone: function (t, textureFormat, mipmaps, linear, applyPMA) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetClone", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (linear === void 0) { linear = false; }
                    if (applyPMA === void 0) { applyPMA = false; }

                    var newTexture = new UnityEngine.Texture2D.$ctor2(t.width, t.height, textureFormat, mipmaps, linear);
                    Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom(newTexture, t);
                    if (applyPMA) {
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA(t, new UnityEngine.Rect.$ctor1(0, 0, t.width, t.height), newTexture);
                    } else {
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture(t, new UnityEngine.Rect.$ctor1(0, 0, t.width, t.height), newTexture);
                    }
                    return newTexture;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetClone:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture:static start.*/
                CopyTexture: function (source, sourceRect, destination) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#CopyTexture", this ); }

                    if (UnityEngine.SystemInfo.copyTextureSupport === UnityEngine.Rendering.CopyTextureSupport.None) {
                        // GetPixels fallback for old devices.
                        var pixelBuffer = source.GetPixels$2(Bridge.Int.clip32(sourceRect.x), Bridge.Int.clip32(sourceRect.y), Bridge.Int.clip32(sourceRect.width), Bridge.Int.clip32(sourceRect.height));
                        destination.SetPixels$1(pixelBuffer);
                        destination.Apply();
                    } else {
                        UnityEngine.Graphics.CopyTexture(source, 0, 0, Bridge.Int.clip32(sourceRect.x), Bridge.Int.clip32(sourceRect.y), Bridge.Int.clip32(sourceRect.width), Bridge.Int.clip32(sourceRect.height), destination, 0, 0, 0, 0);
                    }
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA:static start.*/
                CopyTextureApplyPMA: function (source, sourceRect, destination) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#CopyTextureApplyPMA", this ); }

                    var pixelBuffer = source.GetPixels$2(Bridge.Int.clip32(sourceRect.x), Bridge.Int.clip32(sourceRect.y), Bridge.Int.clip32(sourceRect.width), Bridge.Int.clip32(sourceRect.height));
                    for (var i = 0, n = pixelBuffer.length; i < n; i = (i + 1) | 0) {
                        var p = pixelBuffer[i].$clone();
                        var a = p.a;
                        p.r = p.r * a;
                        p.g = p.g * a;
                        p.b = p.b * a;
                        pixelBuffer[i] = p.$clone();
                    }
                    destination.SetPixels$1(pixelBuffer);
                    destination.Apply();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.IsRenderable:static start.*/
                IsRenderable: function (a) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#IsRenderable", this ); }

                    return Bridge.is(a, Spine.IHasRendererObject);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.IsRenderable:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect:static start.*/
                /**
                 * Get a rect with flipped Y so that a Spine atlas rect gets converted to a Unity Sprite rect and vice versa.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Rect}    rect             
                 * @param   {number}              textureHeight
                 * @return  {UnityEngine.Rect}
                 */
                SpineUnityFlipRect: function (rect, textureHeight) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#SpineUnityFlipRect", this ); }

                    rect.y = textureHeight - rect.y - rect.height;
                    return rect.$clone();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect:static start.*/
                /**
                 * Gets the Rect of an AtlasRegion according to Unity texture coordinates (x-right, y-up).
                 This overload relies on region.page.height being correctly set.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}    region
                 * @return  {UnityEngine.Rect}
                 */
                GetUnityRect: function (region) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetUnityRect", this ); }

                    return Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect(Spine.Unity.AttachmentTools.AtlasUtilities.GetSpineAtlasRect(region), region.page.height);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect$1:static start.*/
                /**
                 * Gets the Rect of an AtlasRegion according to Unity texture coordinates (x-right, y-up).
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}    region           
                 * @param   {number}               textureHeight
                 * @return  {UnityEngine.Rect}
                 */
                GetUnityRect$1: function (region, textureHeight) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetUnityRect$1", this ); }

                    return Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect(Spine.Unity.AttachmentTools.AtlasUtilities.GetSpineAtlasRect(region), textureHeight);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetSpineAtlasRect:static start.*/
                /**
                 * Returns a Rect of the AtlasRegion according to Spine texture coordinates. (x-right, y-down)
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}    region           
                 * @param   {boolean}              includeRotate
                 * @return  {UnityEngine.Rect}
                 */
                GetSpineAtlasRect: function (region, includeRotate) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetSpineAtlasRect", this ); }

                    if (includeRotate === void 0) { includeRotate = true; }
                    if (includeRotate && (region.degrees === 90 || region.degrees === 270)) {
                        return new UnityEngine.Rect.$ctor1(region.x, region.y, region.height, region.width);
                    } else {
                        return new UnityEngine.Rect.$ctor1(region.x, region.y, region.width, region.height);
                    }
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetSpineAtlasRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToTextureRect:static start.*/
                /**
                 * Denormalize a uvRect into a texture-space Rect.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Rect}    uvRect       
                 * @param   {number}              texWidth     
                 * @param   {number}              texHeight
                 * @return  {UnityEngine.Rect}
                 */
                UVRectToTextureRect: function (uvRect, texWidth, texHeight) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#UVRectToTextureRect", this ); }

                    uvRect.x *= texWidth;
                    uvRect.width *= texWidth;
                    uvRect.y *= texHeight;
                    uvRect.height *= texHeight;
                    return uvRect.$clone();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToTextureRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.TextureRectToUVRect:static start.*/
                /**
                 * Normalize a texture Rect into UV coordinates.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Rect}    textureRect    
                 * @param   {number}              texWidth       
                 * @param   {number}              texHeight
                 * @return  {UnityEngine.Rect}
                 */
                TextureRectToUVRect: function (textureRect, texWidth, texHeight) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#TextureRectToUVRect", this ); }

                    textureRect.x = pc.math.inverseLerp(0, texWidth, textureRect.x);
                    textureRect.y = pc.math.inverseLerp(0, texHeight, textureRect.y);
                    textureRect.width = pc.math.inverseLerp(0, texWidth, textureRect.width);
                    textureRect.height = pc.math.inverseLerp(0, texHeight, textureRect.height);
                    return textureRect.$clone();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.TextureRectToUVRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToAtlasRegion:static start.*/
                /**
                 * Creates a new Spine AtlasRegion according to a Unity UV Rect (x-right, y-up, uv-normalized).
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Rect}     uvRect             
                 * @param   {Spine.AtlasRegion}    referenceRegion    
                 * @param   {Spine.AtlasPage}      page
                 * @return  {Spine.AtlasRegion}
                 */
                UVRectToAtlasRegion: function (uvRect, referenceRegion, page) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#UVRectToAtlasRegion", this ); }

                    var $t;
                    var tr = Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToTextureRect(uvRect.$clone(), page.width, page.height);
                    var rr = Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect(tr, page.height);

                    var x = Bridge.Int.clip32(rr.x), y = Bridge.Int.clip32(rr.y);
                    var w, h;
                    if (referenceRegion.degrees === 90 || referenceRegion.degrees === 270) {
                        w = Bridge.Int.clip32(rr.height);
                        h = Bridge.Int.clip32(rr.width);
                    } else {
                        w = Bridge.Int.clip32(rr.width);
                        h = Bridge.Int.clip32(rr.height);
                    }

                    var originalW = Math.round(w * (referenceRegion.originalWidth / referenceRegion.width));
                    var originalH = Math.round(h * (referenceRegion.originalHeight / referenceRegion.height));
                    var offsetX = Math.round(referenceRegion.offsetX * (w / referenceRegion.width));
                    var offsetY = Math.round(referenceRegion.offsetY * (h / referenceRegion.height));

                    if (referenceRegion.degrees === 270) {
                        w = Bridge.Int.clip32(rr.width);
                        h = Bridge.Int.clip32(rr.height);
                    }

                    var u = uvRect.xMin;
                    var u2 = uvRect.xMax;
                    var v = uvRect.yMax;
                    var v2 = uvRect.yMin;

                    return ($t = new Spine.AtlasRegion(), $t.page = page, $t.name = referenceRegion.name, $t.u = u, $t.u2 = u2, $t.v = v, $t.v2 = v2, $t.index = -1, $t.width = w, $t.originalWidth = originalW, $t.height = h, $t.originalHeight = originalH, $t.offsetX = offsetX, $t.offsetY = offsetY, $t.x = x, $t.y = y, $t.rotate = referenceRegion.rotate, $t.degrees = referenceRegion.degrees, $t);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToAtlasRegion:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetMainTexture:static start.*/
                /**
                 * Convenience method for getting the main texture of the material of the page of the region.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}        region
                 * @return  {UnityEngine.Texture2D}
                 */
                GetMainTexture: function (region) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetMainTexture", this ); }

                    var material = (Bridge.as(region.page.rendererObject, UnityEngine.Material));
                    return Bridge.as(material.mainTexture, UnityEngine.Texture2D);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetMainTexture:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture$1:static start.*/
                /**
                 * Convenience method for getting any texture of the material of the page of the region by texture property name.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}        region                 
                 * @param   {string}                   texturePropertyName
                 * @return  {UnityEngine.Texture2D}
                 */
                GetTexture$1: function (region, texturePropertyName) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetTexture$1", this ); }

                    var material = (Bridge.as(region.page.rendererObject, UnityEngine.Material));
                    return Bridge.as(material.GetTexture$1(texturePropertyName), UnityEngine.Texture2D);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture:static start.*/
                /**
                 * Convenience method for getting any texture of the material of the page of the region by texture property id.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}        region               
                 * @param   {number}                   texturePropertyId
                 * @return  {UnityEngine.Texture2D}
                 */
                GetTexture: function (region, texturePropertyId) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetTexture", this ); }

                    var material = (Bridge.as(region.page.rendererObject, UnityEngine.Material));
                    return Bridge.as(material.GetTexture(texturePropertyId), UnityEngine.Texture2D);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom:static start.*/
                CopyTextureAttributesFrom: function (destination, source) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#CopyTextureAttributesFrom", this ); }

                    destination.filterMode = source.filterMode;
                    destination.anisoLevel = source.anisoLevel;
                    destination.wrapModeU = source.wrapModeU;
                    destination.wrapModeV = source.wrapModeV;
                    destination.wrapModeW = source.wrapModeW;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp:static start.*/
                InverseLerp: function (a, b, value) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#InverseLerp", this ); }

                    return (value - a) / (b - a);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp:static end.*/


            }
        }
    });
    /*Spine.Unity.AttachmentTools.AtlasUtilities end.*/

    /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey start.*/
    Bridge.define("Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#getDefaultValue", this ); }
 return new Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey(); }
            }
        },
        fields: {
            i: 0,
            region: null
        },
        ctors: {
            $ctor1: function (i, region) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#$ctor1", this ); }

                this.$initialize();
                this.i = i;
                this.region = region;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey.getHashCode start.*/
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#getHashCode", this ); }

                return Bridge.Int.mul(Bridge.getHashCode(this.i), 23) ^ Bridge.getHashCode(this.region);
            },
            /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey.getHashCode end.*/

            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey)) {
                    return false;
                }
                return Bridge.equals(this.i, o.i) && Bridge.equals(this.region, o.region);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#$clone", this ); }

                var s = to || new Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey();
                s.i = this.i;
                s.region = this.region;
                return s;
            }
        },
        overloads: {
            "GetHashCode()": "getHashCode"
        }
    });
    /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey end.*/

    /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions start.*/
    Bridge.define("Spine.Unity.AttachmentTools.AttachmentCloneExtensions", {
        statics: {
            methods: {
                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetCopy:static start.*/
                /**
                 * Clones the attachment.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentCloneExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentCloneExtensions
                 * @param   {Spine.Attachment}    o                      
                 * @param   {boolean}             cloneMeshesAsLinked
                 * @return  {Spine.Attachment}
                 */
                GetCopy: function (o, cloneMeshesAsLinked) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentCloneExtensions#GetCopy", this ); }

                    var meshAttachment = Bridge.as(o, Spine.MeshAttachment);
                    if (meshAttachment != null && cloneMeshesAsLinked) {
                        return meshAttachment.NewLinkedMesh();
                    }
                    return o.Copy();
                },
                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetCopy:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetLinkedMesh:static start.*/
                /**
                 * Returns a new linked mesh linked to this MeshAttachment. It will be mapped to the AtlasRegion provided.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentCloneExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentCloneExtensions
                 * @param   {Spine.MeshAttachment}    o                    
                 * @param   {string}                  newLinkedMeshName    
                 * @param   {Spine.AtlasRegion}       region
                 * @return  {Spine.MeshAttachment}
                 */
                GetLinkedMesh: function (o, newLinkedMeshName, region) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentCloneExtensions#GetLinkedMesh", this ); }

                    if (region == null) {
                        throw new System.ArgumentNullException.$ctor1("region");
                    }
                    var mesh = o.NewLinkedMesh();
                    Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRegion$1(mesh, region, false);
                    return mesh;
                },
                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetLinkedMesh:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetLinkedMesh$2:static start.*/
                /**
                 * Returns a new linked mesh linked to this MeshAttachment. It will be mapped to an AtlasRegion generated from a Sprite. The AtlasRegion will be mapped to a new Material based on the shader.
                 For better caching and batching, use GetLinkedMesh(string, AtlasRegion, bool)
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentCloneExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentCloneExtensions
                 * @param   {Spine.MeshAttachment}    o                         
                 * @param   {UnityEngine.Sprite}      sprite                    
                 * @param   {UnityEngine.Shader}      shader                    
                 * @param   {UnityEngine.Material}    materialPropertySource
                 * @return  {Spine.MeshAttachment}
                 */
                GetLinkedMesh$2: function (o, sprite, shader, materialPropertySource) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentCloneExtensions#GetLinkedMesh$2", this ); }

                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    var m = new UnityEngine.Material.$ctor2(shader);
                    if (materialPropertySource != null) {
                        m.CopyPropertiesFromMaterial(materialPropertySource);
                        m.shaderKeywords = materialPropertySource.shaderKeywords;
                    }
                    return Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetLinkedMesh(o, sprite.name, Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4(sprite));
                },
                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetLinkedMesh$2:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetLinkedMesh$1:static start.*/
                /**
                 * Returns a new linked mesh linked to this MeshAttachment. It will be mapped to an AtlasRegion generated from a Sprite. The AtlasRegion will be mapped to a new Material based on the shader.
                 For better caching and batching, use GetLinkedMesh(string, AtlasRegion, bool)
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentCloneExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentCloneExtensions
                 * @param   {Spine.MeshAttachment}    o                         
                 * @param   {UnityEngine.Sprite}      sprite                    
                 * @param   {UnityEngine.Material}    materialPropertySource
                 * @return  {Spine.MeshAttachment}
                 */
                GetLinkedMesh$1: function (o, sprite, materialPropertySource) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentCloneExtensions#GetLinkedMesh$1", this ); }

                    return Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetLinkedMesh$2(o, sprite, materialPropertySource.shader, materialPropertySource);
                },
                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetLinkedMesh$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone$1:static start.*/
                /**
                 * Gets a clone of the attachment remapped with a sprite image.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentCloneExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentCloneExtensions
                 * @param   {Spine.Attachment}        o                          The original attachment.
                 * @param   {UnityEngine.Sprite}      sprite                     The sprite whose texture to use.
                 * @param   {UnityEngine.Material}    sourceMaterial             The source material used to copy the shader and material properties from.
                 * @param   {boolean}                 premultiplyAlpha           If <pre><code>true</code></pre>, a premultiply alpha clone of the original texture will be created.
                 See remarks below for additional info.
                 * @param   {boolean}                 cloneMeshAsLinked          If <pre><code>true</code></pre> MeshAttachments will be cloned as linked meshes and will inherit animation from the original attachment.
                 * @param   {boolean}                 useOriginalRegionSize      If <pre><code>true</code></pre> the size of the original attachment will be followed, instead of using the Sprite size.
                 * @param   {boolean}                 pivotShiftsMeshUVCoords    If <pre><code>true</code></pre> and the original Attachment is a MeshAttachment, then
                	a non-central sprite pivot will shift uv coords in the opposite direction. Vertices will not be offset in
                	any case when the original Attachment is a MeshAttachment.
                 * @param   {boolean}                 useOriginalRegionScale     If <pre><code>true</code></pre> and the original Attachment is a RegionAttachment, then
                	the original region's scale value is used instead of the Sprite's pixels per unit property. Since uniform scale is used,
                	x scale of the original attachment (width scale) is used, scale in y direction (height scale) is ignored.
                 * @return  {Spine.Attachment}                                   The remapped clone.
                 */
                GetRemappedClone$1: function (o, sprite, sourceMaterial, premultiplyAlpha, cloneMeshAsLinked, useOriginalRegionSize, pivotShiftsMeshUVCoords, useOriginalRegionScale) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentCloneExtensions#GetRemappedClone$1", this ); }

                    var $t;
                    if (premultiplyAlpha === void 0) { premultiplyAlpha = true; }
                    if (cloneMeshAsLinked === void 0) { cloneMeshAsLinked = true; }
                    if (useOriginalRegionSize === void 0) { useOriginalRegionSize = false; }
                    if (pivotShiftsMeshUVCoords === void 0) { pivotShiftsMeshUVCoords = true; }
                    if (useOriginalRegionScale === void 0) { useOriginalRegionScale = false; }
                    var atlasRegion = premultiplyAlpha ? Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone(sprite, sourceMaterial) : Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$1(sprite, ($t = new UnityEngine.Material.$ctor1(sourceMaterial), $t.mainTexture = sprite.texture, $t));
                    if (!pivotShiftsMeshUVCoords && Bridge.is(o, Spine.MeshAttachment)) {
                        // prevent non-central sprite pivot setting offsetX/Y and shifting uv coords out of mesh bounds
                        atlasRegion.offsetX = 0;
                        atlasRegion.offsetY = 0;
                    }
                    var scale = 1.0 / sprite.pixelsPerUnit;
                    if (useOriginalRegionScale) {
                        var regionAttachment = Bridge.as(o, Spine.RegionAttachment);
                        if (regionAttachment != null) {
                            scale = regionAttachment.width / regionAttachment.regionOriginalWidth;
                        }
                    }
                    return Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone(o, atlasRegion, cloneMeshAsLinked, useOriginalRegionSize, scale);
                },
                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone:static start.*/
                /**
                 * Gets a clone of the attachment remapped with an atlasRegion image.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentCloneExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentCloneExtensions
                 * @param   {Spine.Attachment}     o                        The original attachment.
                 * @param   {Spine.AtlasRegion}    atlasRegion              Atlas region.
                 * @param   {boolean}              cloneMeshAsLinked        If <pre><code>true</code></pre> MeshAttachments will be cloned as linked meshes and will inherit animation from the original attachment.
                 * @param   {boolean}              useOriginalRegionSize    If <pre><code>true</code></pre> the size of the original attachment will be followed, instead of using the Sprite size.
                 * @param   {number}               scale                    Unity units per pixel scale used to scale the atlas region size when not using the original region size.
                 * @return  {Spine.Attachment}                              The remapped clone.
                 */
                GetRemappedClone: function (o, atlasRegion, cloneMeshAsLinked, useOriginalRegionSize, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentCloneExtensions#GetRemappedClone", this ); }

                    if (cloneMeshAsLinked === void 0) { cloneMeshAsLinked = true; }
                    if (useOriginalRegionSize === void 0) { useOriginalRegionSize = false; }
                    if (scale === void 0) { scale = 0.01; }
                    var regionAttachment = Bridge.as(o, Spine.RegionAttachment);
                    if (regionAttachment != null) {
                        var newAttachment = Bridge.cast(regionAttachment.Copy(), Spine.RegionAttachment);
                        Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRegion$2(newAttachment, atlasRegion, false);
                        if (!useOriginalRegionSize) {
                            newAttachment.width = atlasRegion.width * scale;
                            newAttachment.height = atlasRegion.height * scale;
                        }
                        newAttachment.UpdateOffset();
                        return newAttachment;
                    } else {
                        var meshAttachment = Bridge.as(o, Spine.MeshAttachment);
                        if (meshAttachment != null) {
                            var newAttachment1 = cloneMeshAsLinked ? meshAttachment.NewLinkedMesh() : Bridge.cast(meshAttachment.Copy(), Spine.MeshAttachment);
                            Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRegion$1(newAttachment1, atlasRegion);
                            return newAttachment1;
                        }
                    }

                    return Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetCopy(o, true); // Non-renderable Attachments will return as normal cloned attachments.
                },
                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone:static end.*/


            }
        }
    });
    /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions end.*/

    /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions start.*/
    Bridge.define("Spine.Unity.AttachmentTools.AttachmentRegionExtensions", {
        statics: {
            methods: {
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.GetRegion:static start.*/
                /**
                 * Tries to get the region (image) of a renderable attachment. If the attachment is not renderable, it returns null.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.Attachment}     attachment
                 * @return  {Spine.AtlasRegion}
                 */
                GetRegion: function (attachment) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#GetRegion", this ); }

                    var renderableAttachment = Bridge.as(attachment, Spine.IHasRendererObject);
                    if (renderableAttachment != null) {
                        return Bridge.as(renderableAttachment.Spine$IHasRendererObject$RendererObject, Spine.AtlasRegion);
                    }

                    return null;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.GetRegion:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.GetRegion$2:static start.*/
                /**
                 * Gets the region (image) of a RegionAttachment
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    regionAttachment
                 * @return  {Spine.AtlasRegion}
                 */
                GetRegion$2: function (regionAttachment) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#GetRegion$2", this ); }

                    return Bridge.as(regionAttachment.RendererObject, Spine.AtlasRegion);
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.GetRegion$2:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.GetRegion$1:static start.*/
                /**
                 * Gets the region (image) of a MeshAttachment
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.MeshAttachment}    meshAttachment
                 * @return  {Spine.AtlasRegion}
                 */
                GetRegion$1: function (meshAttachment) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#GetRegion$1", this ); }

                    return Bridge.as(meshAttachment.RendererObject, Spine.AtlasRegion);
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.GetRegion$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRegion:static start.*/
                /**
                 * Tries to set the region (image) of a renderable attachment. If the attachment is not renderable, nothing is applied.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.Attachment}     attachment      
                 * @param   {Spine.AtlasRegion}    region          
                 * @param   {boolean}              updateOffset
                 * @return  {void}
                 */
                SetRegion: function (attachment, region, updateOffset) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetRegion", this ); }

                    if (updateOffset === void 0) { updateOffset = true; }
                    var regionAttachment = Bridge.as(attachment, Spine.RegionAttachment);
                    if (regionAttachment != null) {
                        Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRegion$2(regionAttachment, region, updateOffset);
                    }

                    var meshAttachment = Bridge.as(attachment, Spine.MeshAttachment);
                    if (meshAttachment != null) {
                        Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRegion$1(meshAttachment, region, updateOffset);
                    }
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRegion:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRegion$2:static start.*/
                /**
                 * Sets the region (image) of a RegionAttachment
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    attachment      
                 * @param   {Spine.AtlasRegion}         region          
                 * @param   {boolean}                   updateOffset
                 * @return  {void}
                 */
                SetRegion$2: function (attachment, region, updateOffset) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetRegion$2", this ); }

                    if (updateOffset === void 0) { updateOffset = true; }
                    if (region == null) {
                        throw new System.ArgumentNullException.$ctor1("region");
                    }

                    // (AtlasAttachmentLoader.cs)
                    attachment.RendererObject = region;
                    attachment.SetUVs(region.u, region.v, region.u2, region.v2, region.rotate);
                    attachment.regionOffsetX = region.offsetX;
                    attachment.regionOffsetY = region.offsetY;
                    attachment.regionWidth = region.width;
                    attachment.regionHeight = region.height;
                    attachment.regionOriginalWidth = region.originalWidth;
                    attachment.regionOriginalHeight = region.originalHeight;

                    if (updateOffset) {
                        attachment.UpdateOffset();
                    }
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRegion$2:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRegion$1:static start.*/
                /**
                 * Sets the region (image) of a MeshAttachment
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.MeshAttachment}    attachment    
                 * @param   {Spine.AtlasRegion}       region        
                 * @param   {boolean}                 updateUVs
                 * @return  {void}
                 */
                SetRegion$1: function (attachment, region, updateUVs) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetRegion$1", this ); }

                    if (updateUVs === void 0) { updateUVs = true; }
                    if (region == null) {
                        throw new System.ArgumentNullException.$ctor1("region");
                    }

                    // (AtlasAttachmentLoader.cs)
                    attachment.RendererObject = region;
                    attachment.RegionU = region.u;
                    attachment.RegionV = region.v;
                    attachment.RegionU2 = region.u2;
                    attachment.RegionV2 = region.v2;
                    attachment.RegionRotate = region.rotate;
                    attachment.RegionDegrees = region.degrees;
                    attachment.regionOffsetX = region.offsetX;
                    attachment.regionOffsetY = region.offsetY;
                    attachment.regionWidth = region.width;
                    attachment.regionHeight = region.height;
                    attachment.regionOriginalWidth = region.originalWidth;
                    attachment.regionOriginalHeight = region.originalHeight;

                    if (updateUVs) {
                        attachment.UpdateUVs();
                    }
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRegion$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$2:static start.*/
                /**
                 * Creates a RegionAttachment based on a sprite. This method creates a real, usable AtlasRegion. That AtlasRegion uses a new AtlasPage with the Material provided.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {UnityEngine.Sprite}        sprite      
                 * @param   {UnityEngine.Material}      material    
                 * @param   {number}                    rotation
                 * @return  {Spine.RegionAttachment}
                 */
                ToRegionAttachment$2: function (sprite, material, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment$2", this ); }

                    if (rotation === void 0) { rotation = 0.0; }
                    return Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$1(sprite, Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material), rotation);
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$2:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$1:static start.*/
                /**
                 * Creates a RegionAttachment based on a sprite. This method creates a real, usable AtlasRegion. That AtlasRegion uses the AtlasPage provided.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {UnityEngine.Sprite}        sprite      
                 * @param   {Spine.AtlasPage}           page        
                 * @param   {number}                    rotation
                 * @return  {Spine.RegionAttachment}
                 */
                ToRegionAttachment$1: function (sprite, page, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment$1", this ); }

                    if (rotation === void 0) { rotation = 0.0; }
                    if (sprite == null) {
                        throw new System.ArgumentNullException.$ctor1("sprite");
                    }
                    if (page == null) {
                        throw new System.ArgumentNullException.$ctor1("page");
                    }
                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion(sprite, page);
                    var unitsPerPixel = 1.0 / sprite.pixelsPerUnit;
                    return Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment(region, sprite.name, unitsPerPixel, rotation);
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment:static start.*/
                /**
                 * Creates a new RegionAttachment from a given AtlasRegion.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.AtlasRegion}         region            
                 * @param   {string}                    attachmentName    
                 * @param   {number}                    scale             
                 * @param   {number}                    rotation
                 * @return  {Spine.RegionAttachment}
                 */
                ToRegionAttachment: function (region, attachmentName, scale, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    if (rotation === void 0) { rotation = 0.0; }
                    if (System.String.isNullOrEmpty(attachmentName)) {
                        throw new System.ArgumentException.$ctor3("attachmentName can't be null or empty.", "attachmentName");
                    }
                    if (region == null) {
                        throw new System.ArgumentNullException.$ctor1("region");
                    }

                    // (AtlasAttachmentLoader.cs)
                    var attachment = new Spine.RegionAttachment(attachmentName);

                    attachment.RendererObject = region;
                    attachment.SetUVs(region.u, region.v, region.u2, region.v2, region.rotate);
                    attachment.regionOffsetX = region.offsetX;
                    attachment.regionOffsetY = region.offsetY;
                    attachment.regionWidth = region.width;
                    attachment.regionHeight = region.height;
                    attachment.regionOriginalWidth = region.originalWidth;
                    attachment.regionOriginalHeight = region.originalHeight;

                    attachment.Path = region.name;
                    attachment.scaleX = 1;
                    attachment.scaleY = 1;
                    attachment.rotation = rotation;

                    attachment.r = 1;
                    attachment.g = 1;
                    attachment.b = 1;
                    attachment.a = 1;

                    // pass OriginalWidth and OriginalHeight because UpdateOffset uses it in its calculation.
                    attachment.width = attachment.regionOriginalWidth * scale;
                    attachment.height = attachment.regionOriginalHeight * scale;

                    Spine.Unity.SkeletonExtensions.SetColor$2(attachment, new pc.Color( 1, 1, 1, 1 ));
                    attachment.UpdateOffset();
                    return attachment;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone$1:static start.*/
                /**
                 * Creates a Spine.AtlasRegion that uses a premultiplied alpha duplicate texture of the Sprite's texture data.
                 Returns a RegionAttachment that uses it. Use this if you plan to use a premultiply alpha shader such as "Spine/Skeleton".
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {UnityEngine.Sprite}           sprite                    
                 * @param   {UnityEngine.Shader}           shader                    
                 * @param   {UnityEngine.TextureFormat}    textureFormat             
                 * @param   {boolean}                      mipmaps                   
                 * @param   {UnityEngine.Material}         materialPropertySource    
                 * @param   {number}                       rotation
                 * @return  {Spine.RegionAttachment}
                 */
                ToRegionAttachmentPMAClone$1: function (sprite, shader, textureFormat, mipmaps, materialPropertySource, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachmentPMAClone$1", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    if (rotation === void 0) { rotation = 0.0; }
                    if (sprite == null) {
                        throw new System.ArgumentNullException.$ctor1("sprite");
                    }
                    if (shader == null) {
                        throw new System.ArgumentNullException.$ctor1("shader");
                    }
                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$1(sprite, shader, textureFormat, mipmaps, materialPropertySource);
                    var unitsPerPixel = 1.0 / sprite.pixelsPerUnit;
                    return Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment(region, sprite.name, unitsPerPixel, rotation);
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone:static start.*/
                ToRegionAttachmentPMAClone: function (sprite, materialPropertySource, textureFormat, mipmaps, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachmentPMAClone", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (rotation === void 0) { rotation = 0.0; }
                    return Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone$1(sprite, materialPropertySource.shader, textureFormat, mipmaps, materialPropertySource, rotation);
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetScale$1:static start.*/
                /**
                 * Sets the scale. Call regionAttachment.UpdateOffset to apply the change.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    regionAttachment    
                 * @param   {UnityEngine.Vector2}       scale
                 * @return  {void}
                 */
                SetScale$1: function (regionAttachment, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetScale$1", this ); }

                    regionAttachment.scaleX = scale.x;
                    regionAttachment.scaleY = scale.y;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetScale$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetScale:static start.*/
                /**
                 * Sets the scale. Call regionAttachment.UpdateOffset to apply the change.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    regionAttachment    
                 * @param   {number}                    x                   
                 * @param   {number}                    y
                 * @return  {void}
                 */
                SetScale: function (regionAttachment, x, y) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetScale", this ); }

                    regionAttachment.scaleX = x;
                    regionAttachment.scaleY = y;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetScale:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetPositionOffset$1:static start.*/
                /**
                 * Sets the position offset. Call regionAttachment.UpdateOffset to apply the change.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    regionAttachment    
                 * @param   {UnityEngine.Vector2}       offset
                 * @return  {void}
                 */
                SetPositionOffset$1: function (regionAttachment, offset) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetPositionOffset$1", this ); }

                    regionAttachment.x = offset.x;
                    regionAttachment.y = offset.y;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetPositionOffset$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetPositionOffset:static start.*/
                /**
                 * Sets the position offset. Call regionAttachment.UpdateOffset to apply the change.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    regionAttachment    
                 * @param   {number}                    x                   
                 * @param   {number}                    y
                 * @return  {void}
                 */
                SetPositionOffset: function (regionAttachment, x, y) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetPositionOffset", this ); }

                    regionAttachment.x = x;
                    regionAttachment.y = y;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetPositionOffset:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRotation:static start.*/
                /**
                 * Sets the rotation. Call regionAttachment.UpdateOffset to apply the change.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    regionAttachment    
                 * @param   {number}                    rotation
                 * @return  {void}
                 */
                SetRotation: function (regionAttachment, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetRotation", this ); }

                    regionAttachment.rotation = rotation;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRotation:static end.*/


            }
        }
    });
    /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions end.*/

    /*Spine.Unity.AttachmentTools.SkinUtilities start.*/
    Bridge.define("Spine.Unity.AttachmentTools.SkinUtilities", {
        statics: {
            methods: {
                /*Spine.Unity.AttachmentTools.SkinUtilities.UnshareSkin:static start.*/
                /**
                 * Convenience method for duplicating a skeleton's current active skin so changes to it will not affect other skeleton instances. .
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.SkinUtilities
                 * @memberof Spine.Unity.AttachmentTools.SkinUtilities
                 * @param   {Spine.Skeleton}          skeleton              
                 * @param   {boolean}                 includeDefaultSkin    
                 * @param   {boolean}                 unshareAttachments    
                 * @param   {Spine.AnimationState}    state
                 * @return  {Spine.Skin}
                 */
                UnshareSkin: function (skeleton, includeDefaultSkin, unshareAttachments, state) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.SkinUtilities#UnshareSkin", this ); }

                    if (state === void 0) { state = null; }
                    // 1. Copy the current skin and set the skeleton's skin to the new one.
                    var newSkin = Spine.Unity.AttachmentTools.SkinUtilities.GetClonedSkin(skeleton, "cloned skin", includeDefaultSkin, unshareAttachments, true);
                    skeleton.SetSkin(newSkin);

                    // 2. Apply correct attachments: skeleton.SetToSetupPose + animationState.Apply
                    if (state != null) {
                        skeleton.SetToSetupPose();
                        state.Apply(skeleton);
                    }

                    // 3. Return unshared skin.
                    return newSkin;
                },
                /*Spine.Unity.AttachmentTools.SkinUtilities.UnshareSkin:static end.*/

                /*Spine.Unity.AttachmentTools.SkinUtilities.GetClonedSkin:static start.*/
                GetClonedSkin: function (skeleton, newSkinName, includeDefaultSkin, cloneAttachments, cloneMeshesAsLinked) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.SkinUtilities#GetClonedSkin", this ); }

                    if (includeDefaultSkin === void 0) { includeDefaultSkin = false; }
                    if (cloneAttachments === void 0) { cloneAttachments = false; }
                    if (cloneMeshesAsLinked === void 0) { cloneMeshesAsLinked = true; }
                    var newSkin = new Spine.Skin(newSkinName); // may have null name. Harmless.
                    var defaultSkin = skeleton.data.DefaultSkin;
                    var activeSkin = skeleton.skin;

                    if (includeDefaultSkin) {
                        Spine.Unity.AttachmentTools.SkinUtilities.CopyTo(defaultSkin, newSkin, true, cloneAttachments, cloneMeshesAsLinked);
                    }

                    if (activeSkin != null) {
                        Spine.Unity.AttachmentTools.SkinUtilities.CopyTo(activeSkin, newSkin, true, cloneAttachments, cloneMeshesAsLinked);
                    }

                    return newSkin;
                },
                /*Spine.Unity.AttachmentTools.SkinUtilities.GetClonedSkin:static end.*/

                /*Spine.Unity.AttachmentTools.SkinUtilities.GetClone:static start.*/
                /**
                 * Gets a shallow copy of the skin. The cloned skin's attachments are shared with the original skin.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.SkinUtilities
                 * @memberof Spine.Unity.AttachmentTools.SkinUtilities
                 * @param   {Spine.Skin}    original
                 * @return  {Spine.Skin}
                 */
                GetClone: function (original) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.SkinUtilities#GetClone", this ); }

                    var $t;
                    var newSkin = new Spine.Skin((original.name || "") + " clone");
                    var newSkinAttachments = newSkin.Attachments;
                    var newSkinBones = newSkin.Bones;
                    var newSkinConstraints = newSkin.Constraints;

                    $t = Bridge.getEnumerator(original.Attachments);
                    try {
                        while ($t.moveNext()) {
                            var a = $t.Current;
                            newSkinAttachments.setItem(a.key, a.value);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    newSkinBones.AddRange(original.bones);
                    newSkinConstraints.AddRange(original.constraints);
                    return newSkin;
                },
                /*Spine.Unity.AttachmentTools.SkinUtilities.GetClone:static end.*/

                /*Spine.Unity.AttachmentTools.SkinUtilities.SetAttachment$1:static start.*/
                /**
                 * Adds an attachment to the skin for the specified slot index and name. If the name already exists for the slot, the previous value is replaced.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.SkinUtilities
                 * @memberof Spine.Unity.AttachmentTools.SkinUtilities
                 * @param   {Spine.Skin}          skin          
                 * @param   {string}              slotName      
                 * @param   {string}              keyName       
                 * @param   {Spine.Attachment}    attachment    
                 * @param   {Spine.Skeleton}      skeleton
                 * @return  {void}
                 */
                SetAttachment$1: function (skin, slotName, keyName, attachment, skeleton) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.SkinUtilities#SetAttachment$1", this ); }

                    var slotIndex = skeleton.FindSlotIndex(slotName);
                    if (skeleton == null) {
                        throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                    }
                    if (slotIndex === -1) {
                        throw new System.ArgumentException.$ctor3(System.String.format("Slot '{0}' does not exist in skeleton.", [slotName]), "slotName");
                    }
                    skin.SetAttachment(slotIndex, keyName, attachment);
                },
                /*Spine.Unity.AttachmentTools.SkinUtilities.SetAttachment$1:static end.*/

                /*Spine.Unity.AttachmentTools.SkinUtilities.SetAttachment:static start.*/
                /**
                 * Adds an attachment to the skin for the specified slot index and name. If the name already exists for the slot, the previous value is replaced.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.SkinUtilities
                 * @memberof Spine.Unity.AttachmentTools.SkinUtilities
                 * @param   {Spine.Skin}          skin          
                 * @param   {number}              slotIndex     
                 * @param   {string}              keyName       
                 * @param   {Spine.Attachment}    attachment
                 * @return  {void}
                 */
                SetAttachment: function (skin, slotIndex, keyName, attachment) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.SkinUtilities#SetAttachment", this ); }

                    skin.SetAttachment(slotIndex, keyName, attachment);
                },
                /*Spine.Unity.AttachmentTools.SkinUtilities.SetAttachment:static end.*/

                /*Spine.Unity.AttachmentTools.SkinUtilities.AddAttachments:static start.*/
                /**
                 * Adds skin items from another skin. For items that already exist, the previous values are replaced.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.SkinUtilities
                 * @memberof Spine.Unity.AttachmentTools.SkinUtilities
                 * @param   {Spine.Skin}    skin         
                 * @param   {Spine.Skin}    otherSkin
                 * @return  {void}
                 */
                AddAttachments: function (skin, otherSkin) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.SkinUtilities#AddAttachments", this ); }

                    if (otherSkin == null) {
                        return;
                    }
                    Spine.Unity.AttachmentTools.SkinUtilities.CopyTo(otherSkin, skin, true, false);
                },
                /*Spine.Unity.AttachmentTools.SkinUtilities.AddAttachments:static end.*/

                /*Spine.Unity.AttachmentTools.SkinUtilities.GetAttachment:static start.*/
                /**
                 * Gets an attachment from the skin for the specified slot index and name.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.SkinUtilities
                 * @memberof Spine.Unity.AttachmentTools.SkinUtilities
                 * @param   {Spine.Skin}          skin        
                 * @param   {string}              slotName    
                 * @param   {string}              keyName     
                 * @param   {Spine.Skeleton}      skeleton
                 * @return  {Spine.Attachment}
                 */
                GetAttachment: function (skin, slotName, keyName, skeleton) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.SkinUtilities#GetAttachment", this ); }

                    var slotIndex = skeleton.FindSlotIndex(slotName);
                    if (skeleton == null) {
                        throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                    }
                    if (slotIndex === -1) {
                        throw new System.ArgumentException.$ctor3(System.String.format("Slot '{0}' does not exist in skeleton.", [slotName]), "slotName");
                    }
                    return skin.GetAttachment(slotIndex, keyName);
                },
                /*Spine.Unity.AttachmentTools.SkinUtilities.GetAttachment:static end.*/

                /*Spine.Unity.AttachmentTools.SkinUtilities.RemoveAttachment:static start.*/
                RemoveAttachment: function (skin, slotName, keyName, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.SkinUtilities#RemoveAttachment", this ); }

                    var slotIndex = skeletonData.FindSlotIndex(slotName);
                    if (skeletonData == null) {
                        throw new System.ArgumentNullException.$ctor3("skeletonData", "skeletonData cannot be null.");
                    }
                    if (slotIndex === -1) {
                        throw new System.ArgumentException.$ctor3(System.String.format("Slot '{0}' does not exist in skeleton.", [slotName]), "slotName");
                    }
                    skin.RemoveAttachment(slotIndex, keyName);
                },
                /*Spine.Unity.AttachmentTools.SkinUtilities.RemoveAttachment:static end.*/

                /*Spine.Unity.AttachmentTools.SkinUtilities.Clear:static start.*/
                Clear: function (skin) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.SkinUtilities#Clear", this ); }

                    skin.Attachments.clear();
                },
                /*Spine.Unity.AttachmentTools.SkinUtilities.Clear:static end.*/

                /*Spine.Unity.AttachmentTools.SkinUtilities.Append:static start.*/
                Append: function (destination, source) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.SkinUtilities#Append", this ); }

                    Spine.Unity.AttachmentTools.SkinUtilities.CopyTo(source, destination, true, false);
                },
                /*Spine.Unity.AttachmentTools.SkinUtilities.Append:static end.*/

                /*Spine.Unity.AttachmentTools.SkinUtilities.CopyTo:static start.*/
                CopyTo: function (source, destination, overwrite, cloneAttachments, cloneMeshesAsLinked) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.SkinUtilities#CopyTo", this ); }

                    var $t, $t1, $t2, $t3, $t4, $t5;
                    if (cloneMeshesAsLinked === void 0) { cloneMeshesAsLinked = true; }
                    var sourceAttachments = source.Attachments;
                    var destinationAttachments = destination.Attachments;
                    var destinationBones = destination.Bones;
                    var destinationConstraints = destination.Constraints;

                    if (cloneAttachments) {
                        if (overwrite) {
                            $t = Bridge.getEnumerator(sourceAttachments);
                            try {
                                while ($t.moveNext()) {
                                    var e = $t.Current;
                                    var clonedAttachment = Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetCopy(e.value, cloneMeshesAsLinked);
                                    destinationAttachments.setItem(new Spine.Skin.SkinEntry.$ctor1(e.key.SlotIndex, e.key.Name, clonedAttachment), clonedAttachment);
                                }
                            } finally {
                                if (Bridge.is($t, System.IDisposable)) {
                                    $t.System$IDisposable$Dispose();
                                }
                            }
                        } else {
                            $t1 = Bridge.getEnumerator(sourceAttachments);
                            try {
                                while ($t1.moveNext()) {
                                    var e1 = $t1.Current;
                                    if (destinationAttachments.containsKey(e1.key)) {
                                        continue;
                                    }
                                    var clonedAttachment1 = Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetCopy(e1.value, cloneMeshesAsLinked);
                                    destinationAttachments.add(new Spine.Skin.SkinEntry.$ctor1(e1.key.SlotIndex, e1.key.Name, clonedAttachment1), clonedAttachment1);
                                }
                            } finally {
                                if (Bridge.is($t1, System.IDisposable)) {
                                    $t1.System$IDisposable$Dispose();
                                }
                            }
                        }
                    } else {
                        if (overwrite) {
                            $t2 = Bridge.getEnumerator(sourceAttachments);
                            try {
                                while ($t2.moveNext()) {
                                    var e2 = $t2.Current;
                                    destinationAttachments.setItem(e2.key, e2.value);
                                }
                            } finally {
                                if (Bridge.is($t2, System.IDisposable)) {
                                    $t2.System$IDisposable$Dispose();
                                }
                            }
                        } else {
                            $t3 = Bridge.getEnumerator(sourceAttachments);
                            try {
                                while ($t3.moveNext()) {
                                    var e3 = $t3.Current;
                                    if (destinationAttachments.containsKey(e3.key)) {
                                        continue;
                                    }
                                    destinationAttachments.add(e3.key, e3.value);
                                }
                            } finally {
                                if (Bridge.is($t3, System.IDisposable)) {
                                    $t3.System$IDisposable$Dispose();
                                }
                            }
                        }
                    }

                    $t4 = Bridge.getEnumerator(source.bones);
                    try {
                        while ($t4.moveNext()) {
                            var data = $t4.Current;
                            if (!destinationBones.Contains(data)) {
                                destinationBones.Add(data);
                            }
                        }
                    } finally {
                        if (Bridge.is($t4, System.IDisposable)) {
                            $t4.System$IDisposable$Dispose();
                        }
                    }

                    $t5 = Bridge.getEnumerator(source.constraints);
                    try {
                        while ($t5.moveNext()) {
                            var data1 = $t5.Current;
                            if (!destinationConstraints.Contains(data1)) {
                                destinationConstraints.Add(data1);
                            }
                        }
                    } finally {
                        if (Bridge.is($t5, System.IDisposable)) {
                            $t5.System$IDisposable$Dispose();
                        }
                    }
                },
                /*Spine.Unity.AttachmentTools.SkinUtilities.CopyTo:static end.*/


            }
        }
    });
    /*Spine.Unity.AttachmentTools.SkinUtilities end.*/

    /*Spine.Unity.BlendModeMaterials start.*/
    Bridge.define("Spine.Unity.BlendModeMaterials", {
        fields: {
            requiresBlendModeMaterials: false,
            applyAdditiveMaterial: false,
            additiveMaterials: null,
            multiplyMaterials: null,
            screenMaterials: null
        },
        props: {
            RequiresBlendModeMaterials: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#RequiresBlendModeMaterials#get", this ); }

                    return this.requiresBlendModeMaterials;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#RequiresBlendModeMaterials#set", this ); }

                    this.requiresBlendModeMaterials = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#init", this ); }

                this.requiresBlendModeMaterials = false;
                this.applyAdditiveMaterial = false;
                this.additiveMaterials = new (System.Collections.Generic.List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)).ctor();
                this.multiplyMaterials = new (System.Collections.Generic.List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)).ctor();
                this.screenMaterials = new (System.Collections.Generic.List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BlendModeMaterials.ApplyMaterials start.*/
            ApplyMaterials: function (skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#ApplyMaterials", this ); }

                var $t, $t1;
                if (skeletonData == null) {
                    throw new System.ArgumentNullException.$ctor1("skeletonData");
                }
                if (!this.requiresBlendModeMaterials) {
                    return;
                }

                var skinEntries = new (System.Collections.Generic.List$1(Spine.Skin.SkinEntry)).ctor();
                var slotsItems = skeletonData.Slots.Items;
                for (var slotIndex = 0, slotCount = skeletonData.Slots.Count; slotIndex < slotCount; slotIndex = (slotIndex + 1) | 0) {
                    var slot = slotsItems[slotIndex];
                    if (slot.blendMode === Spine.BlendMode.Normal) {
                        continue;
                    }
                    if (!this.applyAdditiveMaterial && slot.blendMode === Spine.BlendMode.Additive) {
                        continue;
                    }

                    var replacementMaterials = null;
                    switch (slot.blendMode) {
                        case Spine.BlendMode.Multiply: 
                            replacementMaterials = this.multiplyMaterials;
                            break;
                        case Spine.BlendMode.Screen: 
                            replacementMaterials = this.screenMaterials;
                            break;
                        case Spine.BlendMode.Additive: 
                            replacementMaterials = this.additiveMaterials;
                            break;
                    }
                    if (replacementMaterials == null) {
                        continue;
                    }

                    skinEntries.clear();
                    $t = Bridge.getEnumerator(skeletonData.Skins);
                    try {
                        while ($t.moveNext()) {
                            var skin = $t.Current;
                            skin.GetAttachments$1(slotIndex, skinEntries);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    $t1 = Bridge.getEnumerator(skinEntries);
                    try {
                        while ($t1.moveNext()) {
                            var entry = $t1.Current;
                            var renderableAttachment = Bridge.as(entry.Attachment, Spine.IHasRendererObject);
                            if (renderableAttachment != null) {
                                renderableAttachment.Spine$IHasRendererObject$RendererObject = this.CloneAtlasRegionWithMaterial(Bridge.cast(renderableAttachment.Spine$IHasRendererObject$RendererObject, Spine.AtlasRegion), replacementMaterials);
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                }
            },
            /*Spine.Unity.BlendModeMaterials.ApplyMaterials end.*/

            /*Spine.Unity.BlendModeMaterials.CloneAtlasRegionWithMaterial start.*/
            CloneAtlasRegionWithMaterial: function (originalRegion, replacementMaterials) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#CloneAtlasRegionWithMaterial", this ); }

                var $t;
                var newRegion = originalRegion.Clone();
                var material = null;
                $t = Bridge.getEnumerator(replacementMaterials);
                try {
                    while ($t.moveNext()) {
                        var replacement = $t.Current;
                        if (Bridge.referenceEquals(replacement.pageName, originalRegion.page.name)) {
                            material = replacement.material;
                            break;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                var originalPage = originalRegion.page;
                var newPage = originalPage.Clone();
                newPage.rendererObject = material;
                newRegion.page = newPage;
                return newRegion;
            },
            /*Spine.Unity.BlendModeMaterials.CloneAtlasRegionWithMaterial end.*/


        }
    });
    /*Spine.Unity.BlendModeMaterials end.*/

    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial start.*/
    Bridge.define("Spine.Unity.BlendModeMaterials.ReplacementMaterial", {
        $kind: 1002,
        fields: {
            pageName: null,
            material: null
        }
    });
    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial end.*/

    /*Spine.Unity.SkeletonDataModifierAsset start.*/
    /**
     * Can be stored by SkeletonDataAsset to automatically apply modifications to loaded SkeletonData.
     *
     * @abstract
     * @public
     * @class Spine.Unity.SkeletonDataModifierAsset
     * @augments UnityEngine.ScriptableObject
     */
    Bridge.define("Spine.Unity.SkeletonDataModifierAsset", {
        inherits: [UnityEngine.ScriptableObject]
    });
    /*Spine.Unity.SkeletonDataModifierAsset end.*/

    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache start.*/
    Bridge.define("Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache", {
        inherits: [System.IDisposable],
        $kind: 1002,
        fields: {
            cache: null
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#init", this ); }

                this.cache = new (System.Collections.Generic.Dictionary$2(System.Collections.Generic.KeyValuePair$2(Spine.AtlasPage,UnityEngine.Material),Spine.AtlasPage)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.CloneAtlasRegionWithMaterial start.*/
            /**
             * Creates a clone of an AtlasRegion that uses different Material settings, while retaining the original texture.
             *
             * @instance
             * @public
             * @this Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache
             * @memberof Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache
             * @param   {Spine.AtlasRegion}       originalRegion      
             * @param   {UnityEngine.Material}    materialTemplate
             * @return  {Spine.AtlasRegion}
             */
            CloneAtlasRegionWithMaterial: function (originalRegion, materialTemplate) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#CloneAtlasRegionWithMaterial", this ); }

                var newRegion = originalRegion.Clone();
                newRegion.page = this.GetAtlasPageWithMaterial(originalRegion.page, materialTemplate);
                return newRegion;
            },
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.CloneAtlasRegionWithMaterial end.*/

            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.GetAtlasPageWithMaterial start.*/
            GetAtlasPageWithMaterial: function (originalPage, materialTemplate) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#GetAtlasPageWithMaterial", this ); }

                var $t;
                if (originalPage == null) {
                    throw new System.ArgumentNullException.$ctor1("originalPage");
                }

                var newPage = { v : null };
                var key = new (System.Collections.Generic.KeyValuePair$2(Spine.AtlasPage,UnityEngine.Material)).$ctor1(originalPage, materialTemplate);
                this.cache.tryGetValue(key, newPage);

                if (newPage.v == null) {
                    newPage.v = originalPage.Clone();
                    var originalMaterial = Bridge.as(originalPage.rendererObject, UnityEngine.Material);
                    newPage.v.rendererObject = ($t = new UnityEngine.Material.$ctor1(materialTemplate), $t.name = (originalMaterial.name || "") + " " + (materialTemplate.name || ""), $t.mainTexture = originalMaterial.mainTexture, $t);
                    this.cache.add(key, newPage.v);
                }

                return newPage.v;
            },
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.GetAtlasPageWithMaterial end.*/

            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#Dispose", this ); }

                this.cache.clear();
            },
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.Dispose end.*/


        }
    });
    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache end.*/

    /*Spine.Unity.BoneFollower start.*/
    /**
     * Sets a GameObject's transform to match a bone on a Spine skeleton.
     *
     * @public
     * @class Spine.Unity.BoneFollower
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.BoneFollower", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonRenderer: null,
            /**
             * If a bone isn't set in code, boneName is used to find the bone at the beginning. For runtime switching by name, use SetBoneByName. You can also set the BoneFollower.bone field directly.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.BoneFollower
             * @type string
             */
            boneName: null,
            followXYPosition: false,
            followZPosition: false,
            followBoneRotation: false,
            followSkeletonFlip: false,
            followLocalScale: false,
            maintainedAxisOrientation: 0,
            initializeOnAwake: false,
            valid: false,
            bone: null,
            skeletonTransform: null,
            skeletonTransformIsParent: false
        },
        props: {
            SkeletonRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#SkeletonRenderer#get", this ); }

                    return this.skeletonRenderer;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#SkeletonRenderer#set", this ); }

                    this.skeletonRenderer = value;
                    this.Initialize();
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#init", this ); }

                this.followXYPosition = true;
                this.followZPosition = true;
                this.followBoneRotation = true;
                this.followSkeletonFlip = true;
                this.followLocalScale = false;
                this.maintainedAxisOrientation = Spine.Unity.BoneFollower.AxisOrientation.XAxis;
                this.initializeOnAwake = true;
            }
        },
        methods: {
            /*Spine.Unity.BoneFollower.SetBone start.*/
            /**
             * Sets the target bone by its bone name. Returns false if no bone was found. To set the bone by reference, use BoneFollower.bone directly.
             *
             * @instance
             * @public
             * @this Spine.Unity.BoneFollower
             * @memberof Spine.Unity.BoneFollower
             * @param   {string}     name
             * @return  {boolean}
             */
            SetBone: function (name) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#SetBone", this ); }

                this.bone = this.skeletonRenderer.skeleton.FindBone(name);
                if (this.bone == null) {
                    UnityEngine.Debug.LogError$2("Bone not found: " + (name || ""), this);
                    return false;
                }
                this.boneName = name;
                return true;
            },
            /*Spine.Unity.BoneFollower.SetBone end.*/

            /*Spine.Unity.BoneFollower.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#Awake", this ); }

                if (this.initializeOnAwake) {
                    this.Initialize();
                }
            },
            /*Spine.Unity.BoneFollower.Awake end.*/

            /*Spine.Unity.BoneFollower.HandleRebuildRenderer start.*/
            HandleRebuildRenderer: function (skeletonRenderer) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#HandleRebuildRenderer", this ); }

                this.Initialize();
            },
            /*Spine.Unity.BoneFollower.HandleRebuildRenderer end.*/

            /*Spine.Unity.BoneFollower.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#Initialize", this ); }

                this.bone = null;
                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) && this.skeletonRenderer.valid;
                if (!this.valid) {
                    return;
                }

                this.skeletonTransform = this.skeletonRenderer.transform;
                this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonTransformIsParent = Bridge.referenceEquals(this.skeletonTransform, this.transform.parent);

                if (!System.String.isNullOrEmpty(this.boneName)) {
                    this.bone = this.skeletonRenderer.skeleton.FindBone(this.boneName);
                }

            },
            /*Spine.Unity.BoneFollower.Initialize end.*/

            /*Spine.Unity.BoneFollower.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#OnDestroy", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                }
            },
            /*Spine.Unity.BoneFollower.OnDestroy end.*/

            /*Spine.Unity.BoneFollower.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#LateUpdate", this ); }

                var $t, $t1;
                if (!this.valid) {
                    this.Initialize();
                    return;
                }


                if (this.bone == null) {
                    if (System.String.isNullOrEmpty(this.boneName)) {
                        return;
                    }
                    this.bone = this.skeletonRenderer.skeleton.FindBone(this.boneName);
                    if (!this.SetBone(this.boneName)) {
                        return;
                    }
                }

                var thisTransform = this.transform;
                var additionalFlipScale = 1;
                if (this.skeletonTransformIsParent) {
                    // Recommended setup: Use local transform properties if Spine GameObject is the immediate parent
                    thisTransform.localPosition = new pc.Vec3( this.followXYPosition ? this.bone.worldX : thisTransform.localPosition.x, this.followXYPosition ? this.bone.worldY : thisTransform.localPosition.y, this.followZPosition ? 0.0 : thisTransform.localPosition.z );
                    if (this.followBoneRotation) {
                        var halfRotation = Math.atan2(this.bone.c, this.bone.a) * 0.5;
                        if (this.followLocalScale && this.bone.scaleX < 0) {
                            halfRotation += 1.57079637;
                        }

                        var q = Bridge.getDefaultValue(UnityEngine.Quaternion);
                        q.z = Math.sin(halfRotation);
                        q.w = Math.cos(halfRotation);
                        thisTransform.localRotation = q.$clone();
                    }
                } else {
                    // For special cases: Use transform world properties if transform relationship is complicated
                    var targetWorldPosition = this.skeletonTransform.TransformPoint$1(new pc.Vec3( this.bone.worldX, this.bone.worldY, 0.0 ));
                    if (!this.followZPosition) {
                        targetWorldPosition.z = thisTransform.position.z;
                    }
                    if (!this.followXYPosition) {
                        targetWorldPosition.x = thisTransform.position.x;
                        targetWorldPosition.y = thisTransform.position.y;
                    }

                    var skeletonLossyScale = this.skeletonTransform.lossyScale.$clone();
                    var transformParent = thisTransform.parent;
                    var parentLossyScale = UnityEngine.Component.op_Inequality(transformParent, null) ? transformParent.lossyScale.$clone() : new pc.Vec3( 1, 1, 1 );
                    if (this.followBoneRotation) {
                        var boneWorldRotation = this.bone.WorldRotationX;

                        if ((skeletonLossyScale.x * skeletonLossyScale.y) < 0) {
                            boneWorldRotation = -boneWorldRotation;
                        }

                        if (this.followSkeletonFlip || this.maintainedAxisOrientation === Spine.Unity.BoneFollower.AxisOrientation.XAxis) {
                            if ((skeletonLossyScale.x * parentLossyScale.x < 0)) {
                                boneWorldRotation += 180.0;
                            }
                        } else {
                            if ((skeletonLossyScale.y * parentLossyScale.y < 0)) {
                                boneWorldRotation += 180.0;
                            }
                        }

                        var worldRotation = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                        if (this.followLocalScale && this.bone.scaleX < 0) {
                            boneWorldRotation += 180.0;
                        }
                        thisTransform.SetPositionAndRotation(targetWorldPosition.$clone(), new pc.Quat().setFromEulerAngles_Unity( worldRotation.x, worldRotation.y, worldRotation.z + boneWorldRotation ));
                    } else {
                        thisTransform.position = targetWorldPosition.$clone();
                    }

                    additionalFlipScale = ($t = skeletonLossyScale.x * parentLossyScale.x * skeletonLossyScale.y * parentLossyScale.y, ($t === 0 ? 1 : Math.sign($t)));
                }

                var localScale = this.followLocalScale ? new pc.Vec3( this.bone.scaleX, this.bone.scaleY, 1.0 ) : new pc.Vec3( 1.0, 1.0, 1.0 );
                if (this.followSkeletonFlip) {
                    localScale.y *= ($t1 = this.bone.skeleton.ScaleX * this.bone.skeleton.ScaleY, ($t1 === 0 ? 1 : Math.sign($t1))) * additionalFlipScale;
                }

                thisTransform.localScale = localScale.$clone();
            },
            /*Spine.Unity.BoneFollower.LateUpdate end.*/


        }
    });
    /*Spine.Unity.BoneFollower end.*/

    /*Spine.Unity.BoneFollower+AxisOrientation start.*/
    Bridge.define("Spine.Unity.BoneFollower.AxisOrientation", {
        $kind: 1006,
        statics: {
            fields: {
                XAxis: 1,
                YAxis: 2
            }
        }
    });
    /*Spine.Unity.BoneFollower+AxisOrientation end.*/

    /*Spine.Unity.BoneFollowerGraphic start.*/
    Bridge.define("Spine.Unity.BoneFollowerGraphic", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonGraphic: null,
            initializeOnAwake: false,
            /**
             * If a bone isn't set in code, boneName is used to find the bone at the beginning. For runtime switching by name, use SetBoneByName. You can also set the BoneFollower.bone field directly.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.BoneFollowerGraphic
             * @type string
             */
            boneName: null,
            followBoneRotation: false,
            followSkeletonFlip: false,
            followLocalScale: false,
            followXYPosition: false,
            followZPosition: false,
            maintainedAxisOrientation: 0,
            bone: null,
            skeletonTransform: null,
            skeletonTransformIsParent: false,
            valid: false
        },
        props: {
            SkeletonGraphic: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#SkeletonGraphic#get", this ); }

                    return this.skeletonGraphic;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#SkeletonGraphic#set", this ); }

                    this.skeletonGraphic = value;
                    this.Initialize();
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#init", this ); }

                this.initializeOnAwake = true;
                this.followBoneRotation = true;
                this.followSkeletonFlip = true;
                this.followLocalScale = false;
                this.followXYPosition = true;
                this.followZPosition = true;
                this.maintainedAxisOrientation = Spine.Unity.BoneFollower.AxisOrientation.XAxis;
            }
        },
        methods: {
            /*Spine.Unity.BoneFollowerGraphic.SetBone start.*/
            /**
             * Sets the target bone by its bone name. Returns false if no bone was found.
             *
             * @instance
             * @public
             * @this Spine.Unity.BoneFollowerGraphic
             * @memberof Spine.Unity.BoneFollowerGraphic
             * @param   {string}     name
             * @return  {boolean}
             */
            SetBone: function (name) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#SetBone", this ); }

                this.bone = this.skeletonGraphic.Skeleton.FindBone(name);
                if (this.bone == null) {
                    UnityEngine.Debug.LogError$2("Bone not found: " + (name || ""), this);
                    return false;
                }
                this.boneName = name;
                return true;
            },
            /*Spine.Unity.BoneFollowerGraphic.SetBone end.*/

            /*Spine.Unity.BoneFollowerGraphic.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#Awake", this ); }

                if (this.initializeOnAwake) {
                    this.Initialize();
                }
            },
            /*Spine.Unity.BoneFollowerGraphic.Awake end.*/

            /*Spine.Unity.BoneFollowerGraphic.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#Initialize", this ); }

                this.bone = null;
                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) && this.skeletonGraphic.IsValid;
                if (!this.valid) {
                    return;
                }

                this.skeletonTransform = this.skeletonGraphic.transform;
                //			skeletonGraphic.OnRebuild -= HandleRebuildRenderer;
                //			skeletonGraphic.OnRebuild += HandleRebuildRenderer;
                this.skeletonTransformIsParent = Bridge.referenceEquals(this.skeletonTransform, this.transform.parent);

                if (!System.String.isNullOrEmpty(this.boneName)) {
                    this.bone = this.skeletonGraphic.Skeleton.FindBone(this.boneName);
                }

            },
            /*Spine.Unity.BoneFollowerGraphic.Initialize end.*/

            /*Spine.Unity.BoneFollowerGraphic.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#LateUpdate", this ); }

                var $t, $t1;
                if (!this.valid) {
                    this.Initialize();
                    return;
                }


                if (this.bone == null) {
                    if (System.String.isNullOrEmpty(this.boneName)) {
                        return;
                    }
                    this.bone = this.skeletonGraphic.Skeleton.FindBone(this.boneName);
                    if (!this.SetBone(this.boneName)) {
                        return;
                    }
                }

                var thisTransform = Bridge.as(this.transform, UnityEngine.RectTransform);
                if (UnityEngine.Component.op_Equality(thisTransform, null)) {
                    return;
                }

                var canvas = this.skeletonGraphic.canvas;
                if (UnityEngine.Component.op_Equality(canvas, null)) {
                    canvas = this.skeletonGraphic.GetComponentInParent(UnityEngine.Canvas);
                }
                var scale = UnityEngine.Component.op_Inequality(canvas, null) ? canvas.referencePixelsPerUnit : 100.0;

                var additionalFlipScale = 1;
                if (this.skeletonTransformIsParent) {
                    // Recommended setup: Use local transform properties if Spine GameObject is the immediate parent
                    thisTransform.localPosition = new pc.Vec3( this.followXYPosition ? this.bone.worldX * scale : thisTransform.localPosition.x, this.followXYPosition ? this.bone.worldY * scale : thisTransform.localPosition.y, this.followZPosition ? 0.0 : thisTransform.localPosition.z );
                    if (this.followBoneRotation) {
                        thisTransform.localRotation = Spine.Unity.SkeletonExtensions.GetQuaternion(this.bone);
                    }
                } else {
                    // For special cases: Use transform world properties if transform relationship is complicated
                    var targetWorldPosition = this.skeletonTransform.TransformPoint$1(new pc.Vec3( this.bone.worldX * scale, this.bone.worldY * scale, 0.0 ));
                    if (!this.followZPosition) {
                        targetWorldPosition.z = thisTransform.position.z;
                    }
                    if (!this.followXYPosition) {
                        targetWorldPosition.x = thisTransform.position.x;
                        targetWorldPosition.y = thisTransform.position.y;
                    }

                    var skeletonLossyScale = this.skeletonTransform.lossyScale.$clone();
                    var transformParent = thisTransform.parent;
                    var parentLossyScale = UnityEngine.Component.op_Inequality(transformParent, null) ? transformParent.lossyScale.$clone() : new pc.Vec3( 1, 1, 1 );
                    if (this.followBoneRotation) {
                        var boneWorldRotation = this.bone.WorldRotationX;

                        if ((skeletonLossyScale.x * skeletonLossyScale.y) < 0) {
                            boneWorldRotation = -boneWorldRotation;
                        }

                        if (this.followSkeletonFlip || this.maintainedAxisOrientation === Spine.Unity.BoneFollower.AxisOrientation.XAxis) {
                            if ((skeletonLossyScale.x * parentLossyScale.x < 0)) {
                                boneWorldRotation += 180.0;
                            }
                        } else {
                            if ((skeletonLossyScale.y * parentLossyScale.y < 0)) {
                                boneWorldRotation += 180.0;
                            }
                        }

                        var worldRotation = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                        if (this.followLocalScale && this.bone.scaleX < 0) {
                            boneWorldRotation += 180.0;
                        }
                        thisTransform.SetPositionAndRotation(targetWorldPosition.$clone(), new pc.Quat().setFromEulerAngles_Unity( worldRotation.x, worldRotation.y, worldRotation.z + boneWorldRotation ));
                    } else {
                        thisTransform.position = targetWorldPosition.$clone();
                    }

                    additionalFlipScale = ($t = skeletonLossyScale.x * parentLossyScale.x * skeletonLossyScale.y * parentLossyScale.y, ($t === 0 ? 1 : Math.sign($t)));
                }

                var localScale = this.followLocalScale ? new pc.Vec3( this.bone.scaleX, this.bone.scaleY, 1.0 ) : new pc.Vec3( 1.0, 1.0, 1.0 );
                if (this.followSkeletonFlip) {
                    localScale.y *= ($t1 = this.bone.skeleton.ScaleX * this.bone.skeleton.ScaleY, ($t1 === 0 ? 1 : Math.sign($t1))) * additionalFlipScale;
                }
                thisTransform.localScale = localScale.$clone();
            },
            /*Spine.Unity.BoneFollowerGraphic.LateUpdate end.*/


        }
    });
    /*Spine.Unity.BoneFollowerGraphic end.*/

    /*Spine.Unity.BoundingBoxFollower start.*/
    Bridge.define("Spine.Unity.BoundingBoxFollower", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                DebugMessages: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#init", this ); }

                    this.DebugMessages = true;
                }
            }
        },
        fields: {
            skeletonRenderer: null,
            slotName: null,
            isTrigger: false,
            clearStateOnDisable: false,
            slot: null,
            currentAttachment: null,
            currentAttachmentName: null,
            currentCollider: null,
            colliderTable: null,
            nameTable: null
        },
        props: {
            Slot: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#Slot#get", this ); }

                    return this.slot;
                }
            },
            CurrentAttachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#CurrentAttachment#get", this ); }

                    return this.currentAttachment;
                }
            },
            CurrentAttachmentName: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#CurrentAttachmentName#get", this ); }

                    return this.currentAttachmentName;
                }
            },
            CurrentCollider: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#CurrentCollider#get", this ); }

                    return this.currentCollider;
                }
            },
            IsTrigger: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#IsTrigger#get", this ); }

                    return this.isTrigger;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#init", this ); }

                this.clearStateOnDisable = true;
                this.colliderTable = new (System.Collections.Generic.Dictionary$2(Spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D)).ctor();
                this.nameTable = new (System.Collections.Generic.Dictionary$2(Spine.BoundingBoxAttachment,System.String)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BoundingBoxFollower.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#Start", this ); }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollower.Start end.*/

            /*Spine.Unity.BoundingBoxFollower.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                    this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollower.OnEnable end.*/

            /*Spine.Unity.BoundingBoxFollower.HandleRebuild start.*/
            HandleRebuild: function (sr) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#HandleRebuild", this ); }

                //if (BoundingBoxFollower.DebugMessages) Debug.Log("Skeleton was rebuilt. Repopulating BoundingBoxFollower.");
                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollower.HandleRebuild end.*/

            /*Spine.Unity.BoundingBoxFollower.Initialize start.*/
            /**
             * Initialize and instantiate the BoundingBoxFollower colliders. This is method checks if the BoundingBoxFollower has already been initialized for the skeleton instance and slotName and prevents overwriting unless it detects a new setup.
             *
             * @instance
             * @public
             * @this Spine.Unity.BoundingBoxFollower
             * @memberof Spine.Unity.BoundingBoxFollower
             * @param   {boolean}    overwrite
             * @return  {void}
             */
            Initialize: function (overwrite) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#Initialize", this ); }

                var $t;
                if (overwrite === void 0) { overwrite = false; }
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    return;
                }

                this.skeletonRenderer.Initialize(false);

                if (System.String.isNullOrEmpty(this.slotName)) {
                    return;
                }

                // Don't reinitialize if the setup did not change.
                if (!overwrite && this.colliderTable.Count > 0 && this.slot != null && Bridge.referenceEquals(this.skeletonRenderer.skeleton, this.slot.Skeleton) && Bridge.referenceEquals(this.slotName, this.slot.data.name)) {
                    return;
                }

                this.slot = null;
                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
                this.colliderTable.clear();
                this.nameTable.clear();

                var skeleton = this.skeletonRenderer.skeleton;
                if (skeleton == null) {
                    return;
                }
                this.slot = skeleton.FindSlot(this.slotName);
                var slotIndex = skeleton.FindSlotIndex(this.slotName);

                if (this.slot == null) {
                    if (Spine.Unity.BoundingBoxFollower.DebugMessages) {
                        UnityEngine.Debug.LogWarning$1(System.String.format("Slot '{0}' not found for BoundingBoxFollower on '{1}'. (Previous colliders were disposed.)", this.slotName, this.gameObject.name));
                    }
                    return;
                }

                var requiredCollidersCount = { v : 0 };
                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (this.gameObject.activeInHierarchy) {
                    $t = Bridge.getEnumerator(skeleton.Data.Skins);
                    try {
                        while ($t.moveNext()) {
                            var skin = $t.Current;
                            this.AddCollidersForSkin(skin, slotIndex, colliders, requiredCollidersCount);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    if (skeleton.skin != null) {
                        this.AddCollidersForSkin(skeleton.skin, slotIndex, colliders, requiredCollidersCount);
                    }
                }
                this.DisposeExcessCollidersAfter(requiredCollidersCount.v);

                if (Spine.Unity.BoundingBoxFollower.DebugMessages) {
                    var valid = this.colliderTable.Count !== 0;
                    if (!valid) {
                        if (this.gameObject.activeInHierarchy) {
                            UnityEngine.Debug.LogWarning$1("Bounding Box Follower not valid! Slot [" + (this.slotName || "") + "] does not contain any Bounding Box Attachments!");
                        } else {
                            UnityEngine.Debug.LogWarning$1("Bounding Box Follower tried to rebuild as a prefab.");
                        }
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.Initialize end.*/

            /*Spine.Unity.BoundingBoxFollower.AddCollidersForSkin start.*/
            AddCollidersForSkin: function (skin, slotIndex, previousColliders, collidersCount) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#AddCollidersForSkin", this ); }

                var $t;
                if (skin == null) {
                    return;
                }
                var skinEntries = new (System.Collections.Generic.List$1(Spine.Skin.SkinEntry)).ctor();
                skin.GetAttachments$1(slotIndex, skinEntries);

                $t = Bridge.getEnumerator(skinEntries);
                try {
                    while ($t.moveNext()) {
                        var entry = $t.Current;
                        var attachment = skin.GetAttachment(slotIndex, entry.Name);
                        var boundingBoxAttachment = Bridge.as(attachment, Spine.BoundingBoxAttachment);

                        if (Spine.Unity.BoundingBoxFollower.DebugMessages && attachment != null && boundingBoxAttachment == null) {
                            UnityEngine.Debug.Log$1("BoundingBoxFollower tried to follow a slot that contains non-boundingbox attachments: " + (this.slotName || ""));
                        }

                        if (boundingBoxAttachment != null) {
                            if (!this.colliderTable.containsKey(boundingBoxAttachment)) {
                                var bbCollider = collidersCount.v < previousColliders.length ? previousColliders[collidersCount.v] : this.gameObject.AddComponent(UnityEngine.PolygonCollider2D);
                                collidersCount.v = (collidersCount.v + 1) | 0;
                                Spine.Unity.SkeletonUtility.SetColliderPointsLocal(bbCollider, this.slot, boundingBoxAttachment);
                                bbCollider.isTrigger = this.isTrigger;
                                bbCollider.enabled = false;
                                bbCollider.hideFlags = UnityEngine.HideFlags.NotEditable;
                                bbCollider.isTrigger = this.IsTrigger;
                                this.colliderTable.add(boundingBoxAttachment, bbCollider);
                                this.nameTable.add(boundingBoxAttachment, entry.Name);
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.AddCollidersForSkin end.*/

            /*Spine.Unity.BoundingBoxFollower.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#OnDisable", this ); }

                if (this.clearStateOnDisable) {
                    this.ClearState();
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }
            },
            /*Spine.Unity.BoundingBoxFollower.OnDisable end.*/

            /*Spine.Unity.BoundingBoxFollower.ClearState start.*/
            ClearState: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#ClearState", this ); }

                var $t;
                if (this.colliderTable != null) {
                    $t = Bridge.getEnumerator(this.colliderTable.Values);
                    try {
                        while ($t.moveNext()) {
                            var col = $t.Current;
                            col.enabled = false;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
            },
            /*Spine.Unity.BoundingBoxFollower.ClearState end.*/

            /*Spine.Unity.BoundingBoxFollower.DisposeExcessCollidersAfter start.*/
            DisposeExcessCollidersAfter: function (requiredCount) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#DisposeExcessCollidersAfter", this ); }

                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (colliders.length === 0) {
                    return;
                }

                for (var i = requiredCount; i < colliders.length; i = (i + 1) | 0) {
                    var collider = colliders[i];
                    if (UnityEngine.Component.op_Inequality(collider, null)) {
                        UnityEngine.Object.Destroy(collider);
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.DisposeExcessCollidersAfter end.*/

            /*Spine.Unity.BoundingBoxFollower.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#LateUpdate", this ); }

                if (this.slot != null && !Bridge.referenceEquals(this.slot.Attachment, this.currentAttachment)) {
                    this.MatchAttachment(this.slot.Attachment);
                }
            },
            /*Spine.Unity.BoundingBoxFollower.LateUpdate end.*/

            /*Spine.Unity.BoundingBoxFollower.MatchAttachment start.*/
            /**
             * Sets the current collider to match attachment.
             *
             * @instance
             * @private
             * @this Spine.Unity.BoundingBoxFollower
             * @memberof Spine.Unity.BoundingBoxFollower
             * @param   {Spine.Attachment}    attachment    If the attachment is not a bounding box, it will be treated as null.
             * @return  {void}
             */
            MatchAttachment: function (attachment) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#MatchAttachment", this ); }

                var bbAttachment = Bridge.as(attachment, Spine.BoundingBoxAttachment);

                if (Spine.Unity.BoundingBoxFollower.DebugMessages && attachment != null && bbAttachment == null) {
                    UnityEngine.Debug.LogWarning$1("BoundingBoxFollower tried to match a non-boundingbox attachment. It will treat it as null.");
                }

                if (UnityEngine.Component.op_Inequality(this.currentCollider, null)) {
                    this.currentCollider.enabled = false;
                }

                if (bbAttachment == null) {
                    this.currentCollider = null;
                    this.currentAttachment = null;
                    this.currentAttachmentName = null;
                } else {
                    var foundCollider = { };
                    this.colliderTable.tryGetValue(bbAttachment, foundCollider);
                    if (UnityEngine.Component.op_Inequality(foundCollider.v, null)) {
                        this.currentCollider = foundCollider.v;
                        this.currentCollider.enabled = true;
                        this.currentAttachment = bbAttachment;
                        this.currentAttachmentName = this.nameTable.getItem(bbAttachment);
                    } else {
                        this.currentCollider = null;
                        this.currentAttachment = bbAttachment;
                        this.currentAttachmentName = null;
                        if (Spine.Unity.BoundingBoxFollower.DebugMessages) {
                            UnityEngine.Debug.LogFormat("Collider for BoundingBoxAttachment named '{0}' was not initialized. It is possibly from a new skin. currentAttachmentName will be null. You may need to call BoundingBoxFollower.Initialize(overwrite: true);", [bbAttachment.Name]);
                        }
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.MatchAttachment end.*/


        }
    });
    /*Spine.Unity.BoundingBoxFollower end.*/

    /*Spine.Unity.BoundingBoxFollowerGraphic start.*/
    Bridge.define("Spine.Unity.BoundingBoxFollowerGraphic", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                DebugMessages: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#init", this ); }

                    this.DebugMessages = true;
                }
            }
        },
        fields: {
            skeletonGraphic: null,
            slotName: null,
            isTrigger: false,
            clearStateOnDisable: false,
            slot: null,
            currentAttachment: null,
            currentAttachmentName: null,
            currentCollider: null,
            colliderTable: null,
            nameTable: null
        },
        props: {
            Slot: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#Slot#get", this ); }

                    return this.slot;
                }
            },
            CurrentAttachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#CurrentAttachment#get", this ); }

                    return this.currentAttachment;
                }
            },
            CurrentAttachmentName: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#CurrentAttachmentName#get", this ); }

                    return this.currentAttachmentName;
                }
            },
            CurrentCollider: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#CurrentCollider#get", this ); }

                    return this.currentCollider;
                }
            },
            IsTrigger: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#IsTrigger#get", this ); }

                    return this.isTrigger;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#init", this ); }

                this.clearStateOnDisable = true;
                this.colliderTable = new (System.Collections.Generic.Dictionary$2(Spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D)).ctor();
                this.nameTable = new (System.Collections.Generic.Dictionary$2(Spine.BoundingBoxAttachment,System.String)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BoundingBoxFollowerGraphic.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#Start", this ); }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.Start end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                    this.skeletonGraphic.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.OnEnable end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.HandleRebuild start.*/
            HandleRebuild: function (sr) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#HandleRebuild", this ); }

                //if (BoundingBoxFollowerGraphic.DebugMessages) Debug.Log("Skeleton was rebuilt. Repopulating BoundingBoxFollowerGraphic.");
                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.HandleRebuild end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.Initialize start.*/
            /**
             * Initialize and instantiate the BoundingBoxFollowerGraphic colliders. This is method checks if the BoundingBoxFollowerGraphic has already been initialized for the skeleton instance and slotName and prevents overwriting unless it detects a new setup.
             *
             * @instance
             * @public
             * @this Spine.Unity.BoundingBoxFollowerGraphic
             * @memberof Spine.Unity.BoundingBoxFollowerGraphic
             * @param   {boolean}    overwrite
             * @return  {void}
             */
            Initialize: function (overwrite) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#Initialize", this ); }

                var $t;
                if (overwrite === void 0) { overwrite = false; }
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    return;
                }

                this.skeletonGraphic.Initialize(false);

                if (System.String.isNullOrEmpty(this.slotName)) {
                    return;
                }

                // Don't reinitialize if the setup did not change.
                if (!overwrite && this.colliderTable.Count > 0 && this.slot != null && Bridge.referenceEquals(this.skeletonGraphic.Skeleton, this.slot.Skeleton) && Bridge.referenceEquals(this.slotName, this.slot.data.name)) {
                    return;
                }

                this.slot = null;
                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
                this.colliderTable.clear();
                this.nameTable.clear();

                var skeleton = this.skeletonGraphic.Skeleton;
                if (skeleton == null) {
                    return;
                }
                this.slot = skeleton.FindSlot(this.slotName);
                var slotIndex = skeleton.FindSlotIndex(this.slotName);

                if (this.slot == null) {
                    if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages) {
                        UnityEngine.Debug.LogWarning$1(System.String.format("Slot '{0}' not found for BoundingBoxFollowerGraphic on '{1}'. (Previous colliders were disposed.)", this.slotName, this.gameObject.name));
                    }
                    return;
                }

                var requiredCollidersCount = { v : 0 };
                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (this.gameObject.activeInHierarchy) {
                    var canvas = this.skeletonGraphic.canvas;
                    if (UnityEngine.Component.op_Equality(canvas, null)) {
                        canvas = this.skeletonGraphic.GetComponentInParent(UnityEngine.Canvas);
                    }
                    var scale = UnityEngine.Component.op_Inequality(canvas, null) ? canvas.referencePixelsPerUnit : 100.0;

                    $t = Bridge.getEnumerator(skeleton.Data.Skins);
                    try {
                        while ($t.moveNext()) {
                            var skin = $t.Current;
                            this.AddCollidersForSkin(skin, slotIndex, colliders, scale, requiredCollidersCount);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    if (skeleton.skin != null) {
                        this.AddCollidersForSkin(skeleton.skin, slotIndex, colliders, scale, requiredCollidersCount);
                    }
                }
                this.DisposeExcessCollidersAfter(requiredCollidersCount.v);

                if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages) {
                    var valid = this.colliderTable.Count !== 0;
                    if (!valid) {
                        if (this.gameObject.activeInHierarchy) {
                            UnityEngine.Debug.LogWarning$1("Bounding Box Follower not valid! Slot [" + (this.slotName || "") + "] does not contain any Bounding Box Attachments!");
                        } else {
                            UnityEngine.Debug.LogWarning$1("Bounding Box Follower tried to rebuild as a prefab.");
                        }
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.Initialize end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.AddCollidersForSkin start.*/
            AddCollidersForSkin: function (skin, slotIndex, previousColliders, scale, collidersCount) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#AddCollidersForSkin", this ); }

                var $t;
                if (skin == null) {
                    return;
                }
                var skinEntries = new (System.Collections.Generic.List$1(Spine.Skin.SkinEntry)).ctor();
                skin.GetAttachments$1(slotIndex, skinEntries);

                $t = Bridge.getEnumerator(skinEntries);
                try {
                    while ($t.moveNext()) {
                        var entry = $t.Current;
                        var attachment = skin.GetAttachment(slotIndex, entry.Name);
                        var boundingBoxAttachment = Bridge.as(attachment, Spine.BoundingBoxAttachment);

                        if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages && attachment != null && boundingBoxAttachment == null) {
                            UnityEngine.Debug.Log$1("BoundingBoxFollowerGraphic tried to follow a slot that contains non-boundingbox attachments: " + (this.slotName || ""));
                        }

                        if (boundingBoxAttachment != null) {
                            if (!this.colliderTable.containsKey(boundingBoxAttachment)) {
                                var bbCollider = collidersCount.v < previousColliders.length ? previousColliders[collidersCount.v] : this.gameObject.AddComponent(UnityEngine.PolygonCollider2D);
                                collidersCount.v = (collidersCount.v + 1) | 0;
                                Spine.Unity.SkeletonUtility.SetColliderPointsLocal(bbCollider, this.slot, boundingBoxAttachment, scale);
                                bbCollider.isTrigger = this.isTrigger;
                                bbCollider.enabled = false;
                                bbCollider.hideFlags = UnityEngine.HideFlags.NotEditable;
                                bbCollider.isTrigger = this.IsTrigger;
                                this.colliderTable.add(boundingBoxAttachment, bbCollider);
                                this.nameTable.add(boundingBoxAttachment, entry.Name);
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.AddCollidersForSkin end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#OnDisable", this ); }

                if (this.clearStateOnDisable) {
                    this.ClearState();
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.OnDisable end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.ClearState start.*/
            ClearState: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#ClearState", this ); }

                var $t;
                if (this.colliderTable != null) {
                    $t = Bridge.getEnumerator(this.colliderTable.Values);
                    try {
                        while ($t.moveNext()) {
                            var col = $t.Current;
                            col.enabled = false;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.ClearState end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.DisposeExcessCollidersAfter start.*/
            DisposeExcessCollidersAfter: function (requiredCount) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#DisposeExcessCollidersAfter", this ); }

                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (colliders.length === 0) {
                    return;
                }

                for (var i = requiredCount; i < colliders.length; i = (i + 1) | 0) {
                    var collider = colliders[i];
                    if (UnityEngine.Component.op_Inequality(collider, null)) {
                        UnityEngine.Object.Destroy(collider);
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.DisposeExcessCollidersAfter end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#LateUpdate", this ); }

                if (this.slot != null && !Bridge.referenceEquals(this.slot.Attachment, this.currentAttachment)) {
                    this.MatchAttachment(this.slot.Attachment);
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.LateUpdate end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.MatchAttachment start.*/
            /**
             * Sets the current collider to match attachment.
             *
             * @instance
             * @private
             * @this Spine.Unity.BoundingBoxFollowerGraphic
             * @memberof Spine.Unity.BoundingBoxFollowerGraphic
             * @param   {Spine.Attachment}    attachment    If the attachment is not a bounding box, it will be treated as null.
             * @return  {void}
             */
            MatchAttachment: function (attachment) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#MatchAttachment", this ); }

                var bbAttachment = Bridge.as(attachment, Spine.BoundingBoxAttachment);

                if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages && attachment != null && bbAttachment == null) {
                    UnityEngine.Debug.LogWarning$1("BoundingBoxFollowerGraphic tried to match a non-boundingbox attachment. It will treat it as null.");
                }

                if (UnityEngine.Component.op_Inequality(this.currentCollider, null)) {
                    this.currentCollider.enabled = false;
                }

                if (bbAttachment == null) {
                    this.currentCollider = null;
                    this.currentAttachment = null;
                    this.currentAttachmentName = null;
                } else {
                    var foundCollider = { };
                    this.colliderTable.tryGetValue(bbAttachment, foundCollider);
                    if (UnityEngine.Component.op_Inequality(foundCollider.v, null)) {
                        this.currentCollider = foundCollider.v;
                        this.currentCollider.enabled = true;
                        this.currentAttachment = bbAttachment;
                        this.currentAttachmentName = this.nameTable.getItem(bbAttachment);
                    } else {
                        this.currentCollider = null;
                        this.currentAttachment = bbAttachment;
                        this.currentAttachmentName = null;
                        if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages) {
                            UnityEngine.Debug.LogFormat("Collider for BoundingBoxAttachment named '{0}' was not initialized. It is possibly from a new skin. currentAttachmentName will be null. You may need to call BoundingBoxFollowerGraphic.Initialize(overwrite: true);", [bbAttachment.Name]);
                        }
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.MatchAttachment end.*/


        }
    });
    /*Spine.Unity.BoundingBoxFollowerGraphic end.*/

    /*Spine.Unity.Deprecated.SlotBlendModes start.*/
    /** @namespace Spine.Unity.Deprecated */

    /**
     * Deprecated. The spine-unity 3.7 runtime introduced SkeletonDataModifierAssets BlendModeMaterials which replaced SlotBlendModes. See the
     {@link } and
     {@link } for further information.
     This class will be removed in the spine-unity 3.9 runtime.
     *
     * @public
     * @class Spine.Unity.Deprecated.SlotBlendModes
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.Deprecated.SlotBlendModes", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                materialTable: null
            },
            props: {
                MaterialTable: {
                    get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes#MaterialTable#get", this ); }

                        if (Spine.Unity.Deprecated.SlotBlendModes.materialTable == null) {
                            Spine.Unity.Deprecated.SlotBlendModes.materialTable = new (System.Collections.Generic.Dictionary$2(Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair,Spine.Unity.Deprecated.SlotBlendModes.MaterialWithRefcount)).ctor();
                        }
                        return Spine.Unity.Deprecated.SlotBlendModes.materialTable;
                    }
                }
            },
            methods: {
                /*Spine.Unity.Deprecated.SlotBlendModes.GetOrAddMaterialFor:static start.*/
                GetOrAddMaterialFor: function (materialSource, texture) {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes#GetOrAddMaterialFor", this ); }

                    var $t;
                    if (materialSource == null || texture == null) {
                        return null;
                    }

                    var mt = Spine.Unity.Deprecated.SlotBlendModes.MaterialTable;
                    var matWithRefcount = { };
                    var key = ($t = new Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair(), $t.material = materialSource, $t.texture2D = texture, $t);
                    if (!mt.tryGetValue(key.$clone(), matWithRefcount)) {
                        matWithRefcount.v = new Spine.Unity.Deprecated.SlotBlendModes.MaterialWithRefcount(new UnityEngine.Material.$ctor1(materialSource));
                        var m = matWithRefcount.v.materialClone;
                        m.name = "(Clone)" + (texture.name || "") + "-" + (materialSource.name || "");
                        m.mainTexture = texture;
                        mt.setItem(key, matWithRefcount.v);
                    } else {
                        matWithRefcount.v.refcount = (matWithRefcount.v.refcount + 1) | 0;
                    }
                    return matWithRefcount.v.materialClone;
                },
                /*Spine.Unity.Deprecated.SlotBlendModes.GetOrAddMaterialFor:static end.*/

                /*Spine.Unity.Deprecated.SlotBlendModes.GetExistingMaterialFor:static start.*/
                GetExistingMaterialFor: function (materialSource, texture) {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes#GetExistingMaterialFor", this ); }

                    var $t;
                    if (materialSource == null || texture == null) {
                        return null;
                    }

                    var mt = Spine.Unity.Deprecated.SlotBlendModes.MaterialTable;
                    var matWithRefcount = { };
                    var key = ($t = new Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair(), $t.material = materialSource, $t.texture2D = texture, $t);
                    if (!mt.tryGetValue(key.$clone(), matWithRefcount)) {
                        return null;
                    }
                    return matWithRefcount.v;
                },
                /*Spine.Unity.Deprecated.SlotBlendModes.GetExistingMaterialFor:static end.*/

                /*Spine.Unity.Deprecated.SlotBlendModes.RemoveMaterialFromTable:static start.*/
                RemoveMaterialFromTable: function (materialSource, texture) {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes#RemoveMaterialFromTable", this ); }

                    var $t;
                    var mt = Spine.Unity.Deprecated.SlotBlendModes.MaterialTable;
                    var key = ($t = new Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair(), $t.material = materialSource, $t.texture2D = texture, $t);
                    mt.remove(key.$clone());
                },
                /*Spine.Unity.Deprecated.SlotBlendModes.RemoveMaterialFromTable:static end.*/


            }
        },
        fields: {
            multiplyMaterialSource: null,
            screenMaterialSource: null,
            texture: null,
            slotsWithCustomMaterial: null,
            Applied: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes#init", this ); }

                this.slotsWithCustomMaterial = System.Array.init(0, function (){
                    return new Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple();
                }, Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple);
            }
        },
        methods: {
            /*Spine.Unity.Deprecated.SlotBlendModes.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes#Start", this ); }

                if (!this.Applied) {
                    this.Apply();
                }
            },
            /*Spine.Unity.Deprecated.SlotBlendModes.Start end.*/

            /*Spine.Unity.Deprecated.SlotBlendModes.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes#OnDestroy", this ); }

                if (this.Applied) {
                    this.Remove();
                }
            },
            /*Spine.Unity.Deprecated.SlotBlendModes.OnDestroy end.*/

            /*Spine.Unity.Deprecated.SlotBlendModes.Apply start.*/
            Apply: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes#Apply", this ); }

                var $t, $t1;
                this.GetTexture();
                if (this.texture == null) {
                    return;
                }

                var skeletonRenderer = this.GetComponent(Spine.Unity.SkeletonRenderer);
                if (UnityEngine.MonoBehaviour.op_Equality(skeletonRenderer, null)) {
                    return;
                }

                var slotMaterials = skeletonRenderer.CustomSlotMaterials;

                var numSlotsWithCustomMaterial = 0;
                $t = Bridge.getEnumerator(skeletonRenderer.Skeleton.Slots);
                try {
                    while ($t.moveNext()) {
                        var s = $t.Current;
                        switch (s.data.blendMode) {
                            case Spine.BlendMode.Multiply: 
                                if (this.multiplyMaterialSource != null) {
                                    slotMaterials.setItem(s, Spine.Unity.Deprecated.SlotBlendModes.GetOrAddMaterialFor(this.multiplyMaterialSource, this.texture));
                                    numSlotsWithCustomMaterial = (numSlotsWithCustomMaterial + 1) | 0;
                                }
                                break;
                            case Spine.BlendMode.Screen: 
                                if (this.screenMaterialSource != null) {
                                    slotMaterials.setItem(s, Spine.Unity.Deprecated.SlotBlendModes.GetOrAddMaterialFor(this.screenMaterialSource, this.texture));
                                    numSlotsWithCustomMaterial = (numSlotsWithCustomMaterial + 1) | 0;
                                }
                                break;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.slotsWithCustomMaterial = System.Array.init(numSlotsWithCustomMaterial, function (){
                    return new Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple();
                }, Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple);
                var storedSlotIndex = 0;
                $t1 = Bridge.getEnumerator(skeletonRenderer.Skeleton.Slots);
                try {
                    while ($t1.moveNext()) {
                        var s1 = $t1.Current;
                        switch (s1.data.blendMode) {
                            case Spine.BlendMode.Multiply: 
                                if (this.multiplyMaterialSource != null) {
                                    this.slotsWithCustomMaterial[Bridge.identity(storedSlotIndex, ((storedSlotIndex = (storedSlotIndex + 1) | 0)))] = new Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple.$ctor1(s1, this.multiplyMaterialSource, this.texture);
                                }
                                break;
                            case Spine.BlendMode.Screen: 
                                if (this.screenMaterialSource != null) {
                                    this.slotsWithCustomMaterial[Bridge.identity(storedSlotIndex, ((storedSlotIndex = (storedSlotIndex + 1) | 0)))] = new Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple.$ctor1(s1, this.screenMaterialSource, this.texture);
                                }
                                break;
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                this.Applied = true;
                skeletonRenderer.LateUpdate();
            },
            /*Spine.Unity.Deprecated.SlotBlendModes.Apply end.*/

            /*Spine.Unity.Deprecated.SlotBlendModes.Remove start.*/
            Remove: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes#Remove", this ); }

                var $t;
                this.GetTexture();
                if (this.texture == null) {
                    return;
                }

                var skeletonRenderer = this.GetComponent(Spine.Unity.SkeletonRenderer);
                if (UnityEngine.MonoBehaviour.op_Equality(skeletonRenderer, null)) {
                    return;
                }

                var slotMaterials = skeletonRenderer.CustomSlotMaterials;

                $t = Bridge.getEnumerator(this.slotsWithCustomMaterial);
                try {
                    while ($t.moveNext()) {
                        var slotWithCustomMat = $t.Current.$clone();

                        var s = slotWithCustomMat.slot;
                        var storedMaterialSource = slotWithCustomMat.material;
                        var storedTexture = slotWithCustomMat.texture2D;

                        var matWithRefcount = Spine.Unity.Deprecated.SlotBlendModes.GetExistingMaterialFor(storedMaterialSource, storedTexture);
                        if (((matWithRefcount.refcount = (matWithRefcount.refcount - 1) | 0)) === 0) {
                            Spine.Unity.Deprecated.SlotBlendModes.RemoveMaterialFromTable(storedMaterialSource, storedTexture);
                        }
                        // we don't want to remove slotMaterials[s] if it has been changed in the meantime.
                        var m = { };
                        if (slotMaterials.tryGetValue(s, m)) {
                            var existingMat = matWithRefcount == null ? null : matWithRefcount.materialClone;
                            if (Bridge.referenceEquals(m.v, existingMat)) {
                                slotMaterials.remove(s);
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.slotsWithCustomMaterial = null;

                this.Applied = false;
                if (skeletonRenderer.valid) {
                    skeletonRenderer.LateUpdate();
                }
            },
            /*Spine.Unity.Deprecated.SlotBlendModes.Remove end.*/

            /*Spine.Unity.Deprecated.SlotBlendModes.GetTexture start.*/
            GetTexture: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes#GetTexture", this ); }

                if (this.texture == null) {
                    var sr = this.GetComponent(Spine.Unity.SkeletonRenderer);
                    if (UnityEngine.MonoBehaviour.op_Equality(sr, null)) {
                        return;
                    }
                    var sda = sr.skeletonDataAsset;
                    if (sda == null) {
                        return;
                    }
                    var aa = sda.atlasAssets[0];
                    if (aa == null) {
                        return;
                    }
                    var am = aa.PrimaryMaterial;
                    if (am == null) {
                        return;
                    }
                    this.texture = Bridge.as(am.mainTexture, UnityEngine.Texture2D);
                }
            },
            /*Spine.Unity.Deprecated.SlotBlendModes.GetTexture end.*/


        }
    });
    /*Spine.Unity.Deprecated.SlotBlendModes end.*/

    /*Spine.Unity.Deprecated.SlotBlendModes+MaterialTexturePair start.*/
    Bridge.define("Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair#getDefaultValue", this ); }
 return new Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair(); }
            }
        },
        fields: {
            texture2D: null,
            material: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair#getHashCode", this ); }

                var h = Bridge.addHash([6830820329, this.texture2D, this.material]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair)) {
                    return false;
                }
                return Bridge.equals(this.texture2D, o.texture2D) && Bridge.equals(this.material, o.material);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair#$clone", this ); }

                var s = to || new Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair();
                s.texture2D = this.texture2D;
                s.material = this.material;
                return s;
            }
        }
    });
    /*Spine.Unity.Deprecated.SlotBlendModes+MaterialTexturePair end.*/

    /*Spine.Unity.Deprecated.SlotBlendModes+MaterialWithRefcount start.*/
    Bridge.define("Spine.Unity.Deprecated.SlotBlendModes.MaterialWithRefcount", {
        $kind: 1002,
        fields: {
            materialClone: null,
            refcount: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes.MaterialWithRefcount#init", this ); }

                this.refcount = 1;
            },
            ctor: function (mat) {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes.MaterialWithRefcount#ctor", this ); }

                this.$initialize();
                this.materialClone = mat;
            }
        }
    });
    /*Spine.Unity.Deprecated.SlotBlendModes+MaterialWithRefcount end.*/

    /*Spine.Unity.Deprecated.SlotBlendModes+SlotMaterialTextureTuple start.*/
    Bridge.define("Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple#getDefaultValue", this ); }
 return new Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple(); }
            }
        },
        fields: {
            slot: null,
            texture2D: null,
            material: null
        },
        ctors: {
            $ctor1: function (slot, material, texture) {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple#$ctor1", this ); }

                this.$initialize();
                this.slot = slot;
                this.material = material;
                this.texture2D = texture;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple#getHashCode", this ); }

                var h = Bridge.addHash([10545495888, this.slot, this.texture2D, this.material]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple)) {
                    return false;
                }
                return Bridge.equals(this.slot, o.slot) && Bridge.equals(this.texture2D, o.texture2D) && Bridge.equals(this.material, o.material);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple#$clone", this ); }

                var s = to || new Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple();
                s.slot = this.slot;
                s.texture2D = this.texture2D;
                s.material = this.material;
                return s;
            }
        }
    });
    /*Spine.Unity.Deprecated.SlotBlendModes+SlotMaterialTextureTuple end.*/

    /*Spine.Unity.DoubleBuffered$1 start.*/
    Bridge.define("Spine.Unity.DoubleBuffered$1", function (T) { return {
        fields: {
            a: null,
            b: null,
            usingA: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.DoubleBuffered$1#init", this ); }

                this.a = Bridge.createInstance(T);
                this.b = Bridge.createInstance(T);
            }
        },
        methods: {
            /*Spine.Unity.DoubleBuffered$1.GetCurrent start.*/
            GetCurrent: function () {
if ( TRACE ) { TRACE( "Spine.Unity.DoubleBuffered$1#GetCurrent", this ); }

                return this.usingA ? Bridge.rValue(this.a) : Bridge.rValue(this.b);
            },
            /*Spine.Unity.DoubleBuffered$1.GetCurrent end.*/

            /*Spine.Unity.DoubleBuffered$1.GetNext start.*/
            GetNext: function () {
if ( TRACE ) { TRACE( "Spine.Unity.DoubleBuffered$1#GetNext", this ); }

                this.usingA = !this.usingA;
                return this.usingA ? Bridge.rValue(this.a) : Bridge.rValue(this.b);
            },
            /*Spine.Unity.DoubleBuffered$1.GetNext end.*/


        }
    }; });
    /*Spine.Unity.DoubleBuffered$1 end.*/

    /*Spine.Unity.EventDataReferenceAsset start.*/
    Bridge.define("Spine.Unity.EventDataReferenceAsset", {
        inherits: [UnityEngine.ScriptableObject],
        statics: {
            fields: {
                QuietSkeletonData: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.EventDataReferenceAsset#init", this ); }

                    this.QuietSkeletonData = true;
                }
            },
            methods: {
                op_Implicit: function (asset) {
if ( TRACE ) { TRACE( "Spine.Unity.EventDataReferenceAsset#op_Implicit", this ); }

                    return asset.EventData;
                }
            }
        },
        fields: {
            skeletonDataAsset: null,
            eventName: null,
            eventData: null
        },
        props: {
            EventData: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.EventDataReferenceAsset#EventData#get", this ); }

                    if (this.eventData == null) {
                        this.Initialize();
                    }
                    return this.eventData;
                }
            }
        },
        methods: {
            /*Spine.Unity.EventDataReferenceAsset.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.EventDataReferenceAsset#Initialize", this ); }

                if (this.skeletonDataAsset == null) {
                    return;
                }
                this.eventData = this.skeletonDataAsset.GetSkeletonData(Spine.Unity.EventDataReferenceAsset.QuietSkeletonData).FindEvent(this.eventName);
                if (this.eventData == null) {
                    UnityEngine.Debug.LogWarningFormat("Event Data '{0}' not found in SkeletonData : {1}.", [this.eventName, this.skeletonDataAsset.name]);
                }
            },
            /*Spine.Unity.EventDataReferenceAsset.Initialize end.*/


        }
    });
    /*Spine.Unity.EventDataReferenceAsset end.*/

    /*Spine.Unity.FollowLocationRigidbody start.*/
    /**
     * Utility component to support flipping of hinge chains (chains of HingeJoint objects) along with the parent skeleton.
     Note: This component is automatically attached when calling "Create Hinge Chain" at {@link }.
     *
     * @public
     * @class Spine.Unity.FollowLocationRigidbody
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.FollowLocationRigidbody", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            reference: null,
            ownRigidbody: null
        },
        methods: {
            /*Spine.Unity.FollowLocationRigidbody.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowLocationRigidbody#Awake", this ); }

                this.ownRigidbody = this.GetComponent(UnityEngine.Rigidbody);
            },
            /*Spine.Unity.FollowLocationRigidbody.Awake end.*/

            /*Spine.Unity.FollowLocationRigidbody.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowLocationRigidbody#FixedUpdate", this ); }

                this.ownRigidbody.rotation = this.reference.rotation.$clone();
                this.ownRigidbody.position = this.reference.position.$clone();
            },
            /*Spine.Unity.FollowLocationRigidbody.FixedUpdate end.*/


        }
    });
    /*Spine.Unity.FollowLocationRigidbody end.*/

    /*Spine.Unity.FollowLocationRigidbody2D start.*/
    /**
     * Utility component to support flipping of hinge chains (chains of HingeJoint objects) along with the parent skeleton.
     Note: This component is automatically attached when calling "Create Hinge Chain" at {@link }.
     *
     * @public
     * @class Spine.Unity.FollowLocationRigidbody2D
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.FollowLocationRigidbody2D", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            reference: null,
            followFlippedX: false,
            ownRigidbody: null
        },
        methods: {
            /*Spine.Unity.FollowLocationRigidbody2D.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowLocationRigidbody2D#Awake", this ); }

                this.ownRigidbody = this.GetComponent(UnityEngine.Rigidbody2D);
            },
            /*Spine.Unity.FollowLocationRigidbody2D.Awake end.*/

            /*Spine.Unity.FollowLocationRigidbody2D.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowLocationRigidbody2D#FixedUpdate", this ); }

                if (this.followFlippedX) {
                    this.ownRigidbody.rotation = ((-this.reference.rotation.getPositiveEulerAngles().z + 270.0) % 360.0) - 90.0;
                } else {
                    this.ownRigidbody.rotation = this.reference.rotation.getPositiveEulerAngles().z;
                }
                this.ownRigidbody.position = UnityEngine.Vector2.FromVector3(this.reference.position.$clone());
            },
            /*Spine.Unity.FollowLocationRigidbody2D.FixedUpdate end.*/


        }
    });
    /*Spine.Unity.FollowLocationRigidbody2D end.*/

    /*Spine.Unity.FollowSkeletonUtilityRootRotation start.*/
    /**
     * Utility component to support flipping of hinge chains (chains of HingeJoint objects) along with the parent skeleton.
     Note that flipping needs to be performed by 180 degree rotation at {@link },
     by setting {@link } to true, not via negative scale.
     Note: This component is automatically attached when calling "Create Hinge Chain" at {@link },
     do not attempt to use this component for other purposes.
     *
     * @public
     * @class Spine.Unity.FollowSkeletonUtilityRootRotation
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.FollowSkeletonUtilityRootRotation", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                FLIP_ANGLE_THRESHOLD: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowSkeletonUtilityRootRotation#init", this ); }

                    this.FLIP_ANGLE_THRESHOLD = 100.0;
                }
            }
        },
        fields: {
            reference: null,
            prevLocalEulerAngles: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowSkeletonUtilityRootRotation#init", this ); }

                this.prevLocalEulerAngles = new UnityEngine.Vector3();
            }
        },
        methods: {
            /*Spine.Unity.FollowSkeletonUtilityRootRotation.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowSkeletonUtilityRootRotation#Start", this ); }

                this.prevLocalEulerAngles = this.transform.localEulerAngles.$clone();
            },
            /*Spine.Unity.FollowSkeletonUtilityRootRotation.Start end.*/

            /*Spine.Unity.FollowSkeletonUtilityRootRotation.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowSkeletonUtilityRootRotation#FixedUpdate", this ); }

                this.transform.rotation = this.reference.rotation.$clone();

                var wasFlippedAroundY = Math.abs(this.transform.localEulerAngles.y - this.prevLocalEulerAngles.y) > Spine.Unity.FollowSkeletonUtilityRootRotation.FLIP_ANGLE_THRESHOLD;
                var wasFlippedAroundX = Math.abs(this.transform.localEulerAngles.x - this.prevLocalEulerAngles.x) > Spine.Unity.FollowSkeletonUtilityRootRotation.FLIP_ANGLE_THRESHOLD;
                if (wasFlippedAroundY) {
                    this.CompensatePositionToYRotation();
                }
                if (wasFlippedAroundX) {
                    this.CompensatePositionToXRotation();
                }

                this.prevLocalEulerAngles = this.transform.localEulerAngles.$clone();
            },
            /*Spine.Unity.FollowSkeletonUtilityRootRotation.FixedUpdate end.*/

            /*Spine.Unity.FollowSkeletonUtilityRootRotation.CompensatePositionToYRotation start.*/
            /**
             * Compensates the position so that a child at the reference position remains in the same place,
             to counter any movement that occurred by rotation.
             *
             * @instance
             * @private
             * @this Spine.Unity.FollowSkeletonUtilityRootRotation
             * @memberof Spine.Unity.FollowSkeletonUtilityRootRotation
             * @return  {void}
             */
            CompensatePositionToYRotation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowSkeletonUtilityRootRotation#CompensatePositionToYRotation", this ); }

                var newPosition = this.reference.position.$clone().add( (this.reference.position.$clone().sub( this.transform.position )) );
                newPosition.y = this.transform.position.y;
                this.transform.position = newPosition.$clone();
            },
            /*Spine.Unity.FollowSkeletonUtilityRootRotation.CompensatePositionToYRotation end.*/

            /*Spine.Unity.FollowSkeletonUtilityRootRotation.CompensatePositionToXRotation start.*/
            /**
             * Compensates the position so that a child at the reference position remains in the same place,
             to counter any movement that occurred by rotation.
             *
             * @instance
             * @private
             * @this Spine.Unity.FollowSkeletonUtilityRootRotation
             * @memberof Spine.Unity.FollowSkeletonUtilityRootRotation
             * @return  {void}
             */
            CompensatePositionToXRotation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowSkeletonUtilityRootRotation#CompensatePositionToXRotation", this ); }

                var newPosition = this.reference.position.$clone().add( (this.reference.position.$clone().sub( this.transform.position )) );
                newPosition.x = this.transform.position.x;
                this.transform.position = newPosition.$clone();
            },
            /*Spine.Unity.FollowSkeletonUtilityRootRotation.CompensatePositionToXRotation end.*/


        }
    });
    /*Spine.Unity.FollowSkeletonUtilityRootRotation end.*/

    /*Spine.Unity.IAnimationStateComponent start.*/
    /**
     * A Spine-Unity Component that uses a Spine.AnimationState to animate its skeleton.
     *
     * @abstract
     * @public
     * @class Spine.Unity.IAnimationStateComponent
     */
    Bridge.define("Spine.Unity.IAnimationStateComponent", {
        $kind: 3
    });
    /*Spine.Unity.IAnimationStateComponent end.*/

    /*Spine.Unity.IHasSkeletonComponent start.*/
    /**
     * A Spine-Unity Component that holds a reference to an ISkeletonComponent.
     *
     * @abstract
     * @public
     * @class Spine.Unity.IHasSkeletonComponent
     */
    Bridge.define("Spine.Unity.IHasSkeletonComponent", {
        $kind: 3
    });
    /*Spine.Unity.IHasSkeletonComponent end.*/

    /*Spine.Unity.IHasSkeletonRenderer start.*/
    /**
     * A Spine-Unity Component that holds a reference to a SkeletonRenderer.
     *
     * @abstract
     * @public
     * @class Spine.Unity.IHasSkeletonRenderer
     */
    Bridge.define("Spine.Unity.IHasSkeletonRenderer", {
        $kind: 3
    });
    /*Spine.Unity.IHasSkeletonRenderer end.*/

    /*Spine.Unity.ISkeletonAnimation start.*/
    /**
     * A Spine-Unity Component that animates a Skeleton but not necessarily with a Spine.AnimationState.
     *
     * @abstract
     * @public
     * @class Spine.Unity.ISkeletonAnimation
     */
    Bridge.define("Spine.Unity.ISkeletonAnimation", {
        $kind: 3
    });
    /*Spine.Unity.ISkeletonAnimation end.*/

    /*Spine.Unity.ISkeletonComponent start.*/
    /**
     * A Spine-Unity Component that manages a Spine.Skeleton instance, instantiated from a SkeletonDataAsset.
     *
     * @abstract
     * @public
     * @class Spine.Unity.ISkeletonComponent
     */
    Bridge.define("Spine.Unity.ISkeletonComponent", {
        $kind: 3
    });
    /*Spine.Unity.ISkeletonComponent end.*/

    /*Spine.Unity.MeshGenerator start.*/
    /**
     * Holds several methods to prepare and generate a UnityEngine mesh based on a skeleton. Contains buffers needed to perform the operation, and serializes settings for mesh generation.
     *
     * @public
     * @class Spine.Unity.MeshGenerator
     */
    Bridge.define("Spine.Unity.MeshGenerator", {
        statics: {
            fields: {
                BoundsMinDefault: 0,
                BoundsMaxDefault: 0,
                AttachmentVerts: null,
                AttachmentUVs: null,
                AttachmentColors32: null,
                AttachmentIndices: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#init", this ); }

                    this.BoundsMinDefault = Number.POSITIVE_INFINITY;
                    this.BoundsMaxDefault = Number.NEGATIVE_INFINITY;
                    this.AttachmentVerts = new (System.Collections.Generic.List$1(UnityEngine.Vector3)).ctor();
                    this.AttachmentUVs = new (System.Collections.Generic.List$1(UnityEngine.Vector2)).ctor();
                    this.AttachmentColors32 = new (System.Collections.Generic.List$1(UnityEngine.Color32)).ctor();
                    this.AttachmentIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                }
            },
            methods: {
                /*Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction:static start.*/
                /**
                 * A specialized variant of {@link }.
                 Generates renderer instructions using a single submesh, using only a single material and texture.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {Spine.Unity.SkeletonRendererInstruction}    instructionOutput    The resulting instructions.
                 * @param   {Spine.Skeleton}                             skeleton             The skeleton to generate renderer instructions for.
                 * @param   {UnityEngine.Material}                       material             Material to be set at the renderer instruction. When null, the last attachment
                 in the draw order list is assigned as the instruction's material.
                 * @return  {void}
                 */
                GenerateSingleSubmeshInstruction: function (instructionOutput, skeleton, material) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#GenerateSingleSubmeshInstruction", this ); }

                    var $t;
                    var drawOrder = skeleton.drawOrder;
                    var drawOrderCount = drawOrder.Count;

                    // Clear last state of attachments and submeshes
                    instructionOutput.Clear(); // submeshInstructions.Clear(); attachments.Clear();
                    var workingSubmeshInstructions = instructionOutput.submeshInstructions;

                    instructionOutput.attachments.Resize(drawOrderCount);
                    var workingAttachmentsItems = instructionOutput.attachments.Items;
                    var totalRawVertexCount = 0;

                    var current = ($t = new Spine.Unity.SubmeshInstruction(), $t.skeleton = skeleton, $t.preActiveClippingSlotSource = -1, $t.startSlot = 0, $t.rawFirstVertexIndex = 0, $t.material = material, $t.forceSeparate = false, $t.endSlot = drawOrderCount, $t);

                    var rendererObject = null;
                    var skeletonHasClipping = false;
                    var drawOrderItems = drawOrder.Items;
                    for (var i = 0; i < drawOrderCount; i = (i + 1) | 0) {
                        var slot = drawOrderItems[i];
                        if (!slot.bone.active) {
                            workingAttachmentsItems[i] = null;
                            continue;
                        }
                        var attachment = slot.attachment;

                        workingAttachmentsItems[i] = attachment;
                        var attachmentTriangleCount;
                        var attachmentVertexCount;

                        var regionAttachment = Bridge.as(attachment, Spine.RegionAttachment);
                        if (regionAttachment != null) {
                            rendererObject = regionAttachment.RendererObject;
                            attachmentVertexCount = 4;
                            attachmentTriangleCount = 6;
                        } else {
                            var meshAttachment = Bridge.as(attachment, Spine.MeshAttachment);
                            if (meshAttachment != null) {
                                rendererObject = meshAttachment.RendererObject;
                                attachmentVertexCount = meshAttachment.worldVerticesLength >> 1;
                                attachmentTriangleCount = meshAttachment.triangles.length;
                            } else {
                                var clippingAttachment = Bridge.as(attachment, Spine.ClippingAttachment);
                                if (clippingAttachment != null) {
                                    current.hasClipping = true;
                                    skeletonHasClipping = true;
                                }
                                attachmentVertexCount = 0;
                                attachmentTriangleCount = 0;
                            }
                        }
                        current.rawTriangleCount = (current.rawTriangleCount + attachmentTriangleCount) | 0;
                        current.rawVertexCount = (current.rawVertexCount + attachmentVertexCount) | 0;
                        totalRawVertexCount = (totalRawVertexCount + attachmentVertexCount) | 0;
                    }

                    if (material == null && rendererObject != null) {
                        current.material = Bridge.cast(Bridge.cast(rendererObject, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                    }

                    instructionOutput.hasActiveClipping = skeletonHasClipping;
                    instructionOutput.rawVertexCount = totalRawVertexCount;

                    if (totalRawVertexCount > 0) {
                        workingSubmeshInstructions.Resize(1);
                        workingSubmeshInstructions.Items[0] = current.$clone();
                    } else {
                        workingSubmeshInstructions.Resize(0);
                    }
                },
                /*Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction:static end.*/

                /*Spine.Unity.MeshGenerator.RequiresMultipleSubmeshesByDrawOrder:static start.*/
                RequiresMultipleSubmeshesByDrawOrder: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#RequiresMultipleSubmeshesByDrawOrder", this ); }


                    var drawOrder = skeleton.drawOrder;
                    var drawOrderCount = drawOrder.Count;
                    var drawOrderItems = drawOrder.Items;

                    var lastRendererMaterial = null;
                    for (var i = 0; i < drawOrderCount; i = (i + 1) | 0) {
                        var slot = drawOrderItems[i];
                        if (!slot.bone.active) {
                            continue;
                        }
                        var attachment = slot.attachment;
                        var rendererAttachment = Bridge.as(attachment, Spine.IHasRendererObject);
                        if (rendererAttachment != null) {
                            var atlasRegion = Bridge.cast(rendererAttachment.Spine$IHasRendererObject$RendererObject, Spine.AtlasRegion);
                            var material = Bridge.cast(atlasRegion.page.rendererObject, UnityEngine.Material);
                            if (!Bridge.referenceEquals(lastRendererMaterial, material)) {
                                if (lastRendererMaterial != null) {
                                    return true;
                                } else {
                                    lastRendererMaterial = material;
                                }
                            }
                        }
                    }
                    return false;
                },
                /*Spine.Unity.MeshGenerator.RequiresMultipleSubmeshesByDrawOrder:static end.*/

                /*Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction:static start.*/
                GenerateSkeletonRendererInstruction: function (instructionOutput, skeleton, customSlotMaterials, separatorSlots, generateMeshOverride, immutableTriangles) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#GenerateSkeletonRendererInstruction", this ); }

                    var $t;
                    if (immutableTriangles === void 0) { immutableTriangles = false; }
                    //			if (skeleton == null) throw new ArgumentNullException("skeleton");
                    //			if (instructionOutput == null) throw new ArgumentNullException("instructionOutput");

                    var drawOrder = skeleton.drawOrder;
                    var drawOrderCount = drawOrder.Count;

                    // Clear last state of attachments and submeshes
                    instructionOutput.Clear(); // submeshInstructions.Clear(); attachments.Clear();
                    var workingSubmeshInstructions = instructionOutput.submeshInstructions;
                    instructionOutput.attachments.Resize(drawOrderCount);
                    var workingAttachmentsItems = instructionOutput.attachments.Items;
                    var totalRawVertexCount = 0;
                    var skeletonHasClipping = false;

                    var current = ($t = new Spine.Unity.SubmeshInstruction(), $t.skeleton = skeleton, $t.preActiveClippingSlotSource = -1, $t);

                    var isCustomSlotMaterialsPopulated = customSlotMaterials != null && customSlotMaterials.Count > 0;

                    var separatorCount = separatorSlots == null ? 0 : separatorSlots.Count;
                    var hasSeparators = separatorCount > 0;

                    var clippingAttachmentSource = -1;
                    var lastPreActiveClipping = -1; // The index of the last slot that had an active ClippingAttachment.
                    var clippingEndSlot = null;
                    var submeshIndex = 0;
                    var drawOrderItems = drawOrder.Items;
                    for (var i = 0; i < drawOrderCount; i = (i + 1) | 0) {
                        var slot = drawOrderItems[i];
                        if (!slot.bone.active) {
                            workingAttachmentsItems[i] = null;
                            continue;
                        }
                        var attachment = slot.attachment;
                        workingAttachmentsItems[i] = attachment;
                        var attachmentVertexCount = 0, attachmentTriangleCount = 0;

                        var rendererObject = null; // An AtlasRegion in plain Spine-Unity. Spine-TK2D hooks into TK2D's system. eventual source of Material object.
                        var noRender = false; // Using this allows empty slots as separators, and keeps separated parts more stable despite slots being reordered

                        var regionAttachment = Bridge.as(attachment, Spine.RegionAttachment);
                        if (regionAttachment != null) {
                            rendererObject = regionAttachment.RendererObject;
                            attachmentVertexCount = 4;
                            attachmentTriangleCount = 6;
                        } else {
                            var meshAttachment = Bridge.as(attachment, Spine.MeshAttachment);
                            if (meshAttachment != null) {
                                rendererObject = meshAttachment.RendererObject;
                                attachmentVertexCount = meshAttachment.worldVerticesLength >> 1;
                                attachmentTriangleCount = meshAttachment.triangles.length;
                            } else {
                                var clippingAttachment = Bridge.as(attachment, Spine.ClippingAttachment);
                                if (clippingAttachment != null) {
                                    clippingEndSlot = clippingAttachment.endSlot;
                                    clippingAttachmentSource = i;
                                    current.hasClipping = true;
                                    skeletonHasClipping = true;
                                }
                                noRender = true;
                            }
                        }

                        // Create a new SubmeshInstruction when material changes. (or when forced to separate by a submeshSeparator)
                        // Slot with a separator/new material will become the starting slot of the next new instruction.
                        if (hasSeparators) { //current.forceSeparate = hasSeparators && separatorSlots.Contains(slot);
                            current.forceSeparate = false;
                            for (var s = 0; s < separatorCount; s = (s + 1) | 0) {
                                if (Bridge.referenceEquals(slot, separatorSlots.getItem(s))) {
                                    current.forceSeparate = true;
                                    break;
                                }
                            }
                        }

                        if (noRender) {
                            if (current.forceSeparate && generateMeshOverride) { // && current.rawVertexCount > 0) {
                                { // Add
                                    current.endSlot = i;
                                    current.preActiveClippingSlotSource = lastPreActiveClipping;

                                    workingSubmeshInstructions.Resize(((submeshIndex + 1) | 0));
                                    workingSubmeshInstructions.Items[submeshIndex] = current.$clone();

                                    submeshIndex = (submeshIndex + 1) | 0;
                                }

                                current.startSlot = i;
                                lastPreActiveClipping = clippingAttachmentSource;
                                current.rawTriangleCount = 0;
                                current.rawVertexCount = 0;
                                current.rawFirstVertexIndex = totalRawVertexCount;
                                current.hasClipping = clippingAttachmentSource >= 0;
                            }
                        } else {
                            var material = { };
                            if (isCustomSlotMaterialsPopulated) {
                                if (!customSlotMaterials.tryGetValue(slot, material)) {
                                    material.v = Bridge.cast(Bridge.cast(rendererObject, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                                }
                            } else {
                                material.v = Bridge.cast(Bridge.cast(rendererObject, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                            }

                            if (current.forceSeparate || (current.rawVertexCount > 0 && !Bridge.referenceEquals(current.material, material.v))) { // Material changed. Add the previous submesh.
                                { // Add
                                    current.endSlot = i;
                                    current.preActiveClippingSlotSource = lastPreActiveClipping;

                                    workingSubmeshInstructions.Resize(((submeshIndex + 1) | 0));
                                    workingSubmeshInstructions.Items[submeshIndex] = current.$clone();
                                    submeshIndex = (submeshIndex + 1) | 0;
                                }
                                current.startSlot = i;
                                lastPreActiveClipping = clippingAttachmentSource;
                                current.rawTriangleCount = 0;
                                current.rawVertexCount = 0;
                                current.rawFirstVertexIndex = totalRawVertexCount;
                                current.hasClipping = clippingAttachmentSource >= 0;
                            }

                            // Update state for the next Attachment.
                            current.material = material.v;
                            current.rawTriangleCount = (current.rawTriangleCount + attachmentTriangleCount) | 0;
                            current.rawVertexCount = (current.rawVertexCount + attachmentVertexCount) | 0;
                            current.rawFirstVertexIndex = totalRawVertexCount;
                            totalRawVertexCount = (totalRawVertexCount + attachmentVertexCount) | 0;
                        }

                        if (clippingEndSlot != null && Bridge.referenceEquals(slot.data, clippingEndSlot) && i !== clippingAttachmentSource) {
                            clippingEndSlot = null;
                            clippingAttachmentSource = -1;
                        }
                    }

                    if (current.rawVertexCount > 0) {
                        { // Add last or only submesh.
                            current.endSlot = drawOrderCount;
                            current.preActiveClippingSlotSource = lastPreActiveClipping;
                            current.forceSeparate = false;

                            workingSubmeshInstructions.Resize(((submeshIndex + 1) | 0));
                            workingSubmeshInstructions.Items[submeshIndex] = current.$clone();
                            //submeshIndex++;
                        }
                    }

                    instructionOutput.hasActiveClipping = skeletonHasClipping;
                    instructionOutput.rawVertexCount = totalRawVertexCount;
                    instructionOutput.immutableTriangles = immutableTriangles;
                },
                /*Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction:static end.*/

                /*Spine.Unity.MeshGenerator.TryReplaceMaterials:static start.*/
                TryReplaceMaterials: function (workingSubmeshInstructions, customMaterialOverride) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#TryReplaceMaterials", this ); }

                    // Material overrides are done here so they can be applied per submesh instead of per slot
                    // but they will still be passed through the GenerateMeshOverride delegate,
                    // and will still go through the normal material match check step in STEP 3.
                    var wsii = workingSubmeshInstructions.Items;
                    for (var i = 0; i < workingSubmeshInstructions.Count; i = (i + 1) | 0) {
                        var m = wsii[i].material;
                        var mo = { };
                        if (customMaterialOverride.tryGetValue(m, mo)) {
                            wsii[i].material = mo.v;
                        }
                    }
                },
                /*Spine.Unity.MeshGenerator.TryReplaceMaterials:static end.*/

                /*Spine.Unity.MeshGenerator.SolveTangents2DEnsureSize:static start.*/
                /**
                 * Step 1 of solving tangents. Ensure you have buffers of the correct size.
                 *
                 * @static
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {UnityEngine.Vector4}    tangentBuffer         Eventual Vector4[] tangent buffer to assign to Mesh.tangents.
                 * @param   {UnityEngine.Vector2}    tempTanBuffer         Temporary Vector2 buffer for calculating directions.
                 * @param   {number}                 vertexCount           Number of vertices that require tangents (or the size of the vertex array)
                 * @param   {number}                 vertexBufferLength
                 * @return  {void}
                 */
                SolveTangents2DEnsureSize: function (tangentBuffer, tempTanBuffer, vertexCount, vertexBufferLength) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#SolveTangents2DEnsureSize", this ); }

                    if (tangentBuffer.v == null || tangentBuffer.v.length !== vertexBufferLength) {
                        tangentBuffer.v = System.Array.init(vertexBufferLength, function (){
                            return new UnityEngine.Vector4();
                        }, UnityEngine.Vector4);
                    }

                    if (tempTanBuffer.v == null || tempTanBuffer.v.length < Bridge.Int.mul(vertexCount, 2)) {
                        tempTanBuffer.v = System.Array.init(Bridge.Int.mul(vertexCount, 2), function (){
                            return new UnityEngine.Vector2();
                        }, UnityEngine.Vector2);
                    } // two arrays in one.
                },
                /*Spine.Unity.MeshGenerator.SolveTangents2DEnsureSize:static end.*/

                /*Spine.Unity.MeshGenerator.SolveTangents2DTriangles:static start.*/
                /**
                 * Step 2 of solving tangents. Fills (part of) a temporary tangent-solution buffer based on the vertices and uvs defined by a submesh's triangle buffer. Only needs to be called once for single-submesh meshes.
                 *
                 * @static
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {Array.<UnityEngine.Vector2>}    tempTanBuffer    A temporary Vector3[] for calculating tangents.
                 * @param   {Array.<number>}                 triangles        The mesh's current triangles buffer.
                 * @param   {number}                         triangleCount    The number of triangle indexes in the triangle array to be used.
                 * @param   {Array.<UnityEngine.Vector3>}    vertices         The mesh's current vertex position buffer.
                 * @param   {Array.<UnityEngine.Vector2>}    uvs              The mesh's current uvs buffer.
                 * @param   {number}                         vertexCount      Number of vertices that require tangents (or the size of the vertex array)
                 * @return  {void}
                 */
                SolveTangents2DTriangles: function (tempTanBuffer, triangles, triangleCount, vertices, uvs, vertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#SolveTangents2DTriangles", this ); }

                    var $t, $t1;
                    var sdir = new UnityEngine.Vector2();
                    var tdir = new UnityEngine.Vector2();
                    for (var t = 0; t < triangleCount; t = (t + 3) | 0) {
                        var i1 = triangles[((t + 0) | 0)];
                        var i2 = triangles[((t + 1) | 0)];
                        var i3 = triangles[((t + 2) | 0)];

                        var v1 = vertices[i1].$clone();
                        var v2 = vertices[i2].$clone();
                        var v3 = vertices[i3].$clone();

                        var w1 = uvs[i1].$clone();
                        var w2 = uvs[i2].$clone();
                        var w3 = uvs[i3].$clone();

                        var x1 = v2.x - v1.x;
                        var x2 = v3.x - v1.x;
                        var y1 = v2.y - v1.y;
                        var y2 = v3.y - v1.y;

                        var s1 = w2.x - w1.x;
                        var s2 = w3.x - w1.x;
                        var t1 = w2.y - w1.y;
                        var t2 = w3.y - w1.y;

                        var div = s1 * t2 - s2 * t1;
                        var r = (div === 0.0) ? 0.0 : 1.0 / div;

                        sdir.x = (t2 * x1 - t1 * x2) * r;
                        sdir.y = (t2 * y1 - t1 * y2) * r;
                        tempTanBuffer[i1] = ($t = (tempTanBuffer[i3] = sdir.$clone(), sdir.$clone()), tempTanBuffer[i2] = $t.$clone(), $t);

                        tdir.x = (s1 * x2 - s2 * x1) * r;
                        tdir.y = (s1 * y2 - s2 * y1) * r;
                        tempTanBuffer[((vertexCount + i1) | 0)] = ($t1 = (tempTanBuffer[((vertexCount + i3) | 0)] = tdir.$clone(), tdir.$clone()), tempTanBuffer[((vertexCount + i2) | 0)] = $t1.$clone(), $t1);
                    }
                },
                /*Spine.Unity.MeshGenerator.SolveTangents2DTriangles:static end.*/

                /*Spine.Unity.MeshGenerator.SolveTangents2DBuffer:static start.*/
                /**
                 * Step 3 of solving tangents. Fills a Vector4[] tangents array according to values calculated in step 2.
                 *
                 * @static
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {Array.<UnityEngine.Vector4>}    tangents         A Vector4[] that will eventually be used to set Mesh.tangents
                 * @param   {Array.<UnityEngine.Vector2>}    tempTanBuffer    A temporary Vector3[] for calculating tangents.
                 * @param   {number}                         vertexCount      Number of vertices that require tangents (or the size of the vertex array)
                 * @return  {void}
                 */
                SolveTangents2DBuffer: function (tangents, tempTanBuffer, vertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#SolveTangents2DBuffer", this ); }

                    var tangent = new UnityEngine.Vector4();
                    tangent.z = 0;
                    for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                        var t = tempTanBuffer[i].$clone();

                        // t.Normalize() (aggressively inlined). Even better if offloaded to GPU via vertex shader.
                        var magnitude = Math.sqrt(t.x * t.x + t.y * t.y);
                        if (magnitude > 1E-05) {
                            var reciprocalMagnitude = 1.0 / magnitude;
                            t.x *= reciprocalMagnitude;
                            t.y *= reciprocalMagnitude;
                        }

                        var t2 = tempTanBuffer[((vertexCount + i) | 0)].$clone();
                        tangent.x = t.x;
                        tangent.y = t.y;
                        //tangent.z = 0;
                        tangent.w = (t.y * t2.x > t.x * t2.y) ? 1 : -1; // 2D direction calculation. Used for binormals.
                        tangents[i] = tangent.$clone();
                    }
                },
                /*Spine.Unity.MeshGenerator.SolveTangents2DBuffer:static end.*/

                /*Spine.Unity.MeshGenerator.FillMeshLocal$1:static start.*/
                /**
                 * Fills mesh vertex data to render a RegionAttachment.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {UnityEngine.Mesh}          mesh                
                 * @param   {Spine.RegionAttachment}    regionAttachment
                 * @return  {void}
                 */
                FillMeshLocal$1: function (mesh, regionAttachment) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillMeshLocal$1", this ); }

                    if (mesh == null) {
                        return;
                    }
                    if (regionAttachment == null) {
                        return;
                    }

                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    var offsets = regionAttachment.Offset;
                    Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[Spine.RegionAttachment.BLX], offsets[Spine.RegionAttachment.BLY], 0 ));
                    Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[Spine.RegionAttachment.ULX], offsets[Spine.RegionAttachment.ULY], 0 ));
                    Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[Spine.RegionAttachment.URX], offsets[Spine.RegionAttachment.URY], 0 ));
                    Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[Spine.RegionAttachment.BRX], offsets[Spine.RegionAttachment.BRY], 0 ));

                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    var uvs = regionAttachment.UVs;
                    Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[Spine.RegionAttachment.ULX], uvs[Spine.RegionAttachment.ULY] ));
                    Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[Spine.RegionAttachment.URX], uvs[Spine.RegionAttachment.URY] ));
                    Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[Spine.RegionAttachment.BRX], uvs[Spine.RegionAttachment.BRY] ));
                    Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[Spine.RegionAttachment.BLX], uvs[Spine.RegionAttachment.BLY] ));

                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    var c = UnityEngine.Color32.op_Implicit$1((new pc.Color( regionAttachment.r, regionAttachment.g, regionAttachment.b, regionAttachment.a )));
                    for (var i = 0; i < 4; i = (i + 1) | 0) {
                        Spine.Unity.MeshGenerator.AttachmentColors32.add(c.$clone());
                    }

                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.AddRange(System.Array.init([0, 2, 1, 0, 3, 2], System.Int32));

                    mesh.Clear();
                    mesh.name = regionAttachment.Name;
                    mesh.SetVertices(Spine.Unity.MeshGenerator.AttachmentVerts);
                    mesh.SetUVs(0, Spine.Unity.MeshGenerator.AttachmentUVs);
                    mesh.SetColors$1(Spine.Unity.MeshGenerator.AttachmentColors32);
                    mesh.SetTriangles(Spine.Unity.MeshGenerator.AttachmentIndices, 0);
                    mesh.RecalculateBounds();

                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                },
                /*Spine.Unity.MeshGenerator.FillMeshLocal$1:static end.*/

                /*Spine.Unity.MeshGenerator.FillMeshLocal:static start.*/
                FillMeshLocal: function (mesh, meshAttachment, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillMeshLocal", this ); }

                    var $t;
                    if (mesh == null) {
                        return;
                    }
                    if (meshAttachment == null) {
                        return;
                    }
                    var vertexCount = (Bridge.Int.div(meshAttachment.WorldVerticesLength, 2)) | 0;

                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    if (Spine.SpineSkeletonExtensions.IsWeighted(meshAttachment)) {
                        var count = meshAttachment.WorldVerticesLength;
                        var meshAttachmentBones = meshAttachment.bones;
                        var v = 0;

                        var vertices = meshAttachment.vertices;
                        for (var w = 0, b = 0; w < count; w = (w + 2) | 0) {
                            var wx = 0, wy = 0;
                            var n = meshAttachmentBones[Bridge.identity(v, ((v = (v + 1) | 0)))];
                            n = (n + v) | 0;
                            for (; v < n; v = (v + 1) | 0, b = (b + 3) | 0) {
                                var bm = Spine.BoneMatrix.CalculateSetupWorld(($t = skeletonData.bones.Items)[meshAttachmentBones[v]]);
                                var vx = vertices[b], vy = vertices[((b + 1) | 0)], weight = vertices[((b + 2) | 0)];
                                wx += (vx * bm.a + vy * bm.b + bm.x) * weight;
                                wy += (vx * bm.c + vy * bm.d + bm.y) * weight;
                            }
                            Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( wx, wy, 0 ));
                        }
                    } else {
                        var localVerts = meshAttachment.Vertices;
                        var pos = Bridge.getDefaultValue(UnityEngine.Vector3);
                        for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                            var ii = Bridge.Int.mul(i, 2);
                            pos.x = localVerts[ii];
                            pos.y = localVerts[((ii + 1) | 0)];
                            Spine.Unity.MeshGenerator.AttachmentVerts.add(pos.$clone());
                        }
                    }

                    var uvs = meshAttachment.uvs;
                    var uv = Bridge.getDefaultValue(UnityEngine.Vector2);
                    var c = UnityEngine.Color32.op_Implicit$1((new pc.Color( meshAttachment.r, meshAttachment.g, meshAttachment.b, meshAttachment.a )));
                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    for (var i1 = 0; i1 < vertexCount; i1 = (i1 + 1) | 0) {
                        var ii1 = Bridge.Int.mul(i1, 2);
                        uv.x = uvs[ii1];
                        uv.y = uvs[((ii1 + 1) | 0)];
                        Spine.Unity.MeshGenerator.AttachmentUVs.add(uv.$clone());

                        Spine.Unity.MeshGenerator.AttachmentColors32.add(c.$clone());
                    }

                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.AddRange(meshAttachment.triangles);

                    mesh.Clear();
                    mesh.name = meshAttachment.Name;
                    mesh.SetVertices(Spine.Unity.MeshGenerator.AttachmentVerts);
                    mesh.SetUVs(0, Spine.Unity.MeshGenerator.AttachmentUVs);
                    mesh.SetColors$1(Spine.Unity.MeshGenerator.AttachmentColors32);
                    mesh.SetTriangles(Spine.Unity.MeshGenerator.AttachmentIndices, 0);
                    mesh.RecalculateBounds();

                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                },
                /*Spine.Unity.MeshGenerator.FillMeshLocal:static end.*/


            }
        },
        fields: {
            settings: null,
            vertexBuffer: null,
            uvBuffer: null,
            colorBuffer: null,
            submeshes: null,
            meshBoundsMin: null,
            meshBoundsMax: null,
            meshBoundsThickness: 0,
            submeshIndex: 0,
            clipper: null,
            tempVerts: null,
            regionTriangles: null,
            normals: null,
            tangents: null,
            tempTanBuffer: null,
            uv2: null,
            uv3: null
        },
        props: {
            VertexCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#VertexCount#get", this ); }

                    return this.vertexBuffer.Count;
                }
            },
            /**
             * A set of mesh arrays whose values are modifiable by the user. Modify these values before they are passed to the UnityEngine mesh object in order to see the effect.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.MeshGenerator
             * @function Buffers
             * @type Spine.Unity.MeshGeneratorBuffers
             */
            Buffers: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#Buffers#get", this ); }

                    var $t;
                    return ($t = new Spine.Unity.MeshGeneratorBuffers(), $t.vertexCount = this.VertexCount, $t.vertexBuffer = this.vertexBuffer.Items, $t.uvBuffer = this.uvBuffer.Items, $t.colorBuffer = this.colorBuffer.Items, $t.meshGenerator = this, $t);
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#init", this ); }

                this.settings = new Spine.Unity.MeshGenerator.Settings();
                this.meshBoundsMin = new UnityEngine.Vector2();
                this.meshBoundsMax = new UnityEngine.Vector2();
                this.settings = Spine.Unity.MeshGenerator.Settings.Default.$clone();
                this.vertexBuffer = new (Spine.ExposedList$1(UnityEngine.Vector3)).$ctor3(4);
                this.uvBuffer = new (Spine.ExposedList$1(UnityEngine.Vector2)).$ctor3(4);
                this.colorBuffer = new (Spine.ExposedList$1(UnityEngine.Color32)).$ctor3(4);
                this.submeshes = function (_o1) {
                        _o1.Add(new (Spine.ExposedList$1(System.Int32)).$ctor3(6));
                        return _o1;
                    }(new (Spine.ExposedList$1(Spine.ExposedList$1(System.Int32))).ctor());
                this.submeshIndex = 0;
                this.clipper = new Spine.SkeletonClipping();
                this.tempVerts = System.Array.init(8, 0, System.Single);
                this.regionTriangles = System.Array.init([
                    0, 
                    1, 
                    2, 
                    2, 
                    3, 
                    0
                ], System.Int32);
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#ctor", this ); }

                this.$initialize();
                this.submeshes.TrimExcess();
            }
        },
        methods: {
            /*Spine.Unity.MeshGenerator.Begin start.*/
            Begin: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#Begin", this ); }

                this.vertexBuffer.Clear(false);
                this.colorBuffer.Clear(false);
                this.uvBuffer.Clear(false);
                this.clipper.ClipEnd();

                {
                    this.meshBoundsMin.x = Spine.Unity.MeshGenerator.BoundsMinDefault;
                    this.meshBoundsMin.y = Spine.Unity.MeshGenerator.BoundsMinDefault;
                    this.meshBoundsMax.x = Spine.Unity.MeshGenerator.BoundsMaxDefault;
                    this.meshBoundsMax.y = Spine.Unity.MeshGenerator.BoundsMaxDefault;
                    this.meshBoundsThickness = 0.0;
                }

                this.submeshIndex = 0;
                this.submeshes.Count = 1;
                //submeshes.Items[0].Clear(false);
            },
            /*Spine.Unity.MeshGenerator.Begin end.*/

            /*Spine.Unity.MeshGenerator.AddSubmesh start.*/
            AddSubmesh: function (instruction, updateTriangles) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#AddSubmesh", this ); }

                var $t, $t1, $t2;
                if (updateTriangles === void 0) { updateTriangles = true; }
                var settings = this.settings.$clone();

                var newSubmeshCount = (this.submeshIndex + 1) | 0;
                if (this.submeshes.Items.length < newSubmeshCount) {
                    this.submeshes.Resize(newSubmeshCount);
                }
                this.submeshes.Count = newSubmeshCount;
                var submesh = ($t = this.submeshes.Items)[this.submeshIndex];
                if (submesh == null) {
                    ($t1 = this.submeshes.Items)[this.submeshIndex] = (submesh = new (Spine.ExposedList$1(System.Int32)).ctor());
                }
                submesh.Clear(false);

                var skeleton = instruction.skeleton;
                var drawOrderItems = skeleton.drawOrder.Items;

                var color = Bridge.getDefaultValue(UnityEngine.Color32);
                var skeletonA = skeleton.a, skeletonR = skeleton.r, skeletonG = skeleton.g, skeletonB = skeleton.b;
                var meshBoundsMin = this.meshBoundsMin.$clone(), meshBoundsMax = this.meshBoundsMax.$clone();

                // Settings
                var zSpacing = settings.zSpacing;
                var pmaVertexColors = settings.pmaVertexColors;
                var tintBlack = settings.tintBlack;
                var useClipping = settings.useClipping && instruction.hasClipping;
                var canvasGroupTintBlack = settings.tintBlack && settings.canvasGroupTintBlack;

                if (useClipping) {
                    if (instruction.preActiveClippingSlotSource >= 0) {
                        var slot = drawOrderItems[instruction.preActiveClippingSlotSource];
                        this.clipper.ClipStart(slot, Bridge.as(slot.attachment, Spine.ClippingAttachment));
                    }
                }

                for (var slotIndex = instruction.startSlot; slotIndex < instruction.endSlot; slotIndex = (slotIndex + 1) | 0) {
                    var slot1 = drawOrderItems[slotIndex];
                    if (!slot1.bone.active) {
                        this.clipper.ClipEnd$1(slot1);
                        continue;
                    }
                    var attachment = slot1.attachment;
                    var z = zSpacing * slotIndex;

                    var workingVerts = this.tempVerts;
                    var uvs;
                    var attachmentTriangleIndices;
                    var attachmentVertexCount;
                    var attachmentIndexCount;

                    var c = Bridge.getDefaultValue(UnityEngine.Color);

                    // Identify and prepare values.
                    var region = Bridge.as(attachment, Spine.RegionAttachment);
                    if (region != null) {
                        region.ComputeWorldVertices(slot1.bone, workingVerts, 0);
                        uvs = region.uvs;
                        attachmentTriangleIndices = this.regionTriangles;
                        c.r = region.r;
                        c.g = region.g;
                        c.b = region.b;
                        c.a = region.a;
                        attachmentVertexCount = 4;
                        attachmentIndexCount = 6;
                    } else {
                        var mesh = Bridge.as(attachment, Spine.MeshAttachment);
                        if (mesh != null) {
                            var meshVerticesLength = mesh.worldVerticesLength;
                            if (workingVerts.length < meshVerticesLength) {
                                workingVerts = System.Array.init(meshVerticesLength, 0, System.Single);
                                this.tempVerts = workingVerts;
                            }
                            mesh.ComputeWorldVertices(slot1, 0, meshVerticesLength, workingVerts, 0); //meshAttachment.ComputeWorldVertices(slot, tempVerts);
                            uvs = mesh.uvs;
                            attachmentTriangleIndices = mesh.triangles;
                            c.r = mesh.r;
                            c.g = mesh.g;
                            c.b = mesh.b;
                            c.a = mesh.a;
                            attachmentVertexCount = meshVerticesLength >> 1; // meshVertexCount / 2;
                            attachmentIndexCount = mesh.triangles.length;
                        } else {
                            if (useClipping) {
                                var clippingAttachment = Bridge.as(attachment, Spine.ClippingAttachment);
                                if (clippingAttachment != null) {
                                    this.clipper.ClipStart(slot1, clippingAttachment);
                                    continue;
                                }
                            }

                            // If not any renderable attachment.
                            this.clipper.ClipEnd$1(slot1);
                            continue;
                        }
                    }

                    var tintBlackAlpha = 1.0;
                    if (pmaVertexColors) {
                        color.a = Bridge.Int.clipu8(skeletonA * slot1.a * c.a * 255);
                        color.r = Bridge.Int.clipu8(skeletonR * slot1.r * c.r * color.a);
                        color.g = Bridge.Int.clipu8(skeletonG * slot1.g * c.g * color.a);
                        color.b = Bridge.Int.clipu8(skeletonB * slot1.b * c.b * color.a);
                        if (slot1.data.blendMode === Spine.BlendMode.Additive) {
                            if (canvasGroupTintBlack) {
                                tintBlackAlpha = 0;
                            } else {
                                color.a = 0;
                            }
                        }
                    } else {
                        color.a = Bridge.Int.clipu8(skeletonA * slot1.a * c.a * 255);
                        color.r = Bridge.Int.clipu8(skeletonR * slot1.r * c.r * 255);
                        color.g = Bridge.Int.clipu8(skeletonG * slot1.g * c.g * 255);
                        color.b = Bridge.Int.clipu8(skeletonB * slot1.b * c.b * 255);
                    }

                    if (useClipping && this.clipper.IsClipping) {
                        this.clipper.ClipTriangles(workingVerts, attachmentVertexCount << 1, attachmentTriangleIndices, attachmentIndexCount, uvs);
                        workingVerts = this.clipper.clippedVertices.Items;
                        attachmentVertexCount = this.clipper.clippedVertices.Count >> 1;
                        attachmentTriangleIndices = this.clipper.clippedTriangles.Items;
                        attachmentIndexCount = this.clipper.clippedTriangles.Count;
                        uvs = this.clipper.clippedUVs.Items;
                    }

                    // Actually add slot/attachment data into buffers.
                    if (attachmentVertexCount !== 0 && attachmentIndexCount !== 0) {
                        if (tintBlack) {
                            var r2 = slot1.r2;
                            var g2 = slot1.g2;
                            var b2 = slot1.b2;
                            if (pmaVertexColors) {
                                var alpha = skeletonA * slot1.a * c.a;
                                r2 *= alpha;
                                g2 *= alpha;
                                b2 *= alpha;
                            }
                            this.AddAttachmentTintBlack(r2, g2, b2, tintBlackAlpha, attachmentVertexCount);
                        }

                        //AddAttachment(workingVerts, uvs, color, attachmentTriangleIndices, attachmentVertexCount, attachmentIndexCount, ref meshBoundsMin, ref meshBoundsMax, z);
                        var ovc = this.vertexBuffer.Count;
                        // Add data to vertex buffers
                        {
                            var newVertexCount = (ovc + attachmentVertexCount) | 0;
                            var oldArraySize = this.vertexBuffer.Items.length;
                            if (newVertexCount > oldArraySize) {
                                var newArraySize = Bridge.Int.clip32(oldArraySize * 1.3);
                                if (newArraySize < newVertexCount) {
                                    newArraySize = newVertexCount;
                                }
                                System.Array.resize(Bridge.ref(this.vertexBuffer, "Items"), newArraySize, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector3);
                                }, UnityEngine.Vector3);
                                System.Array.resize(Bridge.ref(this.uvBuffer, "Items"), newArraySize, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                                System.Array.resize(Bridge.ref(this.colorBuffer, "Items"), newArraySize, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Color32);
                                }, UnityEngine.Color32);
                            }
                            this.vertexBuffer.Count = ($t2 = (this.colorBuffer.Count = newVertexCount, newVertexCount), this.uvBuffer.Count = $t2, $t2);
                        }

                        var vbi = this.vertexBuffer.Items;
                        var ubi = this.uvBuffer.Items;
                        var cbi = this.colorBuffer.Items;
                        if (ovc === 0) {
                            for (var i = 0; i < attachmentVertexCount; i = (i + 1) | 0) {
                                var vi = (ovc + i) | 0;
                                var i2 = i << 1; // i * 2
                                var x = workingVerts[i2];
                                var y = workingVerts[((i2 + 1) | 0)];

                                vbi[vi].x = x;
                                vbi[vi].y = y;
                                vbi[vi].z = z;
                                ubi[vi].x = uvs[i2];
                                ubi[vi].y = uvs[((i2 + 1) | 0)];
                                cbi[vi] = color.$clone();

                                // Calculate bounds.
                                if (x < meshBoundsMin.x) {
                                    meshBoundsMin.x = x;
                                }
                                if (x > meshBoundsMax.x) {
                                    meshBoundsMax.x = x;
                                }
                                if (y < meshBoundsMin.y) {
                                    meshBoundsMin.y = y;
                                }
                                if (y > meshBoundsMax.y) {
                                    meshBoundsMax.y = y;
                                }
                            }
                        } else {
                            for (var i1 = 0; i1 < attachmentVertexCount; i1 = (i1 + 1) | 0) {
                                var vi1 = (ovc + i1) | 0;
                                var i21 = i1 << 1; // i * 2
                                var x1 = workingVerts[i21];
                                var y1 = workingVerts[((i21 + 1) | 0)];

                                vbi[vi1].x = x1;
                                vbi[vi1].y = y1;
                                vbi[vi1].z = z;
                                ubi[vi1].x = uvs[i21];
                                ubi[vi1].y = uvs[((i21 + 1) | 0)];
                                cbi[vi1] = color.$clone();

                                // Calculate bounds.
                                if (x1 < meshBoundsMin.x) {
                                    meshBoundsMin.x = x1;
                                } else {
                                    if (x1 > meshBoundsMax.x) {
                                        meshBoundsMax.x = x1;
                                    }
                                }
                                if (y1 < meshBoundsMin.y) {
                                    meshBoundsMin.y = y1;
                                } else {
                                    if (y1 > meshBoundsMax.y) {
                                        meshBoundsMax.y = y1;
                                    }
                                }
                            }
                        }


                        // Add data to triangle buffer
                        if (updateTriangles) {
                            var oldTriangleCount = submesh.Count;
                            { //submesh.Resize(oldTriangleCount + attachmentIndexCount);
                                var newTriangleCount = (oldTriangleCount + attachmentIndexCount) | 0;
                                if (newTriangleCount > submesh.Items.length) {
                                    System.Array.resize(Bridge.ref(submesh, "Items"), newTriangleCount, 0, System.Int32);
                                }
                                submesh.Count = newTriangleCount;
                            }
                            var submeshItems = submesh.Items;
                            for (var i2 = 0; i2 < attachmentIndexCount; i2 = (i2 + 1) | 0) {
                                submeshItems[((oldTriangleCount + i2) | 0)] = (attachmentTriangleIndices[i2] + ovc) | 0;
                            }
                        }
                    }

                    this.clipper.ClipEnd$1(slot1);
                }
                this.clipper.ClipEnd();

                this.meshBoundsMin = meshBoundsMin.$clone();
                this.meshBoundsMax = meshBoundsMax.$clone();
                this.meshBoundsThickness = instruction.endSlot * zSpacing;

                // Trim or zero submesh triangles.
                var currentSubmeshItems = submesh.Items;
                for (var i3 = submesh.Count, n = currentSubmeshItems.length; i3 < n; i3 = (i3 + 1) | 0) {
                    currentSubmeshItems[i3] = 0;
                }

                this.submeshIndex = (this.submeshIndex + 1) | 0; // Next AddSubmesh will use a new submeshIndex value.
            },
            /*Spine.Unity.MeshGenerator.AddSubmesh end.*/

            /*Spine.Unity.MeshGenerator.BuildMesh start.*/
            BuildMesh: function (instruction, updateTriangles) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#BuildMesh", this ); }

                var wsii = instruction.submeshInstructions.Items;
                for (var i = 0, n = instruction.submeshInstructions.Count; i < n; i = (i + 1) | 0) {
                    this.AddSubmesh(wsii[i].$clone(), updateTriangles);
                }
            },
            /*Spine.Unity.MeshGenerator.BuildMesh end.*/

            /*Spine.Unity.MeshGenerator.BuildMeshWithArrays start.*/
            BuildMeshWithArrays: function (instruction, updateTriangles) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#BuildMeshWithArrays", this ); }

                var $t, $t1, $t2, $t3, $t4;
                var settings = this.settings.$clone();
                var canvasGroupTintBlack = settings.tintBlack && settings.canvasGroupTintBlack;
                var totalVertexCount = instruction.rawVertexCount;

                // Add data to vertex buffers
                {
                    if (totalVertexCount > this.vertexBuffer.Items.length) { // Manual ExposedList.Resize()
                        System.Array.resize(Bridge.ref(this.vertexBuffer, "Items"), totalVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector3);
                        }, UnityEngine.Vector3);
                        System.Array.resize(Bridge.ref(this.uvBuffer, "Items"), totalVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector2);
                        }, UnityEngine.Vector2);
                        System.Array.resize(Bridge.ref(this.colorBuffer, "Items"), totalVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Color32);
                        }, UnityEngine.Color32);
                    }
                    this.vertexBuffer.Count = ($t = (this.colorBuffer.Count = totalVertexCount, totalVertexCount), this.uvBuffer.Count = $t, $t);
                }

                // Populate Verts
                var color = Bridge.getDefaultValue(UnityEngine.Color32);

                var vertexIndex = 0;
                var tempVerts = this.tempVerts;
                var bmin = this.meshBoundsMin.$clone();
                var bmax = this.meshBoundsMax.$clone();

                var vbi = this.vertexBuffer.Items;
                var ubi = this.uvBuffer.Items;
                var cbi = this.colorBuffer.Items;
                var lastSlotIndex = 0;

                // drawOrder[endSlot] is excluded
                for (var si = 0, n = instruction.submeshInstructions.Count; si < n; si = (si + 1) | 0) {
                    var submesh = ($t1 = instruction.submeshInstructions.Items)[si].$clone();
                    var skeleton = submesh.skeleton;
                    var drawOrderItems = skeleton.drawOrder.Items;
                    var a = skeleton.a, r = skeleton.r, g = skeleton.g, b = skeleton.b;

                    var endSlot = submesh.endSlot;
                    var startSlot = submesh.startSlot;
                    lastSlotIndex = endSlot;

                    if (settings.tintBlack) {
                        var rg = new UnityEngine.Vector2(), b2 = new UnityEngine.Vector2();
                        var vi = vertexIndex;
                        b2.y = 1.0;

                        {
                            if (this.uv2 == null) {
                                this.uv2 = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                                this.uv3 = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                            }
                            if (totalVertexCount > this.uv2.Items.length) { // Manual ExposedList.Resize()
                                System.Array.resize(Bridge.ref(this.uv2, "Items"), totalVertexCount, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                                System.Array.resize(Bridge.ref(this.uv3, "Items"), totalVertexCount, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                            }
                            this.uv2.Count = (this.uv3.Count = totalVertexCount, totalVertexCount);
                        }

                        var uv2i = this.uv2.Items;
                        var uv3i = this.uv3.Items;

                        for (var slotIndex = startSlot; slotIndex < endSlot; slotIndex = (slotIndex + 1) | 0) {
                            var slot = drawOrderItems[slotIndex];
                            if (!slot.bone.active) {
                                continue;
                            }
                            var attachment = slot.attachment;

                            rg.x = slot.r2; //r
                            rg.y = slot.g2; //g
                            b2.x = slot.b2; //b
                            b2.y = 1.0;

                            var regionAttachment = Bridge.as(attachment, Spine.RegionAttachment);
                            if (regionAttachment != null) {
                                if (settings.pmaVertexColors) {
                                    var alpha = a * slot.a * regionAttachment.a;
                                    rg.x *= alpha;
                                    rg.y *= alpha;
                                    b2.x *= alpha;
                                    b2.y = slot.data.blendMode === Spine.BlendMode.Additive ? 0 : alpha;
                                }
                                uv2i[vi] = rg.$clone();
                                uv2i[((vi + 1) | 0)] = rg.$clone();
                                uv2i[((vi + 2) | 0)] = rg.$clone();
                                uv2i[((vi + 3) | 0)] = rg.$clone();
                                uv3i[vi] = b2.$clone();
                                uv3i[((vi + 1) | 0)] = b2.$clone();
                                uv3i[((vi + 2) | 0)] = b2.$clone();
                                uv3i[((vi + 3) | 0)] = b2.$clone();
                                vi = (vi + 4) | 0;
                            } else { //} if (settings.renderMeshes) {
                                var meshAttachment = Bridge.as(attachment, Spine.MeshAttachment);
                                if (meshAttachment != null) {
                                    if (settings.pmaVertexColors) {
                                        var alpha1 = a * slot.a * meshAttachment.a;
                                        rg.x *= alpha1;
                                        rg.y *= alpha1;
                                        b2.x *= alpha1;
                                        b2.y = slot.data.blendMode === Spine.BlendMode.Additive ? 0 : alpha1;
                                    }
                                    var meshVertexCount = meshAttachment.worldVerticesLength;
                                    for (var iii = 0; iii < meshVertexCount; iii = (iii + 2) | 0) {
                                        uv2i[vi] = rg.$clone();
                                        uv3i[vi] = b2.$clone();
                                        vi = (vi + 1) | 0;
                                    }
                                }
                            }
                        }
                    }

                    for (var slotIndex1 = startSlot; slotIndex1 < endSlot; slotIndex1 = (slotIndex1 + 1) | 0) {
                        var slot1 = drawOrderItems[slotIndex1];
                        if (!slot1.bone.active) {
                            continue;
                        }
                        var attachment1 = slot1.attachment;
                        var z = slotIndex1 * settings.zSpacing;

                        var regionAttachment1 = Bridge.as(attachment1, Spine.RegionAttachment);
                        if (regionAttachment1 != null) {
                            regionAttachment1.ComputeWorldVertices(slot1.bone, tempVerts, 0);

                            var x1 = tempVerts[Spine.RegionAttachment.BLX], y1 = tempVerts[Spine.RegionAttachment.BLY];
                            var x2 = tempVerts[Spine.RegionAttachment.ULX], y2 = tempVerts[Spine.RegionAttachment.ULY];
                            var x3 = tempVerts[Spine.RegionAttachment.URX], y3 = tempVerts[Spine.RegionAttachment.URY];
                            var x4 = tempVerts[Spine.RegionAttachment.BRX], y4 = tempVerts[Spine.RegionAttachment.BRY];
                            vbi[vertexIndex].x = x1;
                            vbi[vertexIndex].y = y1;
                            vbi[vertexIndex].z = z;
                            vbi[((vertexIndex + 1) | 0)].x = x4;
                            vbi[((vertexIndex + 1) | 0)].y = y4;
                            vbi[((vertexIndex + 1) | 0)].z = z;
                            vbi[((vertexIndex + 2) | 0)].x = x2;
                            vbi[((vertexIndex + 2) | 0)].y = y2;
                            vbi[((vertexIndex + 2) | 0)].z = z;
                            vbi[((vertexIndex + 3) | 0)].x = x3;
                            vbi[((vertexIndex + 3) | 0)].y = y3;
                            vbi[((vertexIndex + 3) | 0)].z = z;

                            if (settings.pmaVertexColors) {
                                color.a = Bridge.Int.clipu8(a * slot1.a * regionAttachment1.a * 255);
                                color.r = Bridge.Int.clipu8(r * slot1.r * regionAttachment1.r * color.a);
                                color.g = Bridge.Int.clipu8(g * slot1.g * regionAttachment1.g * color.a);
                                color.b = Bridge.Int.clipu8(b * slot1.b * regionAttachment1.b * color.a);
                                if (slot1.data.blendMode === Spine.BlendMode.Additive && !canvasGroupTintBlack) {
                                    color.a = 0;
                                }
                            } else {
                                color.a = Bridge.Int.clipu8(a * slot1.a * regionAttachment1.a * 255);
                                color.r = Bridge.Int.clipu8(r * slot1.r * regionAttachment1.r * 255);
                                color.g = Bridge.Int.clipu8(g * slot1.g * regionAttachment1.g * 255);
                                color.b = Bridge.Int.clipu8(b * slot1.b * regionAttachment1.b * 255);
                            }

                            cbi[vertexIndex] = color.$clone();
                            cbi[((vertexIndex + 1) | 0)] = color.$clone();
                            cbi[((vertexIndex + 2) | 0)] = color.$clone();
                            cbi[((vertexIndex + 3) | 0)] = color.$clone();

                            var regionUVs = regionAttachment1.uvs;
                            ubi[vertexIndex].x = regionUVs[Spine.RegionAttachment.BLX];
                            ubi[vertexIndex].y = regionUVs[Spine.RegionAttachment.BLY];
                            ubi[((vertexIndex + 1) | 0)].x = regionUVs[Spine.RegionAttachment.BRX];
                            ubi[((vertexIndex + 1) | 0)].y = regionUVs[Spine.RegionAttachment.BRY];
                            ubi[((vertexIndex + 2) | 0)].x = regionUVs[Spine.RegionAttachment.ULX];
                            ubi[((vertexIndex + 2) | 0)].y = regionUVs[Spine.RegionAttachment.ULY];
                            ubi[((vertexIndex + 3) | 0)].x = regionUVs[Spine.RegionAttachment.URX];
                            ubi[((vertexIndex + 3) | 0)].y = regionUVs[Spine.RegionAttachment.URY];

                            if (x1 < bmin.x) {
                                bmin.x = x1;
                            } // Potential first attachment bounds initialization. Initial min should not block initial max. Same for Y below.
                            if (x1 > bmax.x) {
                                bmax.x = x1;
                            }
                            if (x2 < bmin.x) {
                                bmin.x = x2;
                            } else {
                                if (x2 > bmax.x) {
                                    bmax.x = x2;
                                }
                            }
                            if (x3 < bmin.x) {
                                bmin.x = x3;
                            } else {
                                if (x3 > bmax.x) {
                                    bmax.x = x3;
                                }
                            }
                            if (x4 < bmin.x) {
                                bmin.x = x4;
                            } else {
                                if (x4 > bmax.x) {
                                    bmax.x = x4;
                                }
                            }

                            if (y1 < bmin.y) {
                                bmin.y = y1;
                            }
                            if (y1 > bmax.y) {
                                bmax.y = y1;
                            }
                            if (y2 < bmin.y) {
                                bmin.y = y2;
                            } else {
                                if (y2 > bmax.y) {
                                    bmax.y = y2;
                                }
                            }
                            if (y3 < bmin.y) {
                                bmin.y = y3;
                            } else {
                                if (y3 > bmax.y) {
                                    bmax.y = y3;
                                }
                            }
                            if (y4 < bmin.y) {
                                bmin.y = y4;
                            } else {
                                if (y4 > bmax.y) {
                                    bmax.y = y4;
                                }
                            }

                            vertexIndex = (vertexIndex + 4) | 0;
                        } else { //if (settings.renderMeshes) {
                            var meshAttachment1 = Bridge.as(attachment1, Spine.MeshAttachment);
                            if (meshAttachment1 != null) {
                                var meshVertexCount1 = meshAttachment1.worldVerticesLength;
                                if (tempVerts.length < meshVertexCount1) {
                                    this.tempVerts = (tempVerts = System.Array.init(meshVertexCount1, 0, System.Single));
                                }
                                meshAttachment1.ComputeWorldVertices$1(slot1, tempVerts);

                                if (settings.pmaVertexColors) {
                                    color.a = Bridge.Int.clipu8(a * slot1.a * meshAttachment1.a * 255);
                                    color.r = Bridge.Int.clipu8(r * slot1.r * meshAttachment1.r * color.a);
                                    color.g = Bridge.Int.clipu8(g * slot1.g * meshAttachment1.g * color.a);
                                    color.b = Bridge.Int.clipu8(b * slot1.b * meshAttachment1.b * color.a);
                                    if (slot1.data.blendMode === Spine.BlendMode.Additive && !canvasGroupTintBlack) {
                                        color.a = 0;
                                    }
                                } else {
                                    color.a = Bridge.Int.clipu8(a * slot1.a * meshAttachment1.a * 255);
                                    color.r = Bridge.Int.clipu8(r * slot1.r * meshAttachment1.r * 255);
                                    color.g = Bridge.Int.clipu8(g * slot1.g * meshAttachment1.g * 255);
                                    color.b = Bridge.Int.clipu8(b * slot1.b * meshAttachment1.b * 255);
                                }

                                var attachmentUVs = meshAttachment1.uvs;

                                // Potential first attachment bounds initialization. See conditions in RegionAttachment logic.
                                if (vertexIndex === 0) {
                                    // Initial min should not block initial max.
                                    // vi == vertexIndex does not always mean the bounds are fresh. It could be a submesh. Do not nuke old values by omitting the check.
                                    // Should know that this is the first attachment in the submesh. slotIndex == startSlot could be an empty slot.
                                    var fx = tempVerts[0], fy = tempVerts[1];
                                    if (fx < bmin.x) {
                                        bmin.x = fx;
                                    }
                                    if (fx > bmax.x) {
                                        bmax.x = fx;
                                    }
                                    if (fy < bmin.y) {
                                        bmin.y = fy;
                                    }
                                    if (fy > bmax.y) {
                                        bmax.y = fy;
                                    }
                                }

                                for (var iii1 = 0; iii1 < meshVertexCount1; iii1 = (iii1 + 2) | 0) {
                                    var x = tempVerts[iii1], y = tempVerts[((iii1 + 1) | 0)];
                                    vbi[vertexIndex].x = x;
                                    vbi[vertexIndex].y = y;
                                    vbi[vertexIndex].z = z;
                                    cbi[vertexIndex] = color.$clone();
                                    ubi[vertexIndex].x = attachmentUVs[iii1];
                                    ubi[vertexIndex].y = attachmentUVs[((iii1 + 1) | 0)];

                                    if (x < bmin.x) {
                                        bmin.x = x;
                                    } else {
                                        if (x > bmax.x) {
                                            bmax.x = x;
                                        }
                                    }

                                    if (y < bmin.y) {
                                        bmin.y = y;
                                    } else {
                                        if (y > bmax.y) {
                                            bmax.y = y;
                                        }
                                    }

                                    vertexIndex = (vertexIndex + 1) | 0;
                                }
                            }
                        }
                    }
                }

                this.meshBoundsMin = bmin.$clone();
                this.meshBoundsMax = bmax.$clone();
                this.meshBoundsThickness = lastSlotIndex * settings.zSpacing;

                var submeshInstructionCount = instruction.submeshInstructions.Count;
                this.submeshes.Count = submeshInstructionCount;

                // Add triangles
                if (updateTriangles) {
                    // Match submesh buffers count with submeshInstruction count.
                    if (this.submeshes.Items.length < submeshInstructionCount) {
                        this.submeshes.Resize(submeshInstructionCount);
                        for (var i = 0, n1 = submeshInstructionCount; i < n1; i = (i + 1) | 0) {
                            var submeshBuffer = ($t2 = this.submeshes.Items)[i];
                            if (submeshBuffer == null) {
                                ($t3 = this.submeshes.Items)[i] = new (Spine.ExposedList$1(System.Int32)).ctor();
                            } else {
                                submeshBuffer.Clear(false);
                            }
                        }
                    }

                    var submeshInstructionsItems = instruction.submeshInstructions.Items; // This relies on the resize above.

                    // Fill the buffers.
                    var attachmentFirstVertex = 0;
                    for (var smbi = 0; smbi < submeshInstructionCount; smbi = (smbi + 1) | 0) {
                        var submeshInstruction = submeshInstructionsItems[smbi].$clone();
                        var currentSubmeshBuffer = ($t4 = this.submeshes.Items)[smbi];
                        { //submesh.Resize(submesh.rawTriangleCount);
                            var newTriangleCount = submeshInstruction.rawTriangleCount;
                            if (newTriangleCount > currentSubmeshBuffer.Items.length) {
                                System.Array.resize(Bridge.ref(currentSubmeshBuffer, "Items"), newTriangleCount, 0, System.Int32);
                            } else {
                                if (newTriangleCount < currentSubmeshBuffer.Items.length) {
                                    // Zero the extra.
                                    var sbi = currentSubmeshBuffer.Items;
                                    for (var ei = newTriangleCount, nn = sbi.length; ei < nn; ei = (ei + 1) | 0) {
                                        sbi[ei] = 0;
                                    }
                                }
                            }
                            currentSubmeshBuffer.Count = newTriangleCount;
                        }

                        var tris = currentSubmeshBuffer.Items;
                        var triangleIndex = 0;
                        var skeleton1 = submeshInstruction.skeleton;
                        var drawOrderItems1 = skeleton1.drawOrder.Items;
                        for (var slotIndex2 = submeshInstruction.startSlot, endSlot1 = submeshInstruction.endSlot; slotIndex2 < endSlot1; slotIndex2 = (slotIndex2 + 1) | 0) {
                            var slot2 = drawOrderItems1[slotIndex2];
                            if (!slot2.bone.active) {
                                continue;
                            }

                            var attachment2 = drawOrderItems1[slotIndex2].attachment;
                            if (Bridge.is(attachment2, Spine.RegionAttachment)) {
                                tris[triangleIndex] = attachmentFirstVertex;
                                tris[((triangleIndex + 1) | 0)] = (attachmentFirstVertex + 2) | 0;
                                tris[((triangleIndex + 2) | 0)] = (attachmentFirstVertex + 1) | 0;
                                tris[((triangleIndex + 3) | 0)] = (attachmentFirstVertex + 2) | 0;
                                tris[((triangleIndex + 4) | 0)] = (attachmentFirstVertex + 3) | 0;
                                tris[((triangleIndex + 5) | 0)] = (attachmentFirstVertex + 1) | 0;
                                triangleIndex = (triangleIndex + 6) | 0;
                                attachmentFirstVertex = (attachmentFirstVertex + 4) | 0;
                                continue;
                            }
                            var meshAttachment2 = Bridge.as(attachment2, Spine.MeshAttachment);
                            if (meshAttachment2 != null) {
                                var attachmentTriangles = meshAttachment2.triangles;
                                for (var ii = 0, nn1 = attachmentTriangles.length; ii < nn1; ii = (ii + 1) | 0, triangleIndex = (triangleIndex + 1) | 0) {
                                    tris[triangleIndex] = (attachmentFirstVertex + attachmentTriangles[ii]) | 0;
                                }
                                attachmentFirstVertex = (attachmentFirstVertex + (meshAttachment2.worldVerticesLength >> 1)) | 0; // length/2;
                            }
                        }
                    }
                }
            },
            /*Spine.Unity.MeshGenerator.BuildMeshWithArrays end.*/

            /*Spine.Unity.MeshGenerator.ScaleVertexData start.*/
            ScaleVertexData: function (scale) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#ScaleVertexData", this ); }

                var vbi = this.vertexBuffer.Items;
                for (var i = 0, n = this.vertexBuffer.Count; i < n; i = (i + 1) | 0) {
                    vbi[i] = vbi[i].$clone().clone().scale( scale ); // vbi[i].x *= scale; vbi[i].y *= scale;
                }

                this.meshBoundsMin = this.meshBoundsMin.$clone().scale( scale );
                this.meshBoundsMax = this.meshBoundsMax.$clone().scale( scale );
                this.meshBoundsThickness *= scale;
            },
            /*Spine.Unity.MeshGenerator.ScaleVertexData end.*/

            /*Spine.Unity.MeshGenerator.AddAttachmentTintBlack start.*/
            AddAttachmentTintBlack: function (r2, g2, b2, a, vertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#AddAttachmentTintBlack", this ); }

                var rg = new pc.Vec2( r2, g2 );
                var bo = new pc.Vec2( b2, a );

                var ovc = this.vertexBuffer.Count;
                var newVertexCount = (ovc + vertexCount) | 0;
                {
                    if (this.uv2 == null) {
                        this.uv2 = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                        this.uv3 = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                    }
                    if (newVertexCount > this.uv2.Items.length) { // Manual ExposedList.Resize()
                        System.Array.resize(Bridge.ref(this.uv2, "Items"), newVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector2);
                        }, UnityEngine.Vector2);
                        System.Array.resize(Bridge.ref(this.uv3, "Items"), newVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector2);
                        }, UnityEngine.Vector2);
                    }
                    this.uv2.Count = (this.uv3.Count = newVertexCount, newVertexCount);
                }

                var uv2i = this.uv2.Items;
                var uv3i = this.uv3.Items;
                for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                    uv2i[((ovc + i) | 0)] = rg.$clone();
                    uv3i[((ovc + i) | 0)] = bo.$clone();
                }
            },
            /*Spine.Unity.MeshGenerator.AddAttachmentTintBlack end.*/

            /*Spine.Unity.MeshGenerator.FillVertexData start.*/
            FillVertexData: function (mesh) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillVertexData", this ); }

                var $t;
                var vbi = this.vertexBuffer.Items;
                var ubi = this.uvBuffer.Items;
                var cbi = this.colorBuffer.Items;
                var vbiLength = vbi.length;

                // Zero the extra.
                {
                    var listCount = this.vertexBuffer.Count;
                    var vector3zero = pc.Vec3.ZERO.clone();
                    for (var i = listCount; i < vbiLength; i = (i + 1) | 0) {
                        vbi[i] = vector3zero.$clone();
                    }
                }

                // Set the vertex buffer.
                {
                    mesh.vertices = vbi;
                    mesh.uv = ubi;
                    mesh.colors32 = cbi;

                    if ((Math.abs(this.meshBoundsMin.x) === Number.POSITIVE_INFINITY)) { // meshBoundsMin.x == BoundsMinDefault // == doesn't work on float Infinity constants.
                        mesh.bounds = new pc.BoundingBox.ctor();
                    } else {
                        //mesh.bounds = ArraysMeshGenerator.ToBounds(meshBoundsMin, meshBoundsMax);
                        var halfWidth = (this.meshBoundsMax.x - this.meshBoundsMin.x) * 0.5;
                        var halfHeight = (this.meshBoundsMax.y - this.meshBoundsMin.y) * 0.5;
                        mesh.bounds = ($t = new pc.BoundingBox.ctor(), $t.center = new pc.Vec3( this.meshBoundsMin.x + halfWidth, this.meshBoundsMin.y + halfHeight, 0 ), $t.halfExtents = new pc.Vec3( halfWidth, halfHeight, this.meshBoundsThickness * 0.5 ), $t);
                    }
                }

                {
                    if (this.settings.addNormals) {
                        var oldLength = 0;

                        if (this.normals == null) {
                            this.normals = System.Array.init(vbiLength, function (){
                                return new UnityEngine.Vector3();
                            }, UnityEngine.Vector3);
                        } else {
                            oldLength = this.normals.length;
                        }

                        if (oldLength !== vbiLength) {
                            System.Array.resize(Bridge.ref(this, "normals"), vbiLength, function () {
                                return Bridge.getDefaultValue(UnityEngine.Vector3);
                            }, UnityEngine.Vector3);
                            var localNormals = this.normals;
                            for (var i1 = oldLength; i1 < vbiLength; i1 = (i1 + 1) | 0) {
                                localNormals[i1] = new pc.Vec3( 0, 0, -1 );
                            }
                        }
                        mesh.normals = this.normals;
                    }

                    if (this.settings.tintBlack) {
                        if (this.uv2 != null) {
                            // Sometimes, the vertex buffer becomes smaller. We need to trim the size of the tint black buffers to match.
                            if (vbiLength !== this.uv2.Items.length) {
                                System.Array.resize(Bridge.ref(this.uv2, "Items"), vbiLength, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                                System.Array.resize(Bridge.ref(this.uv3, "Items"), vbiLength, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                                this.uv2.Count = (this.uv3.Count = vbiLength, vbiLength);
                            }
                            mesh.uv2 = this.uv2.Items;
                            mesh.uv3 = this.uv3.Items;
                        }
                    }
                }
            },
            /*Spine.Unity.MeshGenerator.FillVertexData end.*/

            /*Spine.Unity.MeshGenerator.FillLateVertexData start.*/
            FillLateVertexData: function (mesh) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillLateVertexData", this ); }

                if (this.settings.calculateTangents) {
                    var vertexCount = this.vertexBuffer.Count;
                    var sbi = this.submeshes.Items;
                    var submeshCount = this.submeshes.Count;
                    var vbi = this.vertexBuffer.Items;
                    var ubi = this.uvBuffer.Items;

                    Spine.Unity.MeshGenerator.SolveTangents2DEnsureSize(Bridge.ref(this, "tangents"), Bridge.ref(this, "tempTanBuffer"), vertexCount, vbi.length);
                    for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                        var submesh = sbi[i].Items;
                        var triangleCount = sbi[i].Count;
                        Spine.Unity.MeshGenerator.SolveTangents2DTriangles(this.tempTanBuffer, submesh, triangleCount, vbi, ubi, vertexCount);
                    }
                    Spine.Unity.MeshGenerator.SolveTangents2DBuffer(this.tangents, this.tempTanBuffer, vertexCount);
                    mesh.tangents = this.tangents;
                }
            },
            /*Spine.Unity.MeshGenerator.FillLateVertexData end.*/

            /*Spine.Unity.MeshGenerator.FillTriangles start.*/
            FillTriangles: function (mesh) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillTriangles", this ); }

                var submeshCount = this.submeshes.Count;
                var submeshesItems = this.submeshes.Items;
                mesh.subMeshCount = submeshCount;

                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    mesh.SetTriangles$4(submeshesItems[i].Items, 0, submeshesItems[i].Count, i, false);
                }
            },
            /*Spine.Unity.MeshGenerator.FillTriangles end.*/

            /*Spine.Unity.MeshGenerator.EnsureVertexCapacity start.*/
            EnsureVertexCapacity: function (minimumVertexCount, inlcudeTintBlack, includeTangents, includeNormals) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#EnsureVertexCapacity", this ); }

                if (inlcudeTintBlack === void 0) { inlcudeTintBlack = false; }
                if (includeTangents === void 0) { includeTangents = false; }
                if (includeNormals === void 0) { includeNormals = false; }
                if (minimumVertexCount > this.vertexBuffer.Items.length) {
                    System.Array.resize(Bridge.ref(this.vertexBuffer, "Items"), minimumVertexCount, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector3);
                    }, UnityEngine.Vector3);
                    System.Array.resize(Bridge.ref(this.uvBuffer, "Items"), minimumVertexCount, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector2);
                    }, UnityEngine.Vector2);
                    System.Array.resize(Bridge.ref(this.colorBuffer, "Items"), minimumVertexCount, function () {
                        return Bridge.getDefaultValue(UnityEngine.Color32);
                    }, UnityEngine.Color32);

                    if (inlcudeTintBlack) {
                        if (this.uv2 == null) {
                            this.uv2 = new (Spine.ExposedList$1(UnityEngine.Vector2)).$ctor3(minimumVertexCount);
                            this.uv3 = new (Spine.ExposedList$1(UnityEngine.Vector2)).$ctor3(minimumVertexCount);
                        }
                        this.uv2.Resize(minimumVertexCount);
                        this.uv3.Resize(minimumVertexCount);
                    }

                    if (includeNormals) {
                        if (this.normals == null) {
                            this.normals = System.Array.init(minimumVertexCount, function (){
                                return new UnityEngine.Vector3();
                            }, UnityEngine.Vector3);
                        } else {
                            System.Array.resize(Bridge.ref(this, "normals"), minimumVertexCount, function () {
                                return Bridge.getDefaultValue(UnityEngine.Vector3);
                            }, UnityEngine.Vector3);
                        }

                    }

                    if (includeTangents) {
                        if (this.tangents == null) {
                            this.tangents = System.Array.init(minimumVertexCount, function (){
                                return new UnityEngine.Vector4();
                            }, UnityEngine.Vector4);
                        } else {
                            System.Array.resize(Bridge.ref(this, "tangents"), minimumVertexCount, function () {
                                return Bridge.getDefaultValue(UnityEngine.Vector4);
                            }, UnityEngine.Vector4);
                        }
                    }
                }
            },
            /*Spine.Unity.MeshGenerator.EnsureVertexCapacity end.*/

            /*Spine.Unity.MeshGenerator.TrimExcess start.*/
            /**
             * Trims internal buffers to reduce the resulting mesh data stream size.
             *
             * @instance
             * @public
             * @this Spine.Unity.MeshGenerator
             * @memberof Spine.Unity.MeshGenerator
             * @return  {void}
             */
            TrimExcess: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#TrimExcess", this ); }

                this.vertexBuffer.TrimExcess();
                this.uvBuffer.TrimExcess();
                this.colorBuffer.TrimExcess();

                if (this.uv2 != null) {
                    this.uv2.TrimExcess();
                }
                if (this.uv3 != null) {
                    this.uv3.TrimExcess();
                }

                var vbiLength = this.vertexBuffer.Items.length;
                if (this.normals != null) {
                    System.Array.resize(Bridge.ref(this, "normals"), vbiLength, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector3);
                    }, UnityEngine.Vector3);
                }
                if (this.tangents != null) {
                    System.Array.resize(Bridge.ref(this, "tangents"), vbiLength, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector4);
                    }, UnityEngine.Vector4);
                }
            },
            /*Spine.Unity.MeshGenerator.TrimExcess end.*/


        }
    });
    /*Spine.Unity.MeshGenerator end.*/

    /*Spine.Unity.MeshGenerator+Settings start.*/
    Bridge.define("Spine.Unity.MeshGenerator.Settings", {
        $kind: 1004,
        statics: {
            props: {
                Default: {
                    get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#Default#get", this ); }

                        var $t;
                        return ($t = new Spine.Unity.MeshGenerator.Settings(), $t.pmaVertexColors = true, $t.zSpacing = 0.0, $t.useClipping = true, $t.tintBlack = false, $t.calculateTangents = false, $t.addNormals = false, $t.immutableTriangles = false, $t);
                    }
                }
            },
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#getDefaultValue", this ); }
 return new Spine.Unity.MeshGenerator.Settings(); }
            }
        },
        fields: {
            useClipping: false,
            zSpacing: 0,
            pmaVertexColors: false,
            tintBlack: false,
            canvasGroupTintBlack: false,
            calculateTangents: false,
            addNormals: false,
            immutableTriangles: false
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#getHashCode", this ); }

                var h = Bridge.addHash([3889943484, this.useClipping, this.zSpacing, this.pmaVertexColors, this.tintBlack, this.canvasGroupTintBlack, this.calculateTangents, this.addNormals, this.immutableTriangles]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.MeshGenerator.Settings)) {
                    return false;
                }
                return Bridge.equals(this.useClipping, o.useClipping) && Bridge.equals(this.zSpacing, o.zSpacing) && Bridge.equals(this.pmaVertexColors, o.pmaVertexColors) && Bridge.equals(this.tintBlack, o.tintBlack) && Bridge.equals(this.canvasGroupTintBlack, o.canvasGroupTintBlack) && Bridge.equals(this.calculateTangents, o.calculateTangents) && Bridge.equals(this.addNormals, o.addNormals) && Bridge.equals(this.immutableTriangles, o.immutableTriangles);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#$clone", this ); }

                var s = to || new Spine.Unity.MeshGenerator.Settings();
                s.useClipping = this.useClipping;
                s.zSpacing = this.zSpacing;
                s.pmaVertexColors = this.pmaVertexColors;
                s.tintBlack = this.tintBlack;
                s.canvasGroupTintBlack = this.canvasGroupTintBlack;
                s.calculateTangents = this.calculateTangents;
                s.addNormals = this.addNormals;
                s.immutableTriangles = this.immutableTriangles;
                return s;
            }
        }
    });
    /*Spine.Unity.MeshGenerator+Settings end.*/

    /*Spine.Unity.MeshGeneratorBuffers start.*/
    Bridge.define("Spine.Unity.MeshGeneratorBuffers", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#getDefaultValue", this ); }
 return new Spine.Unity.MeshGeneratorBuffers(); }
            }
        },
        fields: {
            /**
             * The vertex count that will actually be used for the mesh. The Lengths of the buffer arrays may be larger than this number.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type number
             */
            vertexCount: 0,
            /**
             * Vertex positions. To be used for UnityEngine.Mesh.vertices.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type Array.<UnityEngine.Vector3>
             */
            vertexBuffer: null,
            /**
             * Vertex UVs. To be used for UnityEngine.Mesh.uvs.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type Array.<UnityEngine.Vector2>
             */
            uvBuffer: null,
            /**
             * Vertex colors. To be used for UnityEngine.Mesh.colors32.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type Array.<UnityEngine.Color32>
             */
            colorBuffer: null,
            /**
             * The Spine rendering component's MeshGenerator.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type Spine.Unity.MeshGenerator
             */
            meshGenerator: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#getHashCode", this ); }

                var h = Bridge.addHash([8979862494, this.vertexCount, this.vertexBuffer, this.uvBuffer, this.colorBuffer, this.meshGenerator]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.MeshGeneratorBuffers)) {
                    return false;
                }
                return Bridge.equals(this.vertexCount, o.vertexCount) && Bridge.equals(this.vertexBuffer, o.vertexBuffer) && Bridge.equals(this.uvBuffer, o.uvBuffer) && Bridge.equals(this.colorBuffer, o.colorBuffer) && Bridge.equals(this.meshGenerator, o.meshGenerator);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#$clone", this ); }

                var s = to || new Spine.Unity.MeshGeneratorBuffers();
                s.vertexCount = this.vertexCount;
                s.vertexBuffer = this.vertexBuffer;
                s.uvBuffer = this.uvBuffer;
                s.colorBuffer = this.colorBuffer;
                s.meshGenerator = this.meshGenerator;
                return s;
            }
        }
    });
    /*Spine.Unity.MeshGeneratorBuffers end.*/

    /*Spine.Unity.MeshRendererBuffers start.*/
    /**
     * A double-buffered Mesh, and a shared material array, bundled for use by Spine components that need to push a Mesh and materials to a Unity MeshRenderer and MeshFilter.
     *
     * @public
     * @class Spine.Unity.MeshRendererBuffers
     * @implements  System.IDisposable
     */
    Bridge.define("Spine.Unity.MeshRendererBuffers", {
        inherits: [System.IDisposable],
        fields: {
            doubleBufferedMesh: null,
            submeshMaterials: null,
            sharedMaterials: null
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#init", this ); }

                this.submeshMaterials = new (Spine.ExposedList$1(UnityEngine.Material)).ctor();
                this.sharedMaterials = System.Array.init(0, null, UnityEngine.Material);
            }
        },
        methods: {
            /*Spine.Unity.MeshRendererBuffers.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#Initialize", this ); }

                if (this.doubleBufferedMesh != null) {
                    this.doubleBufferedMesh.GetNext().Clear();
                    this.doubleBufferedMesh.GetNext().Clear();
                    this.submeshMaterials.Clear();
                } else {
                    this.doubleBufferedMesh = new (Spine.Unity.DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh))();
                }
            },
            /*Spine.Unity.MeshRendererBuffers.Initialize end.*/

            /*Spine.Unity.MeshRendererBuffers.GetUpdatedSharedMaterialsArray start.*/
            /**
             * Returns a sharedMaterials array for use on a MeshRenderer.
             *
             * @instance
             * @public
             * @this Spine.Unity.MeshRendererBuffers
             * @memberof Spine.Unity.MeshRendererBuffers
             * @return  {Array.<UnityEngine.Material>}
             */
            GetUpdatedSharedMaterialsArray: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#GetUpdatedSharedMaterialsArray", this ); }

                if (this.submeshMaterials.Count === this.sharedMaterials.length) {
                    this.submeshMaterials.CopyTo(this.sharedMaterials);
                } else {
                    this.sharedMaterials = this.submeshMaterials.ToArray();
                }

                return this.sharedMaterials;
            },
            /*Spine.Unity.MeshRendererBuffers.GetUpdatedSharedMaterialsArray end.*/

            /*Spine.Unity.MeshRendererBuffers.MaterialsChangedInLastUpdate start.*/
            /**
             * Returns true if the materials were modified since the buffers were last updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.MeshRendererBuffers
             * @memberof Spine.Unity.MeshRendererBuffers
             * @return  {boolean}
             */
            MaterialsChangedInLastUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#MaterialsChangedInLastUpdate", this ); }

                var newSubmeshMaterials = this.submeshMaterials.Count;
                var sharedMaterials = this.sharedMaterials;
                if (newSubmeshMaterials !== sharedMaterials.length) {
                    return true;
                }

                var submeshMaterialsItems = this.submeshMaterials.Items;
                for (var i = 0; i < newSubmeshMaterials; i = (i + 1) | 0) {
                    if (!Bridge.referenceEquals(submeshMaterialsItems[i], sharedMaterials[i])) {
                        return true;
                    }
                } //if (submeshMaterialsItems[i].GetInstanceID() != sharedMaterials[i].GetInstanceID()) return true;

                return false;
            },
            /*Spine.Unity.MeshRendererBuffers.MaterialsChangedInLastUpdate end.*/

            /*Spine.Unity.MeshRendererBuffers.UpdateSharedMaterials start.*/
            /**
             * Updates the internal shared materials array with the given instruction list.
             *
             * @instance
             * @public
             * @this Spine.Unity.MeshRendererBuffers
             * @memberof Spine.Unity.MeshRendererBuffers
             * @param   {Spine.ExposedList$1}    instructions
             * @return  {void}
             */
            UpdateSharedMaterials: function (instructions) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#UpdateSharedMaterials", this ); }

                var newSize = instructions.Count;
                { //submeshMaterials.Resize(instructions.Count);
                    if (newSize > this.submeshMaterials.Items.length) {
                        System.Array.resize(Bridge.ref(this.submeshMaterials, "Items"), newSize, null, UnityEngine.Material);
                    }
                    this.submeshMaterials.Count = newSize;
                }

                var submeshMaterialsItems = this.submeshMaterials.Items;
                var instructionsItems = instructions.Items;
                for (var i = 0; i < newSize; i = (i + 1) | 0) {
                    submeshMaterialsItems[i] = instructionsItems[i].material;
                }
            },
            /*Spine.Unity.MeshRendererBuffers.UpdateSharedMaterials end.*/

            /*Spine.Unity.MeshRendererBuffers.GetNextMesh start.*/
            GetNextMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#GetNextMesh", this ); }

                return this.doubleBufferedMesh.GetNext();
            },
            /*Spine.Unity.MeshRendererBuffers.GetNextMesh end.*/

            /*Spine.Unity.MeshRendererBuffers.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#Clear", this ); }

                this.sharedMaterials = System.Array.init(0, null, UnityEngine.Material);
                this.submeshMaterials.Clear();
            },
            /*Spine.Unity.MeshRendererBuffers.Clear end.*/

            /*Spine.Unity.MeshRendererBuffers.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#Dispose", this ); }

                if (this.doubleBufferedMesh == null) {
                    return;
                }
                this.doubleBufferedMesh.GetNext().Dispose();
                this.doubleBufferedMesh.GetNext().Dispose();
                this.doubleBufferedMesh = null;
            },
            /*Spine.Unity.MeshRendererBuffers.Dispose end.*/


        }
    });
    /*Spine.Unity.MeshRendererBuffers end.*/

    /*Spine.Unity.MeshRendererBuffers+SmartMesh start.*/
    /**
     * This is a Mesh that also stores the instructions SkeletonRenderer generated for it.
     *
     * @public
     * @class Spine.Unity.MeshRendererBuffers.SmartMesh
     * @implements  System.IDisposable
     */
    Bridge.define("Spine.Unity.MeshRendererBuffers.SmartMesh", {
        inherits: [System.IDisposable],
        $kind: 1002,
        fields: {
            mesh: null,
            instructionUsed: null
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers.SmartMesh#init", this ); }

                this.mesh = Spine.Unity.SpineMesh.NewSkeletonMesh();
                this.instructionUsed = new Spine.Unity.SkeletonRendererInstruction();
            }
        },
        methods: {
            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers.SmartMesh#Clear", this ); }

                this.mesh.Clear();
                this.instructionUsed.Clear();
            },
            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Clear end.*/

            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers.SmartMesh#Dispose", this ); }

                if (this.mesh != null) {
                    UnityEngine.Object.Destroy(this.mesh);
                }
                this.mesh = null;
            },
            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Dispose end.*/


        }
    });
    /*Spine.Unity.MeshRendererBuffers+SmartMesh end.*/

    /*Spine.Unity.SkeletonDataAsset start.*/
    Bridge.define("Spine.Unity.SkeletonDataAsset", {
        inherits: [UnityEngine.ScriptableObject],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance:static start.*/
                /**
                 * Creates a runtime SkeletonDataAsset.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonDataAsset
                 * @memberof Spine.Unity.SkeletonDataAsset
                 * @param   {UnityEngine.TextAsset}            skeletonDataFile    
                 * @param   {Spine.Unity.AtlasAssetBase}       atlasAsset          
                 * @param   {boolean}                          initialize          
                 * @param   {number}                           scale
                 * @return  {Spine.Unity.SkeletonDataAsset}
                 */
                CreateRuntimeInstance: function (skeletonDataFile, atlasAsset, initialize, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#CreateRuntimeInstance", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    return Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance$1(skeletonDataFile, System.Array.init([atlasAsset], Spine.Unity.AtlasAssetBase), initialize, scale);
                },
                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance:static end.*/

                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance$1:static start.*/
                /**
                 * Creates a runtime SkeletonDataAsset.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonDataAsset
                 * @memberof Spine.Unity.SkeletonDataAsset
                 * @param   {UnityEngine.TextAsset}                 skeletonDataFile    
                 * @param   {Array.<Spine.Unity.AtlasAssetBase>}    atlasAssets         
                 * @param   {boolean}                               initialize          
                 * @param   {number}                                scale
                 * @return  {Spine.Unity.SkeletonDataAsset}
                 */
                CreateRuntimeInstance$1: function (skeletonDataFile, atlasAssets, initialize, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#CreateRuntimeInstance$1", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    var skeletonDataAsset = UnityEngine.ScriptableObject.CreateInstance(Spine.Unity.SkeletonDataAsset);
                    skeletonDataAsset.Clear();
                    skeletonDataAsset.skeletonJSON = skeletonDataFile;
                    skeletonDataAsset.atlasAssets = atlasAssets;
                    skeletonDataAsset.scale = scale;

                    if (initialize) {
                        skeletonDataAsset.GetSkeletonData(true);
                    }

                    return skeletonDataAsset;
                },
                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance$1:static end.*/

                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData:static start.*/
                ReadSkeletonData: function (bytes, attachmentLoader, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#ReadSkeletonData", this ); }

                    var $t;
                    var input = new System.IO.MemoryStream.$ctor1(bytes);
                    try {
                        var binary = ($t = new Spine.SkeletonBinary.$ctor1(attachmentLoader), $t.Scale = scale, $t);
                        return binary.ReadSkeletonData(input);
                    }
                    finally {
                        if (Bridge.hasValue(input)) {
                            input.System$IDisposable$Dispose();
                        }
                    }
                },
                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData:static end.*/

                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData$1:static start.*/
                ReadSkeletonData$1: function (text, attachmentLoader, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#ReadSkeletonData$1", this ); }

                    var $t;
                    var input = new System.IO.StringReader(text);
                    var json = ($t = new Spine.SkeletonJson.$ctor1(attachmentLoader), $t.Scale = scale, $t);
                    return json.ReadSkeletonData(input);
                },
                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData$1:static end.*/


            }
        },
        fields: {
            atlasAssets: null,
            scale: 0,
            skeletonJSON: null,
            isUpgradingBlendModeMaterials: false,
            blendModeMaterials: null,
            skeletonDataModifiers: null,
            fromAnimation: null,
            toAnimation: null,
            duration: null,
            defaultMix: 0,
            controller: null,
            skeletonData: null,
            stateData: null
        },
        props: {
            IsLoaded: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#IsLoaded#get", this ); }

                    return this.skeletonData != null;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#init", this ); }

                this.atlasAssets = System.Array.init(0, null, Spine.Unity.AtlasAssetBase);
                this.scale = 0.01;
                this.isUpgradingBlendModeMaterials = false;
                this.blendModeMaterials = new Spine.Unity.BlendModeMaterials();
                this.skeletonDataModifiers = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonDataModifierAsset)).ctor();
                this.fromAnimation = System.Array.init(0, null, System.String);
                this.toAnimation = System.Array.init(0, null, System.String);
                this.duration = System.Array.init(0, 0, System.Single);
            }
        },
        methods: {
            /*Spine.Unity.SkeletonDataAsset.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#Reset", this ); }

                this.Clear();
            },
            /*Spine.Unity.SkeletonDataAsset.Reset end.*/

            /*Spine.Unity.SkeletonDataAsset.Clear start.*/
            /**
             * Clears the loaded SkeletonData and AnimationStateData. Use this to force a reload for the next time GetSkeletonData is called.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonDataAsset
             * @memberof Spine.Unity.SkeletonDataAsset
             * @return  {void}
             */
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#Clear", this ); }

                this.skeletonData = null;
                this.stateData = null;
            },
            /*Spine.Unity.SkeletonDataAsset.Clear end.*/

            /*Spine.Unity.SkeletonDataAsset.GetAnimationStateData start.*/
            GetAnimationStateData: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#GetAnimationStateData", this ); }

                if (this.stateData != null) {
                    return this.stateData;
                }
                this.GetSkeletonData(false);
                return this.stateData;
            },
            /*Spine.Unity.SkeletonDataAsset.GetAnimationStateData end.*/

            /*Spine.Unity.SkeletonDataAsset.GetSkeletonData start.*/
            /**
             * Loads, caches and returns the SkeletonData from the skeleton data file. Returns the cached SkeletonData after the first time it is called. Pass false to prevent direct errors from being logged.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonDataAsset
             * @memberof Spine.Unity.SkeletonDataAsset
             * @param   {boolean}               quiet
             * @return  {Spine.SkeletonData}
             */
            GetSkeletonData: function (quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#GetSkeletonData", this ); }

                var $t;
                if (this.skeletonJSON == null) {
                    if (!quiet) {
                        UnityEngine.Debug.LogError$2("Skeleton JSON file not set for SkeletonData asset: " + (this.name || ""), this);
                    }
                    this.Clear();
                    return null;
                }

                // Disabled to support attachmentless/skinless SkeletonData.
                //			if (atlasAssets == null) {
                //				atlasAssets = new AtlasAsset[0];
                //				if (!quiet)
                //					Debug.LogError("Atlas not set for SkeletonData asset: " + name, this);
                //				Clear();
                //				return null;
                //			}
                //			#if !SPINE_TK2D
                //			if (atlasAssets.Length == 0) {
                //				Clear();
                //				return null;
                //			}
                //			#else
                //			if (atlasAssets.Length == 0 && spriteCollection == null) {
                //				Clear();
                //				return null;
                //			}
                //			#endif

                if (this.skeletonData != null) {
                    return this.skeletonData;
                }

                var attachmentLoader;
                var skeletonDataScale;
                var atlasArray = this.GetAtlasArray();

                attachmentLoader = (atlasArray.length === 0) ? Bridge.cast(new Spine.Unity.RegionlessAttachmentLoader(), Spine.AttachmentLoader) : Bridge.cast(new Spine.AtlasAttachmentLoader(atlasArray), Spine.AttachmentLoader);
                skeletonDataScale = this.scale;

                var hasBinaryExtension = System.String.contains(this.skeletonJSON.name.toLowerCase(),".skel");
                var loadedSkeletonData = null;

                try {
                    if (hasBinaryExtension) {
                        loadedSkeletonData = Spine.Unity.SkeletonDataAsset.ReadSkeletonData(this.skeletonJSON.bytes, attachmentLoader, skeletonDataScale);
                    } else {
                        loadedSkeletonData = Spine.Unity.SkeletonDataAsset.ReadSkeletonData$1(this.skeletonJSON.text, attachmentLoader, skeletonDataScale);
                    }
                } catch (ex) {
                    ex = System.Exception.create(ex);
                    if (!quiet) {
                        UnityEngine.Debug.LogError$2("Error reading skeleton JSON file for SkeletonData asset: " + (this.name || "") + "\n" + (ex.Message || "") + "\n" + (ex.StackTrace || ""), this.skeletonJSON);
                    }
                }

                if (loadedSkeletonData == null) {
                    return null;
                }

                if (this.skeletonDataModifiers != null) {
                    $t = Bridge.getEnumerator(this.skeletonDataModifiers);
                    try {
                        while ($t.moveNext()) {
                            var modifier = $t.Current;
                            if (modifier != null && !(this.isUpgradingBlendModeMaterials && Bridge.is(modifier, Spine.Unity.BlendModeMaterialsAsset))) {
                                modifier.Apply(loadedSkeletonData);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
                if (!this.isUpgradingBlendModeMaterials) {
                    this.blendModeMaterials.ApplyMaterials(loadedSkeletonData);
                }

                this.InitializeWithData(loadedSkeletonData);

                return this.skeletonData;
            },
            /*Spine.Unity.SkeletonDataAsset.GetSkeletonData end.*/

            /*Spine.Unity.SkeletonDataAsset.InitializeWithData start.*/
            InitializeWithData: function (sd) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#InitializeWithData", this ); }

                this.skeletonData = sd;
                this.stateData = new Spine.AnimationStateData(this.skeletonData);
                this.FillStateData();
            },
            /*Spine.Unity.SkeletonDataAsset.InitializeWithData end.*/

            /*Spine.Unity.SkeletonDataAsset.FillStateData start.*/
            FillStateData: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#FillStateData", this ); }

                if (this.stateData != null) {
                    this.stateData.defaultMix = this.defaultMix;

                    for (var i = 0, n = this.fromAnimation.length; i < n; i = (i + 1) | 0) {
                        if (this.fromAnimation[i].length === 0 || this.toAnimation[i].length === 0) {
                            continue;
                        }
                        this.stateData.SetMix$1(this.fromAnimation[i], this.toAnimation[i], this.duration[i]);
                    }
                }
            },
            /*Spine.Unity.SkeletonDataAsset.FillStateData end.*/

            /*Spine.Unity.SkeletonDataAsset.GetAtlasArray start.*/
            GetAtlasArray: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#GetAtlasArray", this ); }

                var returnList = new (System.Collections.Generic.List$1(Spine.Atlas)).$ctor2(this.atlasAssets.length);
                for (var i = 0; i < this.atlasAssets.length; i = (i + 1) | 0) {
                    var aa = this.atlasAssets[i];
                    if (aa == null) {
                        continue;
                    }
                    var a = aa.GetAtlas();
                    if (a == null) {
                        continue;
                    }
                    returnList.add(a);
                }
                return returnList.ToArray();
            },
            /*Spine.Unity.SkeletonDataAsset.GetAtlasArray end.*/


        }
    });
    /*Spine.Unity.SkeletonDataAsset end.*/

    /*Spine.Unity.SkeletonDataCompatibility start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility");
    /*Spine.Unity.SkeletonDataCompatibility end.*/

    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo", {
        $kind: 1002,
        fields: {
            actualVersion: null,
            compatibleVersions: null,
            explicitProblemDescription: null
        },
        methods: {
            /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo.DescriptionString start.*/
            DescriptionString: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo#DescriptionString", this ); }

                var $t, $t1, $t2;
                if (!System.String.isNullOrEmpty(this.explicitProblemDescription)) {
                    return this.explicitProblemDescription;
                }

                var compatibleVersionString = "";
                var optionalOr = null;
                $t = Bridge.getEnumerator(this.compatibleVersions);
                try {
                    while ($t.moveNext()) {
                        var version = $t.Current;
                        compatibleVersionString = (compatibleVersionString || "") + ((System.String.format("{0}{1}.{2}", optionalOr, Bridge.box(version[0], System.Int32), Bridge.box(version[1], System.Int32))) || "");
                        optionalOr = " or ";
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return System.String.format("Skeleton data could not be loaded. Data version: {0}. Required version: {1}.\nPlease re-export skeleton data with Spine {1} or change runtime to version {2}.{3}.", this.actualVersion.rawVersion, compatibleVersionString, Bridge.box(($t1 = this.actualVersion.version)[0], System.Int32), Bridge.box(($t2 = this.actualVersion.version)[1], System.Int32));
            },
            /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo.DescriptionString end.*/


        }
    });
    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo end.*/

    /*Spine.Unity.SkeletonDataCompatibility+SourceType start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility.SourceType", {
        $kind: 1006,
        statics: {
            fields: {
                Json: 0,
                Binary: 1
            }
        }
    });
    /*Spine.Unity.SkeletonDataCompatibility+SourceType end.*/

    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility.VersionInfo", {
        $kind: 1002,
        fields: {
            rawVersion: null,
            version: null,
            sourceType: 0
        }
    });
    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo end.*/

    /*Spine.Unity.SkeletonExtensions start.*/
    Bridge.define("Spine.Unity.SkeletonExtensions", {
        statics: {
            fields: {
                ByteToFloat: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#init", this ); }

                    this.ByteToFloat = 0.003921569;
                }
            },
            methods: {
                /*Spine.Unity.SkeletonExtensions.GetColor$2:static start.*/
                GetColor$2: function (s) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColor$2", this ); }

                    return new pc.Color( s.r, s.g, s.b, s.a );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor$2:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColor$1:static start.*/
                GetColor$1: function (a) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColor$1", this ); }

                    return new pc.Color( a.r, a.g, a.b, a.a );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColor:static start.*/
                GetColor: function (a) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColor", this ); }

                    return new pc.Color( a.r, a.g, a.b, a.a );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColor$3:static start.*/
                GetColor$3: function (s) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColor$3", this ); }

                    return new pc.Color( s.r, s.g, s.b, s.a );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor$3:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColorTintBlack:static start.*/
                GetColorTintBlack: function (s) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColorTintBlack", this ); }

                    return new pc.Color( s.r2, s.g2, s.b2, 1.0 );
                },
                /*Spine.Unity.SkeletonExtensions.GetColorTintBlack:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$4:static start.*/
                SetColor$4: function (skeleton, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$4", this ); }

                    skeleton.A = color.a;
                    skeleton.R = color.r;
                    skeleton.G = color.g;
                    skeleton.B = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$4:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$5:static start.*/
                SetColor$5: function (skeleton, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$5", this ); }

                    skeleton.A = color.a * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    skeleton.R = color.r * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    skeleton.G = color.g * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    skeleton.B = color.b * Spine.Unity.SkeletonExtensions.ByteToFloat;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$5:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$6:static start.*/
                SetColor$6: function (slot, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$6", this ); }

                    slot.A = color.a;
                    slot.R = color.r;
                    slot.G = color.g;
                    slot.B = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$6:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$7:static start.*/
                SetColor$7: function (slot, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$7", this ); }

                    slot.A = color.a * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    slot.R = color.r * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    slot.G = color.g * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    slot.B = color.b * Spine.Unity.SkeletonExtensions.ByteToFloat;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$7:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$2:static start.*/
                SetColor$2: function (attachment, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$2", this ); }

                    attachment.A = color.a;
                    attachment.R = color.r;
                    attachment.G = color.g;
                    attachment.B = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$2:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$3:static start.*/
                SetColor$3: function (attachment, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$3", this ); }

                    attachment.A = color.a * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.R = color.r * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.G = color.g * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.B = color.b * Spine.Unity.SkeletonExtensions.ByteToFloat;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$3:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor:static start.*/
                SetColor: function (attachment, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor", this ); }

                    attachment.A = color.a;
                    attachment.R = color.r;
                    attachment.G = color.g;
                    attachment.B = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$1:static start.*/
                SetColor$1: function (attachment, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$1", this ); }

                    attachment.A = color.a * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.R = color.r * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.G = color.g * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.B = color.b * Spine.Unity.SkeletonExtensions.ByteToFloat;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetLocalScale:static start.*/
                /**
                 * Sets the Skeleton's local scale using a UnityEngine.Vector2. If only individual components need to be set, set Skeleton.ScaleX or Skeleton.ScaleY.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Skeleton}         skeleton    
                 * @param   {UnityEngine.Vector2}    scale
                 * @return  {void}
                 */
                SetLocalScale: function (skeleton, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetLocalScale", this ); }

                    skeleton.ScaleX = scale.x;
                    skeleton.ScaleY = scale.y;
                },
                /*Spine.Unity.SkeletonExtensions.SetLocalScale:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetMatrix4x4:static start.*/
                /**
                 * Gets the internal bone matrix as a Unity bonespace-to-skeletonspace transformation matrix.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}               bone
                 * @return  {UnityEngine.Matrix4x4}
                 */
                GetMatrix4x4: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetMatrix4x4", this ); }

                    var $t;
                    return ($t = new pc.Mat4.ctor(), $t.e00 = bone.a, $t.e01 = bone.b, $t.e03 = bone.worldX, $t.e10 = bone.c, $t.e11 = bone.d, $t.e13 = bone.worldY, $t.e33 = 1, $t);
                },
                /*Spine.Unity.SkeletonExtensions.GetMatrix4x4:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetLocalPosition:static start.*/
                /**
                 * Sets the bone's (local) X and Y according to a Vector2
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone        
                 * @param   {UnityEngine.Vector2}    position
                 * @return  {void}
                 */
                SetLocalPosition: function (bone, position) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetLocalPosition", this ); }

                    bone.X = position.x;
                    bone.Y = position.y;
                },
                /*Spine.Unity.SkeletonExtensions.SetLocalPosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetLocalPosition$1:static start.*/
                /**
                 * Sets the bone's (local) X and Y according to a Vector3. The z component is ignored.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone        
                 * @param   {UnityEngine.Vector3}    position
                 * @return  {void}
                 */
                SetLocalPosition$1: function (bone, position) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetLocalPosition$1", this ); }

                    bone.X = position.x;
                    bone.Y = position.y;
                },
                /*Spine.Unity.SkeletonExtensions.SetLocalPosition$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalPosition:static start.*/
                /**
                 * Gets the bone's local X and Y as a Vector2.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone
                 * @return  {UnityEngine.Vector2}
                 */
                GetLocalPosition: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetLocalPosition", this ); }

                    return new pc.Vec2( bone.x, bone.y );
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalPosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition:static start.*/
                /**
                 * Gets the position of the bone in Skeleton-space.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone
                 * @return  {UnityEngine.Vector2}
                 */
                GetSkeletonSpacePosition: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetSkeletonSpacePosition", this ); }

                    return new pc.Vec2( bone.worldX, bone.worldY );
                },
                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition$1:static start.*/
                /**
                 * Gets a local offset from the bone and converts it into Skeleton-space.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone         
                 * @param   {UnityEngine.Vector2}    boneLocal
                 * @return  {UnityEngine.Vector2}
                 */
                GetSkeletonSpacePosition$1: function (bone, boneLocal) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetSkeletonSpacePosition$1", this ); }

                    var o = new UnityEngine.Vector2();
                    bone.LocalToWorld(boneLocal.x, boneLocal.y, Bridge.ref(o, "x"), Bridge.ref(o, "y"));
                    return o.$clone();
                },
                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition:static start.*/
                /**
                 * Gets the bone's Unity World position using its Spine GameObject Transform. UpdateWorldTransform needs to have been called for this to return the correct, updated value.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}               bone                        
                 * @param   {UnityEngine.Transform}    spineGameObjectTransform
                 * @return  {UnityEngine.Vector3}
                 */
                GetWorldPosition: function (bone, spineGameObjectTransform) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition", this ); }

                    return spineGameObjectTransform.TransformPoint$1(new pc.Vec3( bone.worldX, bone.worldY, 0 ));
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$1:static start.*/
                GetWorldPosition$1: function (bone, spineGameObjectTransform, positionScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition$1", this ); }

                    return spineGameObjectTransform.TransformPoint$1(new pc.Vec3( bone.worldX * positionScale, bone.worldY * positionScale, 0 ));
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$3:static start.*/
                /**
                 * Gets the PointAttachment's Unity World position using its Spine GameObject Transform.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.PointAttachment}    attachment                  
                 * @param   {Spine.Slot}               slot                        
                 * @param   {UnityEngine.Transform}    spineGameObjectTransform
                 * @return  {UnityEngine.Vector3}
                 */
                GetWorldPosition$3: function (attachment, slot, spineGameObjectTransform) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition$3", this ); }

                    var skeletonSpacePosition = new UnityEngine.Vector3();
                    skeletonSpacePosition.z = 0;
                    attachment.ComputeWorldPosition(slot.bone, Bridge.ref(skeletonSpacePosition, "x"), Bridge.ref(skeletonSpacePosition, "y"));
                    return spineGameObjectTransform.TransformPoint$1(skeletonSpacePosition);
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$3:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$2:static start.*/
                /**
                 * Gets the PointAttachment's Unity World position using its Spine GameObject Transform.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.PointAttachment}    attachment                  
                 * @param   {Spine.Bone}               bone                        
                 * @param   {UnityEngine.Transform}    spineGameObjectTransform
                 * @return  {UnityEngine.Vector3}
                 */
                GetWorldPosition$2: function (attachment, bone, spineGameObjectTransform) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition$2", this ); }

                    var skeletonSpacePosition = new UnityEngine.Vector3();
                    skeletonSpacePosition.z = 0;
                    attachment.ComputeWorldPosition(bone, Bridge.ref(skeletonSpacePosition, "x"), Bridge.ref(skeletonSpacePosition, "y"));
                    return spineGameObjectTransform.TransformPoint$1(skeletonSpacePosition);
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$2:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetQuaternion:static start.*/
                /**
                 * Gets a skeleton space UnityEngine.Quaternion representation of bone.WorldRotationX.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}                bone
                 * @return  {UnityEngine.Quaternion}
                 */
                GetQuaternion: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetQuaternion", this ); }

                    var halfRotation = Math.atan2(bone.c, bone.a) * 0.5;
                    return new pc.Quat( 0, 0, Math.sin(halfRotation), Math.cos(halfRotation) );
                },
                /*Spine.Unity.SkeletonExtensions.GetQuaternion:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalQuaternion:static start.*/
                /**
                 * Gets a bone-local space UnityEngine.Quaternion representation of bone.rotation.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}                bone
                 * @return  {UnityEngine.Quaternion}
                 */
                GetLocalQuaternion: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetLocalQuaternion", this ); }

                    var halfRotation = bone.rotation * UnityEngine.Mathf.Deg2Rad * 0.5;
                    return new pc.Quat( 0, 0, Math.sin(halfRotation), Math.cos(halfRotation) );
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalQuaternion:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalScale:static start.*/
                /**
                 * Returns the Skeleton's local scale as a UnityEngine.Vector2. If only individual components are needed, use Skeleton.ScaleX or Skeleton.ScaleY.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Skeleton}         skeleton
                 * @return  {UnityEngine.Vector2}
                 */
                GetLocalScale: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetLocalScale", this ); }

                    return new pc.Vec2( skeleton.ScaleX, skeleton.ScaleY );
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalScale:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldToLocalMatrix:static start.*/
                /**
                 * Calculates a 2x2 Transformation Matrix that can convert a skeleton-space position to a bone-local position.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}       bone    
                 * @param   {System.Single}    ia      
                 * @param   {System.Single}    ib      
                 * @param   {System.Single}    ic      
                 * @param   {System.Single}    id
                 * @return  {void}
                 */
                GetWorldToLocalMatrix: function (bone, ia, ib, ic, id) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldToLocalMatrix", this ); }

                    var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
                    var invDet = 1 / (a * d - b * c);
                    ia.v = invDet * d;
                    ib.v = invDet * -b;
                    ic.v = invDet * -c;
                    id.v = invDet * a;
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldToLocalMatrix:static end.*/

                /*Spine.Unity.SkeletonExtensions.WorldToLocal:static start.*/
                /**
                 * UnityEngine.Vector2 override of Bone.WorldToLocal. This converts a skeleton-space position into a bone local position.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone             
                 * @param   {UnityEngine.Vector2}    worldPosition
                 * @return  {UnityEngine.Vector2}
                 */
                WorldToLocal: function (bone, worldPosition) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#WorldToLocal", this ); }

                    var o = new UnityEngine.Vector2();
                    bone.WorldToLocal(worldPosition.x, worldPosition.y, Bridge.ref(o, "x"), Bridge.ref(o, "y"));
                    return o.$clone();
                },
                /*Spine.Unity.SkeletonExtensions.WorldToLocal:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetPositionSkeletonSpace:static start.*/
                /**
                 * Sets the skeleton-space position of a bone.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone                     
                 * @param   {UnityEngine.Vector2}    skeletonSpacePosition
                 * @return  {UnityEngine.Vector2}                             The local position in its parent bone space, or in skeleton space if it is the root bone.
                 */
                SetPositionSkeletonSpace: function (bone, skeletonSpacePosition) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetPositionSkeletonSpace", this ); }

                    if (bone.parent == null) { // root bone
                        Spine.Unity.SkeletonExtensions.SetLocalPosition(bone, skeletonSpacePosition.$clone());
                        return skeletonSpacePosition.$clone();
                    } else {
                        var parent = bone.parent;
                        var parentLocal = Spine.Unity.SkeletonExtensions.WorldToLocal(parent, skeletonSpacePosition.$clone());
                        Spine.Unity.SkeletonExtensions.SetLocalPosition(bone, parentLocal.$clone());
                        return parentLocal.$clone();
                    }
                },
                /*Spine.Unity.SkeletonExtensions.SetPositionSkeletonSpace:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetMaterial:static start.*/
                GetMaterial: function (a) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetMaterial", this ); }

                    var rendererObject = null;
                    var renderableAttachment = Bridge.as(a, Spine.IHasRendererObject);
                    if (renderableAttachment != null) {
                        rendererObject = renderableAttachment.Spine$IHasRendererObject$RendererObject;
                    }

                    if (rendererObject == null) {
                        return null;
                    }

                    return Bridge.cast(Bridge.cast(rendererObject, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                },
                /*Spine.Unity.SkeletonExtensions.GetMaterial:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalVertices:static start.*/
                /**
                 * Fills a Vector2 buffer with local vertices.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.VertexAttachment}         va        The VertexAttachment
                 * @param   {Spine.Slot}                     slot      Slot where the attachment belongs.
                 * @param   {Array.<UnityEngine.Vector2>}    buffer    Correctly-sized buffer. Use attachment's .WorldVerticesLength to get the correct size. If null, a new Vector2[] of the correct size will be allocated.
                 * @return  {Array.<UnityEngine.Vector2>}
                 */
                GetLocalVertices: function (va, slot, buffer) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetLocalVertices", this ); }

                    var floatsCount = va.worldVerticesLength;
                    var bufferTargetSize = floatsCount >> 1;
                    buffer = buffer || System.Array.init(bufferTargetSize, function (){
                        return new UnityEngine.Vector2();
                    }, UnityEngine.Vector2);
                    if (buffer.length < bufferTargetSize) {
                        throw new System.ArgumentException.$ctor3(System.String.format("Vector2 buffer too small. {0} requires an array of size {1}. Use the attachment's .WorldVerticesLength to get the correct size.", va.Name, Bridge.box(floatsCount, System.Int32)), "buffer");
                    }

                    if (va.bones == null) {
                        var localVerts = va.vertices;
                        for (var i = 0; i < bufferTargetSize; i = (i + 1) | 0) {
                            var j = Bridge.Int.mul(i, 2);
                            buffer[i] = new pc.Vec2( localVerts[j], localVerts[((j + 1) | 0)] );
                        }
                    } else {
                        var floats = System.Array.init(floatsCount, 0, System.Single);
                        va.ComputeWorldVertices$1(slot, floats);

                        var sb = slot.bone;
                        var ia = { }, ib = { }, ic = { }, id = { }, bwx = sb.worldX, bwy = sb.worldY;
                        Spine.Unity.SkeletonExtensions.GetWorldToLocalMatrix(sb, ia, ib, ic, id);

                        for (var i1 = 0; i1 < bufferTargetSize; i1 = (i1 + 1) | 0) {
                            var j1 = Bridge.Int.mul(i1, 2);
                            var x = floats[j1] - bwx, y = floats[((j1 + 1) | 0)] - bwy;
                            buffer[i1] = new pc.Vec2( x * ia.v + y * ib.v, x * ic.v + y * id.v );
                        }
                    }

                    return buffer;
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalVertices:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldVertices:static start.*/
                /**
                 * Calculates world vertices and fills a Vector2 buffer.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.VertexAttachment}         a         The VertexAttachment
                 * @param   {Spine.Slot}                     slot      Slot where the attachment belongs.
                 * @param   {Array.<UnityEngine.Vector2>}    buffer    Correctly-sized buffer. Use attachment's .WorldVerticesLength to get the correct size. If null, a new Vector2[] of the correct size will be allocated.
                 * @return  {Array.<UnityEngine.Vector2>}
                 */
                GetWorldVertices: function (a, slot, buffer) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldVertices", this ); }

                    var worldVertsLength = a.worldVerticesLength;
                    var bufferTargetSize = worldVertsLength >> 1;
                    buffer = buffer || System.Array.init(bufferTargetSize, function (){
                        return new UnityEngine.Vector2();
                    }, UnityEngine.Vector2);
                    if (buffer.length < bufferTargetSize) {
                        throw new System.ArgumentException.$ctor3(System.String.format("Vector2 buffer too small. {0} requires an array of size {1}. Use the attachment's .WorldVerticesLength to get the correct size.", a.Name, Bridge.box(worldVertsLength, System.Int32)), "buffer");
                    }

                    var floats = System.Array.init(worldVertsLength, 0, System.Single);
                    a.ComputeWorldVertices$1(slot, floats);

                    for (var i = 0, n = worldVertsLength >> 1; i < n; i = (i + 1) | 0) {
                        var j = Bridge.Int.mul(i, 2);
                        buffer[i] = new pc.Vec2( floats[j], floats[((j + 1) | 0)] );
                    }

                    return buffer;
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldVertices:static end.*/


            }
        }
    });
    /*Spine.Unity.SkeletonExtensions end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials start.*/
    Bridge.define("Spine.Unity.SkeletonGraphicCustomMaterials", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonGraphic: null,
            customMaterialOverrides: null,
            customTextureOverrides: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#init", this ); }

                this.customMaterialOverrides = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride)).ctor();
                this.customTextureOverrides = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomMaterialOverrides start.*/
            SetCustomMaterialOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#SetCustomMaterialOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    if (atlasMaterialOverride.overrideEnabled) {
                        this.skeletonGraphic.CustomMaterialOverride.setItem(atlasMaterialOverride.originalTexture, atlasMaterialOverride.replacementMaterial);
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomMaterialOverrides start.*/
            RemoveCustomMaterialOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#RemoveCustomMaterialOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    var currentMaterial = { };

                    if (!this.skeletonGraphic.CustomMaterialOverride.tryGetValue(atlasMaterialOverride.originalTexture, currentMaterial)) {
                        continue;
                    }

                    // Do not revert the material if it was changed by something else
                    if (!Bridge.referenceEquals(currentMaterial.v, atlasMaterialOverride.replacementMaterial)) {
                        continue;
                    }

                    this.skeletonGraphic.CustomMaterialOverride.remove(atlasMaterialOverride.originalTexture);
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomTextureOverrides start.*/
            SetCustomTextureOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#SetCustomTextureOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                for (var i = 0; i < this.customTextureOverrides.Count; i = (i + 1) | 0) {
                    var atlasTextureOverride = this.customTextureOverrides.getItem(i).$clone();
                    if (atlasTextureOverride.overrideEnabled) {
                        this.skeletonGraphic.CustomTextureOverride.setItem(atlasTextureOverride.originalTexture, atlasTextureOverride.replacementTexture);
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomTextureOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomTextureOverrides start.*/
            RemoveCustomTextureOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#RemoveCustomTextureOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                for (var i = 0; i < this.customTextureOverrides.Count; i = (i + 1) | 0) {
                    var atlasTextureOverride = this.customTextureOverrides.getItem(i).$clone();
                    var currentTexture = { };

                    if (!this.skeletonGraphic.CustomTextureOverride.tryGetValue(atlasTextureOverride.originalTexture, currentTexture)) {
                        continue;
                    }

                    // Do not revert the material if it was changed by something else
                    if (!Bridge.referenceEquals(currentTexture.v, atlasTextureOverride.replacementTexture)) {
                        continue;
                    }

                    this.skeletonGraphic.CustomTextureOverride.remove(atlasTextureOverride.originalTexture);
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomTextureOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic = this.GetComponent(Spine.Unity.SkeletonGraphic);
                }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                this.skeletonGraphic.Initialize(false);
                this.SetCustomMaterialOverrides();
                this.SetCustomTextureOverrides();
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnEnable end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                this.RemoveCustomMaterialOverrides();
                this.RemoveCustomTextureOverrides();
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnDisable end.*/


        }
    });
    /*Spine.Unity.SkeletonGraphicCustomMaterials end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride start.*/
    Bridge.define("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#inherits", this ); }
 return [System.IEquatable$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride)]; },
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride(); }
            }
        },
        fields: {
            overrideEnabled: false,
            originalTexture: null,
            replacementMaterial: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonGraphicCustomMaterials$AtlasMaterialOverride$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#equalsT", this ); }

                return this.overrideEnabled === other.overrideEnabled && Bridge.referenceEquals(this.originalTexture, other.originalTexture) && Bridge.referenceEquals(this.replacementMaterial, other.replacementMaterial);
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#getHashCode", this ); }

                var h = Bridge.addHash([8608216668, this.overrideEnabled, this.originalTexture, this.replacementMaterial]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride();
                s.overrideEnabled = this.overrideEnabled;
                s.originalTexture = this.originalTexture;
                s.replacementMaterial = this.replacementMaterial;
                return s;
            }
        },
        overloads: {
            "Equals(AtlasMaterialOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride start.*/
    Bridge.define("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#inherits", this ); }
 return [System.IEquatable$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride)]; },
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride(); }
            }
        },
        fields: {
            overrideEnabled: false,
            originalTexture: null,
            replacementTexture: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonGraphicCustomMaterials$AtlasTextureOverride$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#equalsT", this ); }

                return this.overrideEnabled === other.overrideEnabled && Bridge.referenceEquals(this.originalTexture, other.originalTexture) && Bridge.referenceEquals(this.replacementTexture, other.replacementTexture);
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#getHashCode", this ); }

                var h = Bridge.addHash([8976735721, this.overrideEnabled, this.originalTexture, this.replacementTexture]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride();
                s.overrideEnabled = this.overrideEnabled;
                s.originalTexture = this.originalTexture;
                s.replacementTexture = this.replacementTexture;
                return s;
            }
        },
        overloads: {
            "Equals(AtlasTextureOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator", {
        $kind: 1002,
        statics: {
            fields: {
                WeightEpsilon: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#init", this ); }

                    this.WeightEpsilon = 0.0001;
                }
            },
            methods: {
                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.AnimationTime$1:static start.*/
                AnimationTime$1: function (normalizedTime, clipLength, loop, reversed) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#AnimationTime$1", this ); }

                    var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationTime(normalizedTime, clipLength, reversed);
                    if (loop) {
                        return time;
                    }
                    var EndSnapEpsilon = 0.0333333351; // Workaround for end-duration keys not being applied.
                    return (clipLength - time < EndSnapEpsilon) ? clipLength : time; // return a time snapped to clipLength;
                },
                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.AnimationTime$1:static end.*/

                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.AnimationTime:static start.*/
                AnimationTime: function (normalizedTime, clipLength, reversed) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#AnimationTime", this ); }

                    if (reversed) {
                        normalizedTime = (1 - normalizedTime);
                    }
                    if (normalizedTime < 0.0) {
                        normalizedTime = (normalizedTime % 1.0) + 1.0;
                    }
                    return normalizedTime * clipLength;
                },
                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.AnimationTime:static end.*/


            }
        },
        fields: {
            autoReset: false,
            useCustomMixMode: false,
            layerMixModes: null,
            layerBlendModes: null,
            animationTable: null,
            clipNameHashCodeTable: null,
            previousAnimations: null,
            layerClipInfos: null,
            animator: null
        },
        events: {
            _OnClipApplied: null
        },
        props: {
            Animator: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#Animator#get", this ); }

                    return this.animator;
                }
            },
            MecanimLayerCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#MecanimLayerCount#get", this ); }

                    if (!UnityEngine.Object.op_Implicit(this.animator)) {
                        return 0;
                    }
                    return this.animator.layerCount;
                }
            },
            MecanimLayerNames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#MecanimLayerNames#get", this ); }

                    if (!UnityEngine.Object.op_Implicit(this.animator)) {
                        return System.Array.init(0, null, System.String);
                    }
                    var layerNames = System.Array.init(this.animator.layerCount, null, System.String);
                    for (var i = 0; i < this.animator.layerCount; i = (i + 1) | 0) {
                        layerNames[i] = this.animator.GetLayerName(i);
                    }
                    return layerNames;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#init", this ); }

                this.autoReset = true;
                this.useCustomMixMode = true;
                this.layerMixModes = System.Array.init(0, 0, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode);
                this.layerBlendModes = System.Array.init(0, 0, Spine.MixBlend);
                this.animationTable = new (System.Collections.Generic.Dictionary$2(System.Int32,Spine.Animation)).$ctor3(Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer.Instance);
                this.clipNameHashCodeTable = new (System.Collections.Generic.Dictionary$2(UnityEngine.AnimationClip,System.Int32)).$ctor3(Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer.Instance);
                this.previousAnimations = new (System.Collections.Generic.List$1(Spine.Animation)).ctor();
                this.layerClipInfos = System.Array.init(0, null, Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos);
            }
        },
        methods: {
            addOnClipApplied: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#addOnClipApplied", this ); }

                this.add_OnClipApplied(value);
            },
            removeOnClipApplied: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#removeOnClipApplied", this ); }

                this.remove_OnClipApplied(value);
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Initialize start.*/
            Initialize: function (animator, skeletonDataAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#Initialize", this ); }

                var $t;
                this.animator = animator;

                this.previousAnimations.clear();

                this.animationTable.clear();
                var data = skeletonDataAsset.GetSkeletonData(true);
                $t = Bridge.getEnumerator(data.Animations);
                try {
                    while ($t.moveNext()) {
                        var a = $t.Current;
                        this.animationTable.add(Bridge.getHashCode(a.Name), a);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                this.clipNameHashCodeTable.clear();
                this.ClearClipInfosForLayers();
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Initialize end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyAnimation start.*/
            ApplyAnimation: function (skeleton, info, stateInfo, layerIndex, layerWeight, layerBlendMode, useClipWeight1) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#ApplyAnimation", this ); }

                if (useClipWeight1 === void 0) { useClipWeight1 = false; }
                var weight = info.weight * layerWeight;
                if (weight < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                    return false;
                }

                var clip = this.GetAnimation(info.clip);
                if (clip == null) {
                    return false;
                }

                var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationTime$1(stateInfo.normalizedTime, info.clip.length, info.clip.isLooping, stateInfo.speed < 0);
                weight = useClipWeight1 ? layerWeight : weight;
                clip.Apply(skeleton, 0, time, info.clip.isLooping, null, weight, layerBlendMode, Spine.MixDirection.In);
                if (!Bridge.staticEquals(this._OnClipApplied, null)) {
                    this.OnClipAppliedCallback(clip, stateInfo, layerIndex, time, info.clip.isLooping, weight);
                }
                return true;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyInterruptionAnimation start.*/
            ApplyInterruptionAnimation: function (skeleton, interpolateWeightTo1, info, stateInfo, layerIndex, layerWeight, layerBlendMode, interruptingClipTimeAddition, useClipWeight1) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#ApplyInterruptionAnimation", this ); }

                if (useClipWeight1 === void 0) { useClipWeight1 = false; }

                var clipWeight = interpolateWeightTo1 ? (info.weight + 1.0) * 0.5 : info.weight;
                var weight = clipWeight * layerWeight;
                if (weight < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                    return false;
                }

                var clip = this.GetAnimation(info.clip);
                if (clip == null) {
                    return false;
                }

                var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationTime(stateInfo.normalizedTime + interruptingClipTimeAddition, info.clip.length, stateInfo.speed < 0);
                weight = useClipWeight1 ? layerWeight : weight;
                clip.Apply(skeleton, 0, time, info.clip.isLooping, null, weight, layerBlendMode, Spine.MixDirection.In);
                if (!Bridge.staticEquals(this._OnClipApplied, null)) {
                    this.OnClipAppliedCallback(clip, stateInfo, layerIndex, time, info.clip.isLooping, weight);
                }
                return true;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyInterruptionAnimation end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.OnClipAppliedCallback start.*/
            OnClipAppliedCallback: function (clip, stateInfo, layerIndex, time, isLooping, weight) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#OnClipAppliedCallback", this ); }


                var speedFactor = stateInfo.speedMultiplier * stateInfo.speed;
                var lastTime = time - (UnityEngine.Time.deltaTime * speedFactor);
                if (isLooping && clip.duration !== 0) {
                    time %= clip.duration;
                    lastTime %= clip.duration;
                }
                this._OnClipApplied(clip, layerIndex, weight, time, lastTime, speedFactor < 0);
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.OnClipAppliedCallback end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Apply start.*/
            Apply: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#Apply", this ); }


                if (this.layerMixModes.length < this.animator.layerCount) {
                    var oldSize = this.layerMixModes.length;
                    System.Array.resize(Bridge.ref(this, "layerMixModes"), this.animator.layerCount, 0, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode);
                    for (var layer = oldSize; layer < this.animator.layerCount; layer = (layer + 1) | 0) {
                        var isAdditiveLayer = false;
                        if (layer < this.layerBlendModes.length) {
                            isAdditiveLayer = this.layerBlendModes[layer] === Spine.MixBlend.Add;
                        }
                        this.layerMixModes[layer] = isAdditiveLayer ? Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix : Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.MixNext;
                    }
                }

                this.InitClipInfosForLayers();
                for (var layer1 = 0, n = this.animator.layerCount; layer1 < n; layer1 = (layer1 + 1) | 0) {
                    this.GetStateUpdatesFromAnimator(layer1);
                }

                // Clear Previous
                if (this.autoReset) {
                    var previousAnimations = this.previousAnimations;
                    for (var i = 0, n1 = previousAnimations.Count; i < n1; i = (i + 1) | 0) {
                        Spine.SpineSkeletonExtensions.SetKeyedItemsToSetupPose(previousAnimations.getItem(i), skeleton);
                    }

                    previousAnimations.clear();
                    for (var layer2 = 0, n2 = this.animator.layerCount; layer2 < n2; layer2 = (layer2 + 1) | 0) {
                        var layerWeight = (layer2 === 0) ? 1 : this.animator.GetLayerWeight(layer2); // Animator.GetLayerWeight always returns 0 on the first layer. Should be interpreted as 1.
                        if (layerWeight <= 0) {
                            continue;
                        }

                        var nextStateInfo = this.animator.GetNextAnimatorStateInfo(layer2);

                        var hasNext = nextStateInfo.fullPathHash !== 0;

                        var clipInfoCount = { }, nextClipInfoCount = { }, interruptingClipInfoCount = { };
                        var clipInfo = { }, nextClipInfo = { }, interruptingClipInfo = { };
                        var isInterruptionActive = { }, shallInterpolateWeightTo1 = { };
                        this.GetAnimatorClipInfos(layer2, isInterruptionActive, clipInfoCount, nextClipInfoCount, interruptingClipInfoCount, clipInfo, nextClipInfo, interruptingClipInfo, shallInterpolateWeightTo1);

                        for (var c = 0; c < clipInfoCount.v; c = (c + 1) | 0) {
                            var info = System.Array.getItem(clipInfo.v, c, UnityEngine.AnimatorClipInfo).$clone();
                            var weight = info.weight * layerWeight;
                            if (weight < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                                continue;
                            }
                            var clip = this.GetAnimation(info.clip);
                            if (clip != null) {
                                previousAnimations.add(clip);
                            }
                        }

                        if (hasNext) {
                            for (var c1 = 0; c1 < nextClipInfoCount.v; c1 = (c1 + 1) | 0) {
                                var info1 = System.Array.getItem(nextClipInfo.v, c1, UnityEngine.AnimatorClipInfo).$clone();
                                var weight1 = info1.weight * layerWeight;
                                if (weight1 < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                                    continue;
                                }
                                var clip1 = this.GetAnimation(info1.clip);
                                if (clip1 != null) {
                                    previousAnimations.add(clip1);
                                }
                            }
                        }

                        if (isInterruptionActive.v) {
                            for (var c2 = 0; c2 < interruptingClipInfoCount.v; c2 = (c2 + 1) | 0) {
                                var info2 = System.Array.getItem(interruptingClipInfo.v, c2, UnityEngine.AnimatorClipInfo).$clone();
                                var clipWeight = shallInterpolateWeightTo1.v ? (info2.weight + 1.0) * 0.5 : info2.weight;
                                var weight2 = clipWeight * layerWeight;
                                if (weight2 < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                                    continue;
                                }
                                var clip2 = this.GetAnimation(info2.clip);
                                if (clip2 != null) {
                                    previousAnimations.add(clip2);
                                }
                            }
                        }
                    }
                }

                // Apply
                for (var layer3 = 0, n3 = this.animator.layerCount; layer3 < n3; layer3 = (layer3 + 1) | 0) {
                    var layerWeight1 = (layer3 === 0) ? 1 : this.animator.GetLayerWeight(layer3); // Animator.GetLayerWeight always returns 0 on the first layer. Should be interpreted as 1.

                    var isInterruptionActive1 = { };
                    var stateInfo = { };
                    var nextStateInfo1 = { };
                    var interruptingStateInfo = { };
                    var interruptingClipTimeAddition = { };
                    this.GetAnimatorStateInfos(layer3, isInterruptionActive1, stateInfo, nextStateInfo1, interruptingStateInfo, interruptingClipTimeAddition);

                    var hasNext1 = nextStateInfo1.v.fullPathHash !== 0;

                    var clipInfoCount1 = { }, nextClipInfoCount1 = { }, interruptingClipInfoCount1 = { };
                    var clipInfo1 = { }, nextClipInfo1 = { }, interruptingClipInfo1 = { };
                    var interpolateWeightTo1 = { };
                    this.GetAnimatorClipInfos(layer3, isInterruptionActive1, clipInfoCount1, nextClipInfoCount1, interruptingClipInfoCount1, clipInfo1, nextClipInfo1, interruptingClipInfo1, interpolateWeightTo1);

                    var layerBlendMode = (layer3 < this.layerBlendModes.length) ? this.layerBlendModes[layer3] : Spine.MixBlend.Replace;
                    var mode = this.GetMixMode(layer3, layerBlendMode);
                    if (mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix) {
                        // Always use Mix instead of Applying the first non-zero weighted clip.
                        for (var c3 = 0; c3 < clipInfoCount1.v; c3 = (c3 + 1) | 0) {
                            this.ApplyAnimation(skeleton, System.Array.getItem(clipInfo1.v, c3, UnityEngine.AnimatorClipInfo).$clone(), stateInfo.v, layer3, layerWeight1, layerBlendMode);
                        }
                        if (hasNext1) {
                            for (var c4 = 0; c4 < nextClipInfoCount1.v; c4 = (c4 + 1) | 0) {
                                this.ApplyAnimation(skeleton, System.Array.getItem(nextClipInfo1.v, c4, UnityEngine.AnimatorClipInfo).$clone(), nextStateInfo1.v, layer3, layerWeight1, layerBlendMode);
                            }
                        }
                        if (isInterruptionActive1.v) {
                            for (var c5 = 0; c5 < interruptingClipInfoCount1.v; c5 = (c5 + 1) | 0) {
                                this.ApplyInterruptionAnimation(skeleton, interpolateWeightTo1.v, System.Array.getItem(interruptingClipInfo1.v, c5, UnityEngine.AnimatorClipInfo).$clone(), interruptingStateInfo.v, layer3, layerWeight1, layerBlendMode, interruptingClipTimeAddition.v);
                            }
                        }
                    } else { // case MixNext || Hard
                        // Apply first non-zero weighted clip
                        var c6 = 0;
                        for (; c6 < clipInfoCount1.v; c6 = (c6 + 1) | 0) {
                            if (!this.ApplyAnimation(skeleton, System.Array.getItem(clipInfo1.v, c6, UnityEngine.AnimatorClipInfo).$clone(), stateInfo.v, layer3, layerWeight1, layerBlendMode, true)) {
                                continue;
                            }
                            c6 = (c6 + 1) | 0;
                            break;
                        }
                        // Mix the rest
                        for (; c6 < clipInfoCount1.v; c6 = (c6 + 1) | 0) {
                            this.ApplyAnimation(skeleton, System.Array.getItem(clipInfo1.v, c6, UnityEngine.AnimatorClipInfo).$clone(), stateInfo.v, layer3, layerWeight1, layerBlendMode);
                        }

                        c6 = 0;
                        if (hasNext1) {
                            // Apply next clip directly instead of mixing (ie: no crossfade, ignores mecanim transition weights)
                            if (mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.Hard) {
                                for (; c6 < nextClipInfoCount1.v; c6 = (c6 + 1) | 0) {
                                    if (!this.ApplyAnimation(skeleton, System.Array.getItem(nextClipInfo1.v, c6, UnityEngine.AnimatorClipInfo).$clone(), nextStateInfo1.v, layer3, layerWeight1, layerBlendMode, true)) {
                                        continue;
                                    }
                                    c6 = (c6 + 1) | 0;
                                    break;
                                }
                            }
                            // Mix the rest
                            for (; c6 < nextClipInfoCount1.v; c6 = (c6 + 1) | 0) {
                                if (!this.ApplyAnimation(skeleton, System.Array.getItem(nextClipInfo1.v, c6, UnityEngine.AnimatorClipInfo).$clone(), nextStateInfo1.v, layer3, layerWeight1, layerBlendMode)) {
                                    continue;
                                }
                            }
                        }

                        c6 = 0;
                        if (isInterruptionActive1.v) {
                            // Apply next clip directly instead of mixing (ie: no crossfade, ignores mecanim transition weights)
                            if (mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.Hard) {
                                for (; c6 < interruptingClipInfoCount1.v; c6 = (c6 + 1) | 0) {
                                    if (this.ApplyInterruptionAnimation(skeleton, interpolateWeightTo1.v, System.Array.getItem(interruptingClipInfo1.v, c6, UnityEngine.AnimatorClipInfo).$clone(), interruptingStateInfo.v, layer3, layerWeight1, layerBlendMode, interruptingClipTimeAddition.v, true)) {

                                        c6 = (c6 + 1) | 0;
                                        break;
                                    }
                                }
                            }
                            // Mix the rest
                            for (; c6 < interruptingClipInfoCount1.v; c6 = (c6 + 1) | 0) {
                                this.ApplyInterruptionAnimation(skeleton, interpolateWeightTo1.v, System.Array.getItem(interruptingClipInfo1.v, c6, UnityEngine.AnimatorClipInfo).$clone(), interruptingStateInfo.v, layer3, layerWeight1, layerBlendMode, interruptingClipTimeAddition.v);
                            }
                        }
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Apply end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetActiveAnimationAndTime start.*/
            GetActiveAnimationAndTime: function (layer) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetActiveAnimationAndTime", this ); }

                if (layer >= this.layerClipInfos.length) {
                    return new (System.Collections.Generic.KeyValuePair$2(Spine.Animation,System.Single)).$ctor1(null, 0);
                }

                var layerInfos = this.layerClipInfos[layer];
                var isInterruptionActive = layerInfos.isInterruptionActive;
                var clip = null;
                var animation = null;
                var stateInfo;
                if (isInterruptionActive && layerInfos.interruptingClipInfoCount > 0) {
                    clip = layerInfos.interruptingClipInfos.getItem(0).$clone().clip;
                    stateInfo = layerInfos.interruptingStateInfo;
                } else {
                    clip = layerInfos.clipInfos.getItem(0).$clone().clip;
                    stateInfo = layerInfos.stateInfo;
                }
                animation = this.GetAnimation(clip);
                var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationTime$1(stateInfo.normalizedTime, clip.length, clip.isLooping, stateInfo.speed < 0);
                return new (System.Collections.Generic.KeyValuePair$2(Spine.Animation,System.Single)).$ctor1(animation, time);
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetActiveAnimationAndTime end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.InitClipInfosForLayers start.*/
            InitClipInfosForLayers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#InitClipInfosForLayers", this ); }

                if (this.layerClipInfos.length < this.animator.layerCount) {
                    System.Array.resize(Bridge.ref(this, "layerClipInfos"), this.animator.layerCount, null, Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos);
                    for (var layer = 0, n = this.animator.layerCount; layer < n; layer = (layer + 1) | 0) {
                        if (this.layerClipInfos[layer] == null) {
                            this.layerClipInfos[layer] = new Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos();
                        }
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.InitClipInfosForLayers end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ClearClipInfosForLayers start.*/
            ClearClipInfosForLayers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#ClearClipInfosForLayers", this ); }

                for (var layer = 0, n = this.layerClipInfos.length; layer < n; layer = (layer + 1) | 0) {
                    if (this.layerClipInfos[layer] == null) {
                        this.layerClipInfos[layer] = new Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos();
                    } else {
                        this.layerClipInfos[layer].isInterruptionActive = false;
                        this.layerClipInfos[layer].isLastFrameOfInterruption = false;
                        this.layerClipInfos[layer].clipInfos.clear();
                        this.layerClipInfos[layer].nextClipInfos.clear();
                        this.layerClipInfos[layer].interruptingClipInfos.clear();
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ClearClipInfosForLayers end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetMixMode start.*/
            GetMixMode: function (layer, layerBlendMode) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetMixMode", this ); }

                if (this.useCustomMixMode) {
                    var mode = this.layerMixModes[layer];
                    // Note: at additive blending it makes no sense to use constant weight 1 at a fadeout anim add1 as
                    // with override layers, so we use AlwaysMix instead to use the proper weights.
                    // AlwaysMix leads to the expected result = lower_layer + lerp(add1, add2, transition_weight).
                    if (layerBlendMode === Spine.MixBlend.Add && mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.MixNext) {
                        mode = Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix;
                        this.layerMixModes[layer] = mode;
                    }
                    return mode;
                } else {
                    return layerBlendMode === Spine.MixBlend.Add ? Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix : Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.MixNext;
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetMixMode end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetStateUpdatesFromAnimator start.*/
            GetStateUpdatesFromAnimator: function (layer) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetStateUpdatesFromAnimator", this ); }


                var layerInfos = this.layerClipInfos[layer];
                var clipInfoCount = this.animator.GetCurrentAnimatorClipInfoCount(layer);
                var nextClipInfoCount = this.animator.GetNextAnimatorClipInfoCount(layer);

                var clipInfos = layerInfos.clipInfos;
                var nextClipInfos = layerInfos.nextClipInfos;
                var interruptingClipInfos = layerInfos.interruptingClipInfos;

                layerInfos.isInterruptionActive = (clipInfoCount === 0 && clipInfos.Count !== 0 && nextClipInfoCount === 0 && nextClipInfos.Count !== 0);

                // Note: during interruption, GetCurrentAnimatorClipInfoCount and GetNextAnimatorClipInfoCount
                // are returning 0 in calls above. Therefore we keep previous clipInfos and nextClipInfos
                // until the interruption is over.
                if (layerInfos.isInterruptionActive) {

                    // Note: The last frame of a transition interruption
                    // will have fullPathHash set to 0, therefore we have to use previous
                    // frame's infos about interruption clips and correct some values
                    // accordingly (normalizedTime and weight).
                    var interruptingStateInfo = this.animator.GetNextAnimatorStateInfo(layer);
                    layerInfos.isLastFrameOfInterruption = interruptingStateInfo.fullPathHash === 0;
                    if (!layerInfos.isLastFrameOfInterruption) {
                        this.animator.GetNextAnimatorClipInfo(layer, interruptingClipInfos);
                        layerInfos.interruptingClipInfoCount = interruptingClipInfos.Count;
                        var oldTime = layerInfos.interruptingStateInfo.normalizedTime;
                        var newTime = interruptingStateInfo.normalizedTime;
                        layerInfos.interruptingClipTimeAddition = newTime - oldTime;
                        layerInfos.interruptingStateInfo = interruptingStateInfo;
                    }
                } else {
                    layerInfos.clipInfoCount = clipInfoCount;
                    layerInfos.nextClipInfoCount = nextClipInfoCount;
                    layerInfos.interruptingClipInfoCount = 0;
                    layerInfos.isLastFrameOfInterruption = false;

                    if (clipInfos.Capacity < clipInfoCount) {
                        clipInfos.Capacity = clipInfoCount;
                    }
                    if (nextClipInfos.Capacity < nextClipInfoCount) {
                        nextClipInfos.Capacity = nextClipInfoCount;
                    }

                    this.animator.GetCurrentAnimatorClipInfo(layer, clipInfos);
                    this.animator.GetNextAnimatorClipInfo(layer, nextClipInfos);

                    layerInfos.stateInfo = this.animator.GetCurrentAnimatorStateInfo(layer);
                    layerInfos.nextStateInfo = this.animator.GetNextAnimatorStateInfo(layer);
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetStateUpdatesFromAnimator end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorClipInfos start.*/
            GetAnimatorClipInfos: function (layer, isInterruptionActive, clipInfoCount, nextClipInfoCount, interruptingClipInfoCount, clipInfo, nextClipInfo, interruptingClipInfo, shallInterpolateWeightTo1) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimatorClipInfos", this ); }


                var layerInfos = this.layerClipInfos[layer];
                isInterruptionActive.v = layerInfos.isInterruptionActive;

                clipInfoCount.v = layerInfos.clipInfoCount;
                nextClipInfoCount.v = layerInfos.nextClipInfoCount;
                interruptingClipInfoCount.v = layerInfos.interruptingClipInfoCount;

                clipInfo.v = layerInfos.clipInfos;
                nextClipInfo.v = layerInfos.nextClipInfos;
                interruptingClipInfo.v = isInterruptionActive.v ? layerInfos.interruptingClipInfos : null;
                shallInterpolateWeightTo1.v = layerInfos.isLastFrameOfInterruption;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorClipInfos end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorStateInfos start.*/
            GetAnimatorStateInfos: function (layer, isInterruptionActive, stateInfo, nextStateInfo, interruptingStateInfo, interruptingClipTimeAddition) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimatorStateInfos", this ); }


                var layerInfos = this.layerClipInfos[layer];
                isInterruptionActive.v = layerInfos.isInterruptionActive;

                stateInfo.v = layerInfos.stateInfo;
                nextStateInfo.v = layerInfos.nextStateInfo;
                interruptingStateInfo.v = layerInfos.interruptingStateInfo;
                interruptingClipTimeAddition.v = layerInfos.isLastFrameOfInterruption ? layerInfos.interruptingClipTimeAddition : 0;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorStateInfos end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimation start.*/
            GetAnimation: function (clip) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimation", this ); }

                var clipNameHashCode = { };
                if (!this.clipNameHashCodeTable.tryGetValue(clip, clipNameHashCode)) {
                    clipNameHashCode.v = Bridge.getHashCode(clip.name);
                    this.clipNameHashCodeTable.add(clip, clipNameHashCode.v);
                }
                var animation = { };
                this.animationTable.tryGetValue(clipNameHashCode.v, animation);
                return animation.v;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimation end.*/


        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer", {
        inherits: [System.Collections.Generic.IEqualityComparer$1(UnityEngine.AnimationClip)],
        $kind: 1002,
        statics: {
            fields: {
                Instance: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#init", this ); }

                    this.Instance = new Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer();
                }
            }
        },
        alias: [
            "equals2", ["System$Collections$Generic$IEqualityComparer$1$UnityEngine$AnimationClip$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2"],
            "getHashCode2", ["System$Collections$Generic$IEqualityComparer$1$UnityEngine$AnimationClip$getHashCode2", "System$Collections$Generic$IEqualityComparer$1$getHashCode2"]
        ],
        methods: {
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.equals2 start.*/
            equals2: function (x, y) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#equals2", this ); }

                return x.GetInstanceID() === y.GetInstanceID();
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.equals2 end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.getHashCode2 start.*/
            getHashCode2: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#getHashCode2", this ); }

                return o.GetInstanceID();
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.getHashCode2 end.*/


        },
        overloads: {
            "Equals(AnimationClip, AnimationClip)": "equals2",
            "GetHashCode(AnimationClip)": "getHashCode2"
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos", {
        $kind: 1002,
        fields: {
            isInterruptionActive: false,
            isLastFrameOfInterruption: false,
            clipInfoCount: 0,
            nextClipInfoCount: 0,
            interruptingClipInfoCount: 0,
            clipInfos: null,
            nextClipInfos: null,
            interruptingClipInfos: null,
            stateInfo: null,
            nextStateInfo: null,
            interruptingStateInfo: null,
            interruptingClipTimeAddition: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos#init", this ); }

                this.isInterruptionActive = false;
                this.isLastFrameOfInterruption = false;
                this.clipInfoCount = 0;
                this.nextClipInfoCount = 0;
                this.interruptingClipInfoCount = 0;
                this.clipInfos = new (System.Collections.Generic.List$1(UnityEngine.AnimatorClipInfo)).ctor();
                this.nextClipInfos = new (System.Collections.Generic.List$1(UnityEngine.AnimatorClipInfo)).ctor();
                this.interruptingClipInfos = new (System.Collections.Generic.List$1(UnityEngine.AnimatorClipInfo)).ctor();
                this.interruptingClipTimeAddition = 0;
            }
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer", {
        inherits: [System.Collections.Generic.IEqualityComparer$1(System.Int32)],
        $kind: 1002,
        statics: {
            fields: {
                Instance: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#init", this ); }

                    this.Instance = new Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer();
                }
            }
        },
        alias: [
            "equals2", ["System$Collections$Generic$IEqualityComparer$1$System$Int32$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2"],
            "getHashCode2", ["System$Collections$Generic$IEqualityComparer$1$System$Int32$getHashCode2", "System$Collections$Generic$IEqualityComparer$1$getHashCode2"]
        ],
        methods: {
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.equals2 start.*/
            equals2: function (x, y) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#equals2", this ); }

                return x === y;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.equals2 end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.getHashCode2 start.*/
            getHashCode2: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#getHashCode2", this ); }

                return o;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.getHashCode2 end.*/


        },
        overloads: {
            "Equals(int, int)": "equals2",
            "GetHashCode(int)": "getHashCode2"
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode", {
        $kind: 1006,
        statics: {
            fields: {
                AlwaysMix: 0,
                MixNext: 1,
                Hard: 2
            }
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode end.*/

    /*Spine.Unity.SkeletonRootMotionBase start.*/
    /**
     * Base class for skeleton root motion components.
     *
     * @abstract
     * @public
     * @class Spine.Unity.SkeletonRootMotionBase
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.SkeletonRootMotionBase", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            rootMotionBoneName: null,
            transformPositionX: false,
            transformPositionY: false,
            rootMotionScaleX: 0,
            rootMotionScaleY: 0,
            /**
             * Skeleton space X translation per skeleton space Y translation root motion.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @default 0
             * @type number
             */
            rootMotionTranslateXPerY: 0,
            /**
             * Skeleton space Y translation per skeleton space X translation root motion.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @default 0
             * @type number
             */
            rootMotionTranslateYPerX: 0,
            rigidBody2D: null,
            rigidBody: null,
            skeletonComponent: null,
            rootMotionBone: null,
            rootMotionBoneIndex: 0,
            topLevelBones: null,
            initialOffset: null,
            tempSkeletonDisplacement: null,
            rigidbodyDisplacement: null
        },
        props: {
            UsesRigidbody: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#UsesRigidbody#get", this ); }

                    return UnityEngine.Component.op_Inequality(this.rigidBody, null) || UnityEngine.Component.op_Inequality(this.rigidBody2D, null);
                }
            },
            AdditionalScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#AdditionalScale#get", this ); }

                    return 1.0;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#init", this ); }

                this.initialOffset = new UnityEngine.Vector2();
                this.tempSkeletonDisplacement = new UnityEngine.Vector2();
                this.rigidbodyDisplacement = new UnityEngine.Vector2();
                this.rootMotionBoneName = "root";
                this.transformPositionX = true;
                this.transformPositionY = true;
                this.rootMotionScaleX = 1;
                this.rootMotionScaleY = 1;
                this.rootMotionTranslateXPerY = 0;
                this.rootMotionTranslateYPerX = 0;
                this.topLevelBones = new (System.Collections.Generic.List$1(Spine.Bone)).ctor();
                this.initialOffset = pc.Vec2.ZERO.clone();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRootMotionBase.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#Reset", this ); }

                this.FindRigidbodyComponent();
            },
            /*Spine.Unity.SkeletonRootMotionBase.Reset end.*/

            /*Spine.Unity.SkeletonRootMotionBase.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#Start", this ); }

                this.skeletonComponent = this.GetComponent(Spine.Unity.ISkeletonComponent);
                this.GatherTopLevelBones();
                this.SetRootMotionBone(this.rootMotionBoneName);
                if (this.rootMotionBone != null) {
                    this.initialOffset = new pc.Vec2( this.rootMotionBone.x, this.rootMotionBone.y );
                }

                var skeletonAnimation = Bridge.as(this.skeletonComponent, Spine.Unity.ISkeletonAnimation);
                if (skeletonAnimation != null) {
                    skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateLocal(Bridge.fn.cacheBind(this, this.HandleUpdateLocal));
                    skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateLocal(Bridge.fn.cacheBind(this, this.HandleUpdateLocal));
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.Start end.*/

            /*Spine.Unity.SkeletonRootMotionBase.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#FixedUpdate", this ); }

                if (!this.isActiveAndEnabled) {
                    return;
                } // Root motion is only applied when component is enabled.

                if (UnityEngine.Component.op_Inequality(this.rigidBody2D, null)) {
                    this.rigidBody2D.MovePosition(new pc.Vec2( this.transform.position.x, this.transform.position.y ).add( this.rigidbodyDisplacement ));
                }
                if (UnityEngine.Component.op_Inequality(this.rigidBody, null)) {
                    this.rigidBody.MovePosition(this.transform.position.$clone().add( new pc.Vec3( this.rigidbodyDisplacement.x, this.rigidbodyDisplacement.y, 0 ) ));
                }
                var parentBoneScale = { v : new UnityEngine.Vector2() };
                this.GetScaleAffectingRootMotion$1(parentBoneScale);
                this.ClearEffectiveBoneOffsets(parentBoneScale.v.$clone());
                this.rigidbodyDisplacement = pc.Vec2.ZERO.clone();
                this.tempSkeletonDisplacement = pc.Vec2.ZERO.clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.FixedUpdate end.*/

            /*Spine.Unity.SkeletonRootMotionBase.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#OnDisable", this ); }

                this.rigidbodyDisplacement = pc.Vec2.ZERO.clone();
                this.tempSkeletonDisplacement = pc.Vec2.ZERO.clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.OnDisable end.*/

            /*Spine.Unity.SkeletonRootMotionBase.FindRigidbodyComponent start.*/
            FindRigidbodyComponent: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#FindRigidbodyComponent", this ); }

                this.rigidBody2D = this.GetComponent(UnityEngine.Rigidbody2D);
                if (!UnityEngine.Object.op_Implicit(this.rigidBody2D)) {
                    this.rigidBody = this.GetComponent(UnityEngine.Rigidbody);
                }

                if (!UnityEngine.Object.op_Implicit(this.rigidBody2D) && !UnityEngine.Object.op_Implicit(this.rigidBody)) {
                    this.rigidBody2D = this.GetComponentInParent(UnityEngine.Rigidbody2D);
                    if (!UnityEngine.Object.op_Implicit(this.rigidBody2D)) {
                        this.rigidBody = this.GetComponentInParent(UnityEngine.Rigidbody);
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.FindRigidbodyComponent end.*/

            /*Spine.Unity.SkeletonRootMotionBase.SetRootMotionBone start.*/
            SetRootMotionBone: function (name) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#SetRootMotionBone", this ); }

                var $t;
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                var index = skeleton.FindBoneIndex(name);
                if (index >= 0) {
                    this.rootMotionBoneIndex = index;
                    this.rootMotionBone = ($t = skeleton.bones.Items)[index];
                } else {
                    UnityEngine.Debug.Log$1("Bone named \"" + (name || "") + "\" could not be found.");
                    this.rootMotionBoneIndex = 0;
                    this.rootMotionBone = skeleton.RootBone;
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.SetRootMotionBone end.*/

            /*Spine.Unity.SkeletonRootMotionBase.AdjustRootMotionToDistance start.*/
            AdjustRootMotionToDistance: function (distanceToTarget, trackIndex, adjustX, adjustY, minX, maxX, minY, maxY, allowXTranslation, allowYTranslation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#AdjustRootMotionToDistance", this ); }

                if (trackIndex === void 0) { trackIndex = 0; }
                if (adjustX === void 0) { adjustX = true; }
                if (adjustY === void 0) { adjustY = true; }
                if (minX === void 0) { minX = 0.0; }
                if (maxX === void 0) { maxX = 3.40282347E+38; }
                if (minY === void 0) { minY = 0.0; }
                if (maxY === void 0) { maxY = 3.40282347E+38; }
                if (allowXTranslation === void 0) { allowXTranslation = false; }
                if (allowYTranslation === void 0) { allowYTranslation = false; }

                var distanceToTargetSkeletonSpace = UnityEngine.Vector2.FromVector3(this.transform.InverseTransformVector(UnityEngine.Vector3.FromVector2(distanceToTarget)));
                var scaleAffectingRootMotion = this.GetScaleAffectingRootMotion();
                if (this.UsesRigidbody) {
                    distanceToTargetSkeletonSpace = distanceToTargetSkeletonSpace.$clone().sub( this.tempSkeletonDisplacement.$clone() );
                }

                var remainingRootMotionSkeletonSpace = this.GetRemainingRootMotion(trackIndex);
                remainingRootMotionSkeletonSpace.mul( scaleAffectingRootMotion );
                if (remainingRootMotionSkeletonSpace.x === 0) {
                    remainingRootMotionSkeletonSpace.x = 0.0001;
                }
                if (remainingRootMotionSkeletonSpace.y === 0) {
                    remainingRootMotionSkeletonSpace.y = 0.0001;
                }

                if (adjustX) {
                    this.rootMotionScaleX = Math.min(maxX, Math.max(minX, distanceToTargetSkeletonSpace.x / remainingRootMotionSkeletonSpace.x));
                }
                if (adjustY) {
                    this.rootMotionScaleY = Math.min(maxY, Math.max(minY, distanceToTargetSkeletonSpace.y / remainingRootMotionSkeletonSpace.y));
                }

                if (allowXTranslation) {
                    this.rootMotionTranslateXPerY = (distanceToTargetSkeletonSpace.x - remainingRootMotionSkeletonSpace.x * this.rootMotionScaleX) / remainingRootMotionSkeletonSpace.y;
                }
                if (allowYTranslation) {
                    this.rootMotionTranslateYPerX = (distanceToTargetSkeletonSpace.y - remainingRootMotionSkeletonSpace.y * this.rootMotionScaleY) / remainingRootMotionSkeletonSpace.x;
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.AdjustRootMotionToDistance end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion start.*/
            GetAnimationRootMotion: function (animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotion", this ); }

                return this.GetAnimationRootMotion$1(0, animation.duration, animation);
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion$1 start.*/
            GetAnimationRootMotion$1: function (startTime, endTime, animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotion$1", this ); }


                var timeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone(animation, this.rootMotionBoneIndex);
                if (timeline != null) {
                    return this.GetTimelineMovementDelta(startTime, endTime, timeline, animation);
                }
                return pc.Vec2.ZERO.clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion$1 end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionInfo start.*/
            GetAnimationRootMotionInfo: function (animation, currentTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionInfo", this ); }

                var rootMotion = new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                var timeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone(animation, this.rootMotionBoneIndex);
                if (timeline != null) {
                    var duration = animation.duration;
                    var mid = duration * 0.5;
                    rootMotion.start = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(timeline, 0);
                    rootMotion.current = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(timeline, currentTime);
                    rootMotion.mid = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(timeline, mid);
                    rootMotion.end = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(timeline, duration);
                    rootMotion.timeIsPastMid = currentTime > mid;
                }
                return rootMotion.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionInfo end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetTimelineMovementDelta start.*/
            GetTimelineMovementDelta: function (startTime, endTime, timeline, animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetTimelineMovementDelta", this ); }


                var currentDelta = new UnityEngine.Vector2();
                if (startTime > endTime) {
                    currentDelta = (Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(timeline, animation.duration).sub( Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(timeline, startTime) )).add( (Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(timeline, endTime).sub( Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(timeline, 0) )) );
                } else {
                    if (startTime !== endTime) {
                        currentDelta = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(timeline, endTime).sub( Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(timeline, startTime) );
                    } else {
                        currentDelta = pc.Vec2.ZERO.clone();
                    }
                }
                return currentDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetTimelineMovementDelta end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GatherTopLevelBones start.*/
            GatherTopLevelBones: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GatherTopLevelBones", this ); }

                var $t;
                this.topLevelBones.clear();
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                $t = Bridge.getEnumerator(skeleton.Bones);
                try {
                    while ($t.moveNext()) {
                        var bone = $t.Current;
                        if (bone.Parent == null) {
                            this.topLevelBones.add(bone);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.GatherTopLevelBones end.*/

            /*Spine.Unity.SkeletonRootMotionBase.HandleUpdateLocal start.*/
            HandleUpdateLocal: function (animatedSkeletonComponent) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#HandleUpdateLocal", this ); }

                if (!this.isActiveAndEnabled) {
                    return;
                } // Root motion is only applied when component is enabled.

                var boneLocalDelta = this.CalculateAnimationsMovementDelta();
                var parentBoneScale = { v : new UnityEngine.Vector2() };
                var skeletonDelta = this.GetSkeletonSpaceMovementDelta(boneLocalDelta.$clone(), parentBoneScale);
                this.ApplyRootMotion(skeletonDelta.$clone(), parentBoneScale.v.$clone());
            },
            /*Spine.Unity.SkeletonRootMotionBase.HandleUpdateLocal end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ApplyRootMotion start.*/
            ApplyRootMotion: function (skeletonDelta, parentBoneScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ApplyRootMotion", this ); }

                // Apply root motion to Transform or RigidBody;
                if (this.UsesRigidbody) {
                    this.rigidbodyDisplacement = this.rigidbodyDisplacement.$clone().add( UnityEngine.Vector2.FromVector3(this.transform.TransformVector(UnityEngine.Vector3.FromVector2(skeletonDelta))) );

                    // Accumulated displacement is applied on the next Physics update in FixedUpdate.
                    // Until the next Physics update, tempBoneDisplacement is offsetting bone locations
                    // to prevent stutter which would otherwise occur if we don't move every Update.
                    this.tempSkeletonDisplacement = this.tempSkeletonDisplacement.$clone().add( skeletonDelta.$clone() );
                    this.SetEffectiveBoneOffsetsTo(this.tempSkeletonDisplacement.$clone(), parentBoneScale.$clone());
                } else {
                    this.transform.position = this.transform.position.$clone().add( this.transform.TransformVector(UnityEngine.Vector3.FromVector2(skeletonDelta)) );
                    this.ClearEffectiveBoneOffsets(parentBoneScale.$clone());
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.ApplyRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion start.*/
            GetScaleAffectingRootMotion: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetScaleAffectingRootMotion", this ); }

                var parentBoneScale = { v : new UnityEngine.Vector2() };
                return this.GetScaleAffectingRootMotion$1(parentBoneScale);
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion$1 start.*/
            GetScaleAffectingRootMotion$1: function (parentBoneScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetScaleAffectingRootMotion$1", this ); }

                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                var totalScale = pc.Vec2.ONE.clone();
                totalScale.x *= skeleton.ScaleX;
                totalScale.y *= skeleton.ScaleY;

                parentBoneScale.v = pc.Vec2.ONE.clone();
                var scaleBone = this.rootMotionBone;
                while (((scaleBone = scaleBone.parent)) != null) {
                    parentBoneScale.v.x *= scaleBone.ScaleX;
                    parentBoneScale.v.y *= scaleBone.ScaleY;
                }
                totalScale = new pc.Vec2( totalScale.x * parentBoneScale.v.x, totalScale.y * parentBoneScale.v.y );
                totalScale = totalScale.$clone().scale( this.AdditionalScale );
                return totalScale.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion$1 end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetSkeletonSpaceMovementDelta start.*/
            GetSkeletonSpaceMovementDelta: function (boneLocalDelta, parentBoneScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetSkeletonSpaceMovementDelta", this ); }

                var skeletonDelta = boneLocalDelta.$clone();
                var totalScale = this.GetScaleAffectingRootMotion$1(parentBoneScale);
                skeletonDelta.mul( totalScale );

                var rootMotionTranslation = new pc.Vec2( this.rootMotionTranslateXPerY * skeletonDelta.y, this.rootMotionTranslateYPerX * skeletonDelta.x );

                skeletonDelta.x *= this.rootMotionScaleX;
                skeletonDelta.y *= this.rootMotionScaleY;
                skeletonDelta.x += rootMotionTranslation.x;
                skeletonDelta.y += rootMotionTranslation.y;

                if (!this.transformPositionX) {
                    skeletonDelta.x = 0.0;
                }
                if (!this.transformPositionY) {
                    skeletonDelta.y = 0.0;
                }
                return skeletonDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetSkeletonSpaceMovementDelta end.*/

            /*Spine.Unity.SkeletonRootMotionBase.SetEffectiveBoneOffsetsTo start.*/
            SetEffectiveBoneOffsetsTo: function (displacementSkeletonSpace, parentBoneScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#SetEffectiveBoneOffsetsTo", this ); }

                var $t;
                // Move top level bones in opposite direction of the root motion bone
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                $t = Bridge.getEnumerator(this.topLevelBones);
                try {
                    while ($t.moveNext()) {
                        var topLevelBone = $t.Current;
                        if (Bridge.referenceEquals(topLevelBone, this.rootMotionBone)) {
                            if (this.transformPositionX) {
                                topLevelBone.x = displacementSkeletonSpace.x / skeleton.ScaleX;
                            }
                            if (this.transformPositionY) {
                                topLevelBone.y = displacementSkeletonSpace.y / skeleton.ScaleY;
                            }
                        } else {
                            var offsetX = (this.initialOffset.x - this.rootMotionBone.x) * parentBoneScale.x;
                            var offsetY = (this.initialOffset.y - this.rootMotionBone.y) * parentBoneScale.y;
                            if (this.transformPositionX) {
                                topLevelBone.x = (displacementSkeletonSpace.x / skeleton.ScaleX) + offsetX;
                            }
                            if (this.transformPositionY) {
                                topLevelBone.y = (displacementSkeletonSpace.y / skeleton.ScaleY) + offsetY;
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.SetEffectiveBoneOffsetsTo end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ClearEffectiveBoneOffsets start.*/
            ClearEffectiveBoneOffsets: function (parentBoneScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ClearEffectiveBoneOffsets", this ); }

                this.SetEffectiveBoneOffsetsTo(pc.Vec2.ZERO.clone(), parentBoneScale.$clone());
            },
            /*Spine.Unity.SkeletonRootMotionBase.ClearEffectiveBoneOffsets end.*/


        },
        overloads: {
            "GetAnimationRootMotion(float, float, Animation)": "GetAnimationRootMotion$1",
            "GetScaleAffectingRootMotion(Vector2)": "GetScaleAffectingRootMotion$1"
        }
    });
    /*Spine.Unity.SkeletonRootMotionBase end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonPartsRenderer.SkeletonPartsRendererDelegate
     * @param   {Spine.Unity.SkeletonPartsRenderer}    skeletonPartsRenderer
     * @return  {void}
     */


    /*Spine.Unity.SkeletonPartsRenderer start.*/
    Bridge.define("Spine.Unity.SkeletonPartsRenderer", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject:static start.*/
                NewPartsRendererGameObject: function (parent, name, sortingOrder) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#NewPartsRendererGameObject", this ); }

                    if (sortingOrder === void 0) { sortingOrder = 0; }
                    var go = new UnityEngine.GameObject.$ctor4(name, [UnityEngine.MeshFilter, UnityEngine.MeshRenderer]);
                    go.transform.SetParent(parent, false);
                    var returnComponent = go.AddComponent(Spine.Unity.SkeletonPartsRenderer);
                    returnComponent.MeshRenderer.sortingOrder = sortingOrder;

                    return returnComponent;
                },
                /*Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject:static end.*/


            }
        },
        fields: {
            meshGenerator: null,
            meshRenderer: null,
            meshFilter: null,
            buffers: null,
            currentInstructions: null
        },
        events: {
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonPartsRenderer
             * @memberof Spine.Unity.SkeletonPartsRenderer
             * @function addOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonPartsRenderer.SkeletonPartsRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonPartsRenderer
             * @memberof Spine.Unity.SkeletonPartsRenderer
             * @function removeOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonPartsRenderer.SkeletonPartsRendererDelegate}    value
             * @return  {void}
             */
            OnMeshAndMaterialsUpdated: null
        },
        props: {
            MeshGenerator: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#MeshGenerator#get", this ); }

                    this.LazyIntialize();
                    return this.meshGenerator;
                }
            },
            MeshRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#MeshRenderer#get", this ); }

                    this.LazyIntialize();
                    return this.meshRenderer;
                }
            },
            MeshFilter: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#MeshFilter#get", this ); }

                    this.LazyIntialize();
                    return this.meshFilter;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#init", this ); }

                this.currentInstructions = new Spine.Unity.SkeletonRendererInstruction();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonPartsRenderer.LazyIntialize start.*/
            LazyIntialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#LazyIntialize", this ); }

                if (this.buffers == null) {
                    this.buffers = new Spine.Unity.MeshRendererBuffers();
                    this.buffers.Initialize();

                    if (this.meshGenerator != null) {
                        return;
                    }
                    this.meshGenerator = new Spine.Unity.MeshGenerator();
                    this.meshFilter = this.GetComponent(UnityEngine.MeshFilter);
                    this.meshRenderer = this.GetComponent(UnityEngine.MeshRenderer);
                    this.currentInstructions.Clear();
                }
            },
            /*Spine.Unity.SkeletonPartsRenderer.LazyIntialize end.*/

            /*Spine.Unity.SkeletonPartsRenderer.ClearMesh start.*/
            ClearMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#ClearMesh", this ); }

                this.LazyIntialize();
                this.meshFilter.sharedMesh = null;
            },
            /*Spine.Unity.SkeletonPartsRenderer.ClearMesh end.*/

            /*Spine.Unity.SkeletonPartsRenderer.RenderParts start.*/
            RenderParts: function (instructions, startSubmesh, endSubmesh) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#RenderParts", this ); }

                this.LazyIntialize();

                // STEP 1: Create instruction
                var smartMesh = this.buffers.GetNextMesh();
                this.currentInstructions.SetWithSubset(instructions, startSubmesh, endSubmesh);
                var updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(this.currentInstructions, smartMesh.instructionUsed);

                // STEP 2: Generate mesh buffers.
                var currentInstructionsSubmeshesItems = this.currentInstructions.submeshInstructions.Items;
                this.meshGenerator.Begin();
                if (this.currentInstructions.hasActiveClipping) {
                    for (var i = 0; i < this.currentInstructions.submeshInstructions.Count; i = (i + 1) | 0) {
                        this.meshGenerator.AddSubmesh(currentInstructionsSubmeshesItems[i].$clone(), updateTriangles);
                    }
                } else {
                    this.meshGenerator.BuildMeshWithArrays(this.currentInstructions, updateTriangles);
                }

                this.buffers.UpdateSharedMaterials(this.currentInstructions.submeshInstructions);

                // STEP 3: modify mesh.
                var mesh = smartMesh.mesh;

                if (this.meshGenerator.VertexCount <= 0) { // Clear an empty mesh
                    updateTriangles = false;
                    mesh.Clear();
                } else {
                    this.meshGenerator.FillVertexData(mesh);
                    if (updateTriangles) {
                        this.meshGenerator.FillTriangles(mesh);
                        this.meshRenderer.sharedMaterials = this.buffers.GetUpdatedSharedMaterialsArray();
                    } else if (this.buffers.MaterialsChangedInLastUpdate()) {
                        this.meshRenderer.sharedMaterials = this.buffers.GetUpdatedSharedMaterialsArray();
                    }
                    this.meshGenerator.FillLateVertexData(mesh);
                }

                this.meshFilter.sharedMesh = mesh;
                smartMesh.instructionUsed.Set(this.currentInstructions);

                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this);
                }
            },
            /*Spine.Unity.SkeletonPartsRenderer.RenderParts end.*/

            /*Spine.Unity.SkeletonPartsRenderer.SetPropertyBlock start.*/
            SetPropertyBlock: function (block) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#SetPropertyBlock", this ); }

                this.LazyIntialize();
                this.meshRenderer.SetPropertyBlock(block);
            },
            /*Spine.Unity.SkeletonPartsRenderer.SetPropertyBlock end.*/


        }
    });
    /*Spine.Unity.SkeletonPartsRenderer end.*/

    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials start.*/
    Bridge.define("Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials", {
        $kind: 1002,
        fields: {
            /**
             * Material references for switching material sets at runtime when {@link } changes to {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
             * @type Array.<UnityEngine.Material>
             */
            materialsMaskDisabled: null,
            /**
             * Material references for switching material sets at runtime when {@link } changes to {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
             * @type Array.<UnityEngine.Material>
             */
            materialsInsideMask: null,
            /**
             * Material references for switching material sets at runtime when {@link } changes to {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
             * @type Array.<UnityEngine.Material>
             */
            materialsOutsideMask: null
        },
        props: {
            AnyMaterialCreated: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials#AnyMaterialCreated#get", this ); }

                    return this.materialsMaskDisabled.length > 0 || this.materialsInsideMask.length > 0 || this.materialsOutsideMask.length > 0;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials#init", this ); }

                this.materialsMaskDisabled = System.Array.init(0, null, UnityEngine.Material);
                this.materialsInsideMask = System.Array.init(0, null, UnityEngine.Material);
                this.materialsOutsideMask = System.Array.init(0, null, UnityEngine.Material);
            }
        }
    });
    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials start.*/
    Bridge.define("Spine.Unity.SkeletonRendererCustomMaterials", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonRenderer: null,
            customSlotMaterials: null,
            customMaterialOverrides: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#init", this ); }

                this.customSlotMaterials = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride)).ctor();
                this.customMaterialOverrides = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomSlotMaterials start.*/
            SetCustomSlotMaterials: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#SetCustomSlotMaterials", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                for (var i = 0; i < this.customSlotMaterials.Count; i = (i + 1) | 0) {
                    var slotMaterialOverride = this.customSlotMaterials.getItem(i).$clone();
                    if (slotMaterialOverride.overrideDisabled || System.String.isNullOrEmpty(slotMaterialOverride.slotName)) {
                        continue;
                    }

                    var slotObject = this.skeletonRenderer.skeleton.FindSlot(slotMaterialOverride.slotName);
                    this.skeletonRenderer.CustomSlotMaterials.setItem(slotObject, slotMaterialOverride.material);
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomSlotMaterials end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomSlotMaterials start.*/
            RemoveCustomSlotMaterials: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#RemoveCustomSlotMaterials", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                for (var i = 0; i < this.customSlotMaterials.Count; i = (i + 1) | 0) {
                    var slotMaterialOverride = this.customSlotMaterials.getItem(i).$clone();
                    if (System.String.isNullOrEmpty(slotMaterialOverride.slotName)) {
                        continue;
                    }

                    var slotObject = this.skeletonRenderer.skeleton.FindSlot(slotMaterialOverride.slotName);

                    var currentMaterial = { };
                    if (!this.skeletonRenderer.CustomSlotMaterials.tryGetValue(slotObject, currentMaterial)) {
                        continue;
                    }

                    // Do not revert the material if it was changed by something else
                    if (!Bridge.referenceEquals(currentMaterial.v, slotMaterialOverride.material)) {
                        continue;
                    }

                    this.skeletonRenderer.CustomSlotMaterials.remove(slotObject);
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomSlotMaterials end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomMaterialOverrides start.*/
            SetCustomMaterialOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#SetCustomMaterialOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    if (atlasMaterialOverride.overrideDisabled) {
                        continue;
                    }

                    this.skeletonRenderer.CustomMaterialOverride.setItem(atlasMaterialOverride.originalMaterial, atlasMaterialOverride.replacementMaterial);
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomMaterialOverrides start.*/
            RemoveCustomMaterialOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#RemoveCustomMaterialOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    var currentMaterial = { };

                    if (!this.skeletonRenderer.CustomMaterialOverride.tryGetValue(atlasMaterialOverride.originalMaterial, currentMaterial)) {
                        continue;
                    }

                    // Do not revert the material if it was changed by something else
                    if (!Bridge.referenceEquals(currentMaterial.v, atlasMaterialOverride.replacementMaterial)) {
                        continue;
                    }

                    this.skeletonRenderer.CustomMaterialOverride.remove(atlasMaterialOverride.originalMaterial);
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer = this.GetComponent(Spine.Unity.SkeletonRenderer);
                }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                this.skeletonRenderer.Initialize(false);
                this.SetCustomMaterialOverrides();
                this.SetCustomSlotMaterials();
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.OnEnable end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                this.RemoveCustomMaterialOverrides();
                this.RemoveCustomSlotMaterials();
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.OnDisable end.*/


        }
    });
    /*Spine.Unity.SkeletonRendererCustomMaterials end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride start.*/
    Bridge.define("Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#inherits", this ); }
 return [System.IEquatable$1(Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride)]; },
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride(); }
            }
        },
        fields: {
            overrideDisabled: false,
            originalMaterial: null,
            replacementMaterial: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonRendererCustomMaterials$AtlasMaterialOverride$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#equalsT", this ); }

                return this.overrideDisabled === other.overrideDisabled && Bridge.referenceEquals(this.originalMaterial, other.originalMaterial) && Bridge.referenceEquals(this.replacementMaterial, other.replacementMaterial);
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#getHashCode", this ); }

                var h = Bridge.addHash([8608216668, this.overrideDisabled, this.originalMaterial, this.replacementMaterial]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride();
                s.overrideDisabled = this.overrideDisabled;
                s.originalMaterial = this.originalMaterial;
                s.replacementMaterial = this.replacementMaterial;
                return s;
            }
        },
        overloads: {
            "Equals(AtlasMaterialOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride start.*/
    Bridge.define("Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#inherits", this ); }
 return [System.IEquatable$1(Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride)]; },
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride(); }
            }
        },
        fields: {
            overrideDisabled: false,
            slotName: null,
            material: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonRendererCustomMaterials$SlotMaterialOverride$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#equalsT", this ); }

                return this.overrideDisabled === other.overrideDisabled && Bridge.referenceEquals(this.slotName, other.slotName) && Bridge.referenceEquals(this.material, other.material);
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#getHashCode", this ); }

                var h = Bridge.addHash([9094239955, this.overrideDisabled, this.slotName, this.material]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride();
                s.overrideDisabled = this.overrideDisabled;
                s.slotName = this.slotName;
                s.material = this.material;
                return s;
            }
        },
        overloads: {
            "Equals(SlotMaterialOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride end.*/

    /*Spine.Unity.SkeletonRendererInstruction start.*/
    /**
     * Instructions used by a SkeletonRenderer to render a mesh.
     *
     * @public
     * @class Spine.Unity.SkeletonRendererInstruction
     */
    Bridge.define("Spine.Unity.SkeletonRendererInstruction", {
        statics: {
            methods: {
                /*Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual:static start.*/
                GeometryNotEqual: function (a, b) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#GeometryNotEqual", this ); }


                    if (a.hasActiveClipping || b.hasActiveClipping) {
                        return true;
                    } // Triangles are unpredictable when clipping is active.

                    // Everything below assumes the raw vertex and triangle counts were used. (ie, no clipping was done)
                    if (a.rawVertexCount !== b.rawVertexCount) {
                        return true;
                    }

                    if (a.immutableTriangles !== b.immutableTriangles) {
                        return true;
                    }

                    var attachmentCountB = b.attachments.Count;
                    if (a.attachments.Count !== attachmentCountB) {
                        return true;
                    } // Bounds check for the looped storedAttachments count below.

                    // Submesh count changed
                    var submeshCountA = a.submeshInstructions.Count;
                    var submeshCountB = b.submeshInstructions.Count;
                    if (submeshCountA !== submeshCountB) {
                        return true;
                    }

                    // Submesh Instruction mismatch
                    var submeshInstructionsItemsA = a.submeshInstructions.Items;
                    var submeshInstructionsItemsB = b.submeshInstructions.Items;

                    var attachmentsA = a.attachments.Items;
                    var attachmentsB = b.attachments.Items;
                    for (var i = 0; i < attachmentCountB; i = (i + 1) | 0) {
                        if (!Bridge.referenceEquals(attachmentsA[i], attachmentsB[i])) {
                            return true;
                        }
                    }

                    for (var i1 = 0; i1 < submeshCountB; i1 = (i1 + 1) | 0) {
                        var submeshA = submeshInstructionsItemsA[i1].$clone();
                        var submeshB = submeshInstructionsItemsB[i1].$clone();

                        if (!(submeshA.rawVertexCount === submeshB.rawVertexCount && submeshA.startSlot === submeshB.startSlot && submeshA.endSlot === submeshB.endSlot && submeshA.rawTriangleCount === submeshB.rawTriangleCount && submeshA.rawFirstVertexIndex === submeshB.rawFirstVertexIndex)) {
                            return true;
                        }
                    }

                    return false;
                },
                /*Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual:static end.*/


            }
        },
        fields: {
            submeshInstructions: null,
            immutableTriangles: false,
            hasActiveClipping: false,
            rawVertexCount: 0,
            attachments: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#init", this ); }

                this.submeshInstructions = new (Spine.ExposedList$1(Spine.Unity.SubmeshInstruction)).ctor();
                this.rawVertexCount = -1;
                this.attachments = new (Spine.ExposedList$1(Spine.Attachment)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererInstruction.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#Clear", this ); }

                this.attachments.Clear(false);
                this.rawVertexCount = -1;
                this.hasActiveClipping = false;
                this.submeshInstructions.Clear(false);
            },
            /*Spine.Unity.SkeletonRendererInstruction.Clear end.*/

            /*Spine.Unity.SkeletonRendererInstruction.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#Dispose", this ); }

                this.attachments.Clear(true);
            },
            /*Spine.Unity.SkeletonRendererInstruction.Dispose end.*/

            /*Spine.Unity.SkeletonRendererInstruction.SetWithSubset start.*/
            SetWithSubset: function (instructions, startSubmesh, endSubmesh) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#SetWithSubset", this ); }

                var runningVertexCount = 0;

                var submeshes = this.submeshInstructions;
                submeshes.Clear(false);
                var submeshCount = (endSubmesh - startSubmesh) | 0;
                submeshes.Resize(submeshCount);
                var submeshesItems = submeshes.Items;
                var instructionsItems = instructions.Items;
                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    var instruction = instructionsItems[((startSubmesh + i) | 0)].$clone();
                    submeshesItems[i] = instruction.$clone();
                    this.hasActiveClipping = !!(this.hasActiveClipping | instruction.hasClipping);
                    submeshesItems[i].rawFirstVertexIndex = runningVertexCount; // Ensure current instructions have correct cached values.
                    runningVertexCount = (runningVertexCount + instruction.rawVertexCount) | 0; // vertexCount will also be used for the rest of this method.
                }
                this.rawVertexCount = runningVertexCount;

                // assumption: instructions are contiguous. start and end are valid within instructions.

                var startSlot = instructionsItems[startSubmesh].startSlot;
                var endSlot = instructionsItems[((endSubmesh - 1) | 0)].endSlot;
                this.attachments.Clear(false);
                var attachmentCount = (endSlot - startSlot) | 0;
                this.attachments.Resize(attachmentCount);
                var attachmentsItems = this.attachments.Items;

                var drawOrderItems = instructionsItems[0].skeleton.drawOrder.Items;
                for (var i1 = 0; i1 < attachmentCount; i1 = (i1 + 1) | 0) {
                    var slot = drawOrderItems[((startSlot + i1) | 0)];
                    if (!slot.bone.active) {
                        continue;
                    }
                    attachmentsItems[i1] = slot.attachment;
                }

            },
            /*Spine.Unity.SkeletonRendererInstruction.SetWithSubset end.*/

            /*Spine.Unity.SkeletonRendererInstruction.Set start.*/
            Set: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#Set", this ); }

                this.immutableTriangles = other.immutableTriangles;

                this.hasActiveClipping = other.hasActiveClipping;
                this.rawVertexCount = other.rawVertexCount;
                this.attachments.Clear(false);
                this.attachments.EnsureCapacity(other.attachments.Capacity);
                this.attachments.Count = other.attachments.Count;
                other.attachments.CopyTo(this.attachments.Items);

                this.submeshInstructions.Clear(false);
                this.submeshInstructions.EnsureCapacity(other.submeshInstructions.Capacity);
                this.submeshInstructions.Count = other.submeshInstructions.Count;
                other.submeshInstructions.CopyTo(this.submeshInstructions.Items);
            },
            /*Spine.Unity.SkeletonRendererInstruction.Set end.*/


        }
    });
    /*Spine.Unity.SkeletonRendererInstruction end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate
     * @param   {Spine.Unity.SkeletonRenderer}    skeletonRenderer
     * @return  {void}
     */


    /*Spine.Unity.SkeletonRenderSeparator start.*/
    Bridge.define("Spine.Unity.SkeletonRenderSeparator", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                DefaultSortingOrderIncrement: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#init", this ); }

                    this.DefaultSortingOrderIncrement = 5;
                }
            },
            methods: {
                /*Spine.Unity.SkeletonRenderSeparator.AddToSkeletonRenderer:static start.*/
                /**
                 * Adds a SkeletonRenderSeparator and child SkeletonPartsRenderer GameObjects to a given SkeletonRenderer.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonRenderSeparator
                 * @memberof Spine.Unity.SkeletonRenderSeparator
                 * @param   {Spine.Unity.SkeletonRenderer}           skeletonRenderer            The target SkeletonRenderer or SkeletonAnimation.
                 * @param   {number}                                 sortingLayerID              Sorting layer to be used for the parts renderers.
                 * @param   {number}                                 extraPartsRenderers         Number of additional SkeletonPartsRenderers on top of the ones determined by counting the number of separator slots.
                 * @param   {number}                                 sortingOrderIncrement       The integer to increment the sorting order per SkeletonPartsRenderer to separate them.
                 * @param   {number}                                 baseSortingOrder            The sorting order value of the first SkeletonPartsRenderer.
                 * @param   {boolean}                                addMinimumPartsRenderers    If set to <pre><code>true</code></pre>, a minimum number of SkeletonPartsRenderer GameObjects (determined by separatorSlots.Count + 1) will be added.
                 * @return  {Spine.Unity.SkeletonRenderSeparator}                                The to skeleton renderer.
                 */
                AddToSkeletonRenderer: function (skeletonRenderer, sortingLayerID, extraPartsRenderers, sortingOrderIncrement, baseSortingOrder, addMinimumPartsRenderers) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#AddToSkeletonRenderer", this ); }

                    if (sortingLayerID === void 0) { sortingLayerID = 0; }
                    if (extraPartsRenderers === void 0) { extraPartsRenderers = 0; }
                    if (sortingOrderIncrement === void 0) { sortingOrderIncrement = 5; }
                    if (baseSortingOrder === void 0) { baseSortingOrder = 0; }
                    if (addMinimumPartsRenderers === void 0) { addMinimumPartsRenderers = true; }
                    if (UnityEngine.MonoBehaviour.op_Equality(skeletonRenderer, null)) {
                        UnityEngine.Debug.Log$1("Tried to add SkeletonRenderSeparator to a null SkeletonRenderer reference.");
                        return null;
                    }

                    var srs = skeletonRenderer.gameObject.AddComponent(Spine.Unity.SkeletonRenderSeparator);
                    srs.skeletonRenderer = skeletonRenderer;

                    skeletonRenderer.Initialize(false);
                    var count = extraPartsRenderers;
                    if (addMinimumPartsRenderers) {
                        count = (((extraPartsRenderers + skeletonRenderer.separatorSlots.Count) | 0) + 1) | 0;
                    }

                    var skeletonRendererTransform = skeletonRenderer.transform;
                    var componentRenderers = srs.partsRenderers;

                    for (var i = 0; i < count; i = (i + 1) | 0) {
                        var spr = Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject(skeletonRendererTransform, Bridge.toString(i));
                        var mr = spr.MeshRenderer;
                        mr.sortingLayerID = sortingLayerID;
                        mr.sortingOrder = (baseSortingOrder + (Bridge.Int.mul(i, sortingOrderIncrement))) | 0;
                        componentRenderers.add(spr);
                    }

                    srs.OnEnable();


                    return srs;
                },
                /*Spine.Unity.SkeletonRenderSeparator.AddToSkeletonRenderer:static end.*/


            }
        },
        fields: {
            skeletonRenderer: null,
            mainMeshRenderer: null,
            copyPropertyBlock: false,
            copyMeshRendererFlags: false,
            partsRenderers: null,
            copiedBlock: null
        },
        events: {
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderSeparator
             * @memberof Spine.Unity.SkeletonRenderSeparator
             * @function addOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderSeparator
             * @memberof Spine.Unity.SkeletonRenderSeparator
             * @function removeOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnMeshAndMaterialsUpdated: null
        },
        props: {
            SkeletonRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#SkeletonRenderer#get", this ); }

                    return this.skeletonRenderer;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#SkeletonRenderer#set", this ); }

                    if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                        this.skeletonRenderer.removeGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));
                    }

                    this.skeletonRenderer = value;
                    if (UnityEngine.MonoBehaviour.op_Equality(value, null)) {
                        this.enabled = false;
                    }
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#init", this ); }

                this.copyPropertyBlock = true;
                this.copyMeshRendererFlags = true;
                this.partsRenderers = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonPartsRenderer)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRenderSeparator.AddPartsRenderer start.*/
            /**
             * Add a child SkeletonPartsRenderer GameObject to this SkeletonRenderSeparator.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderSeparator
             * @memberof Spine.Unity.SkeletonRenderSeparator
             * @param   {number}                               sortingOrderIncrement    
             * @param   {string}                               name
             * @return  {Spine.Unity.SkeletonPartsRenderer}
             */
            AddPartsRenderer: function (sortingOrderIncrement, name) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#AddPartsRenderer", this ); }

                if (sortingOrderIncrement === void 0) { sortingOrderIncrement = 5; }
                if (name === void 0) { name = null; }
                var sortingLayerID = 0;
                var sortingOrder = 0;
                if (this.partsRenderers.Count > 0) {
                    var previous = this.partsRenderers.getItem(((this.partsRenderers.Count - 1) | 0));
                    var previousMeshRenderer = previous.MeshRenderer;
                    sortingLayerID = previousMeshRenderer.sortingLayerID;
                    sortingOrder = (previousMeshRenderer.sortingOrder + sortingOrderIncrement) | 0;
                }

                if (System.String.isNullOrEmpty(name)) {
                    name = Bridge.toString(this.partsRenderers.Count);
                }

                var spr = Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject(this.skeletonRenderer.transform, name);
                this.partsRenderers.add(spr);

                var mr = spr.MeshRenderer;
                mr.sortingLayerID = sortingLayerID;
                mr.sortingOrder = sortingOrder;

                return spr;
            },
            /*Spine.Unity.SkeletonRenderSeparator.AddPartsRenderer end.*/

            /*Spine.Unity.SkeletonRenderSeparator.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    return;
                }
                if (this.copiedBlock == null) {
                    this.copiedBlock = new UnityEngine.MaterialPropertyBlock();
                }
                this.mainMeshRenderer = this.skeletonRenderer.GetComponent(UnityEngine.MeshRenderer);

                this.skeletonRenderer.removeGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));
                this.skeletonRenderer.addGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));

                if (this.copyMeshRendererFlags) {
                    var lightProbeUsage = this.mainMeshRenderer.lightProbeUsage;
                    var receiveShadows = this.mainMeshRenderer.receiveShadows;
                    var reflectionProbeUsage = this.mainMeshRenderer.reflectionProbeUsage;
                    var shadowCastingMode = this.mainMeshRenderer.shadowCastingMode;
                    var motionVectorGenerationMode = this.mainMeshRenderer.motionVectorGenerationMode;
                    var probeAnchor = this.mainMeshRenderer.probeAnchor;

                    for (var i = 0; i < this.partsRenderers.Count; i = (i + 1) | 0) {
                        var currentRenderer = this.partsRenderers.getItem(i);
                        if (UnityEngine.MonoBehaviour.op_Equality(currentRenderer, null)) {
                            continue;
                        } // skip null items.

                        var mr = currentRenderer.MeshRenderer;
                        mr.lightProbeUsage = lightProbeUsage;
                        mr.receiveShadows = receiveShadows;
                        mr.reflectionProbeUsage = reflectionProbeUsage;
                        mr.shadowCastingMode = shadowCastingMode;
                        mr.motionVectorGenerationMode = motionVectorGenerationMode;
                        mr.probeAnchor = probeAnchor;
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderSeparator.OnEnable end.*/

            /*Spine.Unity.SkeletonRenderSeparator.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#OnDisable", this ); }

                var $t;
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    return;
                }
                this.skeletonRenderer.removeGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));

                this.skeletonRenderer.LateUpdate();

                $t = Bridge.getEnumerator(this.partsRenderers);
                try {
                    while ($t.moveNext()) {
                        var partsRenderer = $t.Current;
                        if (UnityEngine.MonoBehaviour.op_Inequality(partsRenderer, null)) {
                            partsRenderer.ClearMesh();
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderSeparator.OnDisable end.*/

            /*Spine.Unity.SkeletonRenderSeparator.HandleRender start.*/
            HandleRender: function (instruction) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#HandleRender", this ); }

                var $t;
                var rendererCount = this.partsRenderers.Count;
                if (rendererCount <= 0) {
                    return;
                }

                if (this.copyPropertyBlock) {
                    this.mainMeshRenderer.GetPropertyBlock(this.copiedBlock);
                }

                var settings = ($t = new Spine.Unity.MeshGenerator.Settings(), $t.addNormals = this.skeletonRenderer.addNormals, $t.calculateTangents = this.skeletonRenderer.calculateTangents, $t.immutableTriangles = false, $t.pmaVertexColors = this.skeletonRenderer.pmaVertexColors, $t.tintBlack = this.skeletonRenderer.tintBlack, $t.useClipping = true, $t.zSpacing = this.skeletonRenderer.zSpacing, $t);

                var submeshInstructions = instruction.submeshInstructions;
                var submeshInstructionsItems = submeshInstructions.Items;
                var lastSubmeshInstruction = (submeshInstructions.Count - 1) | 0;

                var rendererIndex = 0;
                var currentRenderer = this.partsRenderers.getItem(rendererIndex);
                for (var si = 0, start = 0; si <= lastSubmeshInstruction; si = (si + 1) | 0) {
                    if (UnityEngine.MonoBehaviour.op_Equality(currentRenderer, null)) {
                        continue;
                    }
                    if (submeshInstructionsItems[si].forceSeparate || si === lastSubmeshInstruction) {
                        // Apply properties
                        var meshGenerator = currentRenderer.MeshGenerator;
                        meshGenerator.settings = settings.$clone();

                        if (this.copyPropertyBlock) {
                            currentRenderer.SetPropertyBlock(this.copiedBlock);
                        }

                        // Render
                        currentRenderer.RenderParts(instruction.submeshInstructions, start, ((si + 1) | 0));

                        start = (si + 1) | 0;
                        rendererIndex = (rendererIndex + 1) | 0;
                        if (rendererIndex < rendererCount) {
                            currentRenderer = this.partsRenderers.getItem(rendererIndex);
                        } else {
                            // Not enough renderers. Skip the rest of the instructions.
                            break;
                        }
                    }
                }

                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this.skeletonRenderer);
                }

                // Clear extra renderers if they exist.
                for (; rendererIndex < rendererCount; rendererIndex = (rendererIndex + 1) | 0) {
                    currentRenderer = this.partsRenderers.getItem(rendererIndex);
                    if (UnityEngine.MonoBehaviour.op_Inequality(currentRenderer, null)) {
                        this.partsRenderers.getItem(rendererIndex).ClearMesh();
                    }
                }

            },
            /*Spine.Unity.SkeletonRenderSeparator.HandleRender end.*/


        }
    });
    /*Spine.Unity.SkeletonRenderSeparator end.*/

    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo start.*/
    Bridge.define("Spine.Unity.SkeletonRootMotionBase.RootMotionInfo", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo(); }
            }
        },
        fields: {
            start: null,
            current: null,
            mid: null,
            end: null,
            timeIsPastMid: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#init", this ); }

                this.start = new UnityEngine.Vector2();
                this.current = new UnityEngine.Vector2();
                this.mid = new UnityEngine.Vector2();
                this.end = new UnityEngine.Vector2();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#getHashCode", this ); }

                var h = Bridge.addHash([5573033076, this.start, this.current, this.mid, this.end, this.timeIsPastMid]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.SkeletonRootMotionBase.RootMotionInfo)) {
                    return false;
                }
                return Bridge.equals(this.start, o.start) && Bridge.equals(this.current, o.current) && Bridge.equals(this.mid, o.mid) && Bridge.equals(this.end, o.end) && Bridge.equals(this.timeIsPastMid, o.timeIsPastMid);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                s.start = this.start.$clone();
                s.current = this.current.$clone();
                s.mid = this.mid.$clone();
                s.end = this.end.$clone();
                s.timeIsPastMid = this.timeIsPastMid;
                return s;
            }
        }
    });
    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo end.*/

    /*Spine.Unity.SkeletonUtility start.*/
    Bridge.define("Spine.Unity.SkeletonUtility", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject:static start.*/
                AddBoundingBoxGameObject: function (skeleton, skinName, slotName, attachmentName, parent, isTrigger) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#AddBoundingBoxGameObject", this ); }

                    if (isTrigger === void 0) { isTrigger = true; }
                    var skin = System.String.isNullOrEmpty(skinName) ? skeleton.data.defaultSkin : skeleton.data.FindSkin(skinName);
                    if (skin == null) {
                        UnityEngine.Debug.LogError$2("Skin " + (skinName || "") + " not found!");
                        return null;
                    }

                    var attachment = skin.GetAttachment(skeleton.FindSlotIndex(slotName), attachmentName);
                    if (attachment == null) {
                        UnityEngine.Debug.LogFormat("Attachment in slot '{0}' named '{1}' not found in skin '{2}'.", [slotName, attachmentName, skin.name]);
                        return null;
                    }

                    var box = Bridge.as(attachment, Spine.BoundingBoxAttachment);
                    if (box != null) {
                        var slot = skeleton.FindSlot(slotName);
                        return Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject$1(box.Name, box, slot, parent, isTrigger);
                    } else {
                        UnityEngine.Debug.LogFormat("Attachment '{0}' was not a Bounding Box.", [attachmentName]);
                        return null;
                    }
                },
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject:static end.*/

                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject$1:static start.*/
                AddBoundingBoxGameObject$1: function (name, box, slot, parent, isTrigger) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#AddBoundingBoxGameObject$1", this ); }

                    if (isTrigger === void 0) { isTrigger = true; }
                    var go = new UnityEngine.GameObject.$ctor2("[BoundingBox]" + ((System.String.isNullOrEmpty(name) ? box.Name : name) || ""));
                    var got = go.transform;
                    got.parent = parent;
                    got.localPosition = pc.Vec3.ZERO.clone();
                    got.localRotation = pc.Quat.IDENTITY.clone();
                    got.localScale = new pc.Vec3( 1, 1, 1 );
                    return Spine.Unity.SkeletonUtility.AddBoundingBoxAsComponent(box, slot, go, isTrigger);
                },
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject$1:static end.*/

                /*Spine.Unity.SkeletonUtility.AddBoundingBoxAsComponent:static start.*/
                AddBoundingBoxAsComponent: function (box, slot, gameObject, isTrigger) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#AddBoundingBoxAsComponent", this ); }

                    if (isTrigger === void 0) { isTrigger = true; }
                    if (box == null) {
                        return null;
                    }
                    var collider = gameObject.AddComponent(UnityEngine.PolygonCollider2D);
                    collider.isTrigger = isTrigger;
                    Spine.Unity.SkeletonUtility.SetColliderPointsLocal(collider, slot, box);
                    return collider;
                },
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxAsComponent:static end.*/

                /*Spine.Unity.SkeletonUtility.SetColliderPointsLocal:static start.*/
                SetColliderPointsLocal: function (collider, slot, box, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SetColliderPointsLocal", this ); }

                    if (scale === void 0) { scale = 1.0; }
                    if (box == null) {
                        return;
                    }
                    if (Spine.SpineSkeletonExtensions.IsWeighted(box)) {
                        UnityEngine.Debug.LogWarning$1("UnityEngine.PolygonCollider2D does not support weighted or animated points. Collider points will not be animated and may have incorrect orientation. If you want to use it as a collider, please remove weights and animations from the bounding box in Spine editor.");
                    }
                    var verts = Spine.Unity.SkeletonExtensions.GetLocalVertices(box, slot, null);
                    if (scale !== 1.0) {
                        for (var i = 0, n = verts.length; i < n; i = (i + 1) | 0) {
                            verts[i] = verts[i].$clone().scale( scale );
                        }
                    }
                    collider.SetPath$1(0, verts);
                },
                /*Spine.Unity.SkeletonUtility.SetColliderPointsLocal:static end.*/

                /*Spine.Unity.SkeletonUtility.GetBoundingBoxBounds:static start.*/
                GetBoundingBoxBounds: function (boundingBox, depth) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#GetBoundingBoxBounds", this ); }

                    if (depth === void 0) { depth = 0.0; }
                    var floats = boundingBox.Vertices;
                    var floatCount = floats.length;

                    var bounds = new pc.BoundingBox.ctor();

                    bounds.center = new pc.Vec3( floats[0], floats[1], 0 );
                    for (var i = 2; i < floatCount; i = (i + 2) | 0) {
                        bounds.expandToPoint( new pc.Vec3( floats[i], floats[((i + 1) | 0)], 0 ) );
                    }

                    var size = bounds.halfExtents.$clone().scale( 2 ).$clone();
                    size.z = depth;
                    bounds.halfExtents = size.$clone().$clone().scale( 0.5 );

                    return bounds;
                },
                /*Spine.Unity.SkeletonUtility.GetBoundingBoxBounds:static end.*/

                /*Spine.Unity.SkeletonUtility.AddBoneRigidbody2D:static start.*/
                AddBoneRigidbody2D: function (gameObject, isKinematic, gravityScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#AddBoneRigidbody2D", this ); }

                    if (isKinematic === void 0) { isKinematic = true; }
                    if (gravityScale === void 0) { gravityScale = 0.0; }
                    var rb = gameObject.GetComponent(UnityEngine.Rigidbody2D);
                    if (UnityEngine.Component.op_Equality(rb, null)) {
                        rb = gameObject.AddComponent(UnityEngine.Rigidbody2D);
                        rb.isKinematic = isKinematic;
                        rb.gravityScale = gravityScale;
                    }
                    return rb;
                },
                /*Spine.Unity.SkeletonUtility.AddBoneRigidbody2D:static end.*/


            }
        },
        fields: {
            boneRoot: null,
            /**
             * If true, {@link } and {@link } are followed
             by 180 degree rotation. If false, negative Transform scale is used.
             Note that using negative scale is consistent with previous behaviour (hence the default),
             however causes serious problems with rigidbodies and physics. Therefore, it is recommended to
             enable this parameter where possible. When creating hinge chains for a chain of skeleton bones
             via {@link }, it is mandatory to have <pre><code>flipBy180DegreeRotation</code></pre> enabled.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonUtility
             * @default false
             * @type boolean
             */
            flipBy180DegreeRotation: false,
            skeletonRenderer: null,
            skeletonGraphic: null,
            canvas: null,
            skeletonAnimation: null,
            skeletonComponent: null,
            boneComponents: null,
            constraintComponents: null,
            positionScale: 0,
            hasOverrideBones: false,
            hasConstraints: false,
            needToReprocessBones: false
        },
        events: {
            OnReset: null
        },
        props: {
            SkeletonComponent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SkeletonComponent#get", this ); }

                    if (this.skeletonComponent == null) {
                        this.skeletonComponent = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) ? this.skeletonRenderer.GetComponent(Spine.Unity.ISkeletonComponent) : UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) ? this.skeletonGraphic.GetComponent(Spine.Unity.ISkeletonComponent) : this.GetComponent(Spine.Unity.ISkeletonComponent);
                    }
                    return this.skeletonComponent;
                }
            },
            Skeleton: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#Skeleton#get", this ); }

                    if (this.SkeletonComponent == null) {
                        return null;
                    }
                    return this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                }
            },
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#IsValid#get", this ); }

                    return (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) && this.skeletonRenderer.valid) || (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) && this.skeletonGraphic.IsValid);
                }
            },
            PositionScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#PositionScale#get", this ); }

                    return this.positionScale;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#init", this ); }

                this.flipBy180DegreeRotation = false;
                this.boneComponents = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonUtilityBone)).ctor();
                this.constraintComponents = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonUtilityConstraint)).ctor();
                this.positionScale = 1.0;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonUtility.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#Update", this ); }

                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                if (skeleton != null && UnityEngine.Component.op_Inequality(this.boneRoot, null)) {

                    if (this.flipBy180DegreeRotation) {
                        this.boneRoot.localScale = new pc.Vec3( Math.abs(skeleton.ScaleX), Math.abs(skeleton.ScaleY), 1.0 );
                        this.boneRoot.eulerAngles = new pc.Vec3( skeleton.ScaleY > 0 ? 0 : 180, skeleton.ScaleX > 0 ? 0 : 180, 0 );
                    } else {
                        this.boneRoot.localScale = new pc.Vec3( skeleton.ScaleX, skeleton.ScaleY, 1.0 );
                    }
                }

                if (UnityEngine.Component.op_Inequality(this.canvas, null)) {
                    this.positionScale = this.canvas.referencePixelsPerUnit;
                }
            },
            /*Spine.Unity.SkeletonUtility.Update end.*/

            /*Spine.Unity.SkeletonUtility.ResubscribeEvents start.*/
            ResubscribeEvents: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#ResubscribeEvents", this ); }

                this.OnDisable();
                this.OnEnable();
            },
            /*Spine.Unity.SkeletonUtility.ResubscribeEvents end.*/

            /*Spine.Unity.SkeletonUtility.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer = this.GetComponent(Spine.Unity.SkeletonRenderer);
                }
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic = this.GetComponent(Spine.Unity.SkeletonGraphic);
                }
                if (this.skeletonAnimation == null) {
                    this.skeletonAnimation = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) ? this.skeletonRenderer.GetComponent(Spine.Unity.ISkeletonAnimation) : UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) ? this.skeletonGraphic.GetComponent(Spine.Unity.ISkeletonAnimation) : this.GetComponent(Spine.Unity.ISkeletonAnimation);
                }
                if (this.skeletonComponent == null) {
                    this.skeletonComponent = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) ? this.skeletonRenderer.GetComponent(Spine.Unity.ISkeletonComponent) : UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) ? this.skeletonGraphic.GetComponent(Spine.Unity.ISkeletonComponent) : this.GetComponent(Spine.Unity.ISkeletonComponent);
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset$1));
                    this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset$1));
                } else if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset));
                    this.skeletonGraphic.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset));
                    this.canvas = this.skeletonGraphic.canvas;
                    if (UnityEngine.Component.op_Equality(this.canvas, null)) {
                        this.canvas = this.skeletonGraphic.GetComponentInParent(UnityEngine.Canvas);
                    }
                    if (UnityEngine.Component.op_Equality(this.canvas, null)) {
                        this.positionScale = 100.0;
                    }
                }

                if (this.skeletonAnimation != null) {
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateLocal(Bridge.fn.cacheBind(this, this.UpdateLocal));
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateLocal(Bridge.fn.cacheBind(this, this.UpdateLocal));
                }

                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.OnEnable end.*/

            /*Spine.Unity.SkeletonUtility.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#Start", this ); }

                //recollect because order of operations failure when switching between game mode and edit mode...
                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.Start end.*/

            /*Spine.Unity.SkeletonUtility.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset$1));
                }
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset));
                }

                if (this.skeletonAnimation != null) {
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateLocal(Bridge.fn.cacheBind(this, this.UpdateLocal));
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateWorld(Bridge.fn.cacheBind(this, this.UpdateWorld));
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateComplete(Bridge.fn.cacheBind(this, this.UpdateComplete));
                }
            },
            /*Spine.Unity.SkeletonUtility.OnDisable end.*/

            /*Spine.Unity.SkeletonUtility.HandleRendererReset$1 start.*/
            HandleRendererReset$1: function (r) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#HandleRendererReset$1", this ); }

                if (!Bridge.staticEquals(this.OnReset, null)) {
                    this.OnReset();
                }
                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.HandleRendererReset$1 end.*/

            /*Spine.Unity.SkeletonUtility.HandleRendererReset start.*/
            HandleRendererReset: function (g) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#HandleRendererReset", this ); }

                if (!Bridge.staticEquals(this.OnReset, null)) {
                    this.OnReset();
                }
                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.HandleRendererReset end.*/

            /*Spine.Unity.SkeletonUtility.RegisterBone start.*/
            RegisterBone: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#RegisterBone", this ); }

                if (this.boneComponents.contains(bone)) {
                    return;
                } else {
                    this.boneComponents.add(bone);
                    this.needToReprocessBones = true;
                }
            },
            /*Spine.Unity.SkeletonUtility.RegisterBone end.*/

            /*Spine.Unity.SkeletonUtility.UnregisterBone start.*/
            UnregisterBone: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UnregisterBone", this ); }

                this.boneComponents.remove(bone);
            },
            /*Spine.Unity.SkeletonUtility.UnregisterBone end.*/

            /*Spine.Unity.SkeletonUtility.RegisterConstraint start.*/
            RegisterConstraint: function (constraint) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#RegisterConstraint", this ); }

                if (this.constraintComponents.contains(constraint)) {
                    return;
                } else {
                    this.constraintComponents.add(constraint);
                    this.needToReprocessBones = true;
                }
            },
            /*Spine.Unity.SkeletonUtility.RegisterConstraint end.*/

            /*Spine.Unity.SkeletonUtility.UnregisterConstraint start.*/
            UnregisterConstraint: function (constraint) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UnregisterConstraint", this ); }

                this.constraintComponents.remove(constraint);
            },
            /*Spine.Unity.SkeletonUtility.UnregisterConstraint end.*/

            /*Spine.Unity.SkeletonUtility.CollectBones start.*/
            CollectBones: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#CollectBones", this ); }

                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                if (skeleton == null) {
                    return;
                }

                if (UnityEngine.Component.op_Inequality(this.boneRoot, null)) {
                    var constraintTargets = new (System.Collections.Generic.List$1(System.Object)).ctor();
                    var ikConstraints = skeleton.IkConstraints;
                    for (var i = 0, n = ikConstraints.Count; i < n; i = (i + 1) | 0) {
                        constraintTargets.add(ikConstraints.Items[i].target);
                    }

                    var transformConstraints = skeleton.TransformConstraints;
                    for (var i1 = 0, n1 = transformConstraints.Count; i1 < n1; i1 = (i1 + 1) | 0) {
                        constraintTargets.add(transformConstraints.Items[i1].target);
                    }

                    var boneComponents = this.boneComponents;
                    for (var i2 = 0, n2 = boneComponents.Count; i2 < n2; i2 = (i2 + 1) | 0) {
                        var b = boneComponents.getItem(i2);
                        if (b.bone == null) {
                            b.DoUpdate(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local);
                            if (b.bone == null) {
                                continue;
                            }
                        }
                        this.hasOverrideBones = !!(this.hasOverrideBones | (b.mode === Spine.Unity.SkeletonUtilityBone.Mode.Override));
                        this.hasConstraints = !!(this.hasConstraints | constraintTargets.contains(b.bone));
                    }

                    this.hasConstraints = !!(this.hasConstraints | this.constraintComponents.Count > 0);

                    if (this.skeletonAnimation != null) {
                        this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateWorld(Bridge.fn.cacheBind(this, this.UpdateWorld));
                        this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateComplete(Bridge.fn.cacheBind(this, this.UpdateComplete));

                        if (this.hasOverrideBones || this.hasConstraints) {
                            this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateWorld(Bridge.fn.cacheBind(this, this.UpdateWorld));
                        }

                        if (this.hasConstraints) {
                            this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateComplete(Bridge.fn.cacheBind(this, this.UpdateComplete));
                        }
                    }

                    this.needToReprocessBones = false;
                } else {
                    this.boneComponents.clear();
                    this.constraintComponents.clear();
                }
            },
            /*Spine.Unity.SkeletonUtility.CollectBones end.*/

            /*Spine.Unity.SkeletonUtility.UpdateLocal start.*/
            UpdateLocal: function (anim) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateLocal", this ); }

                if (this.needToReprocessBones) {
                    this.CollectBones();
                }

                var boneComponents = this.boneComponents;
                if (boneComponents == null) {
                    return;
                }
                for (var i = 0, n = boneComponents.Count; i < n; i = (i + 1) | 0) {
                    boneComponents.getItem(i).transformLerpComplete = false;
                }

                this.UpdateAllBones(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local);
            },
            /*Spine.Unity.SkeletonUtility.UpdateLocal end.*/

            /*Spine.Unity.SkeletonUtility.UpdateWorld start.*/
            UpdateWorld: function (anim) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateWorld", this ); }

                this.UpdateAllBones(Spine.Unity.SkeletonUtilityBone.UpdatePhase.World);
                for (var i = 0, n = this.constraintComponents.Count; i < n; i = (i + 1) | 0) {
                    this.constraintComponents.getItem(i).DoUpdate();
                }
            },
            /*Spine.Unity.SkeletonUtility.UpdateWorld end.*/

            /*Spine.Unity.SkeletonUtility.UpdateComplete start.*/
            UpdateComplete: function (anim) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateComplete", this ); }

                this.UpdateAllBones(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Complete);
            },
            /*Spine.Unity.SkeletonUtility.UpdateComplete end.*/

            /*Spine.Unity.SkeletonUtility.UpdateAllBones start.*/
            UpdateAllBones: function (phase) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateAllBones", this ); }

                if (UnityEngine.Component.op_Equality(this.boneRoot, null)) {
                    this.CollectBones();
                }

                var boneComponents = this.boneComponents;
                if (boneComponents == null) {
                    return;
                }
                for (var i = 0, n = boneComponents.Count; i < n; i = (i + 1) | 0) {
                    boneComponents.getItem(i).DoUpdate(phase);
                }
            },
            /*Spine.Unity.SkeletonUtility.UpdateAllBones end.*/

            /*Spine.Unity.SkeletonUtility.GetBoneRoot start.*/
            GetBoneRoot: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#GetBoneRoot", this ); }

                if (UnityEngine.Component.op_Inequality(this.boneRoot, null)) {
                    return this.boneRoot;
                }

                var boneRootObject = new UnityEngine.GameObject.$ctor2("SkeletonUtility-SkeletonRoot");
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    boneRootObject.AddComponent(UnityEngine.RectTransform);
                }

                this.boneRoot = boneRootObject.transform;
                this.boneRoot.SetParent(this.transform);
                this.boneRoot.localPosition = pc.Vec3.ZERO.clone();
                this.boneRoot.localRotation = pc.Quat.IDENTITY.clone();
                this.boneRoot.localScale = new pc.Vec3( 1, 1, 1 );

                return this.boneRoot;
            },
            /*Spine.Unity.SkeletonUtility.GetBoneRoot end.*/

            /*Spine.Unity.SkeletonUtility.SpawnRoot start.*/
            SpawnRoot: function (mode, pos, rot, sca) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SpawnRoot", this ); }

                this.GetBoneRoot();
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;

                var go = this.SpawnBone(skeleton.RootBone, this.boneRoot, mode, pos, rot, sca);
                this.CollectBones();
                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnRoot end.*/

            /*Spine.Unity.SkeletonUtility.SpawnHierarchy start.*/
            SpawnHierarchy: function (mode, pos, rot, sca) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SpawnHierarchy", this ); }

                this.GetBoneRoot();
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                var go = this.SpawnBoneRecursively(skeleton.RootBone, this.boneRoot, mode, pos, rot, sca);
                this.CollectBones();
                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnHierarchy end.*/

            /*Spine.Unity.SkeletonUtility.SpawnBoneRecursively start.*/
            SpawnBoneRecursively: function (bone, parent, mode, pos, rot, sca) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SpawnBoneRecursively", this ); }

                var go = this.SpawnBone(bone, parent, mode, pos, rot, sca);

                var childrenBones = bone.Children;
                for (var i = 0, n = childrenBones.Count; i < n; i = (i + 1) | 0) {
                    var child = childrenBones.Items[i];
                    this.SpawnBoneRecursively(child, go.transform, mode, pos, rot, sca);
                }

                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnBoneRecursively end.*/

            /*Spine.Unity.SkeletonUtility.SpawnBone start.*/
            SpawnBone: function (bone, parent, mode, pos, rot, sca) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SpawnBone", this ); }

                var go = new UnityEngine.GameObject.$ctor2(bone.Data.Name);
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    go.AddComponent(UnityEngine.RectTransform);
                }

                var goTransform = go.transform;
                goTransform.SetParent(parent);

                var b = go.AddComponent(Spine.Unity.SkeletonUtilityBone);
                b.hierarchy = this;
                b.position = pos;
                b.rotation = rot;
                b.scale = sca;
                b.mode = mode;
                b.zPosition = true;
                b.Reset();
                b.bone = bone;
                b.boneName = bone.Data.Name;
                b.valid = true;

                if (mode === Spine.Unity.SkeletonUtilityBone.Mode.Override) {
                    if (rot) {
                        goTransform.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, b.bone.AppliedRotation );
                    }
                    if (pos) {
                        goTransform.localPosition = new pc.Vec3( b.bone.X * this.positionScale, b.bone.Y * this.positionScale, 0 );
                    }
                    goTransform.localScale = new pc.Vec3( b.bone.scaleX, b.bone.scaleY, 0 );
                }

                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnBone end.*/


        },
        overloads: {
            "HandleRendererReset(SkeletonRenderer)": "HandleRendererReset$1"
        }
    });
    /*Spine.Unity.SkeletonUtility end.*/

    /*Spine.Unity.SkeletonUtilityBone start.*/
    /**
     * Sets a GameObject's transform to match a bone on a Spine skeleton.
     *
     * @public
     * @class Spine.Unity.SkeletonUtilityBone
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.SkeletonUtilityBone", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible:static start.*/
                BoneTransformModeIncompatible: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#BoneTransformModeIncompatible", this ); }

                    return !Spine.SpineSkeletonExtensions.InheritsScale(bone.data.transformMode);
                },
                /*Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible:static end.*/


            }
        },
        fields: {
            /**
             * If a bone isn't set, boneName is used to find the bone.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonUtilityBone
             * @type string
             */
            boneName: null,
            parentReference: null,
            mode: 0,
            position: false,
            rotation: false,
            scale: false,
            zPosition: false,
            overrideAlpha: 0,
            hierarchy: null,
            bone: null,
            transformLerpComplete: false,
            valid: false,
            cachedTransform: null,
            skeletonTransform: null,
            incompatibleTransformMode: false
        },
        props: {
            IncompatibleTransformMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#IncompatibleTransformMode#get", this ); }

                    return this.incompatibleTransformMode;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#init", this ); }

                this.zPosition = true;
                this.overrideAlpha = 1;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonUtilityBone.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#Reset", this ); }

                this.bone = null;
                this.cachedTransform = this.transform;
                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.hierarchy, null) && this.hierarchy.IsValid;
                if (!this.valid) {
                    return;
                }
                this.skeletonTransform = this.hierarchy.transform;
                this.hierarchy.removeOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
                this.hierarchy.addOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
                this.DoUpdate(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local);
            },
            /*Spine.Unity.SkeletonUtilityBone.Reset end.*/

            /*Spine.Unity.SkeletonUtilityBone.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.hierarchy, null)) {
                    this.hierarchy = this.transform.GetComponentInParent(Spine.Unity.SkeletonUtility);
                }
                if (UnityEngine.MonoBehaviour.op_Equality(this.hierarchy, null)) {
                    return;
                }

                this.hierarchy.RegisterBone(this);
                this.hierarchy.addOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
            },
            /*Spine.Unity.SkeletonUtilityBone.OnEnable end.*/

            /*Spine.Unity.SkeletonUtilityBone.HandleOnReset start.*/
            HandleOnReset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#HandleOnReset", this ); }

                this.Reset();
            },
            /*Spine.Unity.SkeletonUtilityBone.HandleOnReset end.*/

            /*Spine.Unity.SkeletonUtilityBone.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.hierarchy, null)) {
                    this.hierarchy.removeOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
                    this.hierarchy.UnregisterBone(this);
                }
            },
            /*Spine.Unity.SkeletonUtilityBone.OnDisable end.*/

            /*Spine.Unity.SkeletonUtilityBone.DoUpdate start.*/
            DoUpdate: function (phase) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#DoUpdate", this ); }

                var $t;
                if (!this.valid) {
                    this.Reset();
                    return;
                }

                var skeleton = this.hierarchy.Skeleton;

                if (this.bone == null) {
                    if (System.String.isNullOrEmpty(this.boneName)) {
                        return;
                    }
                    this.bone = skeleton.FindBone(this.boneName);
                    if (this.bone == null) {
                        UnityEngine.Debug.LogError$2("Bone not found: " + (this.boneName || ""), this);
                        return;
                    }
                }
                if (!this.bone.Active) {
                    return;
                }

                var positionScale = this.hierarchy.PositionScale;

                var thisTransform = this.cachedTransform;
                var skeletonFlipRotation = ($t = skeleton.ScaleX * skeleton.ScaleY, ($t === 0 ? 1 : Math.sign($t)));
                if (this.mode === Spine.Unity.SkeletonUtilityBone.Mode.Follow) {
                    switch (phase) {
                        case Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local: 
                            if (this.position) {
                                thisTransform.localPosition = new pc.Vec3( this.bone.x * positionScale, this.bone.y * positionScale, 0 );
                            }
                            if (this.rotation) {
                                if (Spine.SpineSkeletonExtensions.InheritsRotation(this.bone.data.transformMode)) {
                                    thisTransform.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, this.bone.rotation );
                                } else {
                                    var euler = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                                    thisTransform.rotation = new pc.Quat().setFromEulerAngles_Unity( euler.x, euler.y, euler.z + (this.bone.WorldRotationX * skeletonFlipRotation) );
                                }
                            }
                            if (this.scale) {
                                thisTransform.localScale = new pc.Vec3( this.bone.scaleX, this.bone.scaleY, 1.0 );
                                this.incompatibleTransformMode = Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible(this.bone);
                            }
                            break;
                        case Spine.Unity.SkeletonUtilityBone.UpdatePhase.World: 
                        case Spine.Unity.SkeletonUtilityBone.UpdatePhase.Complete: 
                            // Use Applied transform values (ax, ay, AppliedRotation, ascale) if world values were modified by constraints.
                            if (!this.bone.appliedValid) {
                                this.bone.UpdateAppliedTransform();
                            }
                            if (this.position) {
                                thisTransform.localPosition = new pc.Vec3( this.bone.ax * positionScale, this.bone.ay * positionScale, 0 );
                            }
                            if (this.rotation) {
                                if (Spine.SpineSkeletonExtensions.InheritsRotation(this.bone.data.transformMode)) {
                                    thisTransform.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, this.bone.AppliedRotation );
                                } else {
                                    var euler1 = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                                    thisTransform.rotation = new pc.Quat().setFromEulerAngles_Unity( euler1.x, euler1.y, euler1.z + (this.bone.WorldRotationX * skeletonFlipRotation) );
                                }
                            }
                            if (this.scale) {
                                thisTransform.localScale = new pc.Vec3( this.bone.ascaleX, this.bone.ascaleY, 1.0 );
                                this.incompatibleTransformMode = Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible(this.bone);
                            }
                            break;
                    }

                } else if (this.mode === Spine.Unity.SkeletonUtilityBone.Mode.Override) {
                    if (this.transformLerpComplete) {
                        return;
                    }

                    if (UnityEngine.Component.op_Equality(this.parentReference, null)) {
                        if (this.position) {
                            var clp = thisTransform.localPosition.$clone().scale( 1.0 / ( positionScale ) );
                            this.bone.x = pc.math.lerp(this.bone.x, clp.x, this.overrideAlpha);
                            this.bone.y = pc.math.lerp(this.bone.y, clp.y, this.overrideAlpha);
                        }

                        if (this.rotation) {
                            var angle = UnityEngine.Mathf.LerpAngle(this.bone.Rotation, thisTransform.localRotation.getPositiveEulerAngles().z, this.overrideAlpha);
                            this.bone.Rotation = angle;
                            this.bone.AppliedRotation = angle;
                        }

                        if (this.scale) {
                            var cls = thisTransform.localScale.$clone();
                            this.bone.scaleX = pc.math.lerp(this.bone.scaleX, cls.x, this.overrideAlpha);
                            this.bone.scaleY = pc.math.lerp(this.bone.scaleY, cls.y, this.overrideAlpha);
                        }

                    } else {
                        if (this.transformLerpComplete) {
                            return;
                        }

                        if (this.position) {
                            var pos = this.parentReference.InverseTransformPoint(thisTransform.position).scale( 1.0 / ( positionScale ) );
                            this.bone.x = pc.math.lerp(this.bone.x, pos.x, this.overrideAlpha);
                            this.bone.y = pc.math.lerp(this.bone.y, pos.y, this.overrideAlpha);
                        }

                        if (this.rotation) {
                            var angle1 = UnityEngine.Mathf.LerpAngle(this.bone.Rotation, new pc.Quat().setLookAt( new pc.Vec3( 0, 0, 1 ), this.parentReference.InverseTransformDirection(thisTransform.up.$clone()) ).getPositiveEulerAngles().z, this.overrideAlpha);
                            this.bone.Rotation = angle1;
                            this.bone.AppliedRotation = angle1;
                        }

                        if (this.scale) {
                            var cls1 = thisTransform.localScale.$clone();
                            this.bone.scaleX = pc.math.lerp(this.bone.scaleX, cls1.x, this.overrideAlpha);
                            this.bone.scaleY = pc.math.lerp(this.bone.scaleY, cls1.y, this.overrideAlpha);
                        }

                        this.incompatibleTransformMode = Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible(this.bone);
                    }

                    this.transformLerpComplete = true;
                }
            },
            /*Spine.Unity.SkeletonUtilityBone.DoUpdate end.*/

            /*Spine.Unity.SkeletonUtilityBone.AddBoundingBox start.*/
            AddBoundingBox: function (skinName, slotName, attachmentName) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#AddBoundingBox", this ); }

                Spine.Unity.SkeletonUtility.AddBoneRigidbody2D(this.transform.gameObject);
                Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject(this.bone.skeleton, skinName, slotName, attachmentName, this.transform);
            },
            /*Spine.Unity.SkeletonUtilityBone.AddBoundingBox end.*/


        }
    });
    /*Spine.Unity.SkeletonUtilityBone end.*/

    /*Spine.Unity.SkeletonUtilityBone+Mode start.*/
    Bridge.define("Spine.Unity.SkeletonUtilityBone.Mode", {
        $kind: 1006,
        statics: {
            fields: {
                Follow: 0,
                Override: 1
            }
        }
    });
    /*Spine.Unity.SkeletonUtilityBone+Mode end.*/

    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase start.*/
    Bridge.define("Spine.Unity.SkeletonUtilityBone.UpdatePhase", {
        $kind: 1006,
        statics: {
            fields: {
                Local: 0,
                World: 1,
                Complete: 2
            }
        }
    });
    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase end.*/

    /*Spine.Unity.SkeletonUtilityConstraint start.*/
    Bridge.define("Spine.Unity.SkeletonUtilityConstraint", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            bone: null,
            hierarchy: null
        },
        methods: {
            /*Spine.Unity.SkeletonUtilityConstraint.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityConstraint#OnEnable", this ); }

                this.bone = this.GetComponent(Spine.Unity.SkeletonUtilityBone);
                this.hierarchy = this.transform.GetComponentInParent(Spine.Unity.SkeletonUtility);
                this.hierarchy.RegisterConstraint(this);
            },
            /*Spine.Unity.SkeletonUtilityConstraint.OnEnable end.*/

            /*Spine.Unity.SkeletonUtilityConstraint.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityConstraint#OnDisable", this ); }

                this.hierarchy.UnregisterConstraint(this);
            },
            /*Spine.Unity.SkeletonUtilityConstraint.OnDisable end.*/


        }
    });
    /*Spine.Unity.SkeletonUtilityConstraint end.*/

    /*Spine.Unity.SpineAttributeBase start.*/
    Bridge.define("Spine.Unity.SpineAttributeBase", {
        inherits: [UnityEngine.PropertyAttribute],
        fields: {
            dataField: null,
            startsWith: null,
            includeNone: false,
            fallbackToTextField: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttributeBase#init", this ); }

                this.dataField = "";
                this.startsWith = "";
                this.includeNone = true;
                this.fallbackToTextField = false;
            }
        }
    });
    /*Spine.Unity.SpineAttributeBase end.*/

    /*Spine.Unity.SpineAtlasRegion start.*/
    Bridge.define("Spine.Unity.SpineAtlasRegion", {
        inherits: [UnityEngine.PropertyAttribute],
        fields: {
            atlasAssetField: null
        },
        ctors: {
            ctor: function (atlasAssetField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasRegion#ctor", this ); }

                if (atlasAssetField === void 0) { atlasAssetField = ""; }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.atlasAssetField = atlasAssetField;
            }
        }
    });
    /*Spine.Unity.SpineAtlasRegion end.*/

    /*Spine.Unity.SpineAttachment+Hierarchy start.*/
    /**
     * A struct that represents 3 strings that help identify and locate an attachment in a skeleton.
     *
     * @public
     * @class Spine.Unity.SpineAttachment.Hierarchy
     */
    Bridge.define("Spine.Unity.SpineAttachment.Hierarchy", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#getDefaultValue", this ); }
 return new Spine.Unity.SpineAttachment.Hierarchy(); }
            }
        },
        fields: {
            skin: null,
            slot: null,
            name: null
        },
        ctors: {
            $ctor1: function (fullPath) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#$ctor1", this ); }

                this.$initialize();
                var chunks = System.String.split(fullPath, System.Array.init([47], System.Char).map(function (i) {{ return String.fromCharCode(i); }}), null, 1);
                if (chunks.length === 0) {
                    this.skin = "";
                    this.slot = "";
                    this.name = "";
                    return;
                } else if (chunks.length < 2) {
                    throw new System.Exception("Cannot generate Attachment Hierarchy from string! Not enough components! [" + (fullPath || "") + "]");
                }
                this.skin = chunks[0];
                this.slot = chunks[1];
                this.name = "";
                for (var i = 2; i < chunks.length; i = (i + 1) | 0) {
                    this.name = (this.name || "") + (chunks[i] || "");
                }
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#getHashCode", this ); }

                var h = Bridge.addHash([3670596642, this.skin, this.slot, this.name]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.SpineAttachment.Hierarchy)) {
                    return false;
                }
                return Bridge.equals(this.skin, o.skin) && Bridge.equals(this.slot, o.slot) && Bridge.equals(this.name, o.name);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#$clone", this ); }

                var s = to || new Spine.Unity.SpineAttachment.Hierarchy();
                s.skin = this.skin;
                s.slot = this.slot;
                s.name = this.name;
                return s;
            }
        }
    });
    /*Spine.Unity.SpineAttachment+Hierarchy end.*/

    /*Spine.Unity.SpineMesh start.*/
    Bridge.define("Spine.Unity.SpineMesh", {
        statics: {
            fields: {
                MeshHideflags: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineMesh#init", this ); }

                    this.MeshHideflags = 20;
                }
            },
            methods: {
                /*Spine.Unity.SpineMesh.NewSkeletonMesh:static start.*/
                /**
                 * Factory method for creating a new mesh for use in Spine components. This can be called in field initializers.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineMesh
                 * @memberof Spine.Unity.SpineMesh
                 * @return  {UnityEngine.Mesh}
                 */
                NewSkeletonMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineMesh#NewSkeletonMesh", this ); }

                    var m = new UnityEngine.Mesh.ctor();
                    m.MarkDynamic();
                    m.name = "Skeleton Mesh";
                    m.hideFlags = Spine.Unity.SpineMesh.MeshHideflags;
                    return m;
                },
                /*Spine.Unity.SpineMesh.NewSkeletonMesh:static end.*/


            }
        }
    });
    /*Spine.Unity.SpineMesh end.*/

    /*Spine.Unity.SpineSpriteAtlasAsset+SavedRegionInfo start.*/
    Bridge.define("Spine.Unity.SpineSpriteAtlasAsset.SavedRegionInfo", {
        $kind: 1002,
        fields: {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            packingRotation: 0
        }
    });
    /*Spine.Unity.SpineSpriteAtlasAsset+SavedRegionInfo end.*/

    /*Spine.Unity.SubmeshInstruction start.*/
    /**
     * Instructions for how to generate a mesh or submesh: "Render this skeleton's slots: start slot, up to but not including endSlot, using this material."
     *
     * @public
     * @class Spine.Unity.SubmeshInstruction
     */
    Bridge.define("Spine.Unity.SubmeshInstruction", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#getDefaultValue", this ); }
 return new Spine.Unity.SubmeshInstruction(); }
            }
        },
        fields: {
            skeleton: null,
            startSlot: 0,
            endSlot: 0,
            material: null,
            forceSeparate: false,
            preActiveClippingSlotSource: 0,
            rawTriangleCount: 0,
            rawVertexCount: 0,
            rawFirstVertexIndex: 0,
            hasClipping: false
        },
        props: {
            /**
             * The number of slots in this SubmeshInstruction's range. Not necessarily the number of attachments.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SubmeshInstruction
             * @function SlotCount
             * @type number
             */
            SlotCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#SlotCount#get", this ); }

                    return ((this.endSlot - this.startSlot) | 0);
                }
            }
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SubmeshInstruction.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#toString", this ); }

                return System.String.format("[SubmeshInstruction: slots {0} to {1}. (Material){2}. preActiveClippingSlotSource:{3}]", Bridge.box(this.startSlot, System.Int32), Bridge.box(((this.endSlot - 1) | 0), System.Int32), this.material == null ? "<none>" : this.material.name, Bridge.box(this.preActiveClippingSlotSource, System.Int32));
            },
            /*Spine.Unity.SubmeshInstruction.toString end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#getHashCode", this ); }

                var h = Bridge.addHash([6756249098, this.skeleton, this.startSlot, this.endSlot, this.material, this.forceSeparate, this.preActiveClippingSlotSource, this.rawTriangleCount, this.rawVertexCount, this.rawFirstVertexIndex, this.hasClipping]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.SubmeshInstruction)) {
                    return false;
                }
                return Bridge.equals(this.skeleton, o.skeleton) && Bridge.equals(this.startSlot, o.startSlot) && Bridge.equals(this.endSlot, o.endSlot) && Bridge.equals(this.material, o.material) && Bridge.equals(this.forceSeparate, o.forceSeparate) && Bridge.equals(this.preActiveClippingSlotSource, o.preActiveClippingSlotSource) && Bridge.equals(this.rawTriangleCount, o.rawTriangleCount) && Bridge.equals(this.rawVertexCount, o.rawVertexCount) && Bridge.equals(this.rawFirstVertexIndex, o.rawFirstVertexIndex) && Bridge.equals(this.hasClipping, o.hasClipping);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#$clone", this ); }

                var s = to || new Spine.Unity.SubmeshInstruction();
                s.skeleton = this.skeleton;
                s.startSlot = this.startSlot;
                s.endSlot = this.endSlot;
                s.material = this.material;
                s.forceSeparate = this.forceSeparate;
                s.preActiveClippingSlotSource = this.preActiveClippingSlotSource;
                s.rawTriangleCount = this.rawTriangleCount;
                s.rawVertexCount = this.rawVertexCount;
                s.rawFirstVertexIndex = this.rawFirstVertexIndex;
                s.hasClipping = this.hasClipping;
                return s;
            }
        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.Unity.SubmeshInstruction end.*/

    /*Spine.Unity.UpdateMode start.*/
    Bridge.define("Spine.Unity.UpdateMode", {
        $kind: 6,
        statics: {
            fields: {
                Nothing: 0,
                OnlyAnimationStatus: 1,
                OnlyEventTimelines: 4,
                EverythingExceptMesh: 2,
                FullUpdate: 3
            }
        }
    });
    /*Spine.Unity.UpdateMode end.*/

    /*Spine.Unity.WaitForSpineAnimation start.*/
    /**
     * Use this as a condition-blocking yield instruction for Unity Coroutines.
     The routine will pause until the AnimationState.TrackEntry fires any of the
     configured events.
     <p />
     See the {@link }
     and {@link }
     for more information on when track events will be triggered.
     *
     * @public
     * @class Spine.Unity.WaitForSpineAnimation
     * @implements  System.Collections.IEnumerator
     */
    Bridge.define("Spine.Unity.WaitForSpineAnimation", {
        inherits: [System.Collections.IEnumerator],
        fields: {
            m_WasFired: false
        },
        props: {
            System$Collections$IEnumerator$Current: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$Current#get", this ); }

                    return null;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#init", this ); }

                this.m_WasFired = false;
            },
            ctor: function (trackEntry, eventsToWaitFor) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#ctor", this ); }

                this.$initialize();
                this.SafeSubscribe(trackEntry, eventsToWaitFor);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineAnimation.NowWaitFor start.*/
            /**
             * One optimization high-frequency YieldInstruction returns is to cache instances to minimize GC pressure.
             Use NowWaitFor to reuse the same instance of WaitForSpineAnimationComplete.
             *
             * @instance
             * @public
             * @this Spine.Unity.WaitForSpineAnimation
             * @memberof Spine.Unity.WaitForSpineAnimation
             * @param   {Spine.TrackEntry}                     trackEntry         
             * @param   {number}                               eventsToWaitFor
             * @return  {Spine.Unity.WaitForSpineAnimation}
             */
            NowWaitFor: function (trackEntry, eventsToWaitFor) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#NowWaitFor", this ); }

                this.SafeSubscribe(trackEntry, eventsToWaitFor);
                return this;
            },
            /*Spine.Unity.WaitForSpineAnimation.NowWaitFor end.*/

            /*Spine.Unity.WaitForSpineAnimation.System$Collections$IEnumerator$moveNext start.*/
            System$Collections$IEnumerator$moveNext: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$moveNext", this ); }

                if (this.m_WasFired) {
                    Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset(); // auto-reset for YieldInstruction reuse
                    return false;
                }

                return true;
            },
            /*Spine.Unity.WaitForSpineAnimation.System$Collections$IEnumerator$moveNext end.*/

            /*Spine.Unity.WaitForSpineAnimation.System$Collections$IEnumerator$reset start.*/
            System$Collections$IEnumerator$reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$reset", this ); }

                this.m_WasFired = false;
            },
            /*Spine.Unity.WaitForSpineAnimation.System$Collections$IEnumerator$reset end.*/

            /*Spine.Unity.WaitForSpineAnimation.SafeSubscribe start.*/
            SafeSubscribe: function (trackEntry, eventsToWaitFor) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#SafeSubscribe", this ); }

                if (trackEntry == null) {
                    // Break immediately if trackEntry is null.
                    UnityEngine.Debug.LogWarning$1("TrackEntry was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                } else {
                    if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Start) !== 0) {
                        trackEntry.addStart(Bridge.fn.cacheBind(this, this.HandleComplete));
                    }
                    if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Interrupt) !== 0) {
                        trackEntry.addInterrupt(Bridge.fn.cacheBind(this, this.HandleComplete));
                    }
                    if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.End) !== 0) {
                        trackEntry.addEnd(Bridge.fn.cacheBind(this, this.HandleComplete));
                    }
                    if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Dispose) !== 0) {
                        trackEntry.addDispose(Bridge.fn.cacheBind(this, this.HandleComplete));
                    }
                    if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Complete) !== 0) {
                        trackEntry.addComplete(Bridge.fn.cacheBind(this, this.HandleComplete));
                    }
                }
            },
            /*Spine.Unity.WaitForSpineAnimation.SafeSubscribe end.*/

            /*Spine.Unity.WaitForSpineAnimation.HandleComplete start.*/
            HandleComplete: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#HandleComplete", this ); }

                this.m_WasFired = true;
            },
            /*Spine.Unity.WaitForSpineAnimation.HandleComplete end.*/


        }
    });
    /*Spine.Unity.WaitForSpineAnimation end.*/

    /*Spine.Unity.WaitForSpineAnimation+AnimationEventTypes start.*/
    Bridge.define("Spine.Unity.WaitForSpineAnimation.AnimationEventTypes", {
        $kind: 1006,
        statics: {
            fields: {
                Start: 1,
                Interrupt: 2,
                End: 4,
                Dispose: 8,
                Complete: 16
            }
        },
        $flags: true
    });
    /*Spine.Unity.WaitForSpineAnimation+AnimationEventTypes end.*/

    /*Spine.Unity.WaitForSpineEvent start.*/
    /**
     * Use this as a condition-blocking yield instruction for Unity Coroutines.
     The routine will pause until the AnimationState fires an event matching the given event name or EventData reference.
     *
     * @public
     * @class Spine.Unity.WaitForSpineEvent
     * @implements  System.Collections.IEnumerator
     */
    Bridge.define("Spine.Unity.WaitForSpineEvent", {
        inherits: [System.Collections.IEnumerator],
        fields: {
            m_TargetEvent: null,
            m_EventName: null,
            m_AnimationState: null,
            m_WasFired: false,
            m_unsubscribeAfterFiring: false
        },
        props: {
            /**
             * By default, WaitForSpineEvent will unsubscribe from the event immediately after it fires a correct matching event.
             If you want to reuse this WaitForSpineEvent instance on the same event, you can set this to false.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.WaitForSpineEvent
             * @function WillUnsubscribeAfterFiring
             * @type boolean
             */
            WillUnsubscribeAfterFiring: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#WillUnsubscribeAfterFiring#get", this ); }

                    return this.m_unsubscribeAfterFiring;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#WillUnsubscribeAfterFiring#set", this ); }

                    this.m_unsubscribeAfterFiring = value;
                }
            },
            System$Collections$IEnumerator$Current: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$Current#get", this ); }

                    return null;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#init", this ); }

                this.m_WasFired = false;
                this.m_unsubscribeAfterFiring = false;
            },
            ctor: function (state, eventDataReference, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#ctor", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                this.Subscribe(state, eventDataReference, unsubscribeAfterFiring);
            },
            $ctor2: function (skeletonAnimation, eventDataReference, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#$ctor2", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                // If skeletonAnimation is invalid, its state will be null. Subscribe handles null states just fine.
                this.Subscribe(skeletonAnimation.state, eventDataReference, unsubscribeAfterFiring);
            },
            $ctor1: function (state, eventName, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#$ctor1", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                this.SubscribeByName(state, eventName, unsubscribeAfterFiring);
            },
            $ctor3: function (skeletonAnimation, eventName, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#$ctor3", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                // If skeletonAnimation is invalid, its state will be null. Subscribe handles null states just fine.
                this.SubscribeByName(skeletonAnimation.state, eventName, unsubscribeAfterFiring);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineEvent.Subscribe start.*/
            Subscribe: function (state, eventDataReference, unsubscribe) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#Subscribe", this ); }

                if (state == null) {
                    UnityEngine.Debug.LogWarning$1("AnimationState argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                } else if (eventDataReference == null) {
                    UnityEngine.Debug.LogWarning$1("eventDataReference argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                }

                this.m_AnimationState = state;
                this.m_TargetEvent = eventDataReference;
                state.addEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEvent));

                this.m_unsubscribeAfterFiring = unsubscribe;

            },
            /*Spine.Unity.WaitForSpineEvent.Subscribe end.*/

            /*Spine.Unity.WaitForSpineEvent.SubscribeByName start.*/
            SubscribeByName: function (state, eventName, unsubscribe) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#SubscribeByName", this ); }

                if (state == null) {
                    UnityEngine.Debug.LogWarning$1("AnimationState argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                } else if (System.String.isNullOrEmpty(eventName)) {
                    UnityEngine.Debug.LogWarning$1("eventName argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                }

                this.m_AnimationState = state;
                this.m_EventName = eventName;
                state.addEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEventByName));

                this.m_unsubscribeAfterFiring = unsubscribe;
            },
            /*Spine.Unity.WaitForSpineEvent.SubscribeByName end.*/

            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEventByName start.*/
            HandleAnimationStateEventByName: function (trackEntry, e) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#HandleAnimationStateEventByName", this ); }

                this.m_WasFired = !!(this.m_WasFired | (Bridge.referenceEquals(e.Data.Name, this.m_EventName))); // Check event name string match.
                if (this.m_WasFired && this.m_unsubscribeAfterFiring) {
                    this.m_AnimationState.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEventByName));
                } // Unsubscribe after correct event fires.
            },
            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEventByName end.*/

            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEvent start.*/
            HandleAnimationStateEvent: function (trackEntry, e) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#HandleAnimationStateEvent", this ); }

                this.m_WasFired = !!(this.m_WasFired | (Bridge.referenceEquals(e.Data, this.m_TargetEvent))); // Check event data reference match.
                if (this.m_WasFired && this.m_unsubscribeAfterFiring) {
                    this.m_AnimationState.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEvent));
                } // Usubscribe after correct event fires.
            },
            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEvent end.*/

            /*Spine.Unity.WaitForSpineEvent.NowWaitFor start.*/
            NowWaitFor: function (state, eventDataReference, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#NowWaitFor", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }
                Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset();
                this.Clear(state);
                this.Subscribe(state, eventDataReference, unsubscribeAfterFiring);

                return this;
            },
            /*Spine.Unity.WaitForSpineEvent.NowWaitFor end.*/

            /*Spine.Unity.WaitForSpineEvent.NowWaitFor$1 start.*/
            NowWaitFor$1: function (state, eventName, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#NowWaitFor$1", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }
                Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset();
                this.Clear(state);
                this.SubscribeByName(state, eventName, unsubscribeAfterFiring);

                return this;
            },
            /*Spine.Unity.WaitForSpineEvent.NowWaitFor$1 end.*/

            /*Spine.Unity.WaitForSpineEvent.Clear start.*/
            Clear: function (state) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#Clear", this ); }

                state.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEvent));
                state.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEventByName));
            },
            /*Spine.Unity.WaitForSpineEvent.Clear end.*/

            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$moveNext start.*/
            System$Collections$IEnumerator$moveNext: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$moveNext", this ); }

                if (this.m_WasFired) {
                    Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset(); // auto-reset for YieldInstruction reuse
                    return false;
                }

                return true;
            },
            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$moveNext end.*/

            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$reset start.*/
            System$Collections$IEnumerator$reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$reset", this ); }

                this.m_WasFired = false;
            },
            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$reset end.*/


        },
        overloads: {
            "NowWaitFor(Spine.AnimationState, string, bool)": "NowWaitFor$1"
        }
    });
    /*Spine.Unity.WaitForSpineEvent end.*/

    /*Spine.Unity.WaitForSpineTrackEntryEnd start.*/
    /**
     * Use this as a condition-blocking yield instruction for Unity Coroutines.
     The routine will pause until the AnimationState.TrackEntry fires its End event.
     *
     * @public
     * @class Spine.Unity.WaitForSpineTrackEntryEnd
     * @implements  System.Collections.IEnumerator
     */
    Bridge.define("Spine.Unity.WaitForSpineTrackEntryEnd", {
        inherits: [System.Collections.IEnumerator],
        fields: {
            m_WasFired: false
        },
        props: {
            System$Collections$IEnumerator$Current: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#System$Collections$IEnumerator$Current#get", this ); }

                    return null;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#init", this ); }

                this.m_WasFired = false;
            },
            ctor: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#ctor", this ); }

                this.$initialize();
                this.SafeSubscribe(trackEntry);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineTrackEntryEnd.HandleEnd start.*/
            HandleEnd: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#HandleEnd", this ); }

                this.m_WasFired = true;
            },
            /*Spine.Unity.WaitForSpineTrackEntryEnd.HandleEnd end.*/

            /*Spine.Unity.WaitForSpineTrackEntryEnd.SafeSubscribe start.*/
            SafeSubscribe: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#SafeSubscribe", this ); }

                if (trackEntry == null) {
                    // Break immediately if trackEntry is null.
                    UnityEngine.Debug.LogWarning$1("TrackEntry was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                } else {
                    trackEntry.addEnd(Bridge.fn.cacheBind(this, this.HandleEnd));
                }
            },
            /*Spine.Unity.WaitForSpineTrackEntryEnd.SafeSubscribe end.*/

            /*Spine.Unity.WaitForSpineTrackEntryEnd.NowWaitFor start.*/
            /**
             * One optimization high-frequency YieldInstruction returns is to cache instances to minimize GC pressure.
             Use NowWaitFor to reuse the same instance of WaitForSpineAnimationEnd.
             *
             * @instance
             * @public
             * @this Spine.Unity.WaitForSpineTrackEntryEnd
             * @memberof Spine.Unity.WaitForSpineTrackEntryEnd
             * @param   {Spine.TrackEntry}                         trackEntry
             * @return  {Spine.Unity.WaitForSpineTrackEntryEnd}
             */
            NowWaitFor: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#NowWaitFor", this ); }

                this.SafeSubscribe(trackEntry);
                return this;
            },
            /*Spine.Unity.WaitForSpineTrackEntryEnd.NowWaitFor end.*/

            /*Spine.Unity.WaitForSpineTrackEntryEnd.System$Collections$IEnumerator$moveNext start.*/
            System$Collections$IEnumerator$moveNext: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#System$Collections$IEnumerator$moveNext", this ); }

                if (this.m_WasFired) {
                    Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset(); // auto-reset for YieldInstruction reuse
                    return false;
                }

                return true;
            },
            /*Spine.Unity.WaitForSpineTrackEntryEnd.System$Collections$IEnumerator$moveNext end.*/

            /*Spine.Unity.WaitForSpineTrackEntryEnd.System$Collections$IEnumerator$reset start.*/
            System$Collections$IEnumerator$reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#System$Collections$IEnumerator$reset", this ); }

                this.m_WasFired = false;
            },
            /*Spine.Unity.WaitForSpineTrackEntryEnd.System$Collections$IEnumerator$reset end.*/


        }
    });
    /*Spine.Unity.WaitForSpineTrackEntryEnd end.*/

    /*TransformToMouseDirection start.*/
    Bridge.define("TransformToMouseDirection", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            w2: null,
            dir: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TransformToMouseDirection#init", this ); }

                this.dir = new UnityEngine.Vector3();
            }
        },
        methods: {
            /*TransformToMouseDirection.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "TransformToMouseDirection#Start", this ); }

                this.w2 = this.GetComponent(Water2D.Water2D_Spawner);
                this.w2.StopSpawning();
            },
            /*TransformToMouseDirection.Start end.*/

            /*TransformToMouseDirection.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "TransformToMouseDirection#Update", this ); }

                this.dir = this.transform.position.$clone().sub( UnityEngine.Camera.main.ScreenToWorldPoint(UnityEngine.Input.mousePosition) );
                this.dir.z *= 0;
                this.transform.up = this.dir.$clone().scale( -1 );

                this.w2.Speed = this.dir.length() * 3.0;
                this.w2.Speed = Math.max(7.0, Math.min(this.w2.Speed, 25.0));

                if (UnityEngine.MonoBehaviour.op_Inequality(this.w2, null)) {

                    if (UnityEngine.Input.GetMouseButton(0)) {
                        if (!this.w2.IsSpawning) {
                            this.w2.Spawn();
                        }
                    } else {
                        if (this.w2.IsSpawning) {
                            this.w2.StopSpawning();
                        }
                    }


                }

            },
            /*TransformToMouseDirection.Update end.*/


        }
    });
    /*TransformToMouseDirection end.*/

    /*TypeBeverage start.*/
    Bridge.define("TypeBeverage", {
        $kind: 6,
        statics: {
            fields: {
                Coca: 0,
                Lemon: 1,
                MilkTea: 2
            }
        }
    });
    /*TypeBeverage end.*/

    /*TypeDestroy start.*/
    Bridge.define("TypeDestroy", {
        $kind: 6,
        statics: {
            fields: {
                DISABLE: 0,
                RESPAWNER: 1,
                DESTROY: 2
            }
        }
    });
    /*TypeDestroy end.*/

    /*VectorUlti start.*/
    Bridge.define("VectorUlti", {
        statics: {
            methods: {
                /*VectorUlti.GetVectorFromAngle:static start.*/
                GetVectorFromAngle: function (angle) {
if ( TRACE ) { TRACE( "VectorUlti#GetVectorFromAngle", this ); }

                    var angleRad = angle * (0.0174532924);
                    return new pc.Vec3( Math.cos(angleRad), 0, Math.sin(angleRad) );
                },
                /*VectorUlti.GetVectorFromAngle:static end.*/

                /*VectorUlti.GetAngleFromVector:static start.*/
                GetAngleFromVector: function (dir) {
if ( TRACE ) { TRACE( "VectorUlti#GetAngleFromVector", this ); }

                    dir = dir.clone().normalize().$clone();
                    var angle = Math.atan2(dir.z, dir.x) * UnityEngine.Mathf.Rad2Deg;
                    if (angle < 0) {
                        angle += 360;
                    }
                    //int angle = Mathf.RoundToInt(n);

                    return angle;
                },
                /*VectorUlti.GetAngleFromVector:static end.*/

                /*VectorUlti.Set$1:static start.*/
                Set$1: function (vector3, x, y, z) {
if ( TRACE ) { TRACE( "VectorUlti#Set$1", this ); }

                    if (x === void 0) { x = null; }
                    if (y === void 0) { y = null; }
                    if (z === void 0) { z = null; }
                    return new pc.Vec3( x == null ? vector3.x : System.Nullable.getValue(x), y == null ? vector3.y : System.Nullable.getValue(y), z == null ? vector3.z : System.Nullable.getValue(z) );
                },
                /*VectorUlti.Set$1:static end.*/

                /*VectorUlti.Set:static start.*/
                Set: function (vector2, x, y) {
if ( TRACE ) { TRACE( "VectorUlti#Set", this ); }

                    if (x === void 0) { x = null; }
                    if (y === void 0) { y = null; }
                    return new pc.Vec2( x == null ? vector2.x : System.Nullable.getValue(x), y == null ? vector2.y : System.Nullable.getValue(y) );
                },
                /*VectorUlti.Set:static end.*/

                /*VectorUlti.Move:static start.*/
                Move: function (vector3, direction) {
if ( TRACE ) { TRACE( "VectorUlti#Move", this ); }

                    return vector3.$clone().add( direction );
                },
                /*VectorUlti.Move:static end.*/

                /*VectorUlti.ToVectorXZ:static start.*/
                ToVectorXZ: function (vector3) {
if ( TRACE ) { TRACE( "VectorUlti#ToVectorXZ", this ); }

                    return new pc.Vec2( vector3.x, vector3.z );
                },
                /*VectorUlti.ToVectorXZ:static end.*/


            }
        }
    });
    /*VectorUlti end.*/

    /*Water2D._SpawnExampleController start.*/
    Bridge.define("Water2D._SpawnExampleController", {
        inherits: [UnityEngine.MonoBehaviour],
        methods: {
            /*Water2D._SpawnExampleController.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Water2D._SpawnExampleController#Start", this ); }

                //Water2D_Spawner.instance.Loop = true;
                //Water2D_Spawner.instance.Spawn ();
                //Water2D_Spawner.instance.LifeTime = -1;
            },
            /*Water2D._SpawnExampleController.Start end.*/

            /*Water2D._SpawnExampleController.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Water2D._SpawnExampleController#Update", this ); }


            },
            /*Water2D._SpawnExampleController.Update end.*/


        }
    });
    /*Water2D._SpawnExampleController end.*/

    /*Water2D.ColliderFiller start.*/
    Bridge.define("Water2D.ColliderFiller", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            methods: {
                /*Water2D.ColliderFiller.GetBoxPoints:static start.*/
                /**
                 * Get points from BoxCollider2D
                 *
                 * @static
                 * @public
                 * @this Water2D.ColliderFiller
                 * @memberof Water2D.ColliderFiller
                 * @param   {UnityEngine.BoxCollider2D}      box
                 * @return  {Array.<UnityEngine.Vector2>}
                 */
                GetBoxPoints: function (box) {
if ( TRACE ) { TRACE( "Water2D.ColliderFiller#GetBoxPoints", this ); }

                    return System.Array.init([UnityEngine.Vector2.FromVector3(box.transform.TransformPoint$1(new pc.Vec3( -box.size.x, box.size.y, 0 ).clone().scale( 0.5 ))), UnityEngine.Vector2.FromVector3(box.transform.TransformPoint$1(new pc.Vec3( box.size.x, box.size.y, 0 ).clone().scale( 0.5 ))), UnityEngine.Vector2.FromVector3(box.transform.TransformPoint$1(new pc.Vec3( box.size.x, -box.size.y, 0 ).clone().scale( 0.5 ))), UnityEngine.Vector2.FromVector3(box.transform.TransformPoint$1(new pc.Vec3( -box.size.x, -box.size.y, 0 ).clone().scale( 0.5 )))], UnityEngine.Vector2);
                },
                /*Water2D.ColliderFiller.GetBoxPoints:static end.*/

                /*Water2D.ColliderFiller.GetCirclePoints:static start.*/
                /**
                 * Get points from CircleCollider2D
                 *
                 * @static
                 * @public
                 * @this Water2D.ColliderFiller
                 * @memberof Water2D.ColliderFiller
                 * @param   {UnityEngine.CircleCollider2D}    circle    
                 * @param   {number}                          count
                 * @return  {Array.<UnityEngine.Vector2>}
                 */
                GetCirclePoints: function (circle, count) {
if ( TRACE ) { TRACE( "Water2D.ColliderFiller#GetCirclePoints", this ); }

                    var result = System.Array.init(count, function (){
                        return new UnityEngine.Vector2();
                    }, UnityEngine.Vector2);
                    for (var i = 0; i < count; i = (i + 1) | 0) {
                        var angle = i * UnityEngine.Mathf.PI * 2 / count;
                        result[i] = UnityEngine.Vector2.FromVector3(circle.transform.TransformPoint$1(UnityEngine.Vector3.FromVector2(new pc.Vec2( Math.cos(angle), Math.sin(angle) ).scale( circle.radius ))));
                    }
                    return result;
                },
                /*Water2D.ColliderFiller.GetCirclePoints:static end.*/

                /*Water2D.ColliderFiller.GetPolygonPoints:static start.*/
                /**
                 * Get points from PolygonCollider2D
                 *
                 * @static
                 * @public
                 * @this Water2D.ColliderFiller
                 * @memberof Water2D.ColliderFiller
                 * @param   {UnityEngine.PolygonCollider2D}    polygon
                 * @return  {Array.<UnityEngine.Vector2>}
                 */
                GetPolygonPoints: function (polygon) {
if ( TRACE ) { TRACE( "Water2D.ColliderFiller#GetPolygonPoints", this ); }

                    var $t;
                    var count = polygon.points.length;
                    var result = System.Array.init(count, function (){
                        return new UnityEngine.Vector2();
                    }, UnityEngine.Vector2);
                    for (var i = 0; i < count; i = (i + 1) | 0) {
                        result[i] = UnityEngine.Vector2.FromVector3(polygon.transform.TransformPoint$1(UnityEngine.Vector3.FromVector2(($t = polygon.points)[i])));
                    }
                    return result;
                },
                /*Water2D.ColliderFiller.GetPolygonPoints:static end.*/

                /*Water2D.ColliderFiller.IsPointInPolygon:static start.*/
                /**
                 * From: https://codereview.stackexchange.com/questions/108857/point-inside-polygon-check
                 *
                 * @static
                 * @public
                 * @this Water2D.ColliderFiller
                 * @memberof Water2D.ColliderFiller
                 * @param   {UnityEngine.Vector2}            point      
                 * @param   {Array.<UnityEngine.Vector2>}    polygon    
                 * @param   {boolean}                        masked
                 * @return  {boolean}
                 */
                IsPointInPolygon: function (point, polygon, masked) {
if ( TRACE ) { TRACE( "Water2D.ColliderFiller#IsPointInPolygon", this ); }

                    if (masked === void 0) { masked = false; }
                    var polygonLength = polygon.length, i = 0;
                    var inside = masked;
                    var pointX = point.x, pointY = point.y;
                    var startX, startY, endX, endY;
                    var endPoint = polygon[((polygonLength - 1) | 0)].$clone();
                    endX = endPoint.x;
                    endY = endPoint.y;
                    while (i < polygonLength) {
                        startX = endX;
                        startY = endY;
                        endPoint = polygon[Bridge.identity(i, ((i = (i + 1) | 0)))].$clone();
                        endX = endPoint.x;
                        endY = endPoint.y;
                        inside = inside != (endY > pointY != startY > pointY) && ((pointX - endX) < (pointY - endY) * (startX - endX) / (startY - endY));
                    }
                    return inside;
                },
                /*Water2D.ColliderFiller.IsPointInPolygon:static end.*/


            }
        },
        fields: {
            collider: null,
            water2D_Spawner: null,
            radius: 0,
            circleDetailPoints: 0,
            autoRefresh: false,
            pointsInside: null,
            pointsOutside: null,
            Masked: false,
            _lastCollider: null
        },
        props: {
            PointsInside: {
                get: function () {
if ( TRACE ) { TRACE( "Water2D.ColliderFiller#PointsInside#get", this ); }

                    return this.pointsInside;
                }
            },
            PointsOutside: {
                get: function () {
if ( TRACE ) { TRACE( "Water2D.ColliderFiller#PointsOutside#get", this ); }

                    return this.pointsOutside;
                }
            },
            InsidePointsCount: {
                get: function () {
if ( TRACE ) { TRACE( "Water2D.ColliderFiller#InsidePointsCount#get", this ); }

                    return this.pointsInside != null ? this.pointsInside.length : 0;
                }
            },
            OutsidePointsCount: {
                get: function () {
if ( TRACE ) { TRACE( "Water2D.ColliderFiller#OutsidePointsCount#get", this ); }

                    return this.pointsOutside != null ? this.pointsOutside.length : 0;
                }
            },
            Radius: {
                get: function () {
if ( TRACE ) { TRACE( "Water2D.ColliderFiller#Radius#get", this ); }

                    return UnityEngine.MonoBehaviour.op_Inequality(this.water2D_Spawner, null) ? this.water2D_Spawner.ColliderSize * this.water2D_Spawner.size : this.radius;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Water2D.ColliderFiller#init", this ); }

                this.radius = 1;
                this.circleDetailPoints = 10;
                this.autoRefresh = false;
            }
        },
        methods: {
            /*Water2D.ColliderFiller.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Water2D.ColliderFiller#Update", this ); }

                //if (autoRefresh)
                // Refresh();

                if (UnityEngine.Component.op_Inequality(this._lastCollider, this.collider)) {
                    this._lastCollider = this.collider;

                    this.Refresh();
                    this.Fill();
                }
            },
            /*Water2D.ColliderFiller.Update end.*/

            /*Water2D.ColliderFiller.Refresh start.*/
            Refresh: function () {
if ( TRACE ) { TRACE( "Water2D.ColliderFiller#Refresh", this ); }

                if (UnityEngine.Component.op_Equality(this.collider, null)) {
                    return;
                }

                var pointsInside = { };
                var pointsOutside = { };
                var zPos = this.collider.transform.position.z;
                var radius = this.radius;
                if (UnityEngine.Object.op_Implicit(this.water2D_Spawner)) {
                    radius = this.water2D_Spawner.ColliderSize * this.water2D_Spawner.size;
                }
                this.GetPointsInCollider(this.collider, radius, pointsInside, pointsOutside, zPos, this.Masked);
                this.pointsInside = pointsInside.v;
                this.pointsOutside = pointsOutside.v;
                this.water2D_Spawner.DropsUsed = this.PointsInside.length;
            },
            /*Water2D.ColliderFiller.Refresh end.*/

            /*Water2D.ColliderFiller.Fill start.*/
            Fill: function () {
if ( TRACE ) { TRACE( "Water2D.ColliderFiller#Fill", this ); }

                var $t, $t1;
                if (UnityEngine.MonoBehaviour.op_Equality(this.water2D_Spawner, null)) {
                    UnityEngine.Debug.LogError$2("Water2D Spawner is NULL!");
                    return;
                }

                //water2D_Spawner.DropCount = Mathf.Max(pointsInside.Length, water2D_Spawner.DropCount);

                this.water2D_Spawner.SetupParticles();

                var currentMetaball;
                for (var i = 0; i < this.pointsInside.length; i = (i + 1) | 0) {

                    if (i >= this.water2D_Spawner.WaterDropsObjects.length) {
                        UnityEngine.Debug.LogWarning$1("Points in the shape exceed the number of drops. You should increment to " + this.pointsInside.length + " drops in the spawner");
                        return;

                    }
                    ($t = this.water2D_Spawner.WaterDropsObjects)[i].transform.position = this.pointsInside[i].$clone();
                    currentMetaball = ($t1 = this.water2D_Spawner.WaterDropsObjects)[i].GetComponent(MetaballParticleClass);
                    if (UnityEngine.Object.op_Implicit(currentMetaball)) {
                        currentMetaball.Active = true;
                    }
                }
            },
            /*Water2D.ColliderFiller.Fill end.*/

            /*Water2D.ColliderFiller.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Water2D.ColliderFiller#Clear", this ); }

                var $t, $t1;


                if (UnityEngine.MonoBehaviour.op_Equality(this.water2D_Spawner, null)) {
                    UnityEngine.Debug.LogError$2("Water2D Spawner is NULL!");
                    return;
                }
                var currentMetaball;
                for (var i = 0; i < this.pointsInside.length; i = (i + 1) | 0) {
                    ($t = this.water2D_Spawner.WaterDropsObjects)[i].transform.position = this.pointsInside[i].$clone();
                    currentMetaball = ($t1 = this.water2D_Spawner.WaterDropsObjects)[i].GetComponent(MetaballParticleClass);
                    if (UnityEngine.Object.op_Implicit(currentMetaball)) {
                        currentMetaball.Active = true;
                    }
                }
                this.water2D_Spawner.Restore();
            },
            /*Water2D.ColliderFiller.Clear end.*/

            /*Water2D.ColliderFiller.GetPointsInCollider start.*/
            /**
             * Get all point at Collider bounds!
             *
             * @instance
             * @private
             * @this Water2D.ColliderFiller
             * @memberof Water2D.ColliderFiller
             * @param   {UnityEngine.Collider2D}    collider          the collider we work with
             * @param   {number}                    r                 radius of circle
             * @param   {UnityEngine.Vector3}       _pointsInside     result: inside points
             * @param   {UnityEngine.Vector3}       _pointsOutside    result: outside points
             * @param   {number}                    zPos              z position, if needed, default = 0
             * @param   {boolean}                   masked
             * @return  {void}
             */
            GetPointsInCollider: function (collider, r, _pointsInside, _pointsOutside, zPos, masked) {
if ( TRACE ) { TRACE( "Water2D.ColliderFiller#GetPointsInCollider", this ); }

                if (zPos === void 0) { zPos = 0.0; }
                if (masked === void 0) { masked = false; }
                if (UnityEngine.Component.op_Equality(collider, null)) {
                    UnityEngine.Debug.LogError$2("Collider is NULL!");
                    _pointsInside.v = null;
                    _pointsOutside.v = null;
                    return;
                }

                var pointsInside = new (System.Collections.Generic.List$1(UnityEngine.Vector3)).ctor();
                var pointsOutside = new (System.Collections.Generic.List$1(UnityEngine.Vector3)).ctor();

                var isBox = Bridge.is(collider, UnityEngine.BoxCollider2D);
                var isCircle = Bridge.is(collider, UnityEngine.CircleCollider2D);
                var isPolygon = Bridge.is(collider, UnityEngine.PolygonCollider2D);

                var polygonPoints = null;

                if (isBox) {
                    polygonPoints = Water2D.ColliderFiller.GetBoxPoints(Bridge.as(collider, UnityEngine.BoxCollider2D));
                } else {
                    if (isCircle) {
                        polygonPoints = Water2D.ColliderFiller.GetCirclePoints(Bridge.as(collider, UnityEngine.CircleCollider2D), this.circleDetailPoints);
                    } else {
                        if (isPolygon) {
                            polygonPoints = Water2D.ColliderFiller.GetPolygonPoints(Bridge.as(collider, UnityEngine.PolygonCollider2D));
                        }
                    }
                }

                var action = function (currentPos) {
                    if (isBox || isCircle || isPolygon) {
                        var inPolygon = Water2D.ColliderFiller.IsPointInPolygon(UnityEngine.Vector2.FromVector3(currentPos.$clone()), polygonPoints, masked);
                        if (inPolygon) {
                            pointsInside.add(currentPos.$clone());
                        } else {
                            pointsOutside.add(currentPos.$clone());
                        }
                    }
                };

                this.FillByGrid(collider, r, action, zPos);

                _pointsInside.v = pointsInside.ToArray();
                _pointsOutside.v = pointsOutside.ToArray();
            },
            /*Water2D.ColliderFiller.GetPointsInCollider end.*/

            /*Water2D.ColliderFiller.FillByGrid start.*/
            /**
             * Get points by grid and invoke action on every point
             *
             * @instance
             * @private
             * @this Water2D.ColliderFiller
             * @memberof Water2D.ColliderFiller
             * @param   {UnityEngine.Collider2D}    collider    
             * @param   {number}                    r           
             * @param   {System.Action}             action      
             * @param   {number}                    zPos
             * @return  {void}
             */
            FillByGrid: function (collider, r, action, zPos) {
if ( TRACE ) { TRACE( "Water2D.ColliderFiller#FillByGrid", this ); }

                if (zPos === void 0) { zPos = 0.0; }
                var bounds = collider.bounds;
                var d = r * 2;
                var countX = Bridge.Int.clip32(bounds.halfExtents.$clone().scale( 2 ).x / d);
                var countY = Bridge.Int.clip32(bounds.halfExtents.$clone().scale( 2 ).y / d);
                var halfSize = bounds.halfExtents.$clone().scale( 2 ).$clone().scale( 1.0 / ( 2 ) );

                var currentPos = pc.Vec3.ZERO.clone();
                for (var y = 0; y < countY; y = (y + 1) | 0) {
                    for (var x = 0; x < countX; x = (x + 1) | 0) {
                        currentPos = bounds.center.$clone().add( new pc.Vec3( x * d + r, y * d + r, zPos ) ).sub( halfSize );
                        !Bridge.staticEquals(action, null) ? action(currentPos.$clone()) : null;
                    }
                }
            },
            /*Water2D.ColliderFiller.FillByGrid end.*/


        }
    });
    /*Water2D.ColliderFiller end.*/

    /*Water2D.ColorPicker start.*/
    Bridge.define("Water2D.ColorPicker", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            W2D: null,
            Delay: 0,
            Colors: null,
            delta: 0
        },
        methods: {
            /*Water2D.ColorPicker.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Water2D.ColorPicker#Update", this ); }

                if (this.delta >= this.Delay) { // tick 

                    if (this.Colors == null) {
                        return;
                    }

                    if (UnityEngine.MonoBehaviour.op_Equality(this.W2D, null)) {
                        return;
                    }

                    this.W2D.FillColor = this.Colors[UnityEngine.Random.Range(0, this.Colors.length)].$clone();

                    this.delta *= 0;
                } else {
                    this.delta += UnityEngine.Time.deltaTime;
                }
            },
            /*Water2D.ColorPicker.Update end.*/


        }
    });
    /*Water2D.ColorPicker end.*/

    /*Water2D.Extentions.ColliderTrigger start.*/
    Bridge.define("Water2D.Extentions.ColliderTrigger", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            colliderFiller: null,
            tags: null,
            check: false,
            onTrue: null,
            onFalse: null,
            inArea: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Water2D.Extentions.ColliderTrigger#init", this ); }

                this.tags = function (_o1) {
                        _o1.add("Metaball_liquid");
                        return _o1;
                    }(new (System.Collections.Generic.List$1(System.String)).ctor());
                this.check = false;
            }
        },
        methods: {
            /*Water2D.Extentions.ColliderTrigger.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Water2D.Extentions.ColliderTrigger#Start", this ); }

                if (this.inArea == null) {
                    this.inArea = new (System.Collections.Generic.List$1(UnityEngine.Transform)).ctor();
                }
                this.Apply(false);
            },
            /*Water2D.Extentions.ColliderTrigger.Start end.*/

            /*Water2D.Extentions.ColliderTrigger.Apply start.*/
            Apply: function (active) {
if ( TRACE ) { TRACE( "Water2D.Extentions.ColliderTrigger#Apply", this ); }

                if (active) {
                    this.onTrue != null ? this.onTrue.Invoke() : null;
                } else {
                    this.onFalse != null ? this.onFalse.Invoke() : null;
                }
            },
            /*Water2D.Extentions.ColliderTrigger.Apply end.*/

            /*Water2D.Extentions.ColliderTrigger.CheckFilled start.*/
            CheckFilled: function () {
if ( TRACE ) { TRACE( "Water2D.Extentions.ColliderTrigger#CheckFilled", this ); }

                if (this.inArea == null) {
                    this.inArea = new (System.Collections.Generic.List$1(UnityEngine.Transform)).ctor();
                }
                if (this.inArea != null && UnityEngine.MonoBehaviour.op_Inequality(this.colliderFiller, null)) {
                    return this.inArea.Count >= this.colliderFiller.InsidePointsCount;
                }
                return false;
            },
            /*Water2D.Extentions.ColliderTrigger.CheckFilled end.*/

            /*Water2D.Extentions.ColliderTrigger.OnTriggerEnter2D start.*/
            OnTriggerEnter2D: function (collision) {
if ( TRACE ) { TRACE( "Water2D.Extentions.ColliderTrigger#OnTriggerEnter2D", this ); }

                if (this.check === false) {
                    return;
                }
                // Check tag
                if (this.tags.contains(collision.tag) === false) {
                    return;
                }
                // Init list
                if (this.inArea == null) {
                    this.inArea = new (System.Collections.Generic.List$1(UnityEngine.Transform)).ctor();
                }
                // Add obj to list
                if (this.inArea.contains(collision.transform) === false) {
                    this.inArea.add(collision.transform);
                    this.Apply(this.CheckFilled());
                }
            },
            /*Water2D.Extentions.ColliderTrigger.OnTriggerEnter2D end.*/

            /*Water2D.Extentions.ColliderTrigger.OnTriggerExit2D start.*/
            OnTriggerExit2D: function (collision) {
if ( TRACE ) { TRACE( "Water2D.Extentions.ColliderTrigger#OnTriggerExit2D", this ); }

                if (this.check === false) {
                    return;
                }
                // Check tag
                if (this.tags.contains(collision.tag) === false) {
                    return;
                }
                // Init list
                if (this.inArea == null) {
                    this.inArea = new (System.Collections.Generic.List$1(UnityEngine.Transform)).ctor();
                }
                // Remove obj from list
                if (this.inArea.contains(collision.transform)) {
                    this.inArea.remove(collision.transform);
                    this.Apply(this.CheckFilled());
                }
            },
            /*Water2D.Extentions.ColliderTrigger.OnTriggerExit2D end.*/


        }
    });
    /*Water2D.Extentions.ColliderTrigger end.*/

    /*Water2D.MetaballCameraEffect start.*/
    Bridge.define("Water2D.MetaballCameraEffect", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            cutOutMaterial: null,
            bgCamera: null,
            bgTargetTexture: null,
            buffer: null
        },
        methods: {
            /*Water2D.MetaballCameraEffect.Restart start.*/
            Restart: function () {
if ( TRACE ) { TRACE( "Water2D.MetaballCameraEffect#Restart", this ); }

                this.OnEnable();
            },
            /*Water2D.MetaballCameraEffect.Restart end.*/

            /*Water2D.MetaballCameraEffect.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Water2D.MetaballCameraEffect#OnEnable", this ); }

                if (UnityEngine.Screen.width > 0 && UnityEngine.Screen.height > 0) {
                    this.bgTargetTexture = new UnityEngine.RenderTexture.$ctor1(1080, 1920, 16);
                    this.bgCamera.targetTexture = this.bgTargetTexture;
                }
            },
            /*Water2D.MetaballCameraEffect.OnEnable end.*/

            /*Water2D.MetaballCameraEffect.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Water2D.MetaballCameraEffect#OnDisable", this ); }


            },
            /*Water2D.MetaballCameraEffect.OnDisable end.*/

            /*Water2D.MetaballCameraEffect.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Water2D.MetaballCameraEffect#Start", this ); }



                // Disable if the shader can't run on the users graphics card
                if (!this.cutOutMaterial.shader.isSupported) {
                    this.enabled = false;
                    return;
                }

            },
            /*Water2D.MetaballCameraEffect.Start end.*/

            /*Water2D.MetaballCameraEffect.OnRenderImage start.*/
            OnRenderImage: function (source, destination) {
if ( TRACE ) { TRACE( "Water2D.MetaballCameraEffect#OnRenderImage", this ); }

                //if(!Application.isPlaying)
                //	return;

                var rtW = (Bridge.Int.div(source.width, 4)) | 0;
                var rtH = (Bridge.Int.div(source.height, 4)) | 0;
                this.buffer = UnityEngine.RenderTexture.GetTemporary$1(rtW, rtH, 0);


                UnityEngine.Graphics.Blit(this.bgTargetTexture, destination); // background
                UnityEngine.Graphics.Blit(source, destination, this.cutOutMaterial); // water
                UnityEngine.RenderTexture.ReleaseTemporary(this.buffer);


            },
            /*Water2D.MetaballCameraEffect.OnRenderImage end.*/


        }
    });
    /*Water2D.MetaballCameraEffect end.*/

    /*Water2D.microSpawn start.*/
    Bridge.define("Water2D.microSpawn", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Water2D.microSpawn#getDefaultValue", this ); }
 return new Water2D.microSpawn(); }
            }
        },
        fields: {
            pos: null,
            amount: 0,
            initVel: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Water2D.microSpawn#init", this ); }

                this.pos = new UnityEngine.Vector3();
                this.initVel = new UnityEngine.Vector2();
            },
            $ctor1: function (pos, amount, initVel) {
if ( TRACE ) { TRACE( "Water2D.microSpawn#$ctor1", this ); }

                this.$initialize();
                this.pos = pos.$clone();
                this.amount = amount;
                this.initVel = initVel.$clone();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Water2D.microSpawn#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Water2D.microSpawn#getHashCode", this ); }

                var h = Bridge.addHash([3553897299, this.pos, this.amount, this.initVel]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Water2D.microSpawn#equals", this ); }

                if (!Bridge.is(o, Water2D.microSpawn)) {
                    return false;
                }
                return Bridge.equals(this.pos, o.pos) && Bridge.equals(this.amount, o.amount) && Bridge.equals(this.initVel, o.initVel);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Water2D.microSpawn#$clone", this ); }

                var s = to || new Water2D.microSpawn();
                s.pos = this.pos.$clone();
                s.amount = this.amount;
                s.initVel = this.initVel.$clone();
                return s;
            }
        }
    });
    /*Water2D.microSpawn end.*/

    /*Water2D.SpawnersManager start.*/
    Bridge.define("Water2D.SpawnersManager", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                instance: null,
                _scene: null
            },
            methods: {
                /*Water2D.SpawnersManager.Initialize:static start.*/
                Initialize: function (_c) {
if ( TRACE ) { TRACE( "Water2D.SpawnersManager#Initialize", this ); }

                    var $t, $t1;
                    if (UnityEngine.MonoBehaviour.op_Equality(Water2D.SpawnersManager.instance, null)) {
                        var go = UnityEngine.GameObject.Find("Water2D_SpawnersManager");
                        if (UnityEngine.GameObject.op_Equality(go, null)) {
                            var aux = UnityEngine.Object.FindObjectsOfType(Water2D.SpawnersManager);
                            for (var i = 0; i < aux.length; i = (i + 1) | 0) {
                                UnityEngine.Object.DestroyImmediate(aux[i].gameObject);
                            }

                        } else {
                            UnityEngine.Object.DestroyImmediate(go);
                        }

                        go = new UnityEngine.GameObject.$ctor2("Water2D_SpawnersManager");
                        Water2D.SpawnersManager.instance = go.AddComponent(Water2D.SpawnersManager);
                        go.hideFlags = UnityEngine.HideFlags.HideInHierarchy;

                        Water2D.SpawnersManager.instance._arrayColors = System.Array.init(12, function (){
                            return new UnityEngine.Color();
                        }, UnityEngine.Color);
                        Water2D.SpawnersManager.instance._arrayCutOffStroke = System.Array.init(12, 0, System.Single);

                        //instance._arrayTexture2DColors = new Texture2D[4];



                        // Init Color array
                        for (var i1 = 0; i1 < Water2D.SpawnersManager.instance._arrayColors.length; i1 = (i1 + 1) | 0) {
                            ($t = Water2D.SpawnersManager.instance._arrayColors)[i1] = _c.$clone();
                            ($t1 = Water2D.SpawnersManager.instance._arrayCutOffStroke)[i1] = 0.3;
                        }



                        if (Water2D.SpawnersManager.instance.spawnersID == null) {
                            Water2D.SpawnersManager.instance.spawnersID = new (System.Collections.Generic.List$1(System.Int32)).$ctor2(10);
                            Water2D.SpawnersManager.instance.FillColorByID = new (System.Collections.Generic.List$1(UnityEngine.Color)).$ctor2(10);
                            Water2D.SpawnersManager.instance.CuttOffByID = new (System.Collections.Generic.List$1(System.Single)).$ctor2(10);
                            Water2D.SpawnersManager.instance.MultiplierByID = new (System.Collections.Generic.List$1(System.Single)).$ctor2(10);
                            Water2D.SpawnersManager.instance.FresnelColorByID = new (System.Collections.Generic.List$1(UnityEngine.Color)).$ctor2(10);
                            Water2D.SpawnersManager.instance.StyleByID = new (System.Collections.Generic.List$1(System.Single)).$ctor2(10);
                            Water2D.SpawnersManager.instance.LensSizeByID = new (System.Collections.Generic.List$1(System.Single)).$ctor2(10);
                            Water2D.SpawnersManager.instance.MagnitudeByID = new (System.Collections.Generic.List$1(System.Single)).$ctor2(10);
                            Water2D.SpawnersManager.instance.SpeedByID = new (System.Collections.Generic.List$1(System.Single)).$ctor2(10);

                            //print("inint all");

                        }
                    }


                },
                /*Water2D.SpawnersManager.Initialize:static end.*/

                /*Water2D.SpawnersManager.RegisterSpawner:static start.*/
                RegisterSpawner: function (_spawner) {
if ( TRACE ) { TRACE( "Water2D.SpawnersManager#RegisterSpawner", this ); }

                    Water2D.SpawnersManager.Initialize(_spawner.StrokeColor.$clone());

                    // CHECK IF SPAWNER IS BLACK, MEANS IS UNASSIGNED COLOR //
                    // SO RANDOM GENERATE AND COMPARE WITH EXIST LIST OF COLORS UNTIL BE THE ONLY ONE //

                    if (Water2D.SpawnersManager.instance.FillColorByID.Count > 0) {
                        var colorIsCloseTo = -1;
                        for (var i = 0; i < Water2D.SpawnersManager.instance.FillColorByID.Count; i = (i + 1) | 0) {
                            if (Water2D.SpawnersManager.instance.isCloseTo(Water2D.SpawnersManager.instance.FillColorByID.getItem(i).$clone().r, _spawner.FillColor.r, 0.01) && Water2D.SpawnersManager.instance.isCloseTo(Water2D.SpawnersManager.instance.FillColorByID.getItem(i).$clone().g, _spawner.FillColor.g, 0.01) && Water2D.SpawnersManager.instance.isCloseTo(Water2D.SpawnersManager.instance.FillColorByID.getItem(i).$clone().b, _spawner.FillColor.b, 0.01)) {
                                colorIsCloseTo = i;

                            }

                        }

                        if (colorIsCloseTo !== -1) {
                            var a = UnityEngine.Random.value > 0.5 ? 1.0 : -1.0;
                            var b = UnityEngine.Random.value > 0.5 ? 1.0 : -1.0;
                            var c = UnityEngine.Random.value > 0.5 ? 1.0 : -1.0;
                            var threshold = 0.01;

                            _spawner.FillColor = new pc.Color( UnityEngine.Random.value + threshold * a, UnityEngine.Random.value + threshold * b, UnityEngine.Random.value + threshold * c, 1 );
                            _spawner.FillColor.a = 0.9;
                        }

                    } else {
                        // _spawner.FillColor = new Color(0f, 112 / 255f, 1f, .9f);
                    }

                    //}

                    Water2D.SpawnersManager.instance.spawnersID.add(_spawner.getHashCode()); // add new spawnerID
                    Water2D.SpawnersManager.instance.FillColorByID.add(_spawner.FillColor.$clone());
                    Water2D.SpawnersManager.instance.CuttOffByID.add(_spawner.AlphaCutOff);
                    if (_spawner.Water2DType === Water2D.Water2D_Spawner.EnumTypes.Refracting) {
                        Water2D.SpawnersManager.instance.MultiplierByID.add(_spawner.Intensity);
                    } else {
                        Water2D.SpawnersManager.instance.MultiplierByID.add(_spawner.AlphaStroke);
                    }

                    Water2D.SpawnersManager.instance.FresnelColorByID.add(_spawner.StrokeColor.$clone());
                    Water2D.SpawnersManager.instance.StyleByID.add(_spawner.Water2DType);
                    Water2D.SpawnersManager.instance.LensSizeByID.add(_spawner.LensMag);
                    Water2D.SpawnersManager.instance.MagnitudeByID.add(_spawner.Distortion);
                    Water2D.SpawnersManager.instance.SpeedByID.add(_spawner.DistortionSpeed);

                    //print("Init spawner : " + _spawner.name);
                    _spawner.HashID = (Water2D.SpawnersManager.instance.spawnersID.Count - 1) | 0; //hashID used to store indice of current spawner in spawnersID list
                    // print("hassh " + _spawner.HashID);



                },
                /*Water2D.SpawnersManager.RegisterSpawner:static end.*/

                /*Water2D.SpawnersManager.ChangeSpawnerValues:static start.*/
                ChangeSpawnerValues: function (_spawner) {
if ( TRACE ) { TRACE( "Water2D.SpawnersManager#ChangeSpawnerValues", this ); }

                    Water2D.SpawnersManager.Initialize(_spawner.StrokeColor.$clone());

                    //if (_spawner.HashID == -1)
                    //    RegisterSpawner(_spawner);

                    // Look for spawner already in scene
                    var _hash = _spawner.getHashCode();
                    var found = false;
                    var idFound = -1; // _spawner.HashID;

                    if (idFound === -1) { // if ID does not exist, try to find it
                        for (var i = 0; i < Water2D.SpawnersManager.instance.spawnersID.Count; i = (i + 1) | 0) {
                            if (Water2D.SpawnersManager.instance.spawnersID.getItem(i) === _hash) {
                                found = true;
                                idFound = i;
                                break;
                            }

                        }

                        if (found) {
                            _spawner.HashID = idFound;
                        } else {
                            Water2D.SpawnersManager.RegisterSpawner(_spawner);
                        }
                    }


                    //if does not exist, then register it
                    // if (!found)
                    //    RegisterSpawner(_spawner);




                    // if already exists or create recently

                    if (_spawner.HashID !== -1) {

                        // instance.spawnersID[_spawner.HashID] = _spawner.HashID;
                        Water2D.SpawnersManager.instance.FillColorByID.setItem(_spawner.HashID, _spawner.FillColor.$clone());
                        Water2D.SpawnersManager.instance.CuttOffByID.setItem(_spawner.HashID, _spawner.AlphaCutOff);

                        if (_spawner.Water2DType === Water2D.Water2D_Spawner.EnumTypes.Refracting) {
                            Water2D.SpawnersManager.instance.MultiplierByID.setItem(_spawner.HashID, _spawner.Intensity);
                        } else {
                            Water2D.SpawnersManager.instance.MultiplierByID.setItem(_spawner.HashID, _spawner.AlphaStroke);
                        }


                        Water2D.SpawnersManager.instance.FresnelColorByID.setItem(_spawner.HashID, _spawner.StrokeColor.$clone());
                        Water2D.SpawnersManager.instance.StyleByID.setItem(_spawner.HashID, _spawner.Water2DType);
                        Water2D.SpawnersManager.instance.LensSizeByID.setItem(_spawner.HashID, _spawner.Water2DType);
                        Water2D.SpawnersManager.instance.MagnitudeByID.setItem(_spawner.HashID, _spawner.Distortion);
                        Water2D.SpawnersManager.instance.SpeedByID.setItem(_spawner.HashID, _spawner.DistortionSpeed);


                        Water2D.SpawnersManager.instance.setArraysToShader(_spawner.WaterMaterial);
                        Water2D.SpawnersManager.instance.setFloatToShader(_spawner.Water2DType, _spawner.WaterMaterial);
                    } else {

                        UnityEngine.Debug.LogError$2("No set up arrays");
                    }

                },
                /*Water2D.SpawnersManager.ChangeSpawnerValues:static end.*/

                /*Water2D.SpawnersManager.DeleteSpawnerValues:static start.*/
                DeleteSpawnerValues: function (_spawner) {
if ( TRACE ) { TRACE( "Water2D.SpawnersManager#DeleteSpawnerValues", this ); }



                    // Look for spawner already in scene
                    var _hash = _spawner.getHashCode();
                    var found = false;
                    var idFound = -1; // _spawner.HashID;



                    if (idFound === -1) { // if ID does not exist, try to find it
                        if (UnityEngine.MonoBehaviour.op_Inequality(Water2D.SpawnersManager.instance, null)) {
                            for (var i = 0; i < Water2D.SpawnersManager.instance.spawnersID.Count; i = (i + 1) | 0) {
                                if (Water2D.SpawnersManager.instance.spawnersID.getItem(i) === _hash) {
                                    found = true;
                                    idFound = i;
                                    break;
                                }

                            }
                        }



                        if (found) {
                            // try to remove from arrays
                            Water2D.SpawnersManager.instance.spawnersID.removeAt(idFound);
                            Water2D.SpawnersManager.instance.FillColorByID.removeAt(idFound);
                            Water2D.SpawnersManager.instance.CuttOffByID.removeAt(idFound);
                            Water2D.SpawnersManager.instance.MultiplierByID.removeAt(idFound);
                            Water2D.SpawnersManager.instance.FresnelColorByID.removeAt(idFound);
                            Water2D.SpawnersManager.instance.StyleByID.removeAt(idFound);
                            Water2D.SpawnersManager.instance.LensSizeByID.removeAt(idFound);
                            Water2D.SpawnersManager.instance.MagnitudeByID.removeAt(idFound);
                            Water2D.SpawnersManager.instance.SpeedByID.removeAt(idFound);

                        }

                    }



                },
                /*Water2D.SpawnersManager.DeleteSpawnerValues:static end.*/

                /*Water2D.SpawnersManager.SetFresnelColor:static start.*/
                SetFresnelColor: function (StrokeColor) {
if ( TRACE ) { TRACE( "Water2D.SpawnersManager#SetFresnelColor", this ); }

                    Water2D.SpawnersManager.Initialize(StrokeColor.$clone());

                    if (UnityEngine.Component.op_Equality(Water2D.SpawnersManager.instance.fresnelCamera, null)) {
                        Water2D.SpawnersManager.instance.fresnelCamera = UnityEngine.GameObject.Find("1-EffectCamera").GetComponent(UnityEngine.Camera);

                    }

                    var otherSpawners = UnityEngine.Object.FindObjectsOfType(Water2D.Water2D_Spawner);
                    for (var i = 0; i < otherSpawners.length; i = (i + 1) | 0) {

                        otherSpawners[i].StrokeColor = StrokeColor.$clone();
                    }

                    if (UnityEngine.Object.op_Implicit(Water2D.SpawnersManager.instance.fresnelCamera)) {
                        StrokeColor.a = 0.0;
                        Water2D.SpawnersManager.instance.fresnelCamera.backgroundColor = StrokeColor.$clone();
                    }
                },
                /*Water2D.SpawnersManager.SetFresnelColor:static end.*/

                /*Water2D.SpawnersManager.SetSorting:static start.*/
                SetSorting: function (sortingID) {
if ( TRACE ) { TRACE( "Water2D.SpawnersManager#SetSorting", this ); }

                    Water2D.SpawnersManager.Initialize(new pc.Color( 1, 1, 1, 1 ));


                    if (UnityEngine.MonoBehaviour.op_Equality(Water2D.SpawnersManager.instance.quadEffect, null)) {
                        Water2D.SpawnersManager.instance.quadEffect = UnityEngine.GameObject.Find("EffectQuad").GetComponent(ResizeQuadEffectController);

                    }

                    Water2D.SpawnersManager.instance.quadEffect.SetSorting(sortingID);
                },
                /*Water2D.SpawnersManager.SetSorting:static end.*/

                /*Water2D.SpawnersManager.GetAllParticles:static start.*/
                GetAllParticles: function () {
if ( TRACE ) { TRACE( "Water2D.SpawnersManager#GetAllParticles", this ); }

                    if (UnityEngine.MonoBehaviour.op_Equality(Water2D.SpawnersManager.instance, null)) {
                        Water2D.SpawnersManager.Initialize(new pc.Color( 1, 1, 1, 1 ));
                    }

                    Water2D.SpawnersManager.instance.fetchAllParticles();
                    return Water2D.SpawnersManager.instance._allparticles;
                },
                /*Water2D.SpawnersManager.GetAllParticles:static end.*/


            }
        },
        fields: {
            forceToClearColorBuffers: false,
            spawnersID: null,
            FillColorByID: null,
            CuttOffByID: null,
            MultiplierByID: null,
            FresnelColorByID: null,
            StyleByID: null,
            LensSizeByID: null,
            MagnitudeByID: null,
            SpeedByID: null,
            _arrayColors: null,
            _arrayCutOffStroke: null,
            _arrayTexture2DColors: null,
            fresnelCamera: null,
            quadEffect: null,
            _allparticles: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Water2D.SpawnersManager#init", this ); }

                this.forceToClearColorBuffers = true;
            }
        },
        methods: {
            /*Water2D.SpawnersManager.clearColorBuffers start.*/
            clearColorBuffers: function () {
if ( TRACE ) { TRACE( "Water2D.SpawnersManager#clearColorBuffers", this ); }

                //if (instance == null)
                //  return;

                Water2D.SpawnersManager.instance.spawnersID.clear();
                Water2D.SpawnersManager.instance.FillColorByID.clear();
                Water2D.SpawnersManager.instance.CuttOffByID.clear();
                Water2D.SpawnersManager.instance.MultiplierByID.clear();
                Water2D.SpawnersManager.instance.FresnelColorByID.clear();
                Water2D.SpawnersManager.instance.StyleByID.clear();
                Water2D.SpawnersManager.instance.LensSizeByID.clear();
                Water2D.SpawnersManager.instance.MagnitudeByID.clear();
                Water2D.SpawnersManager.instance.SpeedByID.clear();
                //print("cleared");
            },
            /*Water2D.SpawnersManager.clearColorBuffers end.*/

            /*Water2D.SpawnersManager.reloadAllSpawners start.*/
            reloadAllSpawners: function () {
if ( TRACE ) { TRACE( "Water2D.SpawnersManager#reloadAllSpawners", this ); }

                var s = UnityEngine.Object.FindObjectsOfType(Water2D.Water2D_Spawner);
                for (var i = 0; i < s.length; i = (i + 1) | 0) {
                    Water2D.SpawnersManager.ChangeSpawnerValues(s[i]);
                }
            },
            /*Water2D.SpawnersManager.reloadAllSpawners end.*/

            /*Water2D.SpawnersManager.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Water2D.SpawnersManager#Update", this ); }

                if (this.forceToClearColorBuffers) {
                    this.forceToClearColorBuffers = false;
                    this.clearColorBuffers();
                    this.reloadAllSpawners();
                }

            },
            /*Water2D.SpawnersManager.Update end.*/

            /*Water2D.SpawnersManager.isCloseTo start.*/
            isCloseTo: function (value1, value2, threshold) {
if ( TRACE ) { TRACE( "Water2D.SpawnersManager#isCloseTo", this ); }

                var res = value1 - value2;
                if (res < 0) {
                    res *= -1.0;
                }

                if (res < threshold) {
                    return true;
                } else {
                    return false;
                }
            },
            /*Water2D.SpawnersManager.isCloseTo end.*/

            /*Water2D.SpawnersManager.setFloatToShader start.*/
            setFloatToShader: function (f, mat) {
if ( TRACE ) { TRACE( "Water2D.SpawnersManager#setFloatToShader", this ); }

                mat.SetFloat$1("_toon", f);
            },
            /*Water2D.SpawnersManager.setFloatToShader end.*/

            /*Water2D.SpawnersManager.setArraysToShader start.*/
            setArraysToShader: function (mat) {
if ( TRACE ) { TRACE( "Water2D.SpawnersManager#setArraysToShader", this ); }



                //print("just settings color arrays");
                mat.SetColorArray$1("_colors", this.convertToarrayOfSize$1(10, this.FillColorByID));
                mat.SetFloatArray$1("_cutoffs", this.convertToarrayOfSize(10, this.CuttOffByID));
                mat.SetFloatArray$1("_multipliers", this.convertToarrayOfSize(10, this.MultiplierByID));
                mat.SetColorArray$1("_fresnels", this.convertToarrayOfSize$1(10, this.FresnelColorByID));
                mat.SetFloatArray$1("_styles", this.convertToarrayOfSize(10, this.StyleByID));
                mat.SetFloatArray$1("_lens", this.convertToarrayOfSize(10, this.LensSizeByID));
                mat.SetFloatArray$1("_mags", this.convertToarrayOfSize(10, this.MagnitudeByID));
                mat.SetFloatArray$1("_speeds", this.convertToarrayOfSize(10, this.SpeedByID));


            },
            /*Water2D.SpawnersManager.setArraysToShader end.*/

            /*Water2D.SpawnersManager.convertToarrayOfSize$1 start.*/
            convertToarrayOfSize$1: function (_size, _list) {
if ( TRACE ) { TRACE( "Water2D.SpawnersManager#convertToarrayOfSize$1", this ); }

                var ret = System.Array.init(_size, function (){
                    return new UnityEngine.Color();
                }, UnityEngine.Color);
                var nullvalue = new pc.Color( 0, 0, 0, 1 );

                for (var i = 0; i < _size; i = (i + 1) | 0) {

                    if (i < _list.Count) {
                        ret[i] = _list.getItem(i).$clone();
                    } else {
                        ret[i] = nullvalue.$clone();
                    }

                }

                return ret;
            },
            /*Water2D.SpawnersManager.convertToarrayOfSize$1 end.*/

            /*Water2D.SpawnersManager.convertToarrayOfSize start.*/
            convertToarrayOfSize: function (_size, _list) {
if ( TRACE ) { TRACE( "Water2D.SpawnersManager#convertToarrayOfSize", this ); }

                var ret = System.Array.init(_size, 0, System.Single);
                var nullvalue = -1.0;

                for (var i = 0; i < _size; i = (i + 1) | 0) {
                    if (i < _list.Count) {
                        ret[i] = _list.getItem(i);
                    } else {
                        ret[i] = nullvalue;
                    }

                }

                return ret;
            },
            /*Water2D.SpawnersManager.convertToarrayOfSize end.*/

            /*Water2D.SpawnersManager.fetchAllParticles start.*/
            fetchAllParticles: function () {
if ( TRACE ) { TRACE( "Water2D.SpawnersManager#fetchAllParticles", this ); }

                Water2D.SpawnersManager.Initialize(new pc.Color( 1, 1, 1, 1 ));
                this._allparticles = UnityEngine.Object.FindObjectsOfType(MetaballParticleClass);

            },
            /*Water2D.SpawnersManager.fetchAllParticles end.*/


        },
        overloads: {
            "convertToarrayOfSize(int, List<Color>)": "convertToarrayOfSize$1"
        }
    });
    /*Water2D.SpawnersManager end.*/

    /*Water2D.Water2D_Spawner start.*/
    Bridge.define("Water2D.Water2D_Spawner", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            instance: null,
            HashID: 0,
            /**
             * The type of Water spawner (Regular/Toon/Refracting)).
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @type number
             */
            Water2DType: 0,
            /**
             * The emission type (ParticleSystem/FillerCollider)).
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @type number
             */
            Water2DEmissionType: 0,
            /**
             * The collider shape type (box, circle, polygon)
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @type number
             */
            Water2DFillerType: 0,
            /**
             * The fill is inverse?
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default false
             * @type boolean
             */
            FillerColliderMasked: false,
            /**
             * The type of pipeline spawner (Legacy or URP(LWRP)).
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default ""
             * @type string
             */
            Water2DRenderType: null,
            /**
             * The version of the system.
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default "1.2"
             * @type string
             */
            Water2DVersion: null,
            DropObject: null,
            WaterDropsObjects: null,
            /**
             * The tag of all particles inside this spawner
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default "Metaball_liquid"
             * @type string
             */
            ParticlesTag: null,
            /**
             * This means that the spawner won't be update in every change of state and you can generate the amount of fluid in Editor for use in Play mode later.
             When this property is off, the spawner will be refresh at the end of the application runtime.
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default false
             * @type boolean
             */
            PersistentFluid: false,
            /**
             * The size of each drop.
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default 0.45
             * @type number
             */
            size: 0,
            /**
             * If particle can down the scale over lifetime.
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default false
             * @type boolean
             */
            ScaleDown: false,
            /**
             * The life time of each particle.
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default 5.0
             * @type number
             */
            LifeTime: 0,
            /**
             * The delay between particles emission.
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default 0.05
             * @type number
             */
            DelayBetweenParticles: 0,
            /**
             * The Trail size on Start.
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default 0.4
             * @type number
             */
            TrailStartSize: 0,
            /**
             * The Trail size on End.
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default 0.4
             * @type number
             */
            TrailEndSize: 0,
            /**
             * The Trail time between Start - End.
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default 0.1
             * @type number
             */
            TrailDelay: 0,
            /**
             * Actual water material.
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @type UnityEngine.Material
             */
            WaterMaterial: null,
            /**
             * Is shader a Refracting, Toon or Regular style ?
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @type boolean
             */
            StyleByID: false,
            /**
             * The sorting order ID
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @type number
             */
            Sorting: 0,
            /**
             * The color category scheme
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default 1
             * @type number
             */
            ColorScheme: 0,
            /**
             * Fill Color of the particle [Toon/CutoOut shader]
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @type UnityEngine.Color
             */
            FillColor: null,
            /**
             * Stroke Color of the particle [Toon/CutoOut shader]
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @type UnityEngine.Color
             */
            StrokeColor: null,
            _lastStrokeColor: null,
            /**
             * Allow blending colors with neighbor particles
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default false
             * @type boolean
             */
            Blending: false,
            _lastBlending: false,
            /**
             * Threshold alpha value[Toon/CutoOut shader]
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default 0.2
             * @type number
             */
            AlphaCutOff: 0,
            /**
             * Threshold alpha stroke value [Toon/CutoOut shader]
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default 0.2
             * @type number
             */
            AlphaStroke: 0,
            /**
             * Tint Color of the particle [Refracting shader]
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @type UnityEngine.Color
             */
            TintColor: null,
            /**
             * Intensity Color of the particle [Refracting shader]
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default 0.5
             * @type number
             */
            Intensity: 0,
            /**
             * Amplify Mag of UV  [Refracting shader]
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default 1.2
             * @type number
             */
            LensMag: 0,
            /**
             * Distortion of UV [Refracting shader]
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default 0.5
             * @type number
             */
            Distortion: 0,
            /**
             * Distortion of UV [Refracting shader]
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default 0.5
             * @type number
             */
            DistortionSpeed: 0,
            /**
             * Is glow effect enabled
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default false
             * @type boolean
             */
            GlowEffect: false,
            /**
             * The color of the glow
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @type UnityEngine.Color
             */
            GlowColor: null,
            /**
             * the spread size of the glow
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default 1.5
             * @type number
             */
            GlowSize: 0,
            /**
             * Order in rendering the glow sprite
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @type number
             */
            GlowSortingOrder: 0,
            _lastGlowEnabledValue: false,
            /**
             * The initial speed of particles after spawn.
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @type UnityEngine.Vector2
             */
            initSpeed: null,
            /**
             * Amount of speed with which the particle is created
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default 20.0
             * @type number
             */
            Speed: 0,
            /**
             * The physic material
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @type UnityEngine.PhysicsMaterial2D
             */
            PhysicMat: null,
            /**
             * The size of radius / side of collider circle2D or box2D
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default 1.5
             * @type number
             */
            ColliderSize: 0,
            /**
             * The size of radius / side of collider circle2D or box2D
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default 0.0
             * @type number
             */
            LinearDrag: 0,
            /**
             * The size of radius / side of collider circle2D or box2D
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default 0.0
             * @type number
             */
            AngularDrag: 0,
            /**
             * The size of radius / side of collider circle2D or box2D
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default 1.0
             * @type number
             */
            GravityScale: 0,
            /**
             * Constrain rotation on Z axis.
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default false
             * @type boolean
             */
            FreezeRotation: false,
            /**
             * The X speed limit .
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @type UnityEngine.Vector2
             */
            SpeedLimiterX: null,
            /**
             * The Y speed limit .
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @type UnityEngine.Vector2
             */
            SpeedLimiterY: null,
            /**
             * The simulation start in awake.
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default true
             * @type boolean
             */
            SimulateOnAwake: false,
            /**
             * Water system can perform in editor mode.
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default false
             * @type boolean
             */
            SimulateInEditor: false,
            /**
             * Water system can perform in play mode.
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default false
             * @type boolean
             */
            SimulateInPlayMode: false,
            /**
             * How many particles in the spawner?
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default 100
             * @type number
             */
            DropCount: 0,
            _lastDropCount: 0,
            /**
             * The responsible to spawn every particle once or repeat the spawn forever
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default true
             * @type boolean
             */
            Loop: false,
            /**
             * Currently amount of particles useing for the simulation (debug purposes only!)
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @type number
             */
            DropsUsed: 0,
            /**
             * Apply setup changes over lifetime.
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default true
             * @type boolean
             */
            DynamicChanges: false,
            /**
             * List of events to call when shape will filled with water particles.
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @type Water2D.Water2DEvents
             */
            OnValidateShapeFill: null,
            /**
             * The collider 2d array to be use to check the fill level.
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @type Array.<UnityEngine.Collider2D>
             */
            ShapeFillCollider2D: null,
            /**
             * The ShapeFillCollider2D amount.
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default 3
             * @type number
             */
            ShapeFillCollider2DCount: 0,
            /**
             * The shape fill accuracy 1 = 100%
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @default 1.0
             * @type number
             */
            ShapeFillAccuracy: 0,
            /**
             * List of gameobjects that have been collide with water particles .
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @type Water2D.Water2DEvents
             */
            OnCollisionEnterList: null,
            /**
             * List of gameobjects that will be notified when spawner is about to start .
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @type Water2D.Water2DEvents
             */
            OnSpawnerAboutStart: null,
            /**
             * List of gameobjects that will be notified when spawner is about to end .
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @type Water2D.Water2DEvents
             */
            OnSpawnerAboutEnd: null,
            /**
             * List of gameobjects that will be notified when spawner is emitting each particle .
             *
             * @instance
             * @public
             * @memberof Water2D.Water2D_Spawner
             * @type Water2D.Water2DEvents
             */
            OnSpawnerEmitingParticle: null,
            AllBallsCount: 0,
            IsSpawning: false,
            isRefractingMaterial: false,
            usableDropsCount: 0,
            DefaultCount: 0,
            _breakLoop: false,
            _parent: null,
            _parentNameID: null,
            _spawnedDrops: 0,
            _lastFillColor: null,
            _canInvokeAttheEnd: false,
            fresnelCamera: null,
            _lastSorting: 0,
            _checkOnFillRunning: false,
            _breakCheckOnFill: false,
            _checkOnFillComplete: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Water2D.Water2D_Spawner#init", this ); }

                this.FillColor = new UnityEngine.Color();
                this.StrokeColor = new UnityEngine.Color();
                this._lastStrokeColor = new UnityEngine.Color();
                this.TintColor = new UnityEngine.Color();
                this.GlowColor = new UnityEngine.Color();
                this.initSpeed = new UnityEngine.Vector2();
                this.SpeedLimiterX = new UnityEngine.Vector2();
                this.SpeedLimiterY = new UnityEngine.Vector2();
                this._lastFillColor = new UnityEngine.Color();
                this.HashID = -1;
                this.Water2DType = Water2D.Water2D_Spawner.EnumTypes.Regular;
                this.Water2DEmissionType = Water2D.Water2D_Spawner.EmissionType.ParticleSystem;
                this.Water2DFillerType = Water2D.Water2D_Spawner.FillerColliderType.Box;
                this.FillerColliderMasked = false;
                this.Water2DRenderType = "";
                this.Water2DVersion = "1.2";
                this.ParticlesTag = "Metaball_liquid";
                this.PersistentFluid = false;
                this.size = 0.45;
                this.ScaleDown = false;
                this.LifeTime = 5.0;
                this.DelayBetweenParticles = 0.05;
                this.TrailStartSize = 0.4;
                this.TrailEndSize = 0.4;
                this.TrailDelay = 0.1;
                this.ColorScheme = 1;
                this.FillColor = new pc.Color( 0.0, 0.4392157, 1.0, 1 );
                this.StrokeColor = new pc.Color( 0.0156862754, 0.6117647, 1.0, 1 );
                this._lastStrokeColor = new pc.Color( 0.0156862754, 0.6117647, 1.0, 1 );
                this.Blending = false;
                this._lastBlending = false;
                this.AlphaCutOff = 0.2;
                this.AlphaStroke = 0.2;
                this.TintColor = new pc.Color( 0.0, 0.4392157, 1.0, 1 );
                this.Intensity = 0.5;
                this.LensMag = 1.2;
                this.Distortion = 0.5;
                this.DistortionSpeed = 0.5;
                this.GlowEffect = false;
                this.GlowColor = new pc.Color( 1.0, 1.0, 1.0, 0.4 );
                this.GlowSize = 1.5;
                this.GlowSortingOrder = -1;
                this._lastGlowEnabledValue = false;
                this.initSpeed = new pc.Vec2( 1.0, -1.8 );
                this.Speed = 20.0;
                this.ColliderSize = 1.5;
                this.LinearDrag = 0.0;
                this.AngularDrag = 0.0;
                this.GravityScale = 1.0;
                this.FreezeRotation = false;
                this.SpeedLimiterX = new pc.Vec2( -300, 300 );
                this.SpeedLimiterY = new pc.Vec2( -300, 300 );
                this.SimulateOnAwake = true;
                this.SimulateInEditor = false;
                this.SimulateInPlayMode = false;
                this.DropCount = 100;
                this._lastDropCount = 100;
                this.Loop = true;
                this.DynamicChanges = true;
                this.ShapeFillCollider2DCount = 3;
                this.ShapeFillAccuracy = 1.0;
                this.isRefractingMaterial = false;
                this._breakLoop = false;
                this._parentNameID = "Water2DParticlesID_";
                this._spawnedDrops = 0;
                this._canInvokeAttheEnd = true;
                this._checkOnFillRunning = false;
                this._breakCheckOnFill = false;
                this._checkOnFillComplete = false;
            }
        },
        methods: {
            /*Water2D.Water2D_Spawner.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Water2D.Water2D_Spawner#Awake", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.instance, null)) {
                    this.instance = this;
                }
            },
            /*Water2D.Water2D_Spawner.Awake end.*/

            /*Water2D.Water2D_Spawner.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Water2D.Water2D_Spawner#Start", this ); }

                this.StartCoroutine$1(this.StartEnumerator());

                //Register
                Water2D.SpawnersManager.ChangeSpawnerValues(this.instance);
            },
            /*Water2D.Water2D_Spawner.Start end.*/

            /*Water2D.Water2D_Spawner.StartEnumerator start.*/
            StartEnumerator: function () {
if ( TRACE ) { TRACE( "Water2D.Water2D_Spawner#StartEnumerator", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    cf,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(0.25);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    if (UnityEngine.Application.isPlaying && this.SimulateOnAwake && this.Water2DEmissionType === Water2D.Water2D_Spawner.EmissionType.ParticleSystem) {
                                            $step = 2;
                                            continue;
                                        } else  {
                                            $step = 4;
                                            continue;
                                        }
                                }
                                case 2: {
                                    this.Restore();
                                        $enumerator.current = new UnityEngine.WaitForEndOfFrame();
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    this.Spawn();
                                    $step = 6;
                                    continue;
                                }
                                case 4: {
                                    $enumerator.current = new UnityEngine.WaitForEndOfFrame();
                                        $step = 5;
                                        return true;
                                }
                                case 5: {
                                    this.StartCoroutine$1(this.UpdateQuietParticleProperties());
                                        cf = this.GetComponent(Water2D.ColliderFiller);
                                        if (UnityEngine.MonoBehaviour.op_Inequality(cf, null)) {
                                            cf.Fill();
                                        }
                                    $step = 6;
                                    continue;
                                }
                                case 6: {
                                    $enumerator.current = null;
                                        $step = 7;
                                        return true;
                                }
                                case 7: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Water2D.Water2D_Spawner.StartEnumerator end.*/

            /*Water2D.Water2D_Spawner.RunSpawner start.*/
            RunSpawner: function () {
if ( TRACE ) { TRACE( "Water2D.Water2D_Spawner#RunSpawner", this ); }

                this.instance.Spawn();
            },
            /*Water2D.Water2D_Spawner.RunSpawner end.*/

            /*Water2D.Water2D_Spawner.StopSpawner start.*/
            StopSpawner: function () {
if ( TRACE ) { TRACE( "Water2D.Water2D_Spawner#StopSpawner", this ); }

                this.instance.Restore();
            },
            /*Water2D.Water2D_Spawner.StopSpawner end.*/

            /*Water2D.Water2D_Spawner.SetupParticles start.*/
            SetupParticles: function () {
if ( TRACE ) { TRACE( "Water2D.Water2D_Spawner#SetupParticles", this ); }

                // return;
                if (UnityEngine.GameObject.op_Equality(this._parent, null) && this.WaterDropsObjects != null) {
                    if (this.WaterDropsObjects.length > 0 && UnityEngine.GameObject.op_Inequality(this.WaterDropsObjects[0], null)) {
                        this._parent = this.WaterDropsObjects[0].transform.parent.gameObject;
                    }
                }

                if (UnityEngine.GameObject.op_Inequality(this._parent, null)) {
                    UnityEngine.Object.DestroyImmediate(this._parent);
                }

                this._parent = new UnityEngine.GameObject.$ctor2(this._parentNameID);
                this._parent.transform.hideFlags = UnityEngine.HideFlags.HideInHierarchy;

                this.WaterDropsObjects = System.Array.init(this.DropCount, null, UnityEngine.GameObject);

                for (var i = 0; i < this.WaterDropsObjects.length; i = (i + 1) | 0) {
                    this.WaterDropsObjects[i] = UnityEngine.Object.Instantiate$2(UnityEngine.GameObject, this.DropObject, this.gameObject.transform.position.$clone(), new pc.Quat( 0, 0, 0, 0 ));
                    this.WaterDropsObjects[i].GetComponent(MetaballParticleClass).Active = false;
                    this.WaterDropsObjects[i].GetComponent(UnityEngine.Rigidbody2D).velocity = pc.Vec2.ZERO.clone();
                    this.WaterDropsObjects[i].transform.SetParent(this._parent.transform);
                    this.WaterDropsObjects[i].transform.localScale = new pc.Vec3( this.size, this.size, 1.0 );
                    this.WaterDropsObjects[i].layer = this.WaterDropsObjects[0].layer;
                    this.WaterDropsObjects[i].tag = this.ParticlesTag;
                    /* 
                    Transform tt = WaterDropsObjects[i].transform.Find("_glow");
                    */

                    // Create glow
                    if (this.GlowEffect) {
                        this._lastGlowEnabledValue = this.GlowEffect;

                        var o = new UnityEngine.GameObject.$ctor2("_glow");
                        o.transform.SetParent(this.WaterDropsObjects[i].transform);
                        o.transform.localPosition = new pc.Vec3( 0, 0, -1.0 );
                        var sr = o.AddComponent(UnityEngine.SpriteRenderer);
                        sr.sprite = this.WaterDropsObjects[i].GetComponent(UnityEngine.SpriteRenderer).sprite;
                        sr.color = this.GlowColor.$clone();
                        sr.sortingOrder = this.GlowSortingOrder;
                        o.transform.localScale = new pc.Vec3( 1, 1, 1 ).clone().scale( this.GlowSize );
                    } else {
                        var t = this.WaterDropsObjects[i].transform.Find("_glow");
                        if (UnityEngine.Component.op_Inequality(t, null)) {
                            UnityEngine.Object.DestroyImmediate(t);
                        }
                    }


                    //Set tex color for scheme selection
                    var ColorTex = new pc.Color( 1, 1, 1, 1 );

                    if (this.ColorScheme === 1) {
                        ColorTex = new pc.Color( 1.0, 0.0, 0.0, 1 );
                    }
                    if (this.ColorScheme === 2) {
                        ColorTex = new pc.Color( 0.0, 1.0, 0.0, 1 );
                    }
                    if (this.ColorScheme === 3) {
                        ColorTex = new pc.Color( 0.0, 0.0, 1.0, 1 );
                    }
                    /* if (ColorScheme == 4)
                        ColorTex = new Color(1f, 1f, 0f);
                    if (ColorScheme == 5)
                        ColorTex = new Color(0f, 1f, 1f);
                    if (ColorScheme == 6)
                        ColorTex = new Color(1f, 1f, 1f);


                    if(Water2DType == EnumTypes.Regular || Water2DType == EnumTypes.Refracting) 
                        ColorTex = FillColor;

                    */
                    this.WaterDropsObjects[i].GetComponent(UnityEngine.SpriteRenderer).color = this.FillColor.$clone();
                    this.WaterDropsObjects[i].GetComponent(UnityEngine.TrailRenderer).startColor = this.FillColor.$clone();
                    this.WaterDropsObjects[i].GetComponent(UnityEngine.TrailRenderer).endColor = this.FillColor.$clone();

                    this.WaterDropsObjects[i].GetComponent(MetaballParticleClass).BlendingColor = this.Blending;

                    var tr = this.WaterDropsObjects[i].GetComponent(UnityEngine.TrailRenderer);
                    if (this.TrailStartSize <= 0.0) {
                        tr.enabled = false;
                    } else {
                        tr.enabled = true;
                        tr.startWidth = this.TrailStartSize;
                        tr.endWidth = this.TrailEndSize;
                        tr.time = this.TrailDelay;
                    }

                    this.WaterDropsObjects[i].GetComponent(MetaballParticleClass).SpawnerParent = this;
                }


                this.AllBallsCount = this.WaterDropsObjects.length;

                if (this.Water2DEmissionType === Water2D.Water2D_Spawner.EmissionType.ParticleSystem) {
                    this.DropsUsed = Bridge.Int.mul(this.DropsUsed, 0);
                    this._spawnedDrops = Bridge.Int.mul(this._spawnedDrops, 0);
                }


                this.RestoreCheckingFillShape(); // restore events
            },
            /*Water2D.Water2D_Spawner.SetupParticles end.*/

            /*Water2D.Water2D_Spawner.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Water2D.Water2D_Spawner#Update", this ); }

                this.CallShapeFillValidationUpdate();
            },
            /*Water2D.Water2D_Spawner.Update end.*/

            /*Water2D.Water2D_Spawner.CallShapeFillValidationUpdate start.*/
            CallShapeFillValidationUpdate: function () {
if ( TRACE ) { TRACE( "Water2D.Water2D_Spawner#CallShapeFillValidationUpdate", this ); }

                //Check ShapeFill events
                if (System.Nullable.gt((this.OnValidateShapeFill != null ? this.OnValidateShapeFill.GetPersistentEventCount() : null), 0) && this.ShapeFillCollider2D != null) {
                    this.StartCheckingFillShape();
                }
            },
            /*Water2D.Water2D_Spawner.CallShapeFillValidationUpdate end.*/

            /*Water2D.Water2D_Spawner.Spawn start.*/
            Spawn: function () {
if ( TRACE ) { TRACE( "Water2D.Water2D_Spawner#Spawn", this ); }

                this.Spawn$1(this.DefaultCount);
            },
            /*Water2D.Water2D_Spawner.Spawn end.*/

            /*Water2D.Water2D_Spawner.Spawn$1 start.*/
            Spawn$1: function (count) {
if ( TRACE ) { TRACE( "Water2D.Water2D_Spawner#Spawn$1", this ); }

                if (this.DelayBetweenParticles === 0.0) {
                    this.DropsUsed = Bridge.Int.mul(this.DropsUsed, 0);
                    this.SpawnAll();
                } else {
                    this.DropsUsed = Bridge.Int.mul(this.DropsUsed, 0);
                    this.StartCoroutine$1(this.loop(this.gameObject.transform.position.$clone(), this.initSpeed.$clone(), count));
                }
            },
            /*Water2D.Water2D_Spawner.Spawn$1 end.*/

            /*Water2D.Water2D_Spawner.Spawn$2 start.*/
            Spawn$2: function (count, pos) {
if ( TRACE ) { TRACE( "Water2D.Water2D_Spawner#Spawn$2", this ); }

                this.StartCoroutine$1(this.loop(pos.$clone(), this.initSpeed.$clone(), count));
            },
            /*Water2D.Water2D_Spawner.Spawn$2 end.*/

            /*Water2D.Water2D_Spawner.Spawn$3 start.*/
            Spawn$3: function (count, pos, InitVelocity, delay) {
if ( TRACE ) { TRACE( "Water2D.Water2D_Spawner#Spawn$3", this ); }

                if (delay === void 0) { delay = 0.0; }
                this.StartCoroutine$1(this.loop(pos.$clone(), InitVelocity.$clone(), count, delay));
            },
            /*Water2D.Water2D_Spawner.Spawn$3 end.*/

            /*Water2D.Water2D_Spawner.SpawnAll start.*/
            SpawnAll: function () {
if ( TRACE ) { TRACE( "Water2D.Water2D_Spawner#SpawnAll", this ); }

                this.SpawnAllParticles(this.gameObject.transform.position.$clone(), this.initSpeed.$clone(), this.DefaultCount);
            },
            /*Water2D.Water2D_Spawner.SpawnAll end.*/

            /*Water2D.Water2D_Spawner.StopSpawning start.*/
            StopSpawning: function () {
if ( TRACE ) { TRACE( "Water2D.Water2D_Spawner#StopSpawning", this ); }

                this._breakLoop = true;
                this.IsSpawning = false;
            },
            /*Water2D.Water2D_Spawner.StopSpawning end.*/

            /*Water2D.Water2D_Spawner.Restore start.*/
            Restore: function () {
if ( TRACE ) { TRACE( "Water2D.Water2D_Spawner#Restore", this ); }

                this.IsSpawning = false;
                this._breakLoop = true;
                this.DropsUsed = Bridge.Int.mul(this.DropsUsed, 0);


                for (var i = 0; i < this.WaterDropsObjects.length; i = (i + 1) | 0) {
                    if (UnityEngine.GameObject.op_Inequality(this.WaterDropsObjects[i], null)) {
                        if (this.WaterDropsObjects[i].GetComponent(MetaballParticleClass).Active === true) {
                            this.WaterDropsObjects[i].GetComponent(MetaballParticleClass).Active = false;
                        }

                        this.WaterDropsObjects[i].GetComponent(MetaballParticleClass).witinTarget = false;
                    }
                }


                //gameObject.transform.localEulerAngles = Vector3.zero;
                //initSpeed = new Vector2 (0, -2f);

                this.DefaultCount = this.AllBallsCount;
                this.usableDropsCount = this.DefaultCount;
                //Dynamic = false;
            },
            /*Water2D.Water2D_Spawner.Restore end.*/

            /*Water2D.Water2D_Spawner.loop_editor start.*/
            loop_editor: function (_pos, _initSpeed, count, delay, waitBetweenDropSpawn) {
if ( TRACE ) { TRACE( "Water2D.Water2D_Spawner#loop_editor", this ); }

                if (count === void 0) { count = -1; }
                if (delay === void 0) { delay = 0.0; }
                if (waitBetweenDropSpawn === void 0) { waitBetweenDropSpawn = true; }
                if (UnityEngine.Application.isPlaying) {
                    return;
                }

                if (this.Water2DEmissionType === Water2D.Water2D_Spawner.EmissionType.FillerCollider) {
                    //Debug.LogError("You're trying spawn particles in a Filler type. You should create a water spawner instead");
                    return;
                }

                if (!this.SimulateInEditor) {
                    return;
                }

                if (this.WaterDropsObjects == null || this.WaterDropsObjects.length < 1) {
                    this.SetupParticles();
                    return;
                }


                for (var i = 0; i < this.WaterDropsObjects.length; i = (i + 1) | 0) {
                    if (UnityEngine.GameObject.op_Equality(this.WaterDropsObjects[i], null)) {
                        return;
                    }

                    var MetaBall = this.WaterDropsObjects[i].GetComponent(MetaballParticleClass);

                    //CHANGE COLOR

                    if (MetaBall.Active === false) {
                        MetaBall.gameObject.GetComponent(UnityEngine.SpriteRenderer).color = this.FillColor.$clone();
                    }

                    this.SetRegularWaterparams(this.FillColor.$clone(), this.StrokeColor.$clone(), this.AlphaCutOff, this.AlphaStroke);


                    if (MetaBall.Active === true) {
                        continue;
                    }

                    this._canInvokeAttheEnd = true;

                    if (this.LifeTime <= 0) {
                        MetaBall.LifeTime = -1.0;
                    } else {
                        MetaBall.LifeTime = this.LifeTime;
                    }

                    this.WaterDropsObjects[i].transform.position = this.transform.position.$clone();
                    MetaBall.Active = true;
                    MetaBall.witinTarget = false;

                    if (pc.Vec2.equals( _initSpeed, pc.Vec2.ZERO.clone() )) {
                        _initSpeed = this.initSpeed.$clone();
                    }

                    if (true) {
                        _initSpeed = this.initSpeed.$clone();
                        MetaBall.transform.localScale = new pc.Vec3( this.size, this.size, 1.0 );


                        var tr = this.WaterDropsObjects[i].GetComponent(UnityEngine.TrailRenderer);
                        if (this.TrailStartSize <= 0.0) {
                            tr.enabled = false;
                        } else {
                            tr.enabled = true;
                            tr.startWidth = this.TrailStartSize;
                            tr.endWidth = this.TrailEndSize;
                            tr.time = this.TrailDelay;
                        }

                        MetaBall.Velocity_Limiter_X = this.SpeedLimiterX.$clone();
                        MetaBall.Velocity_Limiter_Y = this.SpeedLimiterY.$clone();

                        var rb = MetaBall.GetComponent(UnityEngine.Rigidbody2D);
                        rb.sharedMaterial = this.PhysicMat;
                        rb.drag = this.LinearDrag;
                        rb.angularDrag = this.AngularDrag;
                        rb.gravityScale = this.GravityScale;

                        if (this.FreezeRotation) {
                            rb.constraints = UnityEngine.RigidbodyConstraints2D.FreezeRotation;
                        }

                        MetaBall.GetComponent(UnityEngine.CircleCollider2D).sharedMaterial = this.PhysicMat;
                        MetaBall.GetComponent(UnityEngine.CircleCollider2D).radius = this.ColliderSize;

                        MetaBall.ScaleDown = this.ScaleDown;

                        //CHANGE COLOR IN REALTIME

                        if (MetaBall.Active === false) {
                            MetaBall.gameObject.GetComponent(UnityEngine.SpriteRenderer).color = this.FillColor.$clone();
                        }

                        this.SetRegularWaterparams(this.FillColor.$clone(), this.StrokeColor.$clone(), this.AlphaCutOff, this.AlphaStroke);


                        // CHANGE GLOW IN REALTIME
                        if (this.GlowEffect && UnityEngine.Component.op_Inequality(MetaBall.glowSP, null)) {
                            if (!pc.Color.equals( MetaBall.glowSP.color, this.GlowColor )) {
                                MetaBall.glowSP.color = this.GlowColor.$clone();
                            }

                            if (MetaBall.glowSP.sortingOrder !== this.GlowSortingOrder) {
                                MetaBall.glowSP.sortingOrder = this.GlowSortingOrder;
                            }

                            if (MetaBall.glowSP.transform.localScale.x !== this.GlowSize) {
                                MetaBall.glowSP.transform.localScale = new pc.Vec3( 1, 1, 1 ).clone().scale( this.GlowSize );
                            }
                        }
                    }

                    var dir = UnityEngine.Vector2.FromVector3(this.transform.up.$clone());
                    MetaBall.GetComponent(UnityEngine.Rigidbody2D).velocity = dir.$clone().scale( -1 ).scale( this.Speed );


                    this.DropsUsed = (this.DropsUsed + 1) | 0;
                    this._spawnedDrops = (this._spawnedDrops + 1) | 0;

                    //Invoke event
                    this.InvokeOnSpawnerEmittinEachParticle(this.gameObject, MetaBall.gameObject);

                    if (this._spawnedDrops >= this.DropCount) {
                        if (!this.Loop) {
                            this.SimulateInEditor = false;
                        }

                        //Invoke event End
                        if (this._canInvokeAttheEnd) {
                            this.InvokeOnSpawnerEnd(this.gameObject);
                            this._canInvokeAttheEnd = false;
                        }


                        this._spawnedDrops = Bridge.Int.mul(this._spawnedDrops, 0);
                    }


                    return;
                }
            },
            /*Water2D.Water2D_Spawner.loop_editor end.*/

            /*Water2D.Water2D_Spawner.loop start.*/
            loop: function (_pos, _initSpeed, count, delay, waitBetweenDropSpawn) {
if ( TRACE ) { TRACE( "Water2D.Water2D_Spawner#loop", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    i,
                    MetaBall,
                    tr,
                    rb,
                    dir,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if (count === void 0) { count = -1; }
                                        if (delay === void 0) { delay = 0.0; }
                                        if (waitBetweenDropSpawn === void 0) { waitBetweenDropSpawn = true; }
                                        if (this.IsSpawning) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 2;
                                        continue;
                                }
                                case 1: {
                                    return false;
                                }
                                case 2: {
                                    if (this.Water2DEmissionType === Water2D.Water2D_Spawner.EmissionType.FillerCollider) {
                                            $step = 3;
                                            continue;
                                        } 
                                        $step = 4;
                                        continue;
                                }
                                case 3: {
                                    UnityEngine.Debug.LogError$2("You're trying spawn particles in a Filler type. You should create a water spawner instead");
                                        return false;
                                    $step = 4;
                                    continue;
                                }
                                case 4: {
                                    //  Physics2D.autoSimulation = true;

                                        this.IsSpawning = true;

                                        $enumerator.current = new UnityEngine.WaitForSeconds(delay);
                                        $step = 5;
                                        return true;
                                }
                                case 5: {
                                    this._breakLoop = false;


                                        //int auxCount = 0;

                                        //Invoke event Start
                                        this.InvokeOnSpawnerStart(this.gameObject);
                                    $step = 6;
                                    continue;
                                }
                                case 6: {
                                    if ( true ) {
                                            $step = 7;
                                            continue;
                                        } 
                                        $step = 26;
                                        continue;
                                }
                                case 7: {
                                    i = 0;
                                        $step = 8;
                                        continue;
                                }
                                case 8: {
                                    if ( i < this.WaterDropsObjects.length ) {
                                            $step = 9;
                                            continue;
                                        }
                                    $step = 20;
                                    continue;
                                }
                                case 9: {
                                    if (this._breakLoop) {
                                            $step = 10;
                                            continue;
                                        } 
                                        $step = 11;
                                        continue;
                                }
                                case 10: {
                                    return false;
                                }
                                case 11: {
                                    MetaBall = this.WaterDropsObjects[i].GetComponent(MetaballParticleClass);
                                        //MetaballParticleClass MetaBall = Instantiate(DropObject, gameObject.transform.position,
                                        //                       new Quaternion(0, 0, 0, 0));
                                        if (MetaBall.Active === true) {
                                            $step = 19;
                                            continue;
                                        }

                                        this._canInvokeAttheEnd = true;

                                        if (this.LifeTime <= 0) {
                                            MetaBall.LifeTime = -1.0;
                                        } else {
                                            MetaBall.LifeTime = this.LifeTime;
                                        }

                                        this.WaterDropsObjects[i].transform.position = this.transform.position.$clone();


                                        if (pc.Vec2.equals( _initSpeed, pc.Vec2.ZERO.clone() )) {
                                            _initSpeed = this.initSpeed.$clone();
                                        }

                                        if (this.DynamicChanges) {
                                            _initSpeed = this.initSpeed.$clone();
                                            MetaBall.transform.localScale = new pc.Vec3( this.size, this.size, 1.0 );

                                            //CHANGE COLOR

                                            this._lastFillColor = this.FillColor.$clone();
                                            if (MetaBall.Active === false) {
                                                MetaBall.gameObject.GetComponent(UnityEngine.SpriteRenderer).color = this.FillColor.$clone();
                                            }

                                            this.SetRegularWaterparams(this.FillColor.$clone(), this.StrokeColor.$clone(), this.AlphaCutOff, this.AlphaStroke);


                                            tr = this.WaterDropsObjects[i].GetComponent(UnityEngine.TrailRenderer);
                                            if (this.TrailStartSize <= 0.0) {
                                                tr.enabled = false;
                                            } else {
                                                tr.enabled = true;
                                                tr.startWidth = this.TrailStartSize;
                                                tr.endWidth = this.TrailEndSize;
                                                tr.time = this.TrailDelay;
                                            }


                                            MetaBall.Velocity_Limiter_X = this.SpeedLimiterX.$clone();
                                            MetaBall.Velocity_Limiter_Y = this.SpeedLimiterY.$clone();

                                            rb = MetaBall.GetComponent(UnityEngine.Rigidbody2D);
                                            rb.sharedMaterial = this.PhysicMat;
                                            rb.drag = this.LinearDrag;
                                            rb.angularDrag = this.AngularDrag;
                                            rb.gravityScale = this.GravityScale;

                                            if (this.FreezeRotation) {
                                                rb.constraints = UnityEngine.RigidbodyConstraints2D.FreezeRotation;
                                            }

                                            MetaBall.GetComponent(UnityEngine.CircleCollider2D).sharedMaterial = this.PhysicMat;
                                            MetaBall.GetComponent(UnityEngine.CircleCollider2D).radius = this.ColliderSize;
                                            MetaBall.ScaleDown = this.ScaleDown;
                                        }

                                        MetaBall.Active = true;
                                        MetaBall.witinTarget = false;


                                        //WaterDropsObjects [i].GetComponent<Rigidbody2D> ().velocity = _initSpeed;
                                        dir = UnityEngine.Vector2.FromVector3(this.transform.up.$clone());
                                        MetaBall.GetComponent(UnityEngine.Rigidbody2D).velocity = dir.$clone().scale( -1 ).scale( this.Speed );

                                        this.DropsUsed = (this.DropsUsed + 1) | 0;
                                        this._spawnedDrops = (this._spawnedDrops + 1) | 0;


                                        //print(Time.fixedDeltaTime / DelayBetweenParticles);
                                        if (waitBetweenDropSpawn) {
                                            $step = 12;
                                            continue;
                                        } 
                                        $step = 18;
                                        continue;
                                }
                                case 12: {
                                    if (this.DelayBetweenParticles < 0.001) {
                                            $step = 13;
                                            continue;
                                        } else  {
                                            $step = 15;
                                            continue;
                                        }
                                }
                                case 13: {
                                    $enumerator.current = null;
                                        $step = 14;
                                        return true;
                                }
                                case 14: {
                                    $step = 17;
                                    continue;
                                }
                                case 15: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(this.DelayBetweenParticles);
                                        $step = 16;
                                        return true;
                                }
                                case 16: {
                                    $step = 17;
                                    continue;
                                }
                                case 17: {
                                    $step = 18;
                                    continue;
                                }
                                case 18: {
                                    //Invoke event
                                        this.InvokeOnSpawnerEmittinEachParticle(this.gameObject, MetaBall.gameObject);
                                    $step = 19;
                                    continue;
                                }
                                case 19: {
                                    i = (i + 1) | 0;
                                    $step = 8;
                                    continue;
                                }
                                case 20: {
                                    $enumerator.current = new UnityEngine.WaitForEndOfFrame();
                                        $step = 21;
                                        return true;
                                }
                                case 21: {
                                    if (this._spawnedDrops >= this.DropCount) {
                                            $step = 22;
                                            continue;
                                        } 
                                        $step = 25;
                                        continue;
                                }
                                case 22: {
                                    //Invoke event End
                                        if (this._canInvokeAttheEnd) {
                                            this.InvokeOnSpawnerEnd(this.gameObject);
                                            this._canInvokeAttheEnd = false;
                                        }

                                        this._spawnedDrops = Bridge.Int.mul(this._spawnedDrops, 0);

                                        if (!this.Loop) {
                                            $step = 23;
                                            continue;
                                        } 
                                        $step = 24;
                                        continue;
                                }
                                case 23: {
                                    return false;
                                }
                                case 24: {
                                    $step = 25;
                                    continue;
                                }
                                case 25: {
                                    
                                        $step = 6;
                                        continue;
                                }
                                case 26: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Water2D.Water2D_Spawner.loop end.*/

            /*Water2D.Water2D_Spawner.SpawnAllParticles start.*/
            /**
             * Spawn all particles together at the same time
             *
             * @instance
             * @private
             * @this Water2D.Water2D_Spawner
             * @memberof Water2D.Water2D_Spawner
             * @param   {UnityEngine.Vector3}    _pos          
             * @param   {UnityEngine.Vector2}    _initSpeed    
             * @param   {number}                 count         
             * @param   {number}                 delay
             * @return  {void}
             */
            SpawnAllParticles: function (_pos, _initSpeed, count, delay) {
if ( TRACE ) { TRACE( "Water2D.Water2D_Spawner#SpawnAllParticles", this ); }

                if (count === void 0) { count = -1; }
                if (delay === void 0) { delay = 0.0; }
                this.IsSpawning = true;

                var auxCount = 0;
                // while (true)
                //{
                for (var i = 0; i < this.WaterDropsObjects.length; i = (i + 1) | 0) {
                    var MetaBall = this.WaterDropsObjects[i].GetComponent(MetaballParticleClass);

                    if (MetaBall.Active === true) {
                        continue;
                    }

                    MetaBall.LifeTime = this.LifeTime;
                    this.WaterDropsObjects[i].transform.position = this.transform.position.$clone();
                    MetaBall.Active = true;
                    MetaBall.witinTarget = false;

                    if (pc.Vec2.equals( _initSpeed, pc.Vec2.ZERO.clone() )) {
                        _initSpeed = this.initSpeed.$clone();
                    }

                    if (this.DynamicChanges) {
                        _initSpeed = this.initSpeed.$clone();
                        MetaBall.transform.localScale = new pc.Vec3( this.size, this.size, 1.0 );
                        //CHANGE COLOR

                        //_lastFillColor = FillColor;
                        if (MetaBall.Active === false) {
                            MetaBall.gameObject.GetComponent(UnityEngine.SpriteRenderer).color = this.FillColor.$clone();
                        }

                        this.SetRegularWaterparams(this.FillColor.$clone(), this.StrokeColor.$clone(), this.AlphaCutOff, this.AlphaStroke);
                    }

                    this.WaterDropsObjects[i].GetComponent(UnityEngine.Rigidbody2D).velocity = _initSpeed.$clone();


                    // Count limiter
                    if (count > -1) {
                        auxCount = (auxCount + 1) | 0;
                        if (auxCount >= count && !this.Loop) {
                            break;
                        }
                    }
                }

                //alreadySpawned = true;


                // }
            },
            /*Water2D.Water2D_Spawner.SpawnAllParticles end.*/

            /*Water2D.Water2D_Spawner.InvokeOnShapeFill start.*/
            InvokeOnShapeFill: function (obj, results) {
if ( TRACE ) { TRACE( "Water2D.Water2D_Spawner#InvokeOnShapeFill", this ); }

                this.OnValidateShapeFill != null ? this.OnValidateShapeFill.Invoke(obj, results) : null;
            },
            /*Water2D.Water2D_Spawner.InvokeOnShapeFill end.*/

            /*Water2D.Water2D_Spawner.InvokeOnCollisionEnter2D start.*/
            InvokeOnCollisionEnter2D: function (obj, other) {
if ( TRACE ) { TRACE( "Water2D.Water2D_Spawner#InvokeOnCollisionEnter2D", this ); }

                this.OnCollisionEnterList.Invoke(obj, other);
            },
            /*Water2D.Water2D_Spawner.InvokeOnCollisionEnter2D end.*/

            /*Water2D.Water2D_Spawner.InvokeOnSpawnerStart start.*/
            InvokeOnSpawnerStart: function (obj) {
if ( TRACE ) { TRACE( "Water2D.Water2D_Spawner#InvokeOnSpawnerStart", this ); }

                if (this.OnSpawnerAboutStart != null) {
                    this.OnSpawnerAboutStart.Invoke(obj, null);
                }
            },
            /*Water2D.Water2D_Spawner.InvokeOnSpawnerStart end.*/

            /*Water2D.Water2D_Spawner.InvokeOnSpawnerEnd start.*/
            InvokeOnSpawnerEnd: function (obj) {
if ( TRACE ) { TRACE( "Water2D.Water2D_Spawner#InvokeOnSpawnerEnd", this ); }

                this.OnSpawnerAboutEnd.Invoke(obj, null);
            },
            /*Water2D.Water2D_Spawner.InvokeOnSpawnerEnd end.*/

            /*Water2D.Water2D_Spawner.InvokeOnSpawnerEmittinEachParticle start.*/
            InvokeOnSpawnerEmittinEachParticle: function (obj, obj2) {
if ( TRACE ) { TRACE( "Water2D.Water2D_Spawner#InvokeOnSpawnerEmittinEachParticle", this ); }

                this.OnSpawnerEmitingParticle.Invoke(obj, obj2);
            },
            /*Water2D.Water2D_Spawner.InvokeOnSpawnerEmittinEachParticle end.*/

            /*Water2D.Water2D_Spawner.SetRegularWaterparams start.*/
            SetRegularWaterparams: function (fill, fresnel, alphaCutoff, multiplier) {
if ( TRACE ) { TRACE( "Water2D.Water2D_Spawner#SetRegularWaterparams", this ); }

                /* 
                WaterMaterial.SetFloat("_constant", multiplier);
                WaterMaterial.SetFloat("_botmcut", alphaCutoff);

                */

                Water2D.SpawnersManager.ChangeSpawnerValues(this.instance);

                // I do use Stroke as Fresnel
                // Fresnel is a shared property since I've use camera to reach that effect
                if (!pc.Color.equals( this._lastStrokeColor, this.StrokeColor )) {
                    this._lastStrokeColor = this.StrokeColor.$clone();
                    // SpawnersManager.SetFresnelColor(StrokeColor);
                }

                if (this._lastSorting !== this.Sorting) {
                    this._lastSorting = this.Sorting;
                    Water2D.SpawnersManager.SetSorting(this.Sorting);
                }
            },
            /*Water2D.Water2D_Spawner.SetRegularWaterparams end.*/

            /*Water2D.Water2D_Spawner.UpdateQuietParticleProperties start.*/
            UpdateQuietParticleProperties: function () {
if ( TRACE ) { TRACE( "Water2D.Water2D_Spawner#UpdateQuietParticleProperties", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    MetaBall,
                    rb,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if ( true ) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 3;
                                        continue;
                                }
                                case 1: {
                                    for (var i = 0; i < this.WaterDropsObjects.length; i = (i + 1) | 0) {
                                            MetaBall = this.WaterDropsObjects[i].GetComponent(MetaballParticleClass);


                                            //CHANGE COLOR

                                            this._lastFillColor = this.FillColor.$clone();
                                            if (MetaBall.Active === false) {
                                                MetaBall.gameObject.GetComponent(UnityEngine.SpriteRenderer).color = this.FillColor.$clone();
                                            }

                                            this.SetRegularWaterparams(this.FillColor.$clone(), this.StrokeColor.$clone(), this.AlphaCutOff, this.AlphaStroke);


                                            MetaBall.Velocity_Limiter_X = this.SpeedLimiterX.$clone();
                                            MetaBall.Velocity_Limiter_Y = this.SpeedLimiterY.$clone();


                                            rb = MetaBall.GetComponent(UnityEngine.Rigidbody2D);
                                            rb.sharedMaterial = this.PhysicMat;
                                            rb.drag = this.LinearDrag;
                                            rb.angularDrag = this.AngularDrag;
                                            rb.gravityScale = this.GravityScale;

                                            if (this.FreezeRotation) {
                                                rb.constraints = UnityEngine.RigidbodyConstraints2D.FreezeRotation;
                                            }

                                            MetaBall.GetComponent(UnityEngine.CircleCollider2D).sharedMaterial = this.PhysicMat;
                                            MetaBall.GetComponent(UnityEngine.CircleCollider2D).radius = this.ColliderSize;
                                        }

                                        $enumerator.current = null;
                                        $step = 2;
                                        return true;
                                }
                                case 2: {
                                    
                                        $step = 0;
                                        continue;
                                }
                                case 3: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Water2D.Water2D_Spawner.UpdateQuietParticleProperties end.*/

            /*Water2D.Water2D_Spawner.GetCurrentMaterial start.*/
            GetCurrentMaterial: function () {
if ( TRACE ) { TRACE( "Water2D.Water2D_Spawner#GetCurrentMaterial", this ); }

                return this.WaterMaterial;
            },
            /*Water2D.Water2D_Spawner.GetCurrentMaterial end.*/

            /*Water2D.Water2D_Spawner.StartCheckingFillShape start.*/
            StartCheckingFillShape: function () {
if ( TRACE ) { TRACE( "Water2D.Water2D_Spawner#StartCheckingFillShape", this ); }

                if (!this._checkOnFillRunning && !this._checkOnFillComplete) {
                    UnityEngine.MonoBehaviour.print("StartCheckingFillShape");
                    this.StartCoroutine$1(this.CheckOnFill(this.ShapeFillCollider2D, this.ShapeFillAccuracy));
                }
            },
            /*Water2D.Water2D_Spawner.StartCheckingFillShape end.*/

            /*Water2D.Water2D_Spawner.RestoreCheckingFillShape start.*/
            RestoreCheckingFillShape: function () {
if ( TRACE ) { TRACE( "Water2D.Water2D_Spawner#RestoreCheckingFillShape", this ); }

                this.StartCoroutine$1(this._restoreCheckingFillShapeEnum());
            },
            /*Water2D.Water2D_Spawner.RestoreCheckingFillShape end.*/

            /*Water2D.Water2D_Spawner._restoreCheckingFillShapeEnum start.*/
            _restoreCheckingFillShapeEnum: function () {
if ( TRACE ) { TRACE( "Water2D.Water2D_Spawner#_restoreCheckingFillShapeEnum", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(0.2);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    this._breakCheckOnFill = true;
                                        this._checkOnFillComplete = false;

                                        if (this.ShapeFillCollider2DCount !== this.ShapeFillCollider2D.length) {
                                            this.ShapeFillCollider2D = System.Array.init(this.ShapeFillCollider2DCount, null, UnityEngine.Collider2D);
                                        }

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Water2D.Water2D_Spawner._restoreCheckingFillShapeEnum end.*/

            /*Water2D.Water2D_Spawner.CheckOnFill start.*/
            CheckOnFill: function (shapeCollider, accuracy) {
if ( TRACE ) { TRACE( "Water2D.Water2D_Spawner#CheckOnFill", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    cf,
                    allOverlappingColliders,
                    result,
                    _trigged,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if (accuracy === void 0) { accuracy = 0.8; }
                                        this._checkOnFillRunning = true;

                                        cf = new UnityEngine.ContactFilter2D();
                                        cf.useTriggers = true;
                                        //  cf.SetLayerMask(Physics2D.GetLayerCollisionMask(DropObject.layer));
                                        cf.useLayerMask = true;

                                        allOverlappingColliders = System.Array.init(this.DropCount, null, UnityEngine.Collider2D);


                                        result = 0;
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( true ) {
                                            $step = 2;
                                            continue;
                                        } 
                                        $step = 6;
                                        continue;
                                }
                                case 2: {
                                    if (this._breakCheckOnFill) {
                                            $step = 3;
                                            continue;
                                        } 
                                        $step = 4;
                                        continue;
                                }
                                case 3: {
                                    this._checkOnFillRunning = false;
                                        this._breakCheckOnFill = false;
                                        return false;
                                    $step = 4;
                                    continue;
                                }
                                case 4: {
                                    $enumerator.current = new UnityEngine.WaitForFixedUpdate();
                                        $step = 5;
                                        return true;
                                }
                                case 5: {
                                    for (var i = 0; i < shapeCollider.length; i = (i + 1) | 0) {
                                            // Debug.Log(shapeCollider[i]);

                                            if (UnityEngine.Component.op_Equality(shapeCollider[i], null)) {
                                                continue;
                                            }


                                            result = shapeCollider[i].OverlapCollider(cf.$clone(), allOverlappingColliders);


                                            _trigged = false;

                                            if (this.Water2DEmissionType === Water2D.Water2D_Spawner.EmissionType.FillerCollider) {
                                                _trigged = (result >= this.DropsUsed * accuracy);
                                            } else {
                                                _trigged = (result >= this.DropCount * accuracy);
                                            }


                                            if (_trigged) {
                                                this.InvokeOnShapeFill(this.instance.gameObject, shapeCollider[i].gameObject);
                                                //Debug.Log("Fill Event sucessful Complete! : droplives:" + DropsUsed + "   // " + ((int)(DropsUsed * accuracy)).ToString() + "within the target");
                                                this._checkOnFillComplete = true;
                                                this._breakCheckOnFill = true;
                                            }
                                        }

                                        $step = 1;
                                        continue;
                                }
                                case 6: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Water2D.Water2D_Spawner.CheckOnFill end.*/

            /*Water2D.Water2D_Spawner.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Water2D.Water2D_Spawner#OnDestroy", this ); }

                Water2D.SpawnersManager.DeleteSpawnerValues(this.instance);
                UnityEngine.Object.DestroyImmediate(this.instance._parent);
                //StartCoroutine(_destroyItself());
            },
            /*Water2D.Water2D_Spawner.OnDestroy end.*/


        },
        overloads: {
            "Spawn(int)": "Spawn$1",
            "Spawn(int, Vector3)": "Spawn$2",
            "Spawn(int, Vector3, Vector2, float)": "Spawn$3"
        }
    });
    /*Water2D.Water2D_Spawner end.*/

    /*Water2D.Water2D_Spawner+EmissionType start.*/
    Bridge.define("Water2D.Water2D_Spawner.EmissionType", {
        $kind: 1006,
        statics: {
            fields: {
                ParticleSystem: 0,
                FillerCollider: 1
            }
        }
    });
    /*Water2D.Water2D_Spawner+EmissionType end.*/

    /*Water2D.Water2D_Spawner+EnumTypes start.*/
    Bridge.define("Water2D.Water2D_Spawner.EnumTypes", {
        $kind: 1006,
        statics: {
            fields: {
                Regular: 0,
                Refracting: 1,
                Toon: 2
            }
        }
    });
    /*Water2D.Water2D_Spawner+EnumTypes end.*/

    /*Water2D.Water2D_Spawner+FillerColliderType start.*/
    Bridge.define("Water2D.Water2D_Spawner.FillerColliderType", {
        $kind: 1006,
        statics: {
            fields: {
                Box: 0,
                Circle: 1,
                Polygon: 2
            }
        }
    });
    /*Water2D.Water2D_Spawner+FillerColliderType end.*/

    /*Water2D.Water2DEvents start.*/
    Bridge.define("Water2D.Water2DEvents", {
        inherits: [UnityEngine.Events.UnityEvent$2(UnityEngine.GameObject,UnityEngine.GameObject)]
    });
    /*Water2D.Water2DEvents end.*/

    /*Singleton$1 start.*/
    Bridge.define("Singleton$1", function (T) { return {
        inherits: [SingletonMono$1(T)],
        statics: {
            props: {
                Instance: {
                    get: function () {
if ( TRACE ) { TRACE( "Singleton$1#Instance#get", this ); }

                        if (Bridge.rValue(SingletonMono$1(T).instance) != null) {
                            return Bridge.rValue(SingletonMono$1(T).instance);
                        }
                        SingletonMono$1(T).instance = Bridge.cast(UnityEngine.Object.FindObjectOfType$1(T), T);
                        if (Bridge.rValue(SingletonMono$1(T).instance) == null) {
                            UnityEngine.Debug.LogWarningFormat("[Singleton] Class {0} not found! Create empty instance", [T]);
                            SingletonMono$1(T).instance = Bridge.rValue(new UnityEngine.GameObject.$ctor2(Bridge.Reflection.getTypeName(T)).AddComponent(T));
                        }
                        return Bridge.rValue(SingletonMono$1(T).instance);
                    }
                }
            }
        }
    }; });
    /*Singleton$1 end.*/

    /*Ice start.*/
    Bridge.define("Ice", {
        inherits: [DrinkMaterial],
        fields: {
            lerpDistance: 0,
            feetOffset: null,
            size: null,
            maxVelocityY: 0,
            buoyancyForce: 0,
            sprites: null,
            image: null,
            collider2Ds: null,
            contactFilter2D: null
        },
        props: {
            gravityDirection: {
                get: function () {
if ( TRACE ) { TRACE( "Ice#gravityDirection#get", this ); }

                    return UnityEngine.Physics2D.gravity.clone().normalize().$clone();
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Ice#init", this ); }

                var $t;
                this.feetOffset = new UnityEngine.Vector2();
                this.size = new UnityEngine.Vector2();
                this.contactFilter2D = new UnityEngine.ContactFilter2D();
                this.lerpDistance = 0.2;
                this.feetOffset = new pc.Vec2( 0, 0.1 );
                this.size = new pc.Vec2( 0.5, 0.1 );
                this.maxVelocityY = 0.3;
                this.buoyancyForce = 500;
                this.collider2Ds = System.Array.init(3, null, UnityEngine.Collider2D);
                this.contactFilter2D = ($t = new UnityEngine.ContactFilter2D(), $t.layerMask = UnityEngine.LayerMask.op_Implicit$1(16), $t.useLayerMask = true, $t);
            }
        },
        methods: {
            /*Ice.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "Ice#OnValidate", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.image, null)) {
                    this.image = this.GetComponent(UnityEngine.UI.Image);
                }
            },
            /*Ice.OnValidate end.*/

            /*Ice.OnDrawGizmosSelected start.*/
            OnDrawGizmosSelected: function () {
if ( TRACE ) { TRACE( "Ice#OnDrawGizmosSelected", this ); }

                UnityEngine.Gizmos.DrawCube(this.transform.position.$clone().sub( UnityEngine.Vector3.FromVector2(this.feetOffset) ), UnityEngine.Vector3.FromVector2(this.size.$clone()));
            },
            /*Ice.OnDrawGizmosSelected end.*/

            /*Ice.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Ice#OnEnable", this ); }

                DrinkMaterial.prototype.OnEnable.call(this);
                if (!HelperUtility.IsEmpty(UnityEngine.Sprite, this.sprites)) {
                    this.image.sprite = HelperUtility.GetRandom(UnityEngine.Sprite, this.sprites);
                }
            },
            /*Ice.OnEnable end.*/

            /*Ice.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Ice#FixedUpdate", this ); }

                var hit = UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2.FromVector3(this.transform.position).sub( this.feetOffset ), 3.0);

                var feetCount = hit.length;
                //int feetCount = Physics2D.OverlapBox(
                //    (Vector2)transform.position - feetOffset,
                //    size,
                //    0,
                //    contactFilter2D,
                //    collider2Ds);

                if (feetCount === 0) {
                    // Debug.LogError("Drop");
                    return;
                }


                var lerp = DG.Tweening.DOVirtual.EasedValue(0, 1, Math.max(0, Math.min(1, this.GetDistance(feetCount) / this.lerpDistance)), DG.Tweening.Ease.OutQuart);
                var rb = this.Rb;
                if (feetCount === 1 || feetCount === 2) {
                    rb.AddForce(UnityEngine.Physics2D.gravity.$clone().scale( -1 ));
                    // Debug.LogError("pause");
                } else {
                    rb.AddForce(pc.Vec2.UP.clone().scale( (this.buoyancyForce * lerp) ).sub( UnityEngine.Physics2D.gravity ));
                }

                rb.velocity = new pc.Vec2( UnityEngine.Mathf.Min(rb.velocity.x, this.maxVelocityY * lerp), UnityEngine.Mathf.Min(rb.velocity.y, this.maxVelocityY * lerp) );
            },
            /*Ice.FixedUpdate end.*/

            /*Ice.GetDistance start.*/
            GetDistance: function (colliderCount) {
if ( TRACE ) { TRACE( "Ice#GetDistance", this ); }

                var currentPosition = VectorUlti.Set$1((this.transform.position.$clone().sub( UnityEngine.Vector3.FromVector2(this.feetOffset) )), void 0, void 0, 0);
                var maxDistance = 0.0;
                var gravityDir = this.gravityDirection.$clone();
                var gravityNormal = new pc.Vec3( gravityDir.y, -gravityDir.x, 0 ).clone().normalize().$clone();
                //for (int i = 0; i < colliderCount && i < collider2Ds.Length; i++)
                //{
                //    var colliderPosition =
                //        collider2Ds[i].transform.position.Set(z: 0) - (Vector3)gravityDir * 0.375f;
                //    var dir = colliderPosition - currentPosition;
                //    var dot = Vector3.Dot(gravityDir, dir);
                //    var distance = Vector3.Cross(gravityNormal, dir).magnitude;
                //    distance *= -Mathf.Sign(dot);
                //    maxDistance = Mathf.Max(maxDistance, distance);
                //}

                return maxDistance;
            },
            /*Ice.GetDistance end.*/


        }
    });
    /*Ice end.*/

    /*Liquid start.*/
    Bridge.define("Liquid", {
        inherits: [DrinkMaterial],
        statics: {
            fields: {
                defaultColor: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Liquid#init", this ); }

                    this.defaultColor = new UnityEngine.Color();
                    this.defaultColor = new pc.Color( 0.0, 0.4392157, 1.0, 1 );
                }
            }
        },
        fields: {
            collider2d: null,
            collider2dLiquid: null,
            metaballParticleClass: null,
            firstHit: false
        },
        methods: {
            /*Liquid.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "Liquid#OnValidate", this ); }

                if (UnityEngine.Component.op_Equality(this.collider2d, null)) {
                    this.collider2d = this.GetComponent(UnityEngine.Collider2D);
                }
                if (UnityEngine.Component.op_Equality(this.collider2dLiquid, null)) {
                    this.collider2dLiquid = this.GetComponent(UnityEngine.Collider2D);
                }
            },
            /*Liquid.OnValidate end.*/

            /*Liquid.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Liquid#OnEnable", this ); }

                DrinkMaterial.prototype.OnEnable.call(this);
                this.firstHit = true;
                this.collider2d.isTrigger = true;
                this.collider2dLiquid.isTrigger = true;
                this.Rb.AddForce(new pc.Vec2( UnityEngine.Random.Range$1(-1.0, 1.0), 0 ));
            },
            /*Liquid.OnEnable end.*/

            /*Liquid.OnTriggerEnter2D start.*/
            OnTriggerEnter2D: function (other) {
if ( TRACE ) { TRACE( "Liquid#OnTriggerEnter2D", this ); }

                if (!this.firstHit) {
                    return;
                }
                if (other.isTrigger) {
                    return;
                }
                if (other.gameObject.layer === 6) {
                    return;
                }
                if (other.gameObject.layer === 7) {
                    return;
                }

                this.firstHit = false;
                this.collider2d.isTrigger = false;
                this.collider2dLiquid.isTrigger = false;
                // Rb.AddForce(new Vector2(Random.Range(-10f, 10f), 0));
            },
            /*Liquid.OnTriggerEnter2D end.*/

            /*Liquid.FallsOutOfView start.*/
            FallsOutOfView: function () {
if ( TRACE ) { TRACE( "Liquid#FallsOutOfView", this ); }

                this.metaballParticleClass.Active = false;
            },
            /*Liquid.FallsOutOfView end.*/


        }
    });
    /*Liquid end.*/

    /*Spine.AnimationStateData+AnimationPairComparer start.*/
    Bridge.define("Spine.AnimationStateData.AnimationPairComparer", {
        inherits: [System.Collections.Generic.IEqualityComparer$1(Spine.AnimationStateData.AnimationPair)],
        $kind: 1002,
        statics: {
            fields: {
                Instance: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPairComparer#init", this ); }

                    this.Instance = new Spine.AnimationStateData.AnimationPairComparer();
                }
            }
        },
        alias: [
            "System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2",
            "System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$getHashCode2", "System$Collections$Generic$IEqualityComparer$1$getHashCode2"
        ],
        methods: {
            /*Spine.AnimationStateData+AnimationPairComparer.System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$equals2 start.*/
            System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$equals2: function (x, y) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPairComparer#System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$equals2", this ); }

                return Bridge.referenceEquals(x.a1, y.a1) && Bridge.referenceEquals(x.a2, y.a2);
            },
            /*Spine.AnimationStateData+AnimationPairComparer.System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$equals2 end.*/

            /*Spine.AnimationStateData+AnimationPairComparer.System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$getHashCode2 start.*/
            System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$getHashCode2: function (obj) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPairComparer#System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$getHashCode2", this ); }

                // from Tuple.CombineHashCodes // return (((h1 << 5) + h1) ^ h2);
                var h1 = Bridge.getHashCode(obj.a1);
                return (((((h1 << 5) + h1) | 0)) ^ Bridge.getHashCode(obj.a2));
            },
            /*Spine.AnimationStateData+AnimationPairComparer.System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$getHashCode2 end.*/


        }
    });
    /*Spine.AnimationStateData+AnimationPairComparer end.*/

    /*Spine.Atlas start.*/
    Bridge.define("Spine.Atlas", {
        inherits: [System.Collections.Generic.IEnumerable$1(Spine.AtlasRegion)],
        statics: {
            methods: {
                /*Spine.Atlas.ReadValue:static start.*/
                ReadValue: function (reader) {
if ( TRACE ) { TRACE( "Spine.Atlas#ReadValue", this ); }

                    var line = reader.ReadLine();
                    var colon = System.String.indexOf(line, String.fromCharCode(58));
                    if (colon === -1) {
                        throw new System.Exception("Invalid line: " + (line || ""));
                    }
                    return line.substr(((colon + 1) | 0)).trim();
                },
                /*Spine.Atlas.ReadValue:static end.*/

                /*Spine.Atlas.ReadTuple:static start.*/
                /**
                 * Returns the number of tuple values read (1, 2 or 4).
                 *
                 * @static
                 * @private
                 * @this Spine.Atlas
                 * @memberof Spine.Atlas
                 * @param   {System.IO.TextReader}    reader    
                 * @param   {Array.<string>}          tuple
                 * @return  {number}
                 */
                ReadTuple: function (reader, tuple) {
if ( TRACE ) { TRACE( "Spine.Atlas#ReadTuple", this ); }

                    var line = reader.ReadLine();
                    var colon = System.String.indexOf(line, String.fromCharCode(58));
                    if (colon === -1) {
                        throw new System.Exception("Invalid line: " + (line || ""));
                    }
                    var i = 0, lastMatch = (colon + 1) | 0;
                    for (; i < 3; i = (i + 1) | 0) {
                        var comma = System.String.indexOf(line, String.fromCharCode(44), lastMatch);
                        if (comma === -1) {
                            break;
                        }
                        tuple[i] = line.substr(lastMatch, ((comma - lastMatch) | 0)).trim();
                        lastMatch = (comma + 1) | 0;
                    }
                    tuple[i] = line.substr(lastMatch).trim();
                    return ((i + 1) | 0);
                },
                /*Spine.Atlas.ReadTuple:static end.*/


            }
        },
        fields: {
            pages: null,
            regions: null,
            textureLoader: null
        },
        props: {
            Regions: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Atlas#Regions#get", this ); }

                    return this.regions;
                }
            },
            Pages: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Atlas#Pages#get", this ); }

                    return this.pages;
                }
            }
        },
        alias: ["GetEnumerator", ["System$Collections$Generic$IEnumerable$1$Spine$AtlasRegion$GetEnumerator", "System$Collections$Generic$IEnumerable$1$GetEnumerator"]],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Atlas#init", this ); }

                this.pages = new (System.Collections.Generic.List$1(Spine.AtlasPage)).ctor();
                this.regions = new (System.Collections.Generic.List$1(Spine.AtlasRegion)).ctor();
            },
            $ctor1: function (reader, dir, textureLoader) {
if ( TRACE ) { TRACE( "Spine.Atlas#$ctor1", this ); }

                this.$initialize();
                this.Load(reader, dir, textureLoader);
            },
            ctor: function (pages, regions) {
if ( TRACE ) { TRACE( "Spine.Atlas#ctor", this ); }

                this.$initialize();
                this.pages = pages;
                this.regions = regions;
                this.textureLoader = null;
            }
        },
        methods: {
            /*Spine.Atlas.GetEnumerator start.*/
            GetEnumerator: function () {
if ( TRACE ) { TRACE( "Spine.Atlas#GetEnumerator", this ); }

                return this.regions.GetEnumerator().$clone();
            },
            /*Spine.Atlas.GetEnumerator end.*/

            /*Spine.Atlas.System$Collections$IEnumerable$GetEnumerator start.*/
            System$Collections$IEnumerable$GetEnumerator: function () {
if ( TRACE ) { TRACE( "Spine.Atlas#System$Collections$IEnumerable$GetEnumerator", this ); }

                return this.regions.GetEnumerator().$clone();
            },
            /*Spine.Atlas.System$Collections$IEnumerable$GetEnumerator end.*/

            /*Spine.Atlas.Load start.*/
            Load: function (reader, imagesDir, textureLoader) {
if ( TRACE ) { TRACE( "Spine.Atlas#Load", this ); }

                if (textureLoader == null) {
                    throw new System.ArgumentNullException.$ctor3("textureLoader", "textureLoader cannot be null.");
                }
                this.textureLoader = textureLoader;

                var tuple = System.Array.init(4, null, System.String);
                var page = null;
                while (true) {
                    var line = reader.ReadLine();
                    if (line == null) {
                        break;
                    }
                    if (line.trim().length === 0) {
                        page = null;
                    } else {
                        if (page == null) {
                            page = new Spine.AtlasPage();
                            page.name = line;

                            if (Spine.Atlas.ReadTuple(reader, tuple) === 2) { // size is only optional for an atlas packed with an old TexturePacker.
                                page.width = System.Int32.parseWithProvider(tuple[0], 7, System.Globalization.CultureInfo.invariantCulture);
                                page.height = System.Int32.parseWithProvider(tuple[1], 7, System.Globalization.CultureInfo.invariantCulture);
                                Spine.Atlas.ReadTuple(reader, tuple);
                            }
                            page.format = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.Format, tuple[0], false), Spine.Format), System.Int32));

                            Spine.Atlas.ReadTuple(reader, tuple);
                            page.minFilter = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.TextureFilter, tuple[0], false), Spine.TextureFilter), System.Int32));
                            page.magFilter = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.TextureFilter, tuple[1], false), Spine.TextureFilter), System.Int32));

                            var direction = Spine.Atlas.ReadValue(reader);
                            page.uWrap = Spine.TextureWrap.ClampToEdge;
                            page.vWrap = Spine.TextureWrap.ClampToEdge;
                            if (Bridge.referenceEquals(direction, "x")) {
                                page.uWrap = Spine.TextureWrap.Repeat;
                            } else {
                                if (Bridge.referenceEquals(direction, "y")) {
                                    page.vWrap = Spine.TextureWrap.Repeat;
                                } else {
                                    if (Bridge.referenceEquals(direction, "xy")) {
                                        page.uWrap = (page.vWrap = Spine.TextureWrap.Repeat);
                                    }
                                }
                            }

                            textureLoader.Spine$TextureLoader$Load(page, System.IO.Path.Combine(imagesDir, line));

                            this.pages.add(page);

                        } else {
                            var region = new Spine.AtlasRegion();
                            region.name = line;
                            region.page = page;

                            var rotateValue = Spine.Atlas.ReadValue(reader);
                            if (Bridge.referenceEquals(rotateValue, "true")) {
                                region.degrees = 90;
                            } else {
                                if (Bridge.referenceEquals(rotateValue, "false")) {
                                    region.degrees = 0;
                                } else {
                                    region.degrees = System.Int32.parse(rotateValue);
                                }
                            }
                            region.rotate = region.degrees === 90;

                            Spine.Atlas.ReadTuple(reader, tuple);
                            var x = System.Int32.parseWithProvider(tuple[0], 7, System.Globalization.CultureInfo.invariantCulture);
                            var y = System.Int32.parseWithProvider(tuple[1], 7, System.Globalization.CultureInfo.invariantCulture);

                            Spine.Atlas.ReadTuple(reader, tuple);
                            var width = System.Int32.parseWithProvider(tuple[0], 7, System.Globalization.CultureInfo.invariantCulture);
                            var height = System.Int32.parseWithProvider(tuple[1], 7, System.Globalization.CultureInfo.invariantCulture);

                            region.u = x / page.width;
                            region.v = y / page.height;
                            if (region.rotate) {
                                region.u2 = (((x + height) | 0)) / page.width;
                                region.v2 = (((y + width) | 0)) / page.height;
                            } else {
                                region.u2 = (((x + width) | 0)) / page.width;
                                region.v2 = (((y + height) | 0)) / page.height;
                            }
                            region.x = x;
                            region.y = y;
                            region.width = Math.abs(width);
                            region.height = Math.abs(height);

                            if (Spine.Atlas.ReadTuple(reader, tuple) === 4) { // split is optional
                                region.splits = System.Array.init([System.Int32.parseWithProvider(tuple[0], 7, System.Globalization.CultureInfo.invariantCulture), System.Int32.parseWithProvider(tuple[1], 7, System.Globalization.CultureInfo.invariantCulture), System.Int32.parseWithProvider(tuple[2], 7, System.Globalization.CultureInfo.invariantCulture), System.Int32.parseWithProvider(tuple[3], 7, System.Globalization.CultureInfo.invariantCulture)], System.Int32);

                                if (Spine.Atlas.ReadTuple(reader, tuple) === 4) { // pad is optional, but only present with splits
                                    region.pads = System.Array.init([System.Int32.parseWithProvider(tuple[0], 7, System.Globalization.CultureInfo.invariantCulture), System.Int32.parseWithProvider(tuple[1], 7, System.Globalization.CultureInfo.invariantCulture), System.Int32.parseWithProvider(tuple[2], 7, System.Globalization.CultureInfo.invariantCulture), System.Int32.parseWithProvider(tuple[3], 7, System.Globalization.CultureInfo.invariantCulture)], System.Int32);

                                    Spine.Atlas.ReadTuple(reader, tuple);
                                }
                            }

                            region.originalWidth = System.Int32.parseWithProvider(tuple[0], 7, System.Globalization.CultureInfo.invariantCulture);
                            region.originalHeight = System.Int32.parseWithProvider(tuple[1], 7, System.Globalization.CultureInfo.invariantCulture);

                            Spine.Atlas.ReadTuple(reader, tuple);
                            region.offsetX = System.Int32.parseWithProvider(tuple[0], 7, System.Globalization.CultureInfo.invariantCulture);
                            region.offsetY = System.Int32.parseWithProvider(tuple[1], 7, System.Globalization.CultureInfo.invariantCulture);

                            region.index = System.Int32.parseWithProvider(Spine.Atlas.ReadValue(reader), 7, System.Globalization.CultureInfo.invariantCulture);

                            this.regions.add(region);
                        }
                    }
                }
            },
            /*Spine.Atlas.Load end.*/

            /*Spine.Atlas.FlipV start.*/
            FlipV: function () {
if ( TRACE ) { TRACE( "Spine.Atlas#FlipV", this ); }

                for (var i = 0, n = this.regions.Count; i < n; i = (i + 1) | 0) {
                    var region = this.regions.getItem(i);
                    region.v = 1 - region.v;
                    region.v2 = 1 - region.v2;
                }
            },
            /*Spine.Atlas.FlipV end.*/

            /*Spine.Atlas.FindRegion start.*/
            /**
             * Returns the first region found with the specified name. This method uses string comparison to find the region, so the result
             should be cached rather than calling this method multiple times.
             *
             * @instance
             * @public
             * @this Spine.Atlas
             * @memberof Spine.Atlas
             * @param   {string}               name
             * @return  {Spine.AtlasRegion}            The region, or null.
             */
            FindRegion: function (name) {
if ( TRACE ) { TRACE( "Spine.Atlas#FindRegion", this ); }

                for (var i = 0, n = this.regions.Count; i < n; i = (i + 1) | 0) {
                    if (Bridge.referenceEquals(this.regions.getItem(i).name, name)) {
                        return this.regions.getItem(i);
                    }
                }
                return null;
            },
            /*Spine.Atlas.FindRegion end.*/

            /*Spine.Atlas.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Atlas#Dispose", this ); }

                if (this.textureLoader == null) {
                    return;
                }
                for (var i = 0, n = this.pages.Count; i < n; i = (i + 1) | 0) {
                    this.textureLoader.Spine$TextureLoader$Unload(this.pages.getItem(i).rendererObject);
                }
            },
            /*Spine.Atlas.Dispose end.*/


        }
    });
    /*Spine.Atlas end.*/

    /*Spine.AtlasAttachmentLoader start.*/
    /**
     * An AttachmentLoader that configures attachments using texture regions from an Atlas.
     See <a href="http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data">Loading Skeleton Data</a> in the Spine Runtimes Guide.
     *
     * @public
     * @class Spine.AtlasAttachmentLoader
     * @implements  Spine.AttachmentLoader
     */
    Bridge.define("Spine.AtlasAttachmentLoader", {
        inherits: [Spine.AttachmentLoader],
        fields: {
            atlasArray: null
        },
        alias: [
            "NewRegionAttachment", "Spine$AttachmentLoader$NewRegionAttachment",
            "NewMeshAttachment", "Spine$AttachmentLoader$NewMeshAttachment",
            "NewBoundingBoxAttachment", "Spine$AttachmentLoader$NewBoundingBoxAttachment",
            "NewPathAttachment", "Spine$AttachmentLoader$NewPathAttachment",
            "NewPointAttachment", "Spine$AttachmentLoader$NewPointAttachment",
            "NewClippingAttachment", "Spine$AttachmentLoader$NewClippingAttachment"
        ],
        ctors: {
            ctor: function (atlasArray) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#ctor", this ); }

                if (atlasArray === void 0) { atlasArray = []; }

                this.$initialize();
                if (atlasArray == null) {
                    throw new System.ArgumentNullException.$ctor1("atlas array cannot be null.");
                }
                this.atlasArray = atlasArray;
            }
        },
        methods: {
            /*Spine.AtlasAttachmentLoader.NewRegionAttachment start.*/
            NewRegionAttachment: function (skin, name, path) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#NewRegionAttachment", this ); }

                var region = this.FindRegion(path);
                if (region == null) {
                    throw new System.ArgumentException.$ctor1(System.String.format("Region not found in atlas: {0} (region attachment: {1})", path, name));
                }
                var attachment = new Spine.RegionAttachment(name);
                attachment.RendererObject = region;
                attachment.SetUVs(region.u, region.v, region.u2, region.v2, region.rotate);
                attachment.regionOffsetX = region.offsetX;
                attachment.regionOffsetY = region.offsetY;
                attachment.regionWidth = region.width;
                attachment.regionHeight = region.height;
                attachment.regionOriginalWidth = region.originalWidth;
                attachment.regionOriginalHeight = region.originalHeight;
                return attachment;
            },
            /*Spine.AtlasAttachmentLoader.NewRegionAttachment end.*/

            /*Spine.AtlasAttachmentLoader.NewMeshAttachment start.*/
            NewMeshAttachment: function (skin, name, path) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#NewMeshAttachment", this ); }

                var region = this.FindRegion(path);
                if (region == null) {
                    throw new System.ArgumentException.$ctor1(System.String.format("Region not found in atlas: {0} (region attachment: {1})", path, name));
                }
                var attachment = new Spine.MeshAttachment(name);
                attachment.RendererObject = region;
                attachment.RegionU = region.u;
                attachment.RegionV = region.v;
                attachment.RegionU2 = region.u2;
                attachment.RegionV2 = region.v2;
                attachment.RegionRotate = region.rotate;
                attachment.RegionDegrees = region.degrees;
                attachment.regionOffsetX = region.offsetX;
                attachment.regionOffsetY = region.offsetY;
                attachment.regionWidth = region.width;
                attachment.regionHeight = region.height;
                attachment.regionOriginalWidth = region.originalWidth;
                attachment.regionOriginalHeight = region.originalHeight;
                return attachment;
            },
            /*Spine.AtlasAttachmentLoader.NewMeshAttachment end.*/

            /*Spine.AtlasAttachmentLoader.NewBoundingBoxAttachment start.*/
            NewBoundingBoxAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#NewBoundingBoxAttachment", this ); }

                return new Spine.BoundingBoxAttachment(name);
            },
            /*Spine.AtlasAttachmentLoader.NewBoundingBoxAttachment end.*/

            /*Spine.AtlasAttachmentLoader.NewPathAttachment start.*/
            NewPathAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#NewPathAttachment", this ); }

                return new Spine.PathAttachment(name);
            },
            /*Spine.AtlasAttachmentLoader.NewPathAttachment end.*/

            /*Spine.AtlasAttachmentLoader.NewPointAttachment start.*/
            NewPointAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#NewPointAttachment", this ); }

                return new Spine.PointAttachment(name);
            },
            /*Spine.AtlasAttachmentLoader.NewPointAttachment end.*/

            /*Spine.AtlasAttachmentLoader.NewClippingAttachment start.*/
            NewClippingAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#NewClippingAttachment", this ); }

                return new Spine.ClippingAttachment(name);
            },
            /*Spine.AtlasAttachmentLoader.NewClippingAttachment end.*/

            /*Spine.AtlasAttachmentLoader.FindRegion start.*/
            FindRegion: function (name) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#FindRegion", this ); }

                var region;

                for (var i = 0; i < this.atlasArray.length; i = (i + 1) | 0) {
                    region = this.atlasArray[i].FindRegion(name);
                    if (region != null) {
                        return region;
                    }
                }

                return null;
            },
            /*Spine.AtlasAttachmentLoader.FindRegion end.*/


        }
    });
    /*Spine.AtlasAttachmentLoader end.*/

    /*Spine.AttachmentTimeline start.*/
    /**
     * Changes a slot's {@link }.
     *
     * @public
     * @class Spine.AttachmentTimeline
     * @implements  Spine.Timeline
     * @implements  Spine.ISlotTimeline
     */
    Bridge.define("Spine.AttachmentTimeline", {
        inherits: [Spine.Timeline,Spine.ISlotTimeline],
        fields: {
            slotIndex: 0,
            frames: null,
            attachmentNames: null
        },
        props: {
            PropertyId: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#PropertyId#get", this ); }

                    return (((67108864) + this.slotIndex) | 0);
                }
            },
            /**
             * The number of key frames for this timeline.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.AttachmentTimeline
             * @function FrameCount
             * @type number
             */
            FrameCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#FrameCount#get", this ); }

                    return this.frames.length;
                }
            },
            
            SlotIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#SlotIndex#get", this ); }

                    return this.slotIndex;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#SlotIndex#set", this ); }

                    if (value < 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("index must be >= 0.");
                    }
                    this.slotIndex = value;
                }
            },
            /**
             * The time in seconds for each key frame.
             *
             * @instance
             * @public
             * @memberof Spine.AttachmentTimeline
             * @function Frames
             * @type Array.<number>
             */
            Frames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#Frames#get", this ); }

                    return this.frames;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#Frames#set", this ); }

                    this.frames = value;
                }
            },
            /**
             * The attachment name for each key frame. May contain null values to clear the attachment.
             *
             * @instance
             * @public
             * @memberof Spine.AttachmentTimeline
             * @function AttachmentNames
             * @type Array.<string>
             */
            AttachmentNames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#AttachmentNames#get", this ); }

                    return this.attachmentNames;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#AttachmentNames#set", this ); }

                    this.attachmentNames = value;
                }
            }
        },
        alias: [
            "PropertyId", "Spine$Timeline$PropertyId",
            "SlotIndex", "Spine$ISlotTimeline$SlotIndex",
            "Apply", "Spine$Timeline$Apply"
        ],
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#ctor", this ); }

                this.$initialize();
                this.frames = System.Array.init(frameCount, 0, System.Single);
                this.attachmentNames = System.Array.init(frameCount, null, System.String);
            }
        },
        methods: {
            /*Spine.AttachmentTimeline.SetFrame start.*/
            /**
             * Sets the time in seconds and the attachment name for the specified key frame.
             *
             * @instance
             * @public
             * @this Spine.AttachmentTimeline
             * @memberof Spine.AttachmentTimeline
             * @param   {number}    frameIndex        
             * @param   {number}    time              
             * @param   {string}    attachmentName
             * @return  {void}
             */
            SetFrame: function (frameIndex, time, attachmentName) {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#SetFrame", this ); }

                this.frames[frameIndex] = time;
                this.attachmentNames[frameIndex] = attachmentName;
            },
            /*Spine.AttachmentTimeline.SetFrame end.*/

            /*Spine.AttachmentTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#Apply", this ); }

                var $t;
                var slot = ($t = skeleton.slots.Items)[this.slotIndex];
                if (!slot.bone.active) {
                    return;
                }
                if (direction === Spine.MixDirection.Out) {
                    if (blend === Spine.MixBlend.Setup) {
                        this.SetAttachment(skeleton, slot, slot.data.attachmentName);
                    }
                    return;
                }

                var frames = this.frames;
                if (time < frames[0]) { // Time is before first frame.
                    if (blend === Spine.MixBlend.Setup || blend === Spine.MixBlend.First) {
                        this.SetAttachment(skeleton, slot, slot.data.attachmentName);
                    }
                    return;
                }

                var frameIndex;
                if (time >= frames[((frames.length - 1) | 0)]) {
                    frameIndex = (frames.length - 1) | 0;
                } else {
                    frameIndex = (Spine.Animation.BinarySearch(frames, time) - 1) | 0;
                }

                this.SetAttachment(skeleton, slot, this.attachmentNames[frameIndex]);
            },
            /*Spine.AttachmentTimeline.Apply end.*/

            /*Spine.AttachmentTimeline.SetAttachment start.*/
            SetAttachment: function (skeleton, slot, attachmentName) {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#SetAttachment", this ); }

                slot.Attachment = attachmentName == null ? null : skeleton.GetAttachment(this.slotIndex, attachmentName);
            },
            /*Spine.AttachmentTimeline.SetAttachment end.*/


        }
    });
    /*Spine.AttachmentTimeline end.*/

    /*Spine.Bone start.*/
    /**
     * Stores a bone's current pose.
     <p>A bone has a local transform which is used to compute its world transform. A bone also has an applied transform, which is a
     local transform that can be applied to compute the world transform. The local transform and applied transform may differ if a
     constraint or application code modifies the world transform after it was computed from the local transform.</p>
     *
     * @public
     * @class Spine.Bone
     * @implements  Spine.IUpdatable
     */
    Bridge.define("Spine.Bone", {
        inherits: [Spine.IUpdatable],
        statics: {
            fields: {
                yDown: false
            }
        },
        fields: {
            data: null,
            skeleton: null,
            parent: null,
            children: null,
            x: 0,
            y: 0,
            rotation: 0,
            scaleX: 0,
            scaleY: 0,
            shearX: 0,
            shearY: 0,
            ax: 0,
            ay: 0,
            arotation: 0,
            ascaleX: 0,
            ascaleY: 0,
            ashearX: 0,
            ashearY: 0,
            appliedValid: false,
            a: 0,
            b: 0,
            worldX: 0,
            c: 0,
            d: 0,
            worldY: 0,
            sorted: false,
            active: false
        },
        props: {
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#Data#get", this ); }

                    return this.data;
                }
            },
            Skeleton: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#Skeleton#get", this ); }

                    return this.skeleton;
                }
            },
            Parent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#Parent#get", this ); }

                    return this.parent;
                }
            },
            Children: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#Children#get", this ); }

                    return this.children;
                }
            },
            /**
             * Returns false when the bone has not been computed because {@link } is true and the
             {@link } does not {@link } this bone.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Bone
             * @function Active
             * @type boolean
             */
            Active: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#Active#get", this ); }

                    return this.active;
                }
            },
            /**
             * The local X translation.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function X
             * @type number
             */
            X: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#X#get", this ); }

                    return this.x;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#X#set", this ); }

                    this.x = value;
                }
            },
            /**
             * The local Y translation.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function Y
             * @type number
             */
            Y: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#Y#get", this ); }

                    return this.y;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#Y#set", this ); }

                    this.y = value;
                }
            },
            /**
             * The local rotation.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function Rotation
             * @type number
             */
            Rotation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#Rotation#get", this ); }

                    return this.rotation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#Rotation#set", this ); }

                    this.rotation = value;
                }
            },
            /**
             * The local scaleX.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function ScaleX
             * @type number
             */
            ScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#ScaleX#get", this ); }

                    return this.scaleX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#ScaleX#set", this ); }

                    this.scaleX = value;
                }
            },
            /**
             * The local scaleY.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function ScaleY
             * @type number
             */
            ScaleY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#ScaleY#get", this ); }

                    return this.scaleY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#ScaleY#set", this ); }

                    this.scaleY = value;
                }
            },
            /**
             * The local shearX.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function ShearX
             * @type number
             */
            ShearX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#ShearX#get", this ); }

                    return this.shearX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#ShearX#set", this ); }

                    this.shearX = value;
                }
            },
            /**
             * The local shearY.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function ShearY
             * @type number
             */
            ShearY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#ShearY#get", this ); }

                    return this.shearY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#ShearY#set", this ); }

                    this.shearY = value;
                }
            },
            /**
             * The rotation, as calculated by any constraints.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function AppliedRotation
             * @type number
             */
            AppliedRotation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#AppliedRotation#get", this ); }

                    return this.arotation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#AppliedRotation#set", this ); }

                    this.arotation = value;
                }
            },
            /**
             * The applied local x translation.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function AX
             * @type number
             */
            AX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#AX#get", this ); }

                    return this.ax;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#AX#set", this ); }

                    this.ax = value;
                }
            },
            /**
             * The applied local y translation.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function AY
             * @type number
             */
            AY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#AY#get", this ); }

                    return this.ay;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#AY#set", this ); }

                    this.ay = value;
                }
            },
            /**
             * The applied local scaleX.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function AScaleX
             * @type number
             */
            AScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#AScaleX#get", this ); }

                    return this.ascaleX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#AScaleX#set", this ); }

                    this.ascaleX = value;
                }
            },
            /**
             * The applied local scaleY.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function AScaleY
             * @type number
             */
            AScaleY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#AScaleY#get", this ); }

                    return this.ascaleY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#AScaleY#set", this ); }

                    this.ascaleY = value;
                }
            },
            /**
             * The applied local shearX.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function AShearX
             * @type number
             */
            AShearX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#AShearX#get", this ); }

                    return this.ashearX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#AShearX#set", this ); }

                    this.ashearX = value;
                }
            },
            /**
             * The applied local shearY.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function AShearY
             * @type number
             */
            AShearY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#AShearY#get", this ); }

                    return this.ashearY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#AShearY#set", this ); }

                    this.ashearY = value;
                }
            },
            A: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#A#get", this ); }

                    return this.a;
                }
            },
            B: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#B#get", this ); }

                    return this.b;
                }
            },
            C: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#C#get", this ); }

                    return this.c;
                }
            },
            D: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#D#get", this ); }

                    return this.d;
                }
            },
            WorldX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#WorldX#get", this ); }

                    return this.worldX;
                }
            },
            WorldY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#WorldY#get", this ); }

                    return this.worldY;
                }
            },
            WorldRotationX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#WorldRotationX#get", this ); }

                    return Spine.MathUtils.Atan2(this.c, this.a) * Spine.MathUtils.RadDeg;
                }
            },
            WorldRotationY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#WorldRotationY#get", this ); }

                    return Spine.MathUtils.Atan2(this.d, this.b) * Spine.MathUtils.RadDeg;
                }
            },
            /**
             * Returns the magnitide (always positive) of the world scale X.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Bone
             * @function WorldScaleX
             * @type number
             */
            WorldScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#WorldScaleX#get", this ); }

                    return Math.sqrt(this.a * this.a + this.c * this.c);
                }
            },
            /**
             * Returns the magnitide (always positive) of the world scale Y.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Bone
             * @function WorldScaleY
             * @type number
             */
            WorldScaleY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#WorldScaleY#get", this ); }

                    return Math.sqrt(this.b * this.b + this.d * this.d);
                }
            },
            WorldToLocalRotationX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#WorldToLocalRotationX#get", this ); }

                    var parent = this.parent;
                    if (parent == null) {
                        return this.arotation;
                    }
                    var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d, a = this.a, c = this.c;
                    return Spine.MathUtils.Atan2(pa * c - pc * a, pd * a - pb * c) * Spine.MathUtils.RadDeg;
                }
            },
            WorldToLocalRotationY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#WorldToLocalRotationY#get", this ); }

                    var parent = this.parent;
                    if (parent == null) {
                        return this.arotation;
                    }
                    var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d, b = this.b, d = this.d;
                    return Spine.MathUtils.Atan2(pa * d - pc * b, pd * b - pb * d) * Spine.MathUtils.RadDeg;
                }
            }
        },
        alias: [
            "Active", "Spine$IUpdatable$Active",
            "Update", "Spine$IUpdatable$Update"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Bone#init", this ); }

                this.children = new (Spine.ExposedList$1(Spine.Bone)).ctor();
            },
            /**
             * @instance
             * @public
             * @this Spine.Bone
             * @memberof Spine.Bone
             * @param   {Spine.BoneData}    data        
             * @param   {Spine.Skeleton}    skeleton    
             * @param   {Spine.Bone}        parent      May be null.
             * @return  {void}
             */
            ctor: function (data, skeleton, parent) {
if ( TRACE ) { TRACE( "Spine.Bone#ctor", this ); }

                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                }
                this.data = data;
                this.skeleton = skeleton;
                this.parent = parent;
                this.SetToSetupPose();
            }
        },
        methods: {
            /*Spine.Bone.Update start.*/
            /**
             * Same as {@link }. This method exists for Bone to implement {@link }.
             *
             * @instance
             * @public
             * @this Spine.Bone
             * @memberof Spine.Bone
             * @return  {void}
             */
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Bone#Update", this ); }

                this.UpdateWorldTransform$1(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
            },
            /*Spine.Bone.Update end.*/

            /*Spine.Bone.UpdateWorldTransform start.*/
            /**
             * Computes the world transform using the parent bone and this bone's local transform.
             *
             * @instance
             * @public
             * @this Spine.Bone
             * @memberof Spine.Bone
             * @return  {void}
             */
            UpdateWorldTransform: function () {
if ( TRACE ) { TRACE( "Spine.Bone#UpdateWorldTransform", this ); }

                this.UpdateWorldTransform$1(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
            },
            /*Spine.Bone.UpdateWorldTransform end.*/

            /*Spine.Bone.UpdateWorldTransform$1 start.*/
            /**
             * Computes the world transform using the parent bone and the specified local transform.
             *
             * @instance
             * @public
             * @this Spine.Bone
             * @memberof Spine.Bone
             * @param   {number}    x           
             * @param   {number}    y           
             * @param   {number}    rotation    
             * @param   {number}    scaleX      
             * @param   {number}    scaleY      
             * @param   {number}    shearX      
             * @param   {number}    shearY
             * @return  {void}
             */
            UpdateWorldTransform$1: function (x, y, rotation, scaleX, scaleY, shearX, shearY) {
if ( TRACE ) { TRACE( "Spine.Bone#UpdateWorldTransform$1", this ); }

                this.ax = x;
                this.ay = y;
                this.arotation = rotation;
                this.ascaleX = scaleX;
                this.ascaleY = scaleY;
                this.ashearX = shearX;
                this.ashearY = shearY;
                this.appliedValid = true;
                var skeleton = this.skeleton;

                var parent = this.parent;
                if (parent == null) { // Root bone.
                    var rotationY = rotation + 90 + shearY, sx = skeleton.ScaleX, sy = skeleton.ScaleY;
                    this.a = Spine.MathUtils.CosDeg(rotation + shearX) * scaleX * sx;
                    this.b = Spine.MathUtils.CosDeg(rotationY) * scaleY * sx;
                    this.c = Spine.MathUtils.SinDeg(rotation + shearX) * scaleX * sy;
                    this.d = Spine.MathUtils.SinDeg(rotationY) * scaleY * sy;
                    this.worldX = x * sx + skeleton.x;
                    this.worldY = y * sy + skeleton.y;
                    return;
                }

                var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;
                this.worldX = pa * x + pb * y + parent.worldX;
                this.worldY = pc * x + pd * y + parent.worldY;

                switch (this.data.transformMode) {
                    case Spine.TransformMode.Normal: 
                        {
                            var rotationY1 = rotation + 90 + shearY;
                            var la = Spine.MathUtils.CosDeg(rotation + shearX) * scaleX;
                            var lb = Spine.MathUtils.CosDeg(rotationY1) * scaleY;
                            var lc = Spine.MathUtils.SinDeg(rotation + shearX) * scaleX;
                            var ld = Spine.MathUtils.SinDeg(rotationY1) * scaleY;
                            this.a = pa * la + pb * lc;
                            this.b = pa * lb + pb * ld;
                            this.c = pc * la + pd * lc;
                            this.d = pc * lb + pd * ld;
                            return;
                        }
                    case Spine.TransformMode.OnlyTranslation: 
                        {
                            var rotationY2 = rotation + 90 + shearY;
                            this.a = Spine.MathUtils.CosDeg(rotation + shearX) * scaleX;
                            this.b = Spine.MathUtils.CosDeg(rotationY2) * scaleY;
                            this.c = Spine.MathUtils.SinDeg(rotation + shearX) * scaleX;
                            this.d = Spine.MathUtils.SinDeg(rotationY2) * scaleY;
                            break;
                        }
                    case Spine.TransformMode.NoRotationOrReflection: 
                        {
                            var s = pa * pa + pc * pc, prx;
                            if (s > 0.0001) {
                                s = Math.abs(pa * pd - pb * pc) / s;
                                pa /= skeleton.ScaleX;
                                pc /= skeleton.ScaleY;
                                pb = pc * s;
                                pd = pa * s;
                                prx = Spine.MathUtils.Atan2(pc, pa) * Spine.MathUtils.RadDeg;
                            } else {
                                pa = 0;
                                pc = 0;
                                prx = 90 - Spine.MathUtils.Atan2(pd, pb) * Spine.MathUtils.RadDeg;
                            }
                            var rx = rotation + shearX - prx;
                            var ry = rotation + shearY - prx + 90;
                            var la1 = Spine.MathUtils.CosDeg(rx) * scaleX;
                            var lb1 = Spine.MathUtils.CosDeg(ry) * scaleY;
                            var lc1 = Spine.MathUtils.SinDeg(rx) * scaleX;
                            var ld1 = Spine.MathUtils.SinDeg(ry) * scaleY;
                            this.a = pa * la1 - pb * lc1;
                            this.b = pa * lb1 - pb * ld1;
                            this.c = pc * la1 + pd * lc1;
                            this.d = pc * lb1 + pd * ld1;
                            break;
                        }
                    case Spine.TransformMode.NoScale: 
                    case Spine.TransformMode.NoScaleOrReflection: 
                        {
                            var cos = Spine.MathUtils.CosDeg(rotation), sin = Spine.MathUtils.SinDeg(rotation);
                            var za = (pa * cos + pb * sin) / skeleton.ScaleX;
                            var zc = (pc * cos + pd * sin) / skeleton.ScaleY;
                            var s1 = Math.sqrt(za * za + zc * zc);
                            if (s1 > 1E-05) {
                                s1 = 1 / s1;
                            }
                            za *= s1;
                            zc *= s1;
                            s1 = Math.sqrt(za * za + zc * zc);
                            if (this.data.transformMode === Spine.TransformMode.NoScale && (pa * pd - pb * pc < 0) !== (skeleton.ScaleX < 0 !== skeleton.ScaleY < 0)) {
                                s1 = -s1;
                            }

                            var r = 1.57079637 + Spine.MathUtils.Atan2(zc, za);
                            var zb = Spine.MathUtils.Cos(r) * s1;
                            var zd = Spine.MathUtils.Sin(r) * s1;
                            var la2 = Spine.MathUtils.CosDeg(shearX) * scaleX;
                            var lb2 = Spine.MathUtils.CosDeg(90 + shearY) * scaleY;
                            var lc2 = Spine.MathUtils.SinDeg(shearX) * scaleX;
                            var ld2 = Spine.MathUtils.SinDeg(90 + shearY) * scaleY;
                            this.a = za * la2 + zb * lc2;
                            this.b = za * lb2 + zb * ld2;
                            this.c = zc * la2 + zd * lc2;
                            this.d = zc * lb2 + zd * ld2;
                            break;
                        }
                }

                this.a *= skeleton.ScaleX;
                this.b *= skeleton.ScaleX;
                this.c *= skeleton.ScaleY;
                this.d *= skeleton.ScaleY;
            },
            /*Spine.Bone.UpdateWorldTransform$1 end.*/

            /*Spine.Bone.SetToSetupPose start.*/
            SetToSetupPose: function () {
if ( TRACE ) { TRACE( "Spine.Bone#SetToSetupPose", this ); }

                var data = this.data;
                this.x = data.x;
                this.y = data.y;
                this.rotation = data.rotation;
                this.scaleX = data.scaleX;
                this.scaleY = data.scaleY;
                this.shearX = data.shearX;
                this.shearY = data.shearY;
            },
            /*Spine.Bone.SetToSetupPose end.*/

            /*Spine.Bone.UpdateAppliedTransform start.*/
            /**
             * Computes the individual applied transform values from the world transform. This can be useful to perform processing using
             the applied transform after the world transform has been modified directly (eg, by a constraint)..
             Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation.
             *
             * @instance
             * @this Spine.Bone
             * @memberof Spine.Bone
             * @return  {void}
             */
            UpdateAppliedTransform: function () {
if ( TRACE ) { TRACE( "Spine.Bone#UpdateAppliedTransform", this ); }

                this.appliedValid = true;
                var parent = this.parent;
                if (parent == null) {
                    this.ax = this.worldX;
                    this.ay = this.worldY;
                    this.arotation = Spine.MathUtils.Atan2(this.c, this.a) * Spine.MathUtils.RadDeg;
                    this.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c);
                    this.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d);
                    this.ashearX = 0;
                    this.ashearY = Spine.MathUtils.Atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * Spine.MathUtils.RadDeg;
                    return;
                }
                var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;
                var pid = 1 / (pa * pd - pb * pc);
                var dx = this.worldX - parent.worldX, dy = this.worldY - parent.worldY;
                this.ax = (dx * pd * pid - dy * pb * pid);
                this.ay = (dy * pa * pid - dx * pc * pid);
                var ia = pid * pd;
                var id = pid * pa;
                var ib = pid * pb;
                var ic = pid * pc;
                var ra = ia * this.a - ib * this.c;
                var rb = ia * this.b - ib * this.d;
                var rc = id * this.c - ic * this.a;
                var rd = id * this.d - ic * this.b;
                this.ashearX = 0;
                this.ascaleX = Math.sqrt(ra * ra + rc * rc);
                if (this.ascaleX > 0.0001) {
                    var det = ra * rd - rb * rc;
                    this.ascaleY = det / this.ascaleX;
                    this.ashearY = Spine.MathUtils.Atan2(ra * rb + rc * rd, det) * Spine.MathUtils.RadDeg;
                    this.arotation = Spine.MathUtils.Atan2(rc, ra) * Spine.MathUtils.RadDeg;
                } else {
                    this.ascaleX = 0;
                    this.ascaleY = Math.sqrt(rb * rb + rd * rd);
                    this.ashearY = 0;
                    this.arotation = 90 - Spine.MathUtils.Atan2(rd, rb) * Spine.MathUtils.RadDeg;
                }
            },
            /*Spine.Bone.UpdateAppliedTransform end.*/

            /*Spine.Bone.WorldToLocal start.*/
            WorldToLocal: function (worldX, worldY, localX, localY) {
if ( TRACE ) { TRACE( "Spine.Bone#WorldToLocal", this ); }

                var a = this.a, b = this.b, c = this.c, d = this.d;
                var invDet = 1 / (a * d - b * c);
                var x = worldX - this.worldX, y = worldY - this.worldY;
                localX.v = (x * d * invDet - y * b * invDet);
                localY.v = (y * a * invDet - x * c * invDet);
            },
            /*Spine.Bone.WorldToLocal end.*/

            /*Spine.Bone.LocalToWorld start.*/
            LocalToWorld: function (localX, localY, worldX, worldY) {
if ( TRACE ) { TRACE( "Spine.Bone#LocalToWorld", this ); }

                worldX.v = localX * this.a + localY * this.b + this.worldX;
                worldY.v = localX * this.c + localY * this.d + this.worldY;
            },
            /*Spine.Bone.LocalToWorld end.*/

            /*Spine.Bone.WorldToLocalRotation start.*/
            WorldToLocalRotation: function (worldRotation) {
if ( TRACE ) { TRACE( "Spine.Bone#WorldToLocalRotation", this ); }

                var sin = Spine.MathUtils.SinDeg(worldRotation), cos = Spine.MathUtils.CosDeg(worldRotation);
                return Spine.MathUtils.Atan2(this.a * sin - this.c * cos, this.d * cos - this.b * sin) * Spine.MathUtils.RadDeg + this.rotation - this.shearX;
            },
            /*Spine.Bone.WorldToLocalRotation end.*/

            /*Spine.Bone.LocalToWorldRotation start.*/
            LocalToWorldRotation: function (localRotation) {
if ( TRACE ) { TRACE( "Spine.Bone#LocalToWorldRotation", this ); }

                localRotation -= this.rotation - this.shearX;
                var sin = Spine.MathUtils.SinDeg(localRotation), cos = Spine.MathUtils.CosDeg(localRotation);
                return Spine.MathUtils.Atan2(cos * this.c + sin * this.d, cos * this.a + sin * this.b) * Spine.MathUtils.RadDeg;
            },
            /*Spine.Bone.LocalToWorldRotation end.*/

            /*Spine.Bone.RotateWorld start.*/
            /**
             * Rotates the world transform the specified amount and sets isAppliedValid to false.
             *
             * @instance
             * @public
             * @this Spine.Bone
             * @memberof Spine.Bone
             * @param   {number}    degrees    Degrees.
             * @return  {void}
             */
            RotateWorld: function (degrees) {
if ( TRACE ) { TRACE( "Spine.Bone#RotateWorld", this ); }

                var a = this.a, b = this.b, c = this.c, d = this.d;
                var cos = Spine.MathUtils.CosDeg(degrees), sin = Spine.MathUtils.SinDeg(degrees);
                this.a = cos * a - sin * c;
                this.b = cos * b - sin * d;
                this.c = sin * a + cos * c;
                this.d = sin * b + cos * d;
                this.appliedValid = false;
            },
            /*Spine.Bone.RotateWorld end.*/

            /*Spine.Bone.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Bone#toString", this ); }

                return this.data.name;
            },
            /*Spine.Bone.toString end.*/


        },
        overloads: {
            "UpdateWorldTransform(float, float, float, float, float, float, float)": "UpdateWorldTransform$1",
            "ToString()": "toString"
        }
    });
    /*Spine.Bone end.*/

    /*Spine.VertexAttachment start.*/
    /**
     * &gt;An attachment with vertices that are transformed by one or more bones and can be deformed by a slot's
     {@link }.
     *
     * @abstract
     * @public
     * @class Spine.VertexAttachment
     * @augments Spine.Attachment
     */
    Bridge.define("Spine.VertexAttachment", {
        inherits: [Spine.Attachment],
        statics: {
            fields: {
                nextID: 0,
                nextIdLock: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#init", this ); }

                    this.nextID = 0;
                    this.nextIdLock = { };
                }
            }
        },
        fields: {
            id: 0,
            bones: null,
            vertices: null,
            worldVerticesLength: 0,
            deformAttachment: null
        },
        props: {
            /**
             * Gets a unique ID for this attachment.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.VertexAttachment
             * @function Id
             * @type number
             */
            Id: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#Id#get", this ); }

                    return this.id;
                }
            },
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#Bones#get", this ); }

                    return this.bones;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#Bones#set", this ); }

                    this.bones = value;
                }
            },
            Vertices: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#Vertices#get", this ); }

                    return this.vertices;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#Vertices#set", this ); }

                    this.vertices = value;
                }
            },
            WorldVerticesLength: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#WorldVerticesLength#get", this ); }

                    return this.worldVerticesLength;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#WorldVerticesLength#set", this ); }

                    this.worldVerticesLength = value;
                }
            },
            /**
             * Deform keys for the deform attachment are also applied to this attachment.
             May be null if no deform keys should be applied.
             *
             * @instance
             * @public
             * @memberof Spine.VertexAttachment
             * @function DeformAttachment
             * @type Spine.VertexAttachment
             */
            DeformAttachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#DeformAttachment#get", this ); }

                    return this.deformAttachment;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#DeformAttachment#set", this ); }

                    this.deformAttachment = value;
                }
            }
        },
        ctors: {
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#ctor", this ); }

                var $t;
                this.$initialize();
                Spine.Attachment.ctor.call(this, name);

                this.deformAttachment = this;
                Spine.VertexAttachment.nextIdLock;
                {
                    this.id = (Bridge.identity(Spine.VertexAttachment.nextID, (($t = (Spine.VertexAttachment.nextID + 1) | 0, Spine.VertexAttachment.nextID = $t, $t))) & 65535) << 11;
                }
            }
        },
        methods: {
            /*Spine.VertexAttachment.ComputeWorldVertices$1 start.*/
            ComputeWorldVertices$1: function (slot, worldVertices) {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#ComputeWorldVertices$1", this ); }

                this.ComputeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0);
            },
            /*Spine.VertexAttachment.ComputeWorldVertices$1 end.*/

            /*Spine.VertexAttachment.ComputeWorldVertices start.*/
            /**
             * Transforms the attachment's local {@link } to world coordinates. If the slot's {@link } is
             not empty, it is used to deform the vertices.
             <p />
             See <a href="http://esotericsoftware.com/spine-runtime-skeletons#World-transforms">World transforms</a> in the Spine
             Runtimes Guide.
             *
             * @instance
             * @public
             * @this Spine.VertexAttachment
             * @memberof Spine.VertexAttachment
             * @param   {Spine.Slot}        slot             
             * @param   {number}            start            The index of the first {@link } value to transform. Each vertex has 2 values, x and y.
             * @param   {number}            count            The number of world vertex values to output. Must be less than or equal to {@link } - start.
             * @param   {Array.<number>}    worldVertices    The output world vertices. Must have a length greater than or equal to <b>worldVertices</b> + <b>worldVertices</b>.
             * @param   {number}            offset           The <b>offset</b> index to begin writing values.
             * @param   {number}            stride           The number of <b>stride</b> entries between the value pairs written.
             * @return  {void}
             */
            ComputeWorldVertices: function (slot, start, count, worldVertices, offset, stride) {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#ComputeWorldVertices", this ); }

                if (stride === void 0) { stride = 2; }
                count = (offset + Bridge.Int.mul((count >> 1), stride)) | 0;
                var skeleton = slot.bone.skeleton;
                var deformArray = slot.deform;
                var vertices = this.vertices;
                var bones = this.bones;
                if (bones == null) {
                    if (deformArray.Count > 0) {
                        vertices = deformArray.Items;
                    }
                    var bone = slot.bone;
                    var x = bone.worldX, y = bone.worldY;
                    var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
                    for (var vv = start, w = offset; w < count; vv = (vv + 2) | 0, w = (w + stride) | 0) {
                        var vx = vertices[vv], vy = vertices[((vv + 1) | 0)];
                        worldVertices[w] = vx * a + vy * b + x;
                        worldVertices[((w + 1) | 0)] = vx * c + vy * d + y;
                    }
                    return;
                }
                var v = 0, skip = 0;
                for (var i = 0; i < start; i = (i + 2) | 0) {
                    var n = bones[v];
                    v = (v + (((n + 1) | 0))) | 0;
                    skip = (skip + n) | 0;
                }
                var skeletonBones = skeleton.bones.Items;
                if (deformArray.Count === 0) {
                    for (var w1 = offset, b1 = Bridge.Int.mul(skip, 3); w1 < count; w1 = (w1 + stride) | 0) {
                        var wx = 0, wy = 0;
                        var n1 = bones[Bridge.identity(v, ((v = (v + 1) | 0)))];
                        n1 = (n1 + v) | 0;
                        for (; v < n1; v = (v + 1) | 0, b1 = (b1 + 3) | 0) {
                            var bone1 = skeletonBones[bones[v]];
                            var vx1 = vertices[b1], vy1 = vertices[((b1 + 1) | 0)], weight = vertices[((b1 + 2) | 0)];
                            wx += (vx1 * bone1.a + vy1 * bone1.b + bone1.worldX) * weight;
                            wy += (vx1 * bone1.c + vy1 * bone1.d + bone1.worldY) * weight;
                        }
                        worldVertices[w1] = wx;
                        worldVertices[((w1 + 1) | 0)] = wy;
                    }
                } else {
                    var deform = deformArray.Items;
                    for (var w2 = offset, b2 = Bridge.Int.mul(skip, 3), f = skip << 1; w2 < count; w2 = (w2 + stride) | 0) {
                        var wx1 = 0, wy1 = 0;
                        var n2 = bones[Bridge.identity(v, ((v = (v + 1) | 0)))];
                        n2 = (n2 + v) | 0;
                        for (; v < n2; v = (v + 1) | 0, b2 = (b2 + 3) | 0, f = (f + 2) | 0) {
                            var bone2 = skeletonBones[bones[v]];
                            var vx2 = vertices[b2] + deform[f], vy2 = vertices[((b2 + 1) | 0)] + deform[((f + 1) | 0)], weight1 = vertices[((b2 + 2) | 0)];
                            wx1 += (vx2 * bone2.a + vy2 * bone2.b + bone2.worldX) * weight1;
                            wy1 += (vx2 * bone2.c + vy2 * bone2.d + bone2.worldY) * weight1;
                        }
                        worldVertices[w2] = wx1;
                        worldVertices[((w2 + 1) | 0)] = wy1;
                    }
                }
            },
            /*Spine.VertexAttachment.ComputeWorldVertices end.*/

            /*Spine.VertexAttachment.CopyTo start.*/
            /**
             * Does not copy id (generated) or name (set on construction).
             *
             * @instance
             * @this Spine.VertexAttachment
             * @memberof Spine.VertexAttachment
             * @param   {Spine.VertexAttachment}    attachment
             * @return  {void}
             */
            CopyTo: function (attachment) {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#CopyTo", this ); }

                if (this.bones != null) {
                    attachment.bones = System.Array.init(this.bones.length, 0, System.Int32);
                    System.Array.copy(this.bones, 0, attachment.bones, 0, this.bones.length);
                } else {
                    attachment.bones = null;
                }

                if (this.vertices != null) {
                    attachment.vertices = System.Array.init(this.vertices.length, 0, System.Single);
                    System.Array.copy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);
                } else {
                    attachment.vertices = null;
                }

                attachment.worldVerticesLength = this.worldVerticesLength;
                attachment.deformAttachment = this.deformAttachment;
            },
            /*Spine.VertexAttachment.CopyTo end.*/


        },
        overloads: {
            "ComputeWorldVertices(Slot, float[])": "ComputeWorldVertices$1"
        }
    });
    /*Spine.VertexAttachment end.*/

    /*Spine.CurveTimeline start.*/
    /**
     * The base class for timelines that use interpolation between key frame values.
     *
     * @abstract
     * @public
     * @class Spine.CurveTimeline
     * @implements  Spine.Timeline
     */
    Bridge.define("Spine.CurveTimeline", {
        inherits: [Spine.Timeline],
        statics: {
            fields: {
                LINEAR: 0,
                STEPPED: 0,
                BEZIER: 0,
                BEZIER_SIZE: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.CurveTimeline#init", this ); }

                    this.LINEAR = 0;
                    this.STEPPED = 1;
                    this.BEZIER = 2;
                    this.BEZIER_SIZE = 19;
                }
            }
        },
        fields: {
            curves: null
        },
        props: {
            /**
             * The number of key frames for this timeline.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.CurveTimeline
             * @function FrameCount
             * @type number
             */
            FrameCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.CurveTimeline#FrameCount#get", this ); }

                    return ((((Bridge.Int.div(this.curves.length, Spine.CurveTimeline.BEZIER_SIZE)) | 0) + 1) | 0);
                }
            }
        },
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline#ctor", this ); }

                this.$initialize();
                if (frameCount <= 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("frameCount must be > 0: ");
                }
                this.curves = System.Array.init(Bridge.Int.mul((((frameCount - 1) | 0)), Spine.CurveTimeline.BEZIER_SIZE), 0, System.Single);
            }
        },
        methods: {
            /*Spine.CurveTimeline.SetLinear start.*/
            /**
             * Sets the specified key frame to linear interpolation.
             *
             * @instance
             * @public
             * @this Spine.CurveTimeline
             * @memberof Spine.CurveTimeline
             * @param   {number}    frameIndex
             * @return  {void}
             */
            SetLinear: function (frameIndex) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline#SetLinear", this ); }

                this.curves[Bridge.Int.mul(frameIndex, Spine.CurveTimeline.BEZIER_SIZE)] = Spine.CurveTimeline.LINEAR;
            },
            /*Spine.CurveTimeline.SetLinear end.*/

            /*Spine.CurveTimeline.SetStepped start.*/
            /**
             * Sets the specified key frame to stepped interpolation.
             *
             * @instance
             * @public
             * @this Spine.CurveTimeline
             * @memberof Spine.CurveTimeline
             * @param   {number}    frameIndex
             * @return  {void}
             */
            SetStepped: function (frameIndex) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline#SetStepped", this ); }

                this.curves[Bridge.Int.mul(frameIndex, Spine.CurveTimeline.BEZIER_SIZE)] = Spine.CurveTimeline.STEPPED;
            },
            /*Spine.CurveTimeline.SetStepped end.*/

            /*Spine.CurveTimeline.GetCurveType start.*/
            /**
             * Returns the interpolation type for the specified key frame.
             *
             * @instance
             * @public
             * @this Spine.CurveTimeline
             * @memberof Spine.CurveTimeline
             * @param   {number}    frameIndex
             * @return  {number}                  Linear is 0, stepped is 1, Bezier is 2.
             */
            GetCurveType: function (frameIndex) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline#GetCurveType", this ); }

                var index = Bridge.Int.mul(frameIndex, Spine.CurveTimeline.BEZIER_SIZE);
                if (index === this.curves.length) {
                    return Spine.CurveTimeline.LINEAR;
                }
                var type = this.curves[index];
                if (type === Spine.CurveTimeline.LINEAR) {
                    return Spine.CurveTimeline.LINEAR;
                }
                if (type === Spine.CurveTimeline.STEPPED) {
                    return Spine.CurveTimeline.STEPPED;
                }
                return Spine.CurveTimeline.BEZIER;
            },
            /*Spine.CurveTimeline.GetCurveType end.*/

            /*Spine.CurveTimeline.SetCurve start.*/
            /**
             * Sets the specified key frame to Bezier interpolation. <pre><code>cx1</code></pre> and <pre><code>cx2</code></pre> are from 0 to 1,
             representing the percent of time between the two key frames. <pre><code>cy1</code></pre> and <pre><code>cy2</code></pre> are the percent of the
             difference between the key frame's values.
             *
             * @instance
             * @public
             * @this Spine.CurveTimeline
             * @memberof Spine.CurveTimeline
             * @param   {number}    frameIndex    
             * @param   {number}    cx1           
             * @param   {number}    cy1           
             * @param   {number}    cx2           
             * @param   {number}    cy2
             * @return  {void}
             */
            SetCurve: function (frameIndex, cx1, cy1, cx2, cy2) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline#SetCurve", this ); }

                var tmpx = (-cx1 * 2 + cx2) * 0.03, tmpy = (-cy1 * 2 + cy2) * 0.03;
                var dddfx = ((cx1 - cx2) * 3 + 1) * 0.006, dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;
                var ddfx = tmpx * 2 + dddfx, ddfy = tmpy * 2 + dddfy;
                var dfx = cx1 * 0.3 + tmpx + dddfx * 0.166666672, dfy = cy1 * 0.3 + tmpy + dddfy * 0.166666672;

                var i = Bridge.Int.mul(frameIndex, Spine.CurveTimeline.BEZIER_SIZE);
                var curves = this.curves;
                curves[Bridge.identity(i, ((i = (i + 1) | 0)))] = Spine.CurveTimeline.BEZIER;

                var x = dfx, y = dfy;
                for (var n = (((i + Spine.CurveTimeline.BEZIER_SIZE) | 0) - 1) | 0; i < n; i = (i + 2) | 0) {
                    curves[i] = x;
                    curves[((i + 1) | 0)] = y;
                    dfx += ddfx;
                    dfy += ddfy;
                    ddfx += dddfx;
                    ddfy += dddfy;
                    x += dfx;
                    y += dfy;
                }
            },
            /*Spine.CurveTimeline.SetCurve end.*/

            /*Spine.CurveTimeline.GetCurvePercent start.*/
            /**
             * Returns the interpolated percentage for the specified key frame and linear percentage.
             *
             * @instance
             * @public
             * @this Spine.CurveTimeline
             * @memberof Spine.CurveTimeline
             * @param   {number}    frameIndex    
             * @param   {number}    percent
             * @return  {number}
             */
            GetCurvePercent: function (frameIndex, percent) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline#GetCurvePercent", this ); }

                percent = Spine.MathUtils.Clamp(percent, 0, 1);
                var curves = this.curves;
                var i = Bridge.Int.mul(frameIndex, Spine.CurveTimeline.BEZIER_SIZE);
                var type = curves[i];
                if (type === Spine.CurveTimeline.LINEAR) {
                    return percent;
                }
                if (type === Spine.CurveTimeline.STEPPED) {
                    return 0;
                }
                i = (i + 1) | 0;
                var x = 0;
                for (var start = i, n = (((i + Spine.CurveTimeline.BEZIER_SIZE) | 0) - 1) | 0; i < n; i = (i + 2) | 0) {
                    x = curves[i];
                    if (x >= percent) {
                        if (i === start) {
                            return curves[((i + 1) | 0)] * percent / x;
                        } // First point is 0,0.
                        var prevX = curves[((i - 2) | 0)], prevY = curves[((i - 1) | 0)];
                        return prevY + (curves[((i + 1) | 0)] - prevY) * (percent - prevX) / (x - prevX);
                    }
                }
                var y = curves[((i - 1) | 0)];
                return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.
            },
            /*Spine.CurveTimeline.GetCurvePercent end.*/


        }
    });
    /*Spine.CurveTimeline end.*/

    /*Spine.DrawOrderTimeline start.*/
    /**
     * Changes a skeleton's {@link }.
     *
     * @public
     * @class Spine.DrawOrderTimeline
     * @implements  Spine.Timeline
     */
    Bridge.define("Spine.DrawOrderTimeline", {
        inherits: [Spine.Timeline],
        fields: {
            frames: null,
            drawOrders: null
        },
        props: {
            PropertyId: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.DrawOrderTimeline#PropertyId#get", this ); }

                    return (134217728);
                }
            },
            /**
             * The number of key frames for this timeline.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.DrawOrderTimeline
             * @function FrameCount
             * @type number
             */
            FrameCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.DrawOrderTimeline#FrameCount#get", this ); }

                    return this.frames.length;
                }
            },
            /**
             * The time in seconds for each key frame.
             *
             * @instance
             * @public
             * @memberof Spine.DrawOrderTimeline
             * @function Frames
             * @type Array.<number>
             */
            Frames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.DrawOrderTimeline#Frames#get", this ); }

                    return this.frames;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.DrawOrderTimeline#Frames#set", this ); }

                    this.frames = value;
                }
            },
            /**
             * The draw order for each key frame.
             *
             * @instance
             * @public
             * @memberof Spine.DrawOrderTimeline
             * @function DrawOrders
             * @type Array.<Array.<number>>
             * @see {@link Timeline.setFrame(int, float, int[])}
             */
            DrawOrders: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.DrawOrderTimeline#DrawOrders#get", this ); }

                    return this.drawOrders;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.DrawOrderTimeline#DrawOrders#set", this ); }

                    this.drawOrders = value;
                }
            }
        },
        alias: [
            "PropertyId", "Spine$Timeline$PropertyId",
            "Apply", "Spine$Timeline$Apply"
        ],
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.DrawOrderTimeline#ctor", this ); }

                this.$initialize();
                this.frames = System.Array.init(frameCount, 0, System.Single);
                this.drawOrders = System.Array.init(frameCount, null, System.Array.type(System.Int32));
            }
        },
        methods: {
            /*Spine.DrawOrderTimeline.SetFrame start.*/
            /**
             * Sets the time in seconds and the draw order for the specified key frame.
             *
             * @instance
             * @public
             * @this Spine.DrawOrderTimeline
             * @memberof Spine.DrawOrderTimeline
             * @param   {number}            frameIndex    
             * @param   {number}            time          
             * @param   {Array.<number>}    drawOrder     For each slot in {@link } the index of the new draw order. May be null to use setup pose
                             draw order..
             * @return  {void}
             */
            SetFrame: function (frameIndex, time, drawOrder) {
if ( TRACE ) { TRACE( "Spine.DrawOrderTimeline#SetFrame", this ); }

                this.frames[frameIndex] = time;
                this.drawOrders[frameIndex] = drawOrder;
            },
            /*Spine.DrawOrderTimeline.SetFrame end.*/

            /*Spine.DrawOrderTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.DrawOrderTimeline#Apply", this ); }

                var drawOrder = skeleton.drawOrder;
                var slots = skeleton.slots;
                if (direction === Spine.MixDirection.Out) {
                    if (blend === Spine.MixBlend.Setup) {
                        System.Array.copy(slots.Items, 0, drawOrder.Items, 0, slots.Count);
                    }
                    return;
                }

                var frames = this.frames;
                if (time < frames[0]) { // Time is before first frame.
                    if (blend === Spine.MixBlend.Setup || blend === Spine.MixBlend.First) {
                        System.Array.copy(slots.Items, 0, drawOrder.Items, 0, slots.Count);
                    }
                    return;
                }

                var frame;
                if (time >= frames[((frames.length - 1) | 0)]) {
                    frame = (frames.length - 1) | 0;
                } else {
                    frame = (Spine.Animation.BinarySearch(frames, time) - 1) | 0;
                }

                var drawOrderToSetupIndex = this.drawOrders[frame];
                if (drawOrderToSetupIndex == null) {
                    System.Array.copy(slots.Items, 0, drawOrder.Items, 0, slots.Count);
                } else {
                    var drawOrderItems = drawOrder.Items;
                    var slotsItems = slots.Items;
                    for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i = (i + 1) | 0) {
                        drawOrderItems[i] = slotsItems[drawOrderToSetupIndex[i]];
                    }
                }
            },
            /*Spine.DrawOrderTimeline.Apply end.*/


        }
    });
    /*Spine.DrawOrderTimeline end.*/

    /*Spine.EventTimeline start.*/
    /**
     * Fires an {@link } when specific animation times are reached.
     *
     * @public
     * @class Spine.EventTimeline
     * @implements  Spine.Timeline
     */
    Bridge.define("Spine.EventTimeline", {
        inherits: [Spine.Timeline],
        fields: {
            frames: null,
            events: null
        },
        props: {
            PropertyId: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.EventTimeline#PropertyId#get", this ); }

                    return (117440512);
                }
            },
            /**
             * The number of key frames for this timeline.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.EventTimeline
             * @function FrameCount
             * @type number
             */
            FrameCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.EventTimeline#FrameCount#get", this ); }

                    return this.frames.length;
                }
            },
            /**
             * The time in seconds for each key frame.
             *
             * @instance
             * @public
             * @memberof Spine.EventTimeline
             * @function Frames
             * @type Array.<number>
             */
            Frames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.EventTimeline#Frames#get", this ); }

                    return this.frames;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.EventTimeline#Frames#set", this ); }

                    this.frames = value;
                }
            },
            /**
             * The event for each key frame.
             *
             * @instance
             * @public
             * @memberof Spine.EventTimeline
             * @function Events
             * @type Array.<Spine.Event>
             */
            Events: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.EventTimeline#Events#get", this ); }

                    return this.events;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.EventTimeline#Events#set", this ); }

                    this.events = value;
                }
            }
        },
        alias: [
            "PropertyId", "Spine$Timeline$PropertyId",
            "Apply", "Spine$Timeline$Apply"
        ],
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.EventTimeline#ctor", this ); }

                this.$initialize();
                this.frames = System.Array.init(frameCount, 0, System.Single);
                this.events = System.Array.init(frameCount, null, Spine.Event);
            }
        },
        methods: {
            /*Spine.EventTimeline.SetFrame start.*/
            /**
             * Sets the time in seconds and the event for the specified key frame.
             *
             * @instance
             * @public
             * @this Spine.EventTimeline
             * @memberof Spine.EventTimeline
             * @param   {number}         frameIndex    
             * @param   {Spine.Event}    e
             * @return  {void}
             */
            SetFrame: function (frameIndex, e) {
if ( TRACE ) { TRACE( "Spine.EventTimeline#SetFrame", this ); }

                this.frames[frameIndex] = e.Time;
                this.events[frameIndex] = e;
            },
            /*Spine.EventTimeline.SetFrame end.*/

            /*Spine.EventTimeline.Apply start.*/
            /**
             * Fires events for frames &gt; <pre><code>lastTime</code></pre> and &lt;= <pre><code>time</code></pre>.
             *
             * @instance
             * @public
             * @this Spine.EventTimeline
             * @memberof Spine.EventTimeline
             * @param   {Spine.Skeleton}         skeleton       
             * @param   {number}                 lastTime       
             * @param   {number}                 time           
             * @param   {Spine.ExposedList$1}    firedEvents    
             * @param   {number}                 alpha          
             * @param   {Spine.MixBlend}         blend          
             * @param   {Spine.MixDirection}     direction
             * @return  {void}
             */
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.EventTimeline#Apply", this ); }

                if (firedEvents == null) {
                    return;
                }
                var frames = this.frames;
                var frameCount = frames.length;

                if (lastTime > time) { // Fire events after last time for looped animations.
                    this.Apply(skeleton, lastTime, 2147483647, firedEvents, alpha, blend, direction);
                    lastTime = -1.0;
                } else if (lastTime >= frames[((frameCount - 1) | 0)]) {
                    return;
                }
                if (time < frames[0]) {
                    return;
                } // Time is before first frame.

                var frame;
                if (lastTime < frames[0]) {
                    frame = 0;
                } else {
                    frame = Spine.Animation.BinarySearch(frames, lastTime);
                    var frameTime = frames[frame];
                    while (frame > 0) { // Fire multiple events with the same frame.
                        if (frames[((frame - 1) | 0)] !== frameTime) {
                            break;
                        }
                        frame = (frame - 1) | 0;
                    }
                }
                for (; frame < frameCount && time >= frames[frame]; frame = (frame + 1) | 0) {
                    firedEvents.Add(this.events[frame]);
                }
            },
            /*Spine.EventTimeline.Apply end.*/


        }
    });
    /*Spine.EventTimeline end.*/

    /*Spine.IkConstraint start.*/
    /**
     * <p>Stores the current pose for an IK constraint. An IK constraint adjusts the rotation of 1 or 2 constrained bones so the tip of
     the last bone is as close to the target bone as possible.</p><p>See <a href="http://esotericsoftware.com/spine-ik-constraints">IK constraints</a> in the Spine User Guide.</p>
     *
     * @public
     * @class Spine.IkConstraint
     * @implements  Spine.IUpdatable
     */
    Bridge.define("Spine.IkConstraint", {
        inherits: [Spine.IUpdatable],
        statics: {
            methods: {
                /*Spine.IkConstraint.Apply$1:static start.*/
                /**
                 * Applies 1 bone IK. The target is specified in the world coordinate system.
                 *
                 * @static
                 * @public
                 * @this Spine.IkConstraint
                 * @memberof Spine.IkConstraint
                 * @param   {Spine.Bone}    bone        
                 * @param   {number}        targetX     
                 * @param   {number}        targetY     
                 * @param   {boolean}       compress    
                 * @param   {boolean}       stretch     
                 * @param   {boolean}       uniform     
                 * @param   {number}        alpha
                 * @return  {void}
                 */
                Apply$1: function (bone, targetX, targetY, compress, stretch, uniform, alpha) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Apply$1", this ); }

                    var $step = 0,
                        $jumpFromFinally, 
                        p, 
                        pa, 
                        pb, 
                        pc, 
                        pd, 
                        rotationIK, 
                        tx, 
                        ty, 
                        $t, 
                        s, 
                        sa, 
                        sc, 
                        x, 
                        y, 
                        d, 
                        sx, 
                        sy, 
                        b, 
                        dd, 
                        s1, 
                        $asyncBody = Bridge.fn.bind(this, function () {
                            for (;;) {
                                $step = System.Array.min([0,1,2,3,4], $step);
                                switch ($step) {
                                    case 0: {
                                        if (!bone.appliedValid) {
                                            bone.UpdateAppliedTransform();
                                        }
                                        p = bone.parent;

                                        pa = p.a;
                                        pb = p.b;
                                        pc = p.c;
                                        pd = p.d;
                                        rotationIK = -bone.ashearX - bone.arotation;
                                        tx = 0;
                                        ty = 0;

                                        $t = bone.data.transformMode;
                                        if ($t === Spine.TransformMode.OnlyTranslation) {
                                            $step = 1;
                                            continue;
                                        }
                                        else if ($t === Spine.TransformMode.NoRotationOrReflection) {
                                            $step = 2;
                                            continue;
                                        }
                                        else  {
                                            $step = 3;
                                            continue;
                                        }
                                        $step = 4;
                                        continue;
                                    }
                                    case 1: {
                                        tx = targetX - bone.worldX;
                                        ty = targetY - bone.worldY;
                                        $step = 4;
                                        continue;
                                    }
                                    case 2: {
                                        s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);
                                        sa = pa / bone.skeleton.ScaleX;
                                        sc = pc / bone.skeleton.ScaleY;
                                        pb = -sc * s * bone.skeleton.ScaleX;
                                        pd = sa * s * bone.skeleton.ScaleY;
                                        rotationIK += Math.atan2(pc, pa) * Spine.MathUtils.RadDeg;
                                        $step = 3;
                                        continue;// Fall through.
                                    }
                                    case 3: {
                                        x = targetX - p.worldX;
                                        y = targetY - p.worldY;
                                        d = pa * pd - pb * pc;
                                        tx = (x * pd - y * pb) / d - bone.ax;
                                        ty = (y * pa - x * pc) / d - bone.ay;
                                        $step = 4;
                                        continue;
                                    }
                                    case 4: {
                                        rotationIK += Math.atan2(ty, tx) * Spine.MathUtils.RadDeg;
                                        if (bone.ascaleX < 0) {
                                            rotationIK += 180;
                                        }
                                        if (rotationIK > 180) {
                                            rotationIK -= 360;
                                        } else {
                                            if (rotationIK < -180) {
                                                rotationIK += 360;
                                            }
                                        }

                                        sx = bone.ascaleX;
                                        sy = bone.ascaleY;
                                        if (compress || stretch) {
                                            switch (bone.data.transformMode) {
                                                case Spine.TransformMode.NoScale: 
                                                    tx = targetX - bone.worldX;
                                                    ty = targetY - bone.worldY;
                                                    break;
                                                case Spine.TransformMode.NoScaleOrReflection: 
                                                    tx = targetX - bone.worldX;
                                                    ty = targetY - bone.worldY;
                                                    break;
                                            }
                                            b = bone.data.length * sx;
                                            dd = Math.sqrt(tx * tx + ty * ty);
                                            if ((compress && dd < b) || (stretch && dd > b) && b > 0.0001) {
                                                s1 = (dd / b - 1) * alpha + 1;
                                                sx *= s1;
                                                if (uniform) {
                                                    sy *= s1;
                                                }
                                            }
                                        }
                                        bone.UpdateWorldTransform$1(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);
                                        return;
                                    }
                                    default: {
                                        return;
                                    }
                                }
                            }
                        }, arguments);

                    return $asyncBody();
                },
                /*Spine.IkConstraint.Apply$1:static end.*/

                /*Spine.IkConstraint.Apply:static start.*/
                /**
                 * Applies 2 bone IK. The target is specified in the world coordinate system.
                 *
                 * @static
                 * @public
                 * @this Spine.IkConstraint
                 * @memberof Spine.IkConstraint
                 * @param   {Spine.Bone}    parent      
                 * @param   {Spine.Bone}    child       A direct descendant of the parent bone.
                 * @param   {number}        targetX     
                 * @param   {number}        targetY     
                 * @param   {number}        bendDir     
                 * @param   {boolean}       stretch     
                 * @param   {number}        softness    
                 * @param   {number}        alpha
                 * @return  {void}
                 */
                Apply: function (parent, child, targetX, targetY, bendDir, stretch, softness, alpha) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Apply", this ); }

                    var $step = 0,
                        $jumpFromFinally, 
                        px, 
                        py, 
                        psx, 
                        sx, 
                        psy, 
                        csx, 
                        os1, 
                        os2, 
                        s2, 
                        cx, 
                        cy, 
                        cwx, 
                        cwy, 
                        a, 
                        b, 
                        c, 
                        d, 
                        u, 
                        pp, 
                        id, 
                        x, 
                        y, 
                        dx, 
                        dy, 
                        l1, 
                        l2, 
                        a1, 
                        a2, 
                        tx, 
                        ty, 
                        dd, 
                        td, 
                        sd, 
                        p, 
                        cos, 
                        aa, 
                        bb, 
                        ta, 
                        c1, 
                        c2, 
                        q, 
                        r0, 
                        r1, 
                        r, 
                        minAngle, 
                        minX, 
                        minDist, 
                        minY, 
                        maxAngle, 
                        maxX, 
                        maxDist, 
                        maxY, 
                        os, 
                        rotation, 
                        $asyncBody = Bridge.fn.bind(this, function () {
                            for (;;) {
                                $step = System.Array.min([0,1,2,3,4,6,7,8], $step);
                                switch ($step) {
                                    case 0: {
                                        if (alpha === 0) {
                                            child.UpdateWorldTransform();
                                            return;
                                        }
                                        if (!parent.appliedValid) {
                                            parent.UpdateAppliedTransform();
                                        }
                                        if (!child.appliedValid) {
                                            child.UpdateAppliedTransform();
                                        }
                                        px = parent.ax;
                                        py = parent.ay;
                                        psx = parent.ascaleX;
                                        sx = psx;
                                        psy = parent.ascaleY;
                                        csx = child.ascaleX;
                                        if (psx < 0) {
                                            psx = -psx;
                                            os1 = 180;
                                            s2 = -1;
                                        } else {
                                            os1 = 0;
                                            s2 = 1;
                                        }
                                        if (psy < 0) {
                                            psy = -psy;
                                            s2 = (-s2) | 0;
                                        }
                                        if (csx < 0) {
                                            csx = -csx;
                                            os2 = 180;
                                        } else {
                                            os2 = 0;
                                        }
                                        cx = child.ax;
                                        a = parent.a;
                                        b = parent.b;
                                        c = parent.c;
                                        d = parent.d;
                                        u = Math.abs(psx - psy) <= 0.0001;
                                        if (!u) {
                                            cy = 0;
                                            cwx = a * cx + parent.worldX;
                                            cwy = c * cx + parent.worldY;
                                        } else {
                                            cy = child.ay;
                                            cwx = a * cx + b * cy + parent.worldX;
                                            cwy = c * cx + d * cy + parent.worldY;
                                        }
                                        pp = parent.parent;
                                        a = pp.a;
                                        b = pp.b;
                                        c = pp.c;
                                        d = pp.d;
                                        id = 1 / (a * d - b * c);
                                        x = cwx - pp.worldX;
                                        y = cwy - pp.worldY;
                                        dx = (x * d - y * b) * id - px;
                                        dy = (y * a - x * c) * id - py;
                                        l1 = Math.sqrt(dx * dx + dy * dy);
                                        l2 = child.data.length * csx;
                                        if (l1 < 0.0001) {
                                            Spine.IkConstraint.Apply$1(parent, targetX, targetY, false, stretch, false, alpha);
                                            child.UpdateWorldTransform$1(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
                                            return;
                                        }
                                        x = targetX - pp.worldX;
                                        y = targetY - pp.worldY;
                                        tx = (x * d - y * b) * id - px;
                                        ty = (y * a - x * c) * id - py;
                                        dd = tx * tx + ty * ty;
                                        if (softness !== 0) {
                                            softness *= psx * (csx + 1) / 2;
                                            td = Math.sqrt(dd);
                                            sd = td - l1 - l2 * psx + softness;
                                            if (sd > 0) {
                                                p = Math.min(1, sd / (softness * 2)) - 1;
                                                p = (sd - softness * (1 - p * p)) / td;
                                                tx -= p * tx;
                                                ty -= p * ty;
                                                dd = tx * tx + ty * ty;
                                            }
                                        }
                                        if (u) {
                                            $step = 1;
                                            continue;
                                        } else  {
                                            $step = 2;
                                            continue;
                                        }
                                    }
                                    case 1: {
                                        l2 *= psx;
                                        cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);
                                        if (cos < -1) {
                                            cos = -1;
                                        } else {
                                            if (cos > 1) {
                                                cos = 1;
                                                if (stretch) {
                                                    sx *= (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;
                                                }
                                            }
                                        }
                                        a2 = Math.acos(cos) * bendDir;
                                        a = l1 + l2 * cos;
                                        b = l2 * Math.sin(a2);
                                        a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);
                                        $step = 7;
                                        continue;
                                    }
                                    case 2: {
                                        a = psx * l2;
                                        b = psy * l2;
                                        aa = a * a;
                                        bb = b * b;
                                        ta = Math.atan2(ty, tx);
                                        c = bb * l1 * l1 + aa * dd - aa * bb;
                                        c1 = -2 * bb * l1;
                                        c2 = bb - aa;
                                        d = c1 * c1 - 4 * c2 * c;
                                        if (d >= 0) {
                                            $step = 3;
                                            continue;
                                        } 
                                        $step = 6;
                                        continue;
                                    }
                                    case 3: {
                                        q = Math.sqrt(d);
                                        if (c1 < 0) {
                                            q = -q;
                                        }
                                        q = -(c1 + q) / 2;
                                        r0 = q / c2;
                                        r1 = c / q;
                                        r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
                                        if (r * r <= dd) {
                                            $step = 4;
                                            continue;
                                        } 
                                        $step = 5;
                                        continue;
                                    }
                                    case 4: {
                                        y = Math.sqrt(dd - r * r) * bendDir;
                                        a1 = ta - Math.atan2(y, r);
                                        a2 = Math.atan2(y / psy, (r - l1) / psx);
                                        $step = 8;
                                        continue;// break outer;
                                        $step = 5;
                                        continue;
                                    }

                                    case 6: {
                                        minAngle = Spine.MathUtils.PI;
                                        minX = l1 - a;
                                        minDist = minX * minX;
                                        minY = 0;
                                        maxAngle = 0;
                                        maxX = l1 + a;
                                        maxDist = maxX * maxX;
                                        maxY = 0;
                                        c = -a * l1 / (aa - bb);
                                        if (c >= -1 && c <= 1) {
                                            c = Math.acos(c);
                                            x = a * Math.cos(c) + l1;
                                            y = b * Math.sin(c);
                                            d = x * x + y * y;
                                            if (d < minDist) {
                                                minAngle = c;
                                                minDist = d;
                                                minX = x;
                                                minY = y;
                                            }
                                            if (d > maxDist) {
                                                maxAngle = c;
                                                maxDist = d;
                                                maxX = x;
                                                maxY = y;
                                            }
                                        }
                                        if (dd <= (minDist + maxDist) / 2) {
                                            a1 = ta - Math.atan2(minY * bendDir, minX);
                                            a2 = minAngle * bendDir;
                                        } else {
                                            a1 = ta - Math.atan2(maxY * bendDir, maxX);
                                            a2 = maxAngle * bendDir;
                                        }
                                        $step = 7;
                                        continue;
                                    }
                                    case 7: {

                                    }
                                    case 8: {
                                        os = Math.atan2(cy, cx) * s2;
                                        rotation = parent.arotation;
                                        a1 = (a1 - os) * Spine.MathUtils.RadDeg + os1 - rotation;
                                        if (a1 > 180) {
                                            a1 -= 360;
                                        } else {
                                            if (a1 < -180) {
                                                a1 += 360;
                                            }
                                        }
                                        parent.UpdateWorldTransform$1(px, py, rotation + a1 * alpha, sx, parent.ascaleY, 0, 0);
                                        rotation = child.arotation;
                                        a2 = ((a2 + os) * Spine.MathUtils.RadDeg - child.ashearX) * s2 + os2 - rotation;
                                        if (a2 > 180) {
                                            a2 -= 360;
                                        } else {
                                            if (a2 < -180) {
                                                a2 += 360;
                                            }
                                        }
                                        child.UpdateWorldTransform$1(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
                                        return;
                                    }
                                    default: {
                                        return;
                                    }
                                }
                            }
                        }, arguments);

                    return $asyncBody();
                },
                /*Spine.IkConstraint.Apply:static end.*/


            }
        },
        fields: {
            data: null,
            bones: null,
            target: null,
            bendDirection: 0,
            compress: false,
            stretch: false,
            mix: 0,
            softness: 0,
            active: false
        },
        props: {
            /**
             * The bones that will be modified by this IK constraint.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.IkConstraint
             * @function Bones
             * @type Spine.ExposedList$1
             */
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Bones#get", this ); }

                    return this.bones;
                }
            },
            /**
             * The bone that is the IK target.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraint
             * @function Target
             * @type Spine.Bone
             */
            Target: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Target#get", this ); }

                    return this.target;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Target#set", this ); }

                    this.target = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained rotations.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraint
             * @function Mix
             * @type number
             */
            Mix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Mix#get", this ); }

                    return this.mix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Mix#set", this ); }

                    this.mix = value;
                }
            },
            /**
             * For two bone IK, the distance from the maximum reach of the bones that rotation will slow.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraint
             * @function Softness
             * @type number
             */
            Softness: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Softness#get", this ); }

                    return this.softness;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Softness#set", this ); }

                    this.softness = value;
                }
            },
            /**
             * Controls the bend direction of the IK bones, either 1 or -1.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraint
             * @function BendDirection
             * @type number
             */
            BendDirection: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#BendDirection#get", this ); }

                    return this.bendDirection;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#BendDirection#set", this ); }

                    this.bendDirection = value;
                }
            },
            /**
             * When true and only a single bone is being constrained, if the target is too close, the bone is scaled to reach it.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraint
             * @function Compress
             * @type boolean
             */
            Compress: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Compress#get", this ); }

                    return this.compress;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Compress#set", this ); }

                    this.compress = value;
                }
            },
            /**
             * When true, if the target is out of range, the parent bone is scaled to reach it. If more than one bone is being constrained
              and the parent bone has local nonuniform scale, stretch is not applied.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraint
             * @function Stretch
             * @type boolean
             */
            Stretch: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Stretch#get", this ); }

                    return this.stretch;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Stretch#set", this ); }

                    this.stretch = value;
                }
            },
            Active: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Active#get", this ); }

                    return this.active;
                }
            },
            /**
             * The IK constraint's setup pose data.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.IkConstraint
             * @function Data
             * @type Spine.IkConstraintData
             */
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Data#get", this ); }

                    return this.data;
                }
            }
        },
        alias: [
            "Update", "Spine$IUpdatable$Update",
            "Active", "Spine$IUpdatable$Active"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#init", this ); }

                this.bones = new (Spine.ExposedList$1(Spine.Bone)).ctor();
                this.mix = 1;
            },
            $ctor1: function (data, skeleton) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#$ctor1", this ); }

                var $t;
                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                }
                this.data = data;
                this.mix = data.mix;
                this.softness = data.softness;
                this.bendDirection = data.bendDirection;
                this.compress = data.compress;
                this.stretch = data.stretch;

                this.bones = new (Spine.ExposedList$1(Spine.Bone)).$ctor3(data.bones.Count);
                $t = Bridge.getEnumerator(data.bones);
                try {
                    while ($t.moveNext()) {
                        var boneData = $t.Current;
                        this.bones.Add(skeleton.FindBone(boneData.name));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.target = skeleton.FindBone(data.target.name);
            },
            /**
             * Copy constructor.
             *
             * @instance
             * @public
             * @this Spine.IkConstraint
             * @memberof Spine.IkConstraint
             * @param   {Spine.IkConstraint}    constraint    
             * @param   {Spine.Skeleton}        skeleton
             * @return  {void}
             */
            ctor: function (constraint, skeleton) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#ctor", this ); }

                var $t, $t1, $t2;
                this.$initialize();
                if (constraint == null) {
                    throw new System.ArgumentNullException.$ctor1("constraint cannot be null.");
                }
                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor1("skeleton cannot be null.");
                }
                this.data = constraint.data;
                this.bones = new (Spine.ExposedList$1(Spine.Bone)).$ctor3(constraint.Bones.Count);
                $t = Bridge.getEnumerator(constraint.Bones);
                try {
                    while ($t.moveNext()) {
                        var bone = $t.Current;
                        this.bones.Add(($t1 = skeleton.Bones.Items)[bone.data.index]);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.target = ($t2 = skeleton.Bones.Items)[constraint.target.data.index];
                this.mix = constraint.mix;
                this.softness = constraint.softness;
                this.bendDirection = constraint.bendDirection;
                this.compress = constraint.compress;
                this.stretch = constraint.stretch;
            }
        },
        methods: {
            /*Spine.IkConstraint.Apply start.*/
            /**
             * Applies the constraint to the constrained bones.
             *
             * @instance
             * @public
             * @this Spine.IkConstraint
             * @memberof Spine.IkConstraint
             * @return  {void}
             */
            Apply: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Apply", this ); }

                this.Update();
            },
            /*Spine.IkConstraint.Apply end.*/

            /*Spine.IkConstraint.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Update", this ); }

                var target = this.target;
                var bones = this.bones;
                switch (bones.Count) {
                    case 1: 
                        Spine.IkConstraint.Apply$1(bones.Items[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
                        break;
                    case 2: 
                        Spine.IkConstraint.Apply(bones.Items[0], bones.Items[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.softness, this.mix);
                        break;
                }
            },
            /*Spine.IkConstraint.Update end.*/

            /*Spine.IkConstraint.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#toString", this ); }

                return this.data.name;
            },
            /*Spine.IkConstraint.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.IkConstraint end.*/

    /*Spine.IkConstraintData start.*/
    /**
     * Stores the setup pose for an IkConstraint.
     *
     * @public
     * @class Spine.IkConstraintData
     * @augments Spine.ConstraintData
     */
    Bridge.define("Spine.IkConstraintData", {
        inherits: [Spine.ConstraintData],
        fields: {
            bones: null,
            target: null,
            bendDirection: 0,
            compress: false,
            stretch: false,
            uniform: false,
            mix: 0,
            softness: 0
        },
        props: {
            /**
             * The bones that are constrained by this IK Constraint.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.IkConstraintData
             * @function Bones
             * @type Spine.ExposedList$1
             */
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Bones#get", this ); }

                    return this.bones;
                }
            },
            /**
             * The bone that is the IK target.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraintData
             * @function Target
             * @type Spine.BoneData
             */
            Target: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Target#get", this ); }

                    return this.target;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Target#set", this ); }

                    this.target = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constraint and unconstrained rotations.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraintData
             * @function Mix
             * @type number
             */
            Mix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Mix#get", this ); }

                    return this.mix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Mix#set", this ); }

                    this.mix = value;
                }
            },
            /**
             * For two bone IK, the distance from the maximum reach of the bones that rotation will slow.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraintData
             * @function Softness
             * @type number
             */
            Softness: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Softness#get", this ); }

                    return this.softness;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Softness#set", this ); }

                    this.softness = value;
                }
            },
            /**
             * Controls the bend direction of the IK bones, either 1 or -1.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraintData
             * @function BendDirection
             * @type number
             */
            BendDirection: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#BendDirection#get", this ); }

                    return this.bendDirection;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#BendDirection#set", this ); }

                    this.bendDirection = value;
                }
            },
            /**
             * When true, and only a single bone is being constrained,
             if the target is too close, the bone is scaled to reach it.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraintData
             * @function Compress
             * @type boolean
             */
            Compress: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Compress#get", this ); }

                    return this.compress;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Compress#set", this ); }

                    this.compress = value;
                }
            },
            /**
             * When true, if the target is out of range, the parent bone is scaled on the X axis to reach it.
             If the bone has local nonuniform scale, stretching is not applied.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraintData
             * @function Stretch
             * @type boolean
             */
            Stretch: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Stretch#get", this ); }

                    return this.stretch;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Stretch#set", this ); }

                    this.stretch = value;
                }
            },
            /**
             * When true, only a single bone is being constrained and Compress or Stretch is used,
             the bone is scaled both on the X and Y axes.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraintData
             * @function Uniform
             * @type boolean
             */
            Uniform: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Uniform#get", this ); }

                    return this.uniform;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Uniform#set", this ); }

                    this.uniform = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#init", this ); }

                this.bones = new (Spine.ExposedList$1(Spine.BoneData)).ctor();
                this.bendDirection = 1;
                this.mix = 1;
            },
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#ctor", this ); }

                this.$initialize();
                Spine.ConstraintData.ctor.call(this, name);
            }
        }
    });
    /*Spine.IkConstraintData end.*/

    /*Spine.PathConstraint start.*/
    /**
     * <p>Stores the current pose for a path constraint. A path constraint adjusts the rotation, translation, and scale of the
     constrained bones so they follow a {@link PathAttachment}.</p><p>See <a href="http://esotericsoftware.com/spine-path-constraints">Path constraints</a> in the Spine User Guide.</p>
     *
     * @public
     * @class Spine.PathConstraint
     * @implements  Spine.IUpdatable
     */
    Bridge.define("Spine.PathConstraint", {
        inherits: [Spine.IUpdatable],
        statics: {
            fields: {
                NONE: 0,
                BEFORE: 0,
                AFTER: 0,
                Epsilon: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#init", this ); }

                    this.NONE = -1;
                    this.BEFORE = -2;
                    this.AFTER = -3;
                    this.Epsilon = 1E-05;
                }
            },
            methods: {
                /*Spine.PathConstraint.AddBeforePosition:static start.*/
                AddBeforePosition: function (p, temp, i, output, o) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#AddBeforePosition", this ); }

                    var x1 = temp[i], y1 = temp[((i + 1) | 0)], dx = temp[((i + 2) | 0)] - x1, dy = temp[((i + 3) | 0)] - y1, r = Spine.MathUtils.Atan2(dy, dx);
                    output[o] = x1 + p * Spine.MathUtils.Cos(r);
                    output[((o + 1) | 0)] = y1 + p * Spine.MathUtils.Sin(r);
                    output[((o + 2) | 0)] = r;
                },
                /*Spine.PathConstraint.AddBeforePosition:static end.*/

                /*Spine.PathConstraint.AddAfterPosition:static start.*/
                AddAfterPosition: function (p, temp, i, output, o) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#AddAfterPosition", this ); }

                    var x1 = temp[((i + 2) | 0)], y1 = temp[((i + 3) | 0)], dx = x1 - temp[i], dy = y1 - temp[((i + 1) | 0)], r = Spine.MathUtils.Atan2(dy, dx);
                    output[o] = x1 + p * Spine.MathUtils.Cos(r);
                    output[((o + 1) | 0)] = y1 + p * Spine.MathUtils.Sin(r);
                    output[((o + 2) | 0)] = r;
                },
                /*Spine.PathConstraint.AddAfterPosition:static end.*/

                /*Spine.PathConstraint.AddCurvePosition:static start.*/
                AddCurvePosition: function (p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, output, o, tangents) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#AddCurvePosition", this ); }

                    if (p < Spine.PathConstraint.Epsilon || isNaN(p)) {
                        output[o] = x1;
                        output[((o + 1) | 0)] = y1;
                        output[((o + 2) | 0)] = Math.atan2(cy1 - y1, cx1 - x1);
                        return;
                    }
                    var tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;
                    var ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;
                    var x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;
                    output[o] = x;
                    output[((o + 1) | 0)] = y;
                    if (tangents) {
                        if (p < 0.001) {
                            output[((o + 2) | 0)] = Math.atan2(cy1 - y1, cx1 - x1);
                        } else {
                            output[((o + 2) | 0)] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));
                        }
                    }
                },
                /*Spine.PathConstraint.AddCurvePosition:static end.*/


            }
        },
        fields: {
            data: null,
            bones: null,
            target: null,
            position: 0,
            spacing: 0,
            rotateMix: 0,
            translateMix: 0,
            active: false,
            spaces: null,
            positions: null,
            world: null,
            curves: null,
            lengths: null,
            segments: null
        },
        props: {
            /**
             * The position along the path.
             *
             * @instance
             * @public
             * @memberof Spine.PathConstraint
             * @function Position
             * @type number
             */
            Position: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Position#get", this ); }

                    return this.position;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Position#set", this ); }

                    this.position = value;
                }
            },
            /**
             * The spacing between bones.
             *
             * @instance
             * @public
             * @memberof Spine.PathConstraint
             * @function Spacing
             * @type number
             */
            Spacing: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Spacing#get", this ); }

                    return this.spacing;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Spacing#set", this ); }

                    this.spacing = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained rotations.
             *
             * @instance
             * @public
             * @memberof Spine.PathConstraint
             * @function RotateMix
             * @type number
             */
            RotateMix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#RotateMix#get", this ); }

                    return this.rotateMix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#RotateMix#set", this ); }

                    this.rotateMix = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained translations.
             *
             * @instance
             * @public
             * @memberof Spine.PathConstraint
             * @function TranslateMix
             * @type number
             */
            TranslateMix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#TranslateMix#get", this ); }

                    return this.translateMix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#TranslateMix#set", this ); }

                    this.translateMix = value;
                }
            },
            /**
             * The bones that will be modified by this path constraint.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.PathConstraint
             * @function Bones
             * @type Spine.ExposedList$1
             */
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Bones#get", this ); }

                    return this.bones;
                }
            },
            /**
             * The slot whose path attachment will be used to constrained the bones.
             *
             * @instance
             * @public
             * @memberof Spine.PathConstraint
             * @function Target
             * @type Spine.Slot
             */
            Target: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Target#get", this ); }

                    return this.target;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Target#set", this ); }

                    this.target = value;
                }
            },
            Active: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Active#get", this ); }

                    return this.active;
                }
            },
            /**
             * The path constraint's setup pose data.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.PathConstraint
             * @function Data
             * @type Spine.PathConstraintData
             */
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Data#get", this ); }

                    return this.data;
                }
            }
        },
        alias: [
            "Update", "Spine$IUpdatable$Update",
            "Active", "Spine$IUpdatable$Active"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#init", this ); }

                this.spaces = new (Spine.ExposedList$1(System.Single)).ctor();
                this.positions = new (Spine.ExposedList$1(System.Single)).ctor();
                this.world = new (Spine.ExposedList$1(System.Single)).ctor();
                this.curves = new (Spine.ExposedList$1(System.Single)).ctor();
                this.lengths = new (Spine.ExposedList$1(System.Single)).ctor();
                this.segments = System.Array.init(10, 0, System.Single);
            },
            $ctor1: function (data, skeleton) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#$ctor1", this ); }

                var $t;
                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                }
                this.data = data;
                this.bones = new (Spine.ExposedList$1(Spine.Bone)).$ctor3(data.Bones.Count);
                $t = Bridge.getEnumerator(data.bones);
                try {
                    while ($t.moveNext()) {
                        var boneData = $t.Current;
                        this.bones.Add(skeleton.FindBone(boneData.name));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.target = skeleton.FindSlot(data.target.name);
                this.position = data.position;
                this.spacing = data.spacing;
                this.rotateMix = data.rotateMix;
                this.translateMix = data.translateMix;
            },
            /**
             * Copy constructor.
             *
             * @instance
             * @public
             * @this Spine.PathConstraint
             * @memberof Spine.PathConstraint
             * @param   {Spine.PathConstraint}    constraint    
             * @param   {Spine.Skeleton}          skeleton
             * @return  {void}
             */
            ctor: function (constraint, skeleton) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#ctor", this ); }

                var $t, $t1, $t2;
                this.$initialize();
                if (constraint == null) {
                    throw new System.ArgumentNullException.$ctor1("constraint cannot be null.");
                }
                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor1("skeleton cannot be null.");
                }
                this.data = constraint.data;
                this.bones = new (Spine.ExposedList$1(Spine.Bone)).$ctor3(constraint.Bones.Count);
                $t = Bridge.getEnumerator(constraint.Bones);
                try {
                    while ($t.moveNext()) {
                        var bone = $t.Current;
                        this.bones.Add(($t1 = skeleton.Bones.Items)[bone.data.index]);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.target = ($t2 = skeleton.slots.Items)[constraint.target.data.index];
                this.position = constraint.position;
                this.spacing = constraint.spacing;
                this.rotateMix = constraint.rotateMix;
                this.translateMix = constraint.translateMix;
            }
        },
        methods: {
            /*Spine.PathConstraint.Apply start.*/
            /**
             * Applies the constraint to the constrained bones.
             *
             * @instance
             * @public
             * @this Spine.PathConstraint
             * @memberof Spine.PathConstraint
             * @return  {void}
             */
            Apply: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Apply", this ); }

                this.Update();
            },
            /*Spine.PathConstraint.Apply end.*/

            /*Spine.PathConstraint.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Update", this ); }

                var attachment = Bridge.as(this.target.Attachment, Spine.PathAttachment);
                if (attachment == null) {
                    return;
                }

                var rotateMix = this.rotateMix, translateMix = this.translateMix;
                var translate = translateMix > 0, rotate = rotateMix > 0;
                if (!translate && !rotate) {
                    return;
                }

                var data = this.data;
                var percentSpacing = data.spacingMode === Spine.SpacingMode.Percent;
                var rotateMode = data.rotateMode;
                var tangents = rotateMode === Spine.RotateMode.Tangent, scale = rotateMode === Spine.RotateMode.ChainScale;
                var boneCount = this.bones.Count, spacesCount = tangents ? boneCount : ((boneCount + 1) | 0);
                var bonesItems = this.bones.Items;
                var spaces = this.spaces.Resize(spacesCount), lengths = null;
                var spacing = this.spacing;
                if (scale || !percentSpacing) {
                    if (scale) {
                        lengths = this.lengths.Resize(boneCount);
                    }
                    var lengthSpacing = data.spacingMode === Spine.SpacingMode.Length;
                    for (var i = 0, n = (spacesCount - 1) | 0; i < n; ) {
                        var bone = bonesItems[i];
                        var setupLength = bone.data.length;
                        if (setupLength < Spine.PathConstraint.Epsilon) {
                            if (scale) {
                                lengths.Items[i] = 0;
                            }
                            spaces.Items[((i = (i + 1) | 0))] = 0;
                        } else if (percentSpacing) {
                            if (scale) {
                                var x = setupLength * bone.a, y = setupLength * bone.c;
                                var length = Math.sqrt(x * x + y * y);
                                lengths.Items[i] = length;
                            }
                            spaces.Items[((i = (i + 1) | 0))] = spacing;
                        } else {
                            var x1 = setupLength * bone.a, y1 = setupLength * bone.c;
                            var length1 = Math.sqrt(x1 * x1 + y1 * y1);
                            if (scale) {
                                lengths.Items[i] = length1;
                            }
                            spaces.Items[((i = (i + 1) | 0))] = (lengthSpacing ? setupLength + spacing : spacing) * length1 / setupLength;
                        }
                    }
                } else {
                    for (var i1 = 1; i1 < spacesCount; i1 = (i1 + 1) | 0) {
                        spaces.Items[i1] = spacing;
                    }
                }

                var positions = this.ComputeWorldPositions(attachment, spacesCount, tangents, data.positionMode === Spine.PositionMode.Percent, percentSpacing);
                var boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;
                var tip;
                if (offsetRotation === 0) {
                    tip = rotateMode === Spine.RotateMode.Chain;
                } else {
                    tip = false;
                    var p = this.target.bone;
                    offsetRotation *= p.a * p.d - p.b * p.c > 0 ? Spine.MathUtils.DegRad : -0.0174532924;
                }
                for (var i2 = 0, p1 = 3; i2 < boneCount; i2 = (i2 + 1) | 0, p1 = (p1 + 3) | 0) {
                    var bone1 = bonesItems[i2];
                    bone1.worldX += (boneX - bone1.worldX) * translateMix;
                    bone1.worldY += (boneY - bone1.worldY) * translateMix;
                    var x2 = positions[p1], y2 = positions[((p1 + 1) | 0)], dx = x2 - boneX, dy = y2 - boneY;
                    if (scale) {
                        var length2 = lengths.Items[i2];
                        if (length2 >= Spine.PathConstraint.Epsilon) {
                            var s = (Math.sqrt(dx * dx + dy * dy) / length2 - 1) * rotateMix + 1;
                            bone1.a *= s;
                            bone1.c *= s;
                        }
                    }
                    boneX = x2;
                    boneY = y2;
                    if (rotate) {
                        var a = bone1.a, b = bone1.b, c = bone1.c, d = bone1.d, r, cos, sin;
                        if (tangents) {
                            r = positions[((p1 - 1) | 0)];
                        } else {
                            if (spaces.Items[((i2 + 1) | 0)] < Spine.PathConstraint.Epsilon) {
                                r = positions[((p1 + 2) | 0)];
                            } else {
                                r = Spine.MathUtils.Atan2(dy, dx);
                            }
                        }
                        r -= Spine.MathUtils.Atan2(c, a);
                        if (tip) {
                            cos = Spine.MathUtils.Cos(r);
                            sin = Spine.MathUtils.Sin(r);
                            var length3 = bone1.data.length;
                            boneX += (length3 * (cos * a - sin * c) - dx) * rotateMix;
                            boneY += (length3 * (sin * a + cos * c) - dy) * rotateMix;
                        } else {
                            r += offsetRotation;
                        }
                        if (r > Spine.MathUtils.PI) {
                            r -= Spine.MathUtils.PI2;
                        } else {
                            if (r < -3.14159274) {
                                r += Spine.MathUtils.PI2;
                            }
                        }
                        r *= rotateMix;
                        cos = Spine.MathUtils.Cos(r);
                        sin = Spine.MathUtils.Sin(r);
                        bone1.a = cos * a - sin * c;
                        bone1.b = cos * b - sin * d;
                        bone1.c = sin * a + cos * c;
                        bone1.d = sin * b + cos * d;
                    }
                    bone1.appliedValid = false;
                }
            },
            /*Spine.PathConstraint.Update end.*/

            /*Spine.PathConstraint.ComputeWorldPositions start.*/
            ComputeWorldPositions: function (path, spacesCount, tangents, percentPosition, percentSpacing) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#ComputeWorldPositions", this ); }


                var target = this.target;
                var position = this.position;
                var spacesItems = this.spaces.Items, output = this.positions.Resize(((Bridge.Int.mul(spacesCount, 3) + 2) | 0)).Items, world;
                var closed = path.Closed;
                var verticesLength = path.WorldVerticesLength, curveCount = (Bridge.Int.div(verticesLength, 6)) | 0, prevCurve = Spine.PathConstraint.NONE;
                var pathLength = 0;

                if (!path.ConstantSpeed) {
                    var lengths = path.Lengths;
                    curveCount = (curveCount - (closed ? 1 : 2)) | 0;
                    pathLength = lengths[curveCount];
                    if (percentPosition) {
                        position *= pathLength;
                    }
                    if (percentSpacing) {
                        for (var i = 1; i < spacesCount; i = (i + 1) | 0) {
                            spacesItems[i] *= pathLength;
                        }
                    }
                    world = this.world.Resize(8).Items;
                    for (var i1 = 0, o = 0, curve = 0; i1 < spacesCount; i1 = (i1 + 1) | 0, o = (o + 3) | 0) {
                        var space = spacesItems[i1];
                        position += space;
                        var p = position;

                        if (closed) {
                            p %= pathLength;
                            if (p < 0) {
                                p += pathLength;
                            }
                            curve = 0;
                        } else if (p < 0) {
                            if (prevCurve !== Spine.PathConstraint.BEFORE) {
                                prevCurve = Spine.PathConstraint.BEFORE;
                                path.ComputeWorldVertices(target, 2, 4, world, 0, 2);
                            }
                            Spine.PathConstraint.AddBeforePosition(p, world, 0, output, o);
                            continue;
                        } else if (p > pathLength) {
                            if (prevCurve !== Spine.PathConstraint.AFTER) {
                                prevCurve = Spine.PathConstraint.AFTER;
                                path.ComputeWorldVertices(target, ((verticesLength - 6) | 0), 4, world, 0, 2);
                            }
                            Spine.PathConstraint.AddAfterPosition(p - pathLength, world, 0, output, o);
                            continue;
                        }

                        // Determine curve containing position.
                        for (; ; curve = (curve + 1) | 0) {
                            var length = lengths[curve];
                            if (p > length) {
                                continue;
                            }
                            if (curve === 0) {
                                p /= length;
                            } else {
                                var prev = lengths[((curve - 1) | 0)];
                                p = (p - prev) / (length - prev);
                            }
                            break;
                        }
                        if (curve !== prevCurve) {
                            prevCurve = curve;
                            if (closed && curve === curveCount) {
                                path.ComputeWorldVertices(target, ((verticesLength - 4) | 0), 4, world, 0, 2);
                                path.ComputeWorldVertices(target, 0, 4, world, 4, 2);
                            } else {
                                path.ComputeWorldVertices(target, ((Bridge.Int.mul(curve, 6) + 2) | 0), 8, world, 0, 2);
                            }
                        }
                        Spine.PathConstraint.AddCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], output, o, tangents || (i1 > 0 && space < Spine.PathConstraint.Epsilon));
                    }
                    return output;
                }

                // World vertices.
                if (closed) {
                    verticesLength = (verticesLength + 2) | 0;
                    world = this.world.Resize(verticesLength).Items;
                    path.ComputeWorldVertices(target, 2, ((verticesLength - 4) | 0), world, 0, 2);
                    path.ComputeWorldVertices(target, 0, 2, world, ((verticesLength - 4) | 0), 2);
                    world[((verticesLength - 2) | 0)] = world[0];
                    world[((verticesLength - 1) | 0)] = world[1];
                } else {
                    curveCount = (curveCount - 1) | 0;
                    verticesLength = (verticesLength - 4) | 0;
                    world = this.world.Resize(verticesLength).Items;
                    path.ComputeWorldVertices(target, 2, verticesLength, world, 0, 2);
                }

                // Curve lengths.
                var curves = this.curves.Resize(curveCount).Items;
                pathLength = 0;
                var x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;
                var tmpx, tmpy, dddfx, dddfy, ddfx, ddfy, dfx, dfy;
                for (var i2 = 0, w = 2; i2 < curveCount; i2 = (i2 + 1) | 0, w = (w + 6) | 0) {
                    cx1 = world[w];
                    cy1 = world[((w + 1) | 0)];
                    cx2 = world[((w + 2) | 0)];
                    cy2 = world[((w + 3) | 0)];
                    x2 = world[((w + 4) | 0)];
                    y2 = world[((w + 5) | 0)];
                    tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;
                    tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;
                    dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;
                    dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;
                    ddfx = tmpx * 2 + dddfx;
                    ddfy = tmpy * 2 + dddfy;
                    dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.166666672;
                    dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.166666672;
                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    dfx += ddfx;
                    dfy += ddfy;
                    ddfx += dddfx;
                    ddfy += dddfy;
                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    dfx += ddfx;
                    dfy += ddfy;
                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    dfx += ddfx + dddfx;
                    dfy += ddfy + dddfy;
                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    curves[i2] = pathLength;
                    x1 = x2;
                    y1 = y2;
                }
                if (percentPosition) {
                    position *= pathLength;
                } else {
                    position *= pathLength / path.lengths[((curveCount - 1) | 0)];
                }

                if (percentSpacing) {
                    for (var i3 = 1; i3 < spacesCount; i3 = (i3 + 1) | 0) {
                        spacesItems[i3] *= pathLength;
                    }
                }

                var segments = this.segments;
                var curveLength = 0;
                for (var i4 = 0, o1 = 0, curve1 = 0, segment = 0; i4 < spacesCount; i4 = (i4 + 1) | 0, o1 = (o1 + 3) | 0) {
                    var space1 = spacesItems[i4];
                    position += space1;
                    var p1 = position;

                    if (closed) {
                        p1 %= pathLength;
                        if (p1 < 0) {
                            p1 += pathLength;
                        }
                        curve1 = 0;
                    } else if (p1 < 0) {
                        Spine.PathConstraint.AddBeforePosition(p1, world, 0, output, o1);
                        continue;
                    } else if (p1 > pathLength) {
                        Spine.PathConstraint.AddAfterPosition(p1 - pathLength, world, ((verticesLength - 4) | 0), output, o1);
                        continue;
                    }

                    // Determine curve containing position.
                    for (; ; curve1 = (curve1 + 1) | 0) {
                        var length1 = curves[curve1];
                        if (p1 > length1) {
                            continue;
                        }
                        if (curve1 === 0) {
                            p1 /= length1;
                        } else {
                            var prev1 = curves[((curve1 - 1) | 0)];
                            p1 = (p1 - prev1) / (length1 - prev1);
                        }
                        break;
                    }

                    // Curve segment lengths.
                    if (curve1 !== prevCurve) {
                        prevCurve = curve1;
                        var ii = Bridge.Int.mul(curve1, 6);
                        x1 = world[ii];
                        y1 = world[((ii + 1) | 0)];
                        cx1 = world[((ii + 2) | 0)];
                        cy1 = world[((ii + 3) | 0)];
                        cx2 = world[((ii + 4) | 0)];
                        cy2 = world[((ii + 5) | 0)];
                        x2 = world[((ii + 6) | 0)];
                        y2 = world[((ii + 7) | 0)];
                        tmpx = (x1 - cx1 * 2 + cx2) * 0.03;
                        tmpy = (y1 - cy1 * 2 + cy2) * 0.03;
                        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;
                        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;
                        ddfx = tmpx * 2 + dddfx;
                        ddfy = tmpy * 2 + dddfy;
                        dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.166666672;
                        dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.166666672;
                        curveLength = Math.sqrt(dfx * dfx + dfy * dfy);
                        segments[0] = curveLength;
                        for (ii = 1; ii < 8; ii = (ii + 1) | 0) {
                            dfx += ddfx;
                            dfy += ddfy;
                            ddfx += dddfx;
                            ddfy += dddfy;
                            curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
                            segments[ii] = curveLength;
                        }
                        dfx += ddfx;
                        dfy += ddfy;
                        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
                        segments[8] = curveLength;
                        dfx += ddfx + dddfx;
                        dfy += ddfy + dddfy;
                        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
                        segments[9] = curveLength;
                        segment = 0;
                    }

                    // Weight by segment length.
                    p1 *= curveLength;
                    for (; ; segment = (segment + 1) | 0) {
                        var length2 = segments[segment];
                        if (p1 > length2) {
                            continue;
                        }
                        if (segment === 0) {
                            p1 /= length2;
                        } else {
                            var prev2 = segments[((segment - 1) | 0)];
                            p1 = segment + (p1 - prev2) / (length2 - prev2);
                        }
                        break;
                    }
                    Spine.PathConstraint.AddCurvePosition(p1 * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, output, o1, tangents || (i4 > 0 && space1 < Spine.PathConstraint.Epsilon));
                }
                return output;
            },
            /*Spine.PathConstraint.ComputeWorldPositions end.*/


        }
    });
    /*Spine.PathConstraint end.*/

    /*Spine.PathConstraintData start.*/
    Bridge.define("Spine.PathConstraintData", {
        inherits: [Spine.ConstraintData],
        fields: {
            bones: null,
            target: null,
            positionMode: 0,
            spacingMode: 0,
            rotateMode: 0,
            offsetRotation: 0,
            position: 0,
            spacing: 0,
            rotateMix: 0,
            translateMix: 0
        },
        props: {
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#Bones#get", this ); }

                    return this.bones;
                }
            },
            Target: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#Target#get", this ); }

                    return this.target;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#Target#set", this ); }

                    this.target = value;
                }
            },
            PositionMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#PositionMode#get", this ); }

                    return this.positionMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#PositionMode#set", this ); }

                    this.positionMode = value;
                }
            },
            SpacingMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#SpacingMode#get", this ); }

                    return this.spacingMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#SpacingMode#set", this ); }

                    this.spacingMode = value;
                }
            },
            RotateMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#RotateMode#get", this ); }

                    return this.rotateMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#RotateMode#set", this ); }

                    this.rotateMode = value;
                }
            },
            OffsetRotation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#OffsetRotation#get", this ); }

                    return this.offsetRotation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#OffsetRotation#set", this ); }

                    this.offsetRotation = value;
                }
            },
            Position: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#Position#get", this ); }

                    return this.position;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#Position#set", this ); }

                    this.position = value;
                }
            },
            Spacing: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#Spacing#get", this ); }

                    return this.spacing;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#Spacing#set", this ); }

                    this.spacing = value;
                }
            },
            RotateMix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#RotateMix#get", this ); }

                    return this.rotateMix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#RotateMix#set", this ); }

                    this.rotateMix = value;
                }
            },
            TranslateMix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#TranslateMix#get", this ); }

                    return this.translateMix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#TranslateMix#set", this ); }

                    this.translateMix = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#init", this ); }

                this.bones = new (Spine.ExposedList$1(Spine.BoneData)).ctor();
            },
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#ctor", this ); }

                this.$initialize();
                Spine.ConstraintData.ctor.call(this, name);
            }
        }
    });
    /*Spine.PathConstraintData end.*/

    /*Spine.PointAttachment start.*/
    
    Bridge.define("Spine.PointAttachment", {
        inherits: [Spine.Attachment],
        fields: {
            x: 0,
            y: 0,
            rotation: 0
        },
        props: {
            X: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PointAttachment#X#get", this ); }

                    return this.x;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PointAttachment#X#set", this ); }

                    this.x = value;
                }
            },
            Y: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PointAttachment#Y#get", this ); }

                    return this.y;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PointAttachment#Y#set", this ); }

                    this.y = value;
                }
            },
            Rotation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PointAttachment#Rotation#get", this ); }

                    return this.rotation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PointAttachment#Rotation#set", this ); }

                    this.rotation = value;
                }
            }
        },
        ctors: {
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.PointAttachment#ctor", this ); }

                this.$initialize();
                Spine.Attachment.ctor.call(this, name);
            }
        },
        methods: {
            /*Spine.PointAttachment.ComputeWorldPosition start.*/
            ComputeWorldPosition: function (bone, ox, oy) {
if ( TRACE ) { TRACE( "Spine.PointAttachment#ComputeWorldPosition", this ); }

                bone.LocalToWorld(this.x, this.y, ox, oy);
            },
            /*Spine.PointAttachment.ComputeWorldPosition end.*/

            /*Spine.PointAttachment.ComputeWorldRotation start.*/
            ComputeWorldRotation: function (bone) {
if ( TRACE ) { TRACE( "Spine.PointAttachment#ComputeWorldRotation", this ); }

                var cos = Spine.MathUtils.CosDeg(this.rotation), sin = Spine.MathUtils.SinDeg(this.rotation);
                var ix = cos * bone.a + sin * bone.b;
                var iy = cos * bone.c + sin * bone.d;
                return Spine.MathUtils.Atan2(iy, ix) * Spine.MathUtils.RadDeg;
            },
            /*Spine.PointAttachment.ComputeWorldRotation end.*/

            /*Spine.PointAttachment.Copy start.*/
            Copy: function () {
if ( TRACE ) { TRACE( "Spine.PointAttachment#Copy", this ); }

                var copy = new Spine.PointAttachment(this.Name);
                copy.x = this.x;
                copy.y = this.y;
                copy.rotation = this.rotation;
                return copy;
            },
            /*Spine.PointAttachment.Copy end.*/


        }
    });
    /*Spine.PointAttachment end.*/

    /*Spine.Pow start.*/
    Bridge.define("Spine.Pow", {
        inherits: [Spine.IInterpolation],
        fields: {
            Power: 0
        },
        ctors: {
            ctor: function (power) {
if ( TRACE ) { TRACE( "Spine.Pow#ctor", this ); }

                this.$initialize();
                Spine.IInterpolation.ctor.call(this);
                this.Power = power;
            }
        },
        methods: {
            /*Spine.Pow.Apply$1 start.*/
            Apply$1: function (a) {
if ( TRACE ) { TRACE( "Spine.Pow#Apply$1", this ); }

                if (a <= 0.5) {
                    return Math.pow(a * 2, this.Power) / 2;
                }
                return Math.pow((a - 1) * 2, this.Power) / (this.Power % 2 === 0 ? -2 : 2) + 1;
            },
            /*Spine.Pow.Apply$1 end.*/


        },
        overloads: {
            "Apply(float)": "Apply$1"
        }
    });
    /*Spine.Pow end.*/

    /*Spine.RegionAttachment start.*/
    /**
     * Attachment that displays a texture region.
     *
     * @public
     * @class Spine.RegionAttachment
     * @augments Spine.Attachment
     * @implements  Spine.IHasRendererObject
     */
    Bridge.define("Spine.RegionAttachment", {
        inherits: [Spine.Attachment,Spine.IHasRendererObject],
        statics: {
            fields: {
                BLX: 0,
                BLY: 0,
                ULX: 0,
                ULY: 0,
                URX: 0,
                URY: 0,
                BRX: 0,
                BRY: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#init", this ); }

                    this.BLX = 0;
                    this.BLY = 1;
                    this.ULX = 2;
                    this.ULY = 3;
                    this.URX = 4;
                    this.URY = 5;
                    this.BRX = 6;
                    this.BRY = 7;
                }
            }
        },
        fields: {
            x: 0,
            y: 0,
            rotation: 0,
            scaleX: 0,
            scaleY: 0,
            width: 0,
            height: 0,
            regionOffsetX: 0,
            regionOffsetY: 0,
            regionWidth: 0,
            regionHeight: 0,
            regionOriginalWidth: 0,
            regionOriginalHeight: 0,
            offset: null,
            uvs: null,
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            Path: null,
            RendererObject: null
        },
        props: {
            X: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#X#get", this ); }

                    return this.x;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#X#set", this ); }

                    this.x = value;
                }
            },
            Y: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Y#get", this ); }

                    return this.y;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Y#set", this ); }

                    this.y = value;
                }
            },
            Rotation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Rotation#get", this ); }

                    return this.rotation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Rotation#set", this ); }

                    this.rotation = value;
                }
            },
            ScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#ScaleX#get", this ); }

                    return this.scaleX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#ScaleX#set", this ); }

                    this.scaleX = value;
                }
            },
            ScaleY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#ScaleY#get", this ); }

                    return this.scaleY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#ScaleY#set", this ); }

                    this.scaleY = value;
                }
            },
            Width: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Width#get", this ); }

                    return this.width;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Width#set", this ); }

                    this.width = value;
                }
            },
            Height: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Height#get", this ); }

                    return this.height;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Height#set", this ); }

                    this.height = value;
                }
            },
            R: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#R#get", this ); }

                    return this.r;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#R#set", this ); }

                    this.r = value;
                }
            },
            G: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#G#get", this ); }

                    return this.g;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#G#set", this ); }

                    this.g = value;
                }
            },
            B: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#B#get", this ); }

                    return this.b;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#B#set", this ); }

                    this.b = value;
                }
            },
            A: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#A#get", this ); }

                    return this.a;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#A#set", this ); }

                    this.a = value;
                }
            },
            RegionOffsetX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#RegionOffsetX#get", this ); }

                    return this.regionOffsetX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#RegionOffsetX#set", this ); }

                    this.regionOffsetX = value;
                }
            },
            RegionOffsetY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#RegionOffsetY#get", this ); }

                    return this.regionOffsetY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#RegionOffsetY#set", this ); }

                    this.regionOffsetY = value;
                }
            },
            RegionWidth: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#RegionWidth#get", this ); }

                    return this.regionWidth;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#RegionWidth#set", this ); }

                    this.regionWidth = value;
                }
            },
            RegionHeight: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#RegionHeight#get", this ); }

                    return this.regionHeight;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#RegionHeight#set", this ); }

                    this.regionHeight = value;
                }
            },
            RegionOriginalWidth: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#RegionOriginalWidth#get", this ); }

                    return this.regionOriginalWidth;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#RegionOriginalWidth#set", this ); }

                    this.regionOriginalWidth = value;
                }
            },
            RegionOriginalHeight: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#RegionOriginalHeight#get", this ); }

                    return this.regionOriginalHeight;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#RegionOriginalHeight#set", this ); }

                    this.regionOriginalHeight = value;
                }
            },
            Offset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Offset#get", this ); }

                    return this.offset;
                }
            },
            UVs: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#UVs#get", this ); }

                    return this.uvs;
                }
            }
        },
        alias: ["RendererObject", "Spine$IHasRendererObject$RendererObject"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#init", this ); }

                this.scaleX = 1;
                this.scaleY = 1;
                this.offset = System.Array.init(8, 0, System.Single);
                this.uvs = System.Array.init(8, 0, System.Single);
                this.r = 1;
                this.g = 1;
                this.b = 1;
                this.a = 1;
            },
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#ctor", this ); }

                this.$initialize();
                Spine.Attachment.ctor.call(this, name);
            }
        },
        methods: {
            /*Spine.RegionAttachment.UpdateOffset start.*/
            UpdateOffset: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#UpdateOffset", this ); }

                var width = this.width;
                var height = this.height;
                var localX2 = width * 0.5;
                var localY2 = height * 0.5;
                var localX = -localX2;
                var localY = -localY2;
                if (this.regionOriginalWidth !== 0) { // if (region != null)
                    localX += this.regionOffsetX / this.regionOriginalWidth * width;
                    localY += this.regionOffsetY / this.regionOriginalHeight * height;
                    localX2 -= (this.regionOriginalWidth - this.regionOffsetX - this.regionWidth) / this.regionOriginalWidth * width;
                    localY2 -= (this.regionOriginalHeight - this.regionOffsetY - this.regionHeight) / this.regionOriginalHeight * height;
                }
                var scaleX = this.scaleX;
                var scaleY = this.scaleY;
                localX *= scaleX;
                localY *= scaleY;
                localX2 *= scaleX;
                localY2 *= scaleY;
                var rotation = this.rotation;
                var cos = Spine.MathUtils.CosDeg(rotation);
                var sin = Spine.MathUtils.SinDeg(rotation);
                var x = this.x;
                var y = this.y;
                var localXCos = localX * cos + x;
                var localXSin = localX * sin;
                var localYCos = localY * cos + y;
                var localYSin = localY * sin;
                var localX2Cos = localX2 * cos + x;
                var localX2Sin = localX2 * sin;
                var localY2Cos = localY2 * cos + y;
                var localY2Sin = localY2 * sin;
                var offset = this.offset;
                offset[Spine.RegionAttachment.BLX] = localXCos - localYSin;
                offset[Spine.RegionAttachment.BLY] = localYCos + localXSin;
                offset[Spine.RegionAttachment.ULX] = localXCos - localY2Sin;
                offset[Spine.RegionAttachment.ULY] = localY2Cos + localXSin;
                offset[Spine.RegionAttachment.URX] = localX2Cos - localY2Sin;
                offset[Spine.RegionAttachment.URY] = localY2Cos + localX2Sin;
                offset[Spine.RegionAttachment.BRX] = localX2Cos - localYSin;
                offset[Spine.RegionAttachment.BRY] = localYCos + localX2Sin;
            },
            /*Spine.RegionAttachment.UpdateOffset end.*/

            /*Spine.RegionAttachment.SetUVs start.*/
            SetUVs: function (u, v, u2, v2, rotate) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#SetUVs", this ); }

                var uvs = this.uvs;
                // UV values differ from RegionAttachment.java
                if (rotate) {
                    uvs[Spine.RegionAttachment.URX] = u;
                    uvs[Spine.RegionAttachment.URY] = v2;
                    uvs[Spine.RegionAttachment.BRX] = u;
                    uvs[Spine.RegionAttachment.BRY] = v;
                    uvs[Spine.RegionAttachment.BLX] = u2;
                    uvs[Spine.RegionAttachment.BLY] = v;
                    uvs[Spine.RegionAttachment.ULX] = u2;
                    uvs[Spine.RegionAttachment.ULY] = v2;
                } else {
                    uvs[Spine.RegionAttachment.ULX] = u;
                    uvs[Spine.RegionAttachment.ULY] = v2;
                    uvs[Spine.RegionAttachment.URX] = u;
                    uvs[Spine.RegionAttachment.URY] = v;
                    uvs[Spine.RegionAttachment.BRX] = u2;
                    uvs[Spine.RegionAttachment.BRY] = v;
                    uvs[Spine.RegionAttachment.BLX] = u2;
                    uvs[Spine.RegionAttachment.BLY] = v2;
                }
            },
            /*Spine.RegionAttachment.SetUVs end.*/

            /*Spine.RegionAttachment.ComputeWorldVertices start.*/
            /**
             * Transforms the attachment's four vertices to world coordinates.
             *
             * @instance
             * @public
             * @this Spine.RegionAttachment
             * @memberof Spine.RegionAttachment
             * @param   {Spine.Bone}        bone             The parent bone.
             * @param   {Array.<number>}    worldVertices    The output world vertices. Must have a length greater than or equal to offset + 8.
             * @param   {number}            offset           The worldVertices index to begin writing values.
             * @param   {number}            stride           The number of worldVertices entries between the value pairs written.
             * @return  {void}
             */
            ComputeWorldVertices: function (bone, worldVertices, offset, stride) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#ComputeWorldVertices", this ); }

                if (stride === void 0) { stride = 2; }
                var vertexOffset = this.offset;
                var bwx = bone.worldX, bwy = bone.worldY;
                var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
                var offsetX, offsetY;

                // Vertex order is different from RegionAttachment.java
                offsetX = vertexOffset[Spine.RegionAttachment.BRX]; // 0
                offsetY = vertexOffset[Spine.RegionAttachment.BRY]; // 1
                worldVertices[offset] = offsetX * a + offsetY * b + bwx; // bl
                worldVertices[((offset + 1) | 0)] = offsetX * c + offsetY * d + bwy;
                offset = (offset + stride) | 0;

                offsetX = vertexOffset[Spine.RegionAttachment.BLX]; // 2
                offsetY = vertexOffset[Spine.RegionAttachment.BLY]; // 3
                worldVertices[offset] = offsetX * a + offsetY * b + bwx; // ul
                worldVertices[((offset + 1) | 0)] = offsetX * c + offsetY * d + bwy;
                offset = (offset + stride) | 0;

                offsetX = vertexOffset[Spine.RegionAttachment.ULX]; // 4
                offsetY = vertexOffset[Spine.RegionAttachment.ULY]; // 5
                worldVertices[offset] = offsetX * a + offsetY * b + bwx; // ur
                worldVertices[((offset + 1) | 0)] = offsetX * c + offsetY * d + bwy;
                offset = (offset + stride) | 0;

                offsetX = vertexOffset[Spine.RegionAttachment.URX]; // 6
                offsetY = vertexOffset[Spine.RegionAttachment.URY]; // 7
                worldVertices[offset] = offsetX * a + offsetY * b + bwx; // br
                worldVertices[((offset + 1) | 0)] = offsetX * c + offsetY * d + bwy;
                //offset += stride;
            },
            /*Spine.RegionAttachment.ComputeWorldVertices end.*/

            /*Spine.RegionAttachment.Copy start.*/
            Copy: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Copy", this ); }

                var copy = new Spine.RegionAttachment(this.Name);
                copy.RendererObject = this.RendererObject;
                copy.regionOffsetX = this.regionOffsetX;
                copy.regionOffsetY = this.regionOffsetY;
                copy.regionWidth = this.regionWidth;
                copy.regionHeight = this.regionHeight;
                copy.regionOriginalWidth = this.regionOriginalWidth;
                copy.regionOriginalHeight = this.regionOriginalHeight;
                copy.Path = this.Path;
                copy.x = this.x;
                copy.y = this.y;
                copy.scaleX = this.scaleX;
                copy.scaleY = this.scaleY;
                copy.rotation = this.rotation;
                copy.width = this.width;
                copy.height = this.height;
                System.Array.copy(this.uvs, 0, copy.uvs, 0, 8);
                System.Array.copy(this.offset, 0, copy.offset, 0, 8);
                copy.r = this.r;
                copy.g = this.g;
                copy.b = this.b;
                copy.a = this.a;
                return copy;
            },
            /*Spine.RegionAttachment.Copy end.*/


        }
    });
    /*Spine.RegionAttachment end.*/

    /*Spine.Skin+SkinEntryComparer start.*/
    Bridge.define("Spine.Skin.SkinEntryComparer", {
        inherits: [System.Collections.Generic.IEqualityComparer$1(Spine.Skin.SkinEntry)],
        $kind: 1002,
        statics: {
            fields: {
                Instance: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntryComparer#init", this ); }

                    this.Instance = new Spine.Skin.SkinEntryComparer();
                }
            }
        },
        alias: [
            "System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinEntry$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2",
            "System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinEntry$getHashCode2", "System$Collections$Generic$IEqualityComparer$1$getHashCode2"
        ],
        methods: {
            /*Spine.Skin+SkinEntryComparer.System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinEntry$equals2 start.*/
            System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinEntry$equals2: function (e1, e2) {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntryComparer#System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinEntry$equals2", this ); }

                if (e1.SlotIndex !== e2.SlotIndex) {
                    return false;
                }
                if (!System.String.equals(e1.Name, e2.Name, 4)) {
                    return false;
                }
                return true;
            },
            /*Spine.Skin+SkinEntryComparer.System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinEntry$equals2 end.*/

            /*Spine.Skin+SkinEntryComparer.System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinEntry$getHashCode2 start.*/
            System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinEntry$getHashCode2: function (e) {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntryComparer#System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinEntry$getHashCode2", this ); }

                return ((Bridge.getHashCode(e.Name) + Bridge.Int.mul(e.SlotIndex, 37)) | 0);
            },
            /*Spine.Skin+SkinEntryComparer.System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinEntry$getHashCode2 end.*/


        }
    });
    /*Spine.Skin+SkinEntryComparer end.*/

    /*Spine.TrackEntry start.*/
    /**
     * <p>Stores settings and other state for the playback of an animation on an {@link } track.</p><p>References to a track entry must not be kept after the {@link } event occurs.</p>
     *
     * @public
     * @class Spine.TrackEntry
     * @implements  Spine.Pool$1.IPoolable
     */
    Bridge.define("Spine.TrackEntry", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#inherits", this ); }
 return [Spine.Pool$1.IPoolable(Spine.TrackEntry)]; },
        fields: {
            animation: null,
            next: null,
            mixingFrom: null,
            mixingTo: null,
            trackIndex: 0,
            loop: false,
            holdPrevious: false,
            eventThreshold: 0,
            attachmentThreshold: 0,
            drawOrderThreshold: 0,
            animationStart: 0,
            animationEnd: 0,
            animationLast: 0,
            nextAnimationLast: 0,
            delay: 0,
            trackTime: 0,
            trackLast: 0,
            nextTrackLast: 0,
            trackEnd: 0,
            timeScale: 0,
            alpha: 0,
            mixTime: 0,
            mixDuration: 0,
            interruptAlpha: 0,
            totalAlpha: 0,
            mixBlend: 0,
            timelineMode: null,
            timelineHoldMix: null,
            timelinesRotation: null
        },
        events: {
            Start: null,
            Interrupt: null,
            End: null,
            Dispose: null,
            Complete: null,
            Event: null
        },
        props: {
            /**
             * The index of the track where this entry is either current or queued.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TrackEntry
             * @function TrackIndex
             * @type number
             * @see {@link AnimationState.GetCurrent(int)}
             */
            TrackIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#TrackIndex#get", this ); }

                    return this.trackIndex;
                }
            },
            /**
             * The animation to apply for this track entry.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TrackEntry
             * @function Animation
             * @type Spine.Animation
             */
            Animation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Animation#get", this ); }

                    return this.animation;
                }
            },
            /**
             * If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its
             duration.
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function Loop
             * @type boolean
             */
            Loop: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Loop#get", this ); }

                    return this.loop;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Loop#set", this ); }

                    this.loop = value;
                }
            },
            /**
             * <p>Seconds to postpone playing the animation. When this track entry is the current track entry, <pre><code>Delay</code></pre>
             postpones incrementing the {@link }. When this track entry is queued, <pre><code>Delay</code></pre> is the time from
             the start of the previous animation to when this track entry will become the current track entry (ie when the previous
             track entry {@link } &gt;= this track entry's <pre><code>Delay</code></pre>).</p><p>{@link } affects the delay.</p>
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function Delay
             * @type number
             */
            Delay: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Delay#get", this ); }

                    return this.delay;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Delay#set", this ); }

                    this.delay = value;
                }
            },
            /**
             * Current time in seconds this track entry has been the current track entry. The track time determines
             {@link }. The track time can be set to start the animation at a time other than 0, without affecting
             looping.
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function TrackTime
             * @type number
             */
            TrackTime: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#TrackTime#get", this ); }

                    return this.trackTime;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#TrackTime#set", this ); }

                    this.trackTime = value;
                }
            },
            /**
             * <p>The track time in seconds when this animation will be removed from the track. Defaults to the highest possible float
             value, meaning the animation will be applied until a new animation is set or the track is cleared. If the track end time
             is reached, no other animations are queued for playback, and mixing from any previous animations is complete, then the
             properties keyed by the animation are set to the setup pose and the track is cleared.</p><p>It may be desired to use {@link }  rather than have the animation
             abruptly cease being applied.</p>
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function TrackEnd
             * @type number
             */
            TrackEnd: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#TrackEnd#get", this ); }

                    return this.trackEnd;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#TrackEnd#set", this ); }

                    this.trackEnd = value;
                }
            },
            
            AnimationStart: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AnimationStart#get", this ); }

                    return this.animationStart;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AnimationStart#set", this ); }

                    this.animationStart = value;
                }
            },
            /**
             * Seconds for the last frame of this animation. Non-looping animations won't play past this time. Looping animations will
             loop back to {@link } at this time. Defaults to the animation {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function AnimationEnd
             * @type number
             */
            AnimationEnd: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AnimationEnd#get", this ); }

                    return this.animationEnd;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AnimationEnd#set", this ); }

                    this.animationEnd = value;
                }
            },
            /**
             * The time in seconds this animation was last applied. Some timelines use this for one-time triggers. Eg, when this
             animation is applied, event timelines will fire all events between the <pre><code>AnimationLast</code></pre> time (exclusive) and
             <pre><code>AnimationTime</code></pre> (inclusive). Defaults to -1 to ensure triggers on frame 0 happen the first time this animation
             is applied.
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function AnimationLast
             * @type number
             */
            AnimationLast: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AnimationLast#get", this ); }

                    return this.animationLast;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AnimationLast#set", this ); }

                    this.animationLast = value;
                    this.nextAnimationLast = value;
                }
            },
            /**
             * Uses {@link } to compute the <pre><code>AnimationTime</code></pre>, which is between {@link }
             and {@link }. When the <pre><code>TrackTime</code></pre> is 0, the <pre><code>AnimationTime</code></pre> is equal to the
             <pre><code>AnimationStart</code></pre> time.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TrackEntry
             * @function AnimationTime
             * @type number
             */
            AnimationTime: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AnimationTime#get", this ); }

                    if (this.loop) {
                        var duration = this.animationEnd - this.animationStart;
                        if (duration === 0) {
                            return this.animationStart;
                        }
                        return (this.trackTime % duration) + this.animationStart;
                    }
                    return Math.min(this.trackTime + this.animationStart, this.animationEnd);
                }
            },
            
            TimeScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#TimeScale#get", this ); }

                    return this.timeScale;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#TimeScale#set", this ); }

                    this.timeScale = value;
                }
            },
            
            Alpha: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Alpha#get", this ); }

                    return this.alpha;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Alpha#set", this ); }

                    this.alpha = value;
                }
            },
            /**
             * When the mix percentage ({@link } / {@link }) is less than the
             <pre><code>EventThreshold</code></pre>, event timelines are applied while this animation is being mixed out. Defaults to 0, so event
             timelines are not applied while this animation is being mixed out.
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function EventThreshold
             * @type number
             */
            EventThreshold: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#EventThreshold#get", this ); }

                    return this.eventThreshold;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#EventThreshold#set", this ); }

                    this.eventThreshold = value;
                }
            },
            /**
             * When the mix percentage ({@link } / {@link }) is less than the
             <pre><code>AttachmentThreshold</code></pre>, attachment timelines are applied while this animation is being mixed out. Defaults to
             0, so attachment timelines are not applied while this animation is being mixed out.
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function AttachmentThreshold
             * @type number
             */
            AttachmentThreshold: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AttachmentThreshold#get", this ); }

                    return this.attachmentThreshold;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AttachmentThreshold#set", this ); }

                    this.attachmentThreshold = value;
                }
            },
            /**
             * When the mix percentage ({@link } / {@link }) is less than the
             <pre><code>DrawOrderThreshold</code></pre>, draw order timelines are applied while this animation is being mixed out. Defaults to 0,
             so draw order timelines are not applied while this animation is being mixed out.
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function DrawOrderThreshold
             * @type number
             */
            DrawOrderThreshold: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#DrawOrderThreshold#get", this ); }

                    return this.drawOrderThreshold;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#DrawOrderThreshold#set", this ); }

                    this.drawOrderThreshold = value;
                }
            },
            /**
             * The animation queued to start after this animation, or null. <pre><code>Next</code></pre> makes up a linked list.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TrackEntry
             * @function Next
             * @type Spine.TrackEntry
             */
            Next: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Next#get", this ); }

                    return this.next;
                }
            },
            /**
             * Returns true if at least one loop has been completed.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TrackEntry
             * @function IsComplete
             * @type boolean
             * @see {@link TrackEntry.Complete}
             */
            IsComplete: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#IsComplete#get", this ); }

                    return this.trackTime >= this.animationEnd - this.animationStart;
                }
            },
            /**
             * Seconds from 0 to the {@link } when mixing from the previous animation to this animation. May be
             slightly more than <pre><code>MixDuration</code></pre> when the mix is complete.
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function MixTime
             * @type number
             */
            MixTime: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixTime#get", this ); }

                    return this.mixTime;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixTime#set", this ); }

                    this.mixTime = value;
                }
            },
            /**
             * <p>Seconds for mixing from the previous animation to this animation. Defaults to the value provided by AnimationStateData
             {@link } based on the animation before this animation (if any).</p><p>The <pre><code>MixDuration</code></pre> can be set manually rather than use the value from
             {@link }. In that case, the <pre><code>MixDuration</code></pre> can be set for a new
              track entry only before {@link } is first called.</p><p>When using <seealso cref="AnimationState.AddAnimation(int, Animation, bool, float)" /> with a <pre><code>Delay</code></pre> &lt;= 0, note the
              {@link } is set using the mix duration from the {@link }, not a mix duration set
              afterward.</p>
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function MixDuration
             * @type number
             * @see {@link AnimationState.AddAnimation(int, Animation, bool, float)}
             */
            MixDuration: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixDuration#get", this ); }

                    return this.mixDuration;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixDuration#set", this ); }

                    this.mixDuration = value;
                }
            },
            /**
             * <p>Controls how properties keyed in the animation are mixed with lower tracks. Defaults to {@link }, which
             replaces the values from the lower tracks with the animation values. {@link } adds the animation values to
             the values from the lower tracks.</p><p>The <pre><code>MixBlend</code></pre> can be set for a new track entry only before {@link } is first
              called.</p>
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function MixBlend
             * @type Spine.MixBlend
             */
            MixBlend: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixBlend#get", this ); }

                    return this.mixBlend;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixBlend#set", this ); }

                    this.mixBlend = value;
                }
            },
            /**
             * The track entry for the previous animation when mixing from the previous animation to this animation, or null if no
             mixing is currently occuring. When mixing from multiple animations, <pre><code>MixingFrom</code></pre> makes up a linked list.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TrackEntry
             * @function MixingFrom
             * @type Spine.TrackEntry
             */
            MixingFrom: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixingFrom#get", this ); }

                    return this.mixingFrom;
                }
            },
            /**
             * The track entry for the next animation when mixing from this animation to the next animation, or null if no mixing is
             currently occuring. When mixing to multiple animations, <pre><code>MixingTo</code></pre> makes up a linked list.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TrackEntry
             * @function MixingTo
             * @type Spine.TrackEntry
             */
            MixingTo: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixingTo#get", this ); }

                    return this.mixingTo;
                }
            },
            /**
             * <p>If true, when mixing from the previous animation to this animation, the previous animation is applied as normal instead
             of being mixed out.</p><p>When mixing between animations that key the same property, if a lower track also keys that property then the value will
             briefly dip toward the lower track value during the mix. This happens because the first animation mixes from 100% to 0%
             while the second animation mixes from 0% to 100%. Setting <pre><code>HoldPrevious</code></pre> to true applies the first animation
             at 100% during the mix so the lower track value is overwritten. Such dipping does not occur on the lowest track which
             keys the property, only when a higher track also keys the property.</p><p>Snapping will occur if <pre><code>HoldPrevious</code></pre> is true and this animation does not key all the same properties as the
             previous animation.</p>
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function HoldPrevious
             * @type boolean
             */
            HoldPrevious: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#HoldPrevious#get", this ); }

                    return this.holdPrevious;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#HoldPrevious#set", this ); }

                    this.holdPrevious = value;
                }
            }
        },
        alias: ["Reset", "Spine$Pool$1$IPoolable$Spine$TrackEntry$Reset"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#init", this ); }

                this.timeScale = 1.0;
                this.mixBlend = Spine.MixBlend.Replace;
                this.timelineMode = new (Spine.ExposedList$1(System.Int32)).ctor();
                this.timelineHoldMix = new (Spine.ExposedList$1(Spine.TrackEntry)).ctor();
                this.timelinesRotation = new (Spine.ExposedList$1(System.Single)).ctor();
            }
        },
        methods: {
            /*Spine.TrackEntry.OnStart start.*/
            OnStart: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#OnStart", this ); }

                if (!Bridge.staticEquals(this.Start, null)) {
                    this.Start(this);
                }
            },
            /*Spine.TrackEntry.OnStart end.*/

            /*Spine.TrackEntry.OnInterrupt start.*/
            OnInterrupt: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#OnInterrupt", this ); }

                if (!Bridge.staticEquals(this.Interrupt, null)) {
                    this.Interrupt(this);
                }
            },
            /*Spine.TrackEntry.OnInterrupt end.*/

            /*Spine.TrackEntry.OnEnd start.*/
            OnEnd: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#OnEnd", this ); }

                if (!Bridge.staticEquals(this.End, null)) {
                    this.End(this);
                }
            },
            /*Spine.TrackEntry.OnEnd end.*/

            /*Spine.TrackEntry.OnDispose start.*/
            OnDispose: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#OnDispose", this ); }

                if (!Bridge.staticEquals(this.Dispose, null)) {
                    this.Dispose(this);
                }
            },
            /*Spine.TrackEntry.OnDispose end.*/

            /*Spine.TrackEntry.OnComplete start.*/
            OnComplete: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#OnComplete", this ); }

                if (!Bridge.staticEquals(this.Complete, null)) {
                    this.Complete(this);
                }
            },
            /*Spine.TrackEntry.OnComplete end.*/

            /*Spine.TrackEntry.OnEvent start.*/
            OnEvent: function (e) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#OnEvent", this ); }

                if (!Bridge.staticEquals(this.Event, null)) {
                    this.Event(this, e);
                }
            },
            /*Spine.TrackEntry.OnEvent end.*/

            /*Spine.TrackEntry.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Reset", this ); }

                this.next = null;
                this.mixingFrom = null;
                this.mixingTo = null;
                this.animation = null;
                // replaces 'listener = null;' since delegates are used for event callbacks
                this.Start = null;
                this.Interrupt = null;
                this.End = null;
                this.Dispose = null;
                this.Complete = null;
                this.Event = null;
                this.timelineMode.Clear();
                this.timelineHoldMix.Clear();
                this.timelinesRotation.Clear();
            },
            /*Spine.TrackEntry.Reset end.*/

            /*Spine.TrackEntry.ResetRotationDirections start.*/
            /**
             * <p>Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the
             long way around when using {@link } and starting animations on other tracks.</p><p>Mixing with {@link } involves finding a rotation between two others, which has two possible solutions:
             the short way or the long way around. The two rotations likely change over time, so which direction is the short or long
             way also changes. If the short way was always chosen, bones would flip to the other side when that direction became the
             long way. TrackEntry chooses the short way the first time it is applied and remembers that direction.</p>
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @return  {void}
             */
            ResetRotationDirections: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#ResetRotationDirections", this ); }

                this.timelinesRotation.Clear();
            },
            /*Spine.TrackEntry.ResetRotationDirections end.*/

            /*Spine.TrackEntry.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#toString", this ); }

                return this.animation == null ? "<none>" : this.animation.name;
            },
            /*Spine.TrackEntry.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.TrackEntry end.*/

    /*Spine.TransformConstraint start.*/
    /**
     * <p>Stores the current pose for a transform constraint. A transform constraint adjusts the world transform of the constrained
     bones to match that of the target bone.</p><p>See <a href="http://esotericsoftware.com/spine-transform-constraints">Transform constraints</a> in the Spine User Guide.</p>
     *
     * @public
     * @class Spine.TransformConstraint
     * @implements  Spine.IUpdatable
     */
    Bridge.define("Spine.TransformConstraint", {
        inherits: [Spine.IUpdatable],
        fields: {
            data: null,
            bones: null,
            target: null,
            rotateMix: 0,
            translateMix: 0,
            scaleMix: 0,
            shearMix: 0,
            active: false
        },
        props: {
            /**
             * The bones that will be modified by this transform constraint.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TransformConstraint
             * @function Bones
             * @type Spine.ExposedList$1
             */
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#Bones#get", this ); }

                    return this.bones;
                }
            },
            /**
             * The target bone whose world transform will be copied to the constrained bones.
             *
             * @instance
             * @public
             * @memberof Spine.TransformConstraint
             * @function Target
             * @type Spine.Bone
             */
            Target: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#Target#get", this ); }

                    return this.target;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#Target#set", this ); }

                    this.target = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained rotations.
             *
             * @instance
             * @public
             * @memberof Spine.TransformConstraint
             * @function RotateMix
             * @type number
             */
            RotateMix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#RotateMix#get", this ); }

                    return this.rotateMix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#RotateMix#set", this ); }

                    this.rotateMix = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained translations.
             *
             * @instance
             * @public
             * @memberof Spine.TransformConstraint
             * @function TranslateMix
             * @type number
             */
            TranslateMix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#TranslateMix#get", this ); }

                    return this.translateMix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#TranslateMix#set", this ); }

                    this.translateMix = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained scales.
             *
             * @instance
             * @public
             * @memberof Spine.TransformConstraint
             * @function ScaleMix
             * @type number
             */
            ScaleMix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#ScaleMix#get", this ); }

                    return this.scaleMix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#ScaleMix#set", this ); }

                    this.scaleMix = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained scales.
             *
             * @instance
             * @public
             * @memberof Spine.TransformConstraint
             * @function ShearMix
             * @type number
             */
            ShearMix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#ShearMix#get", this ); }

                    return this.shearMix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#ShearMix#set", this ); }

                    this.shearMix = value;
                }
            },
            Active: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#Active#get", this ); }

                    return this.active;
                }
            },
            /**
             * The transform constraint's setup pose data.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TransformConstraint
             * @function Data
             * @type Spine.TransformConstraintData
             */
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#Data#get", this ); }

                    return this.data;
                }
            }
        },
        alias: [
            "Update", "Spine$IUpdatable$Update",
            "Active", "Spine$IUpdatable$Active"
        ],
        ctors: {
            $ctor1: function (data, skeleton) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#$ctor1", this ); }

                var $t;
                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                }
                this.data = data;
                this.rotateMix = data.rotateMix;
                this.translateMix = data.translateMix;
                this.scaleMix = data.scaleMix;
                this.shearMix = data.shearMix;

                this.bones = new (Spine.ExposedList$1(Spine.Bone)).ctor();
                $t = Bridge.getEnumerator(data.bones);
                try {
                    while ($t.moveNext()) {
                        var boneData = $t.Current;
                        this.bones.Add(skeleton.FindBone(boneData.name));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                this.target = skeleton.FindBone(data.target.name);
            },
            /**
             * Copy constructor.
             *
             * @instance
             * @public
             * @this Spine.TransformConstraint
             * @memberof Spine.TransformConstraint
             * @param   {Spine.TransformConstraint}    constraint    
             * @param   {Spine.Skeleton}               skeleton
             * @return  {void}
             */
            ctor: function (constraint, skeleton) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#ctor", this ); }

                var $t, $t1, $t2;
                this.$initialize();
                if (constraint == null) {
                    throw new System.ArgumentNullException.$ctor1("constraint cannot be null.");
                }
                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor1("skeleton cannot be null.");
                }
                this.data = constraint.data;
                this.bones = new (Spine.ExposedList$1(Spine.Bone)).$ctor3(constraint.Bones.Count);
                $t = Bridge.getEnumerator(constraint.Bones);
                try {
                    while ($t.moveNext()) {
                        var bone = $t.Current;
                        this.bones.Add(($t1 = skeleton.Bones.Items)[bone.data.index]);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.target = ($t2 = skeleton.Bones.Items)[constraint.target.data.index];
                this.rotateMix = constraint.rotateMix;
                this.translateMix = constraint.translateMix;
                this.scaleMix = constraint.scaleMix;
                this.shearMix = constraint.shearMix;
            }
        },
        methods: {
            /*Spine.TransformConstraint.Apply start.*/
            /**
             * Applies the constraint to the constrained bones.
             *
             * @instance
             * @public
             * @this Spine.TransformConstraint
             * @memberof Spine.TransformConstraint
             * @return  {void}
             */
            Apply: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#Apply", this ); }

                this.Update();
            },
            /*Spine.TransformConstraint.Apply end.*/

            /*Spine.TransformConstraint.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#Update", this ); }

                if (this.data.local) {
                    if (this.data.relative) {
                        this.ApplyRelativeLocal();
                    } else {
                        this.ApplyAbsoluteLocal();
                    }
                } else {
                    if (this.data.relative) {
                        this.ApplyRelativeWorld();
                    } else {
                        this.ApplyAbsoluteWorld();
                    }
                }
            },
            /*Spine.TransformConstraint.Update end.*/

            /*Spine.TransformConstraint.ApplyAbsoluteWorld start.*/
            ApplyAbsoluteWorld: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#ApplyAbsoluteWorld", this ); }

                var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
                var target = this.target;
                var ta = target.a, tb = target.b, tc = target.c, td = target.d;
                var degRadReflect = ta * td - tb * tc > 0 ? Spine.MathUtils.DegRad : -0.0174532924;
                var offsetRotation = this.data.offsetRotation * degRadReflect, offsetShearY = this.data.offsetShearY * degRadReflect;
                var bones = this.bones;
                for (var i = 0, n = bones.Count; i < n; i = (i + 1) | 0) {
                    var bone = bones.Items[i];
                    var modified = false;

                    if (rotateMix !== 0) {
                        var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
                        var r = Spine.MathUtils.Atan2(tc, ta) - Spine.MathUtils.Atan2(c, a) + offsetRotation;
                        if (r > Spine.MathUtils.PI) {
                            r -= Spine.MathUtils.PI2;
                        } else {
                            if (r < -3.14159274) {
                                r += Spine.MathUtils.PI2;
                            }
                        }
                        r *= rotateMix;
                        var cos = Spine.MathUtils.Cos(r), sin = Spine.MathUtils.Sin(r);
                        bone.a = cos * a - sin * c;
                        bone.b = cos * b - sin * d;
                        bone.c = sin * a + cos * c;
                        bone.d = sin * b + cos * d;
                        modified = true;
                    }

                    if (translateMix !== 0) {
                        var tx = { }, ty = { }; //Vector2 temp = this.temp;
                        target.LocalToWorld(this.data.offsetX, this.data.offsetY, tx, ty); //target.localToWorld(temp.set(data.offsetX, data.offsetY));
                        bone.worldX += (tx.v - bone.worldX) * translateMix;
                        bone.worldY += (ty.v - bone.worldY) * translateMix;
                        modified = true;
                    }

                    if (scaleMix > 0) {
                        var s = Math.sqrt(bone.a * bone.a + bone.c * bone.c);
                        if (s !== 0) {
                            s = (s + (Math.sqrt(ta * ta + tc * tc) - s + this.data.offsetScaleX) * scaleMix) / s;
                        }
                        bone.a *= s;
                        bone.c *= s;
                        s = Math.sqrt(bone.b * bone.b + bone.d * bone.d);
                        if (s !== 0) {
                            s = (s + (Math.sqrt(tb * tb + td * td) - s + this.data.offsetScaleY) * scaleMix) / s;
                        }
                        bone.b *= s;
                        bone.d *= s;
                        modified = true;
                    }

                    if (shearMix > 0) {
                        var b1 = bone.b, d1 = bone.d;
                        var by = Spine.MathUtils.Atan2(d1, b1);
                        var r1 = Spine.MathUtils.Atan2(td, tb) - Spine.MathUtils.Atan2(tc, ta) - (by - Spine.MathUtils.Atan2(bone.c, bone.a));
                        if (r1 > Spine.MathUtils.PI) {
                            r1 -= Spine.MathUtils.PI2;
                        } else {
                            if (r1 < -3.14159274) {
                                r1 += Spine.MathUtils.PI2;
                            }
                        }
                        r1 = by + (r1 + offsetShearY) * shearMix;
                        var s1 = Math.sqrt(b1 * b1 + d1 * d1);
                        bone.b = Spine.MathUtils.Cos(r1) * s1;
                        bone.d = Spine.MathUtils.Sin(r1) * s1;
                        modified = true;
                    }

                    if (modified) {
                        bone.appliedValid = false;
                    }
                }
            },
            /*Spine.TransformConstraint.ApplyAbsoluteWorld end.*/

            /*Spine.TransformConstraint.ApplyRelativeWorld start.*/
            ApplyRelativeWorld: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#ApplyRelativeWorld", this ); }

                var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
                var target = this.target;
                var ta = target.a, tb = target.b, tc = target.c, td = target.d;
                var degRadReflect = ta * td - tb * tc > 0 ? Spine.MathUtils.DegRad : -0.0174532924;
                var offsetRotation = this.data.offsetRotation * degRadReflect, offsetShearY = this.data.offsetShearY * degRadReflect;
                var bones = this.bones;
                for (var i = 0, n = bones.Count; i < n; i = (i + 1) | 0) {
                    var bone = bones.Items[i];
                    var modified = false;

                    if (rotateMix !== 0) {
                        var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
                        var r = Spine.MathUtils.Atan2(tc, ta) + offsetRotation;
                        if (r > Spine.MathUtils.PI) {
                            r -= Spine.MathUtils.PI2;
                        } else {
                            if (r < -3.14159274) {
                                r += Spine.MathUtils.PI2;
                            }
                        }
                        r *= rotateMix;
                        var cos = Spine.MathUtils.Cos(r), sin = Spine.MathUtils.Sin(r);
                        bone.a = cos * a - sin * c;
                        bone.b = cos * b - sin * d;
                        bone.c = sin * a + cos * c;
                        bone.d = sin * b + cos * d;
                        modified = true;
                    }

                    if (translateMix !== 0) {
                        var tx = { }, ty = { }; //Vector2 temp = this.temp;
                        target.LocalToWorld(this.data.offsetX, this.data.offsetY, tx, ty); //target.localToWorld(temp.set(data.offsetX, data.offsetY));
                        bone.worldX += tx.v * translateMix;
                        bone.worldY += ty.v * translateMix;
                        modified = true;
                    }

                    if (scaleMix > 0) {
                        var s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;
                        bone.a *= s;
                        bone.c *= s;
                        s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;
                        bone.b *= s;
                        bone.d *= s;
                        modified = true;
                    }

                    if (shearMix > 0) {
                        var r1 = Spine.MathUtils.Atan2(td, tb) - Spine.MathUtils.Atan2(tc, ta);
                        if (r1 > Spine.MathUtils.PI) {
                            r1 -= Spine.MathUtils.PI2;
                        } else {
                            if (r1 < -3.14159274) {
                                r1 += Spine.MathUtils.PI2;
                            }
                        }
                        var b1 = bone.b, d1 = bone.d;
                        r1 = Spine.MathUtils.Atan2(d1, b1) + (r1 - 1.57079637 + offsetShearY) * shearMix;
                        var s1 = Math.sqrt(b1 * b1 + d1 * d1);
                        bone.b = Spine.MathUtils.Cos(r1) * s1;
                        bone.d = Spine.MathUtils.Sin(r1) * s1;
                        modified = true;
                    }

                    if (modified) {
                        bone.appliedValid = false;
                    }
                }
            },
            /*Spine.TransformConstraint.ApplyRelativeWorld end.*/

            /*Spine.TransformConstraint.ApplyAbsoluteLocal start.*/
            ApplyAbsoluteLocal: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#ApplyAbsoluteLocal", this ); }

                var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
                var target = this.target;
                if (!target.appliedValid) {
                    target.UpdateAppliedTransform();
                }
                var bonesItems = this.bones.Items;
                for (var i = 0, n = this.bones.Count; i < n; i = (i + 1) | 0) {
                    var bone = bonesItems[i];
                    if (!bone.appliedValid) {
                        bone.UpdateAppliedTransform();
                    }

                    var rotation = bone.arotation;
                    if (rotateMix !== 0) {
                        var r = target.arotation - rotation + this.data.offsetRotation;
                        r -= Bridge.Int.mul((((16384 - Bridge.Int.clip32((16384.499999999996 - r / 360))) | 0)), 360);
                        rotation += r * rotateMix;
                    }

                    var x = bone.ax, y = bone.ay;
                    if (translateMix !== 0) {
                        x += (target.ax - x + this.data.offsetX) * translateMix;
                        y += (target.ay - y + this.data.offsetY) * translateMix;
                    }

                    var scaleX = bone.ascaleX, scaleY = bone.ascaleY;
                    if (scaleMix !== 0) {
                        if (scaleX !== 0) {
                            scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;
                        }
                        if (scaleY !== 0) {
                            scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;
                        }
                    }

                    var shearY = bone.ashearY;
                    if (shearMix !== 0) {
                        var r1 = target.ashearY - shearY + this.data.offsetShearY;
                        r1 -= Bridge.Int.mul((((16384 - Bridge.Int.clip32((16384.499999999996 - r1 / 360))) | 0)), 360);
                        shearY += r1 * shearMix;
                    }

                    bone.UpdateWorldTransform$1(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
                }
            },
            /*Spine.TransformConstraint.ApplyAbsoluteLocal end.*/

            /*Spine.TransformConstraint.ApplyRelativeLocal start.*/
            ApplyRelativeLocal: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#ApplyRelativeLocal", this ); }

                var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
                var target = this.target;
                if (!target.appliedValid) {
                    target.UpdateAppliedTransform();
                }
                var bonesItems = this.bones.Items;
                for (var i = 0, n = this.bones.Count; i < n; i = (i + 1) | 0) {
                    var bone = bonesItems[i];
                    if (!bone.appliedValid) {
                        bone.UpdateAppliedTransform();
                    }

                    var rotation = bone.arotation;
                    if (rotateMix !== 0) {
                        rotation += (target.arotation + this.data.offsetRotation) * rotateMix;
                    }

                    var x = bone.ax, y = bone.ay;
                    if (translateMix !== 0) {
                        x += (target.ax + this.data.offsetX) * translateMix;
                        y += (target.ay + this.data.offsetY) * translateMix;
                    }

                    var scaleX = bone.ascaleX, scaleY = bone.ascaleY;
                    if (scaleMix !== 0) {
                        scaleX *= ((target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix) + 1;
                        scaleY *= ((target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix) + 1;
                    }

                    var shearY = bone.ashearY;
                    if (shearMix !== 0) {
                        shearY += (target.ashearY + this.data.offsetShearY) * shearMix;
                    }

                    bone.UpdateWorldTransform$1(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
                }
            },
            /*Spine.TransformConstraint.ApplyRelativeLocal end.*/

            /*Spine.TransformConstraint.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#toString", this ); }

                return this.data.name;
            },
            /*Spine.TransformConstraint.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.TransformConstraint end.*/

    /*Spine.TransformConstraintData start.*/
    Bridge.define("Spine.TransformConstraintData", {
        inherits: [Spine.ConstraintData],
        fields: {
            bones: null,
            target: null,
            rotateMix: 0,
            translateMix: 0,
            scaleMix: 0,
            shearMix: 0,
            offsetRotation: 0,
            offsetX: 0,
            offsetY: 0,
            offsetScaleX: 0,
            offsetScaleY: 0,
            offsetShearY: 0,
            relative: false,
            local: false
        },
        props: {
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#Bones#get", this ); }

                    return this.bones;
                }
            },
            Target: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#Target#get", this ); }

                    return this.target;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#Target#set", this ); }

                    this.target = value;
                }
            },
            RotateMix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#RotateMix#get", this ); }

                    return this.rotateMix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#RotateMix#set", this ); }

                    this.rotateMix = value;
                }
            },
            TranslateMix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#TranslateMix#get", this ); }

                    return this.translateMix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#TranslateMix#set", this ); }

                    this.translateMix = value;
                }
            },
            ScaleMix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#ScaleMix#get", this ); }

                    return this.scaleMix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#ScaleMix#set", this ); }

                    this.scaleMix = value;
                }
            },
            ShearMix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#ShearMix#get", this ); }

                    return this.shearMix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#ShearMix#set", this ); }

                    this.shearMix = value;
                }
            },
            OffsetRotation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetRotation#get", this ); }

                    return this.offsetRotation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetRotation#set", this ); }

                    this.offsetRotation = value;
                }
            },
            OffsetX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetX#get", this ); }

                    return this.offsetX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetX#set", this ); }

                    this.offsetX = value;
                }
            },
            OffsetY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetY#get", this ); }

                    return this.offsetY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetY#set", this ); }

                    this.offsetY = value;
                }
            },
            OffsetScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetScaleX#get", this ); }

                    return this.offsetScaleX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetScaleX#set", this ); }

                    this.offsetScaleX = value;
                }
            },
            OffsetScaleY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetScaleY#get", this ); }

                    return this.offsetScaleY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetScaleY#set", this ); }

                    this.offsetScaleY = value;
                }
            },
            OffsetShearY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetShearY#get", this ); }

                    return this.offsetShearY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetShearY#set", this ); }

                    this.offsetShearY = value;
                }
            },
            Relative: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#Relative#get", this ); }

                    return this.relative;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#Relative#set", this ); }

                    this.relative = value;
                }
            },
            Local: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#Local#get", this ); }

                    return this.local;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#Local#set", this ); }

                    this.local = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#init", this ); }

                this.bones = new (Spine.ExposedList$1(Spine.BoneData)).ctor();
            },
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#ctor", this ); }

                this.$initialize();
                Spine.ConstraintData.ctor.call(this, name);
            }
        }
    });
    /*Spine.TransformConstraintData end.*/

    /*Spine.Unity.AnimationReferenceAsset start.*/
    Bridge.define("Spine.Unity.AnimationReferenceAsset", {
        inherits: [UnityEngine.ScriptableObject,Spine.Unity.IHasSkeletonDataAsset],
        statics: {
            fields: {
                QuietSkeletonData: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#init", this ); }

                    this.QuietSkeletonData = true;
                }
            },
            methods: {
                op_Implicit: function (asset) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#op_Implicit", this ); }

                    return asset.Animation;
                }
            }
        },
        fields: {
            skeletonDataAsset: null,
            animationName: null,
            animation: null
        },
        props: {
            SkeletonDataAsset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#SkeletonDataAsset#get", this ); }

                    return this.skeletonDataAsset;
                }
            },
            Animation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#Animation#get", this ); }

                    if (this.animation == null) {
                        this.Initialize();
                    }

                    return this.animation;
                }
            }
        },
        alias: ["SkeletonDataAsset", "Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"],
        methods: {
            /*Spine.Unity.AnimationReferenceAsset.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#Initialize", this ); }

                if (this.skeletonDataAsset == null) {
                    return;
                }
                this.animation = this.skeletonDataAsset.GetSkeletonData(Spine.Unity.AnimationReferenceAsset.QuietSkeletonData).FindAnimation(this.animationName);
                if (this.animation == null) {
                    UnityEngine.Debug.LogWarningFormat("Animation '{0}' not found in SkeletonData : {1}.", [this.animationName, this.skeletonDataAsset.name]);
                }
            },
            /*Spine.Unity.AnimationReferenceAsset.Initialize end.*/


        }
    });
    /*Spine.Unity.AnimationReferenceAsset end.*/

    /*Spine.Unity.BlendModeMaterialsAsset start.*/
    Bridge.define("Spine.Unity.BlendModeMaterialsAsset", {
        inherits: [Spine.Unity.SkeletonDataModifierAsset],
        statics: {
            methods: {
                /*Spine.Unity.BlendModeMaterialsAsset.ApplyMaterials:static start.*/
                ApplyMaterials: function (skeletonData, multiplyTemplate, screenTemplate, additiveTemplate, includeAdditiveSlots) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset#ApplyMaterials", this ); }

                    var $t, $t1;
                    if (skeletonData == null) {
                        throw new System.ArgumentNullException.$ctor1("skeletonData");
                    }

                    var materialCache = new Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache();
                    try {
                        var entryBuffer = new (System.Collections.Generic.List$1(Spine.Skin.SkinEntry)).ctor();
                        var slotsItems = skeletonData.Slots.Items;
                        for (var slotIndex = 0, slotCount = skeletonData.Slots.Count; slotIndex < slotCount; slotIndex = (slotIndex + 1) | 0) {
                            var slot = slotsItems[slotIndex];
                            if (slot.blendMode === Spine.BlendMode.Normal) {
                                continue;
                            }
                            if (!includeAdditiveSlots && slot.blendMode === Spine.BlendMode.Additive) {
                                continue;
                            }

                            entryBuffer.clear();
                            $t = Bridge.getEnumerator(skeletonData.Skins);
                            try {
                                while ($t.moveNext()) {
                                    var skin = $t.Current;
                                    skin.GetAttachments$1(slotIndex, entryBuffer);
                                }
                            } finally {
                                if (Bridge.is($t, System.IDisposable)) {
                                    $t.System$IDisposable$Dispose();
                                }
                            }

                            var templateMaterial = null;
                            switch (slot.blendMode) {
                                case Spine.BlendMode.Multiply: 
                                    templateMaterial = multiplyTemplate;
                                    break;
                                case Spine.BlendMode.Screen: 
                                    templateMaterial = screenTemplate;
                                    break;
                                case Spine.BlendMode.Additive: 
                                    templateMaterial = additiveTemplate;
                                    break;
                            }
                            if (templateMaterial == null) {
                                continue;
                            }

                            $t1 = Bridge.getEnumerator(entryBuffer);
                            try {
                                while ($t1.moveNext()) {
                                    var entry = $t1.Current;
                                    var renderableAttachment = Bridge.as(entry.Attachment, Spine.IHasRendererObject);
                                    if (renderableAttachment != null) {
                                        renderableAttachment.Spine$IHasRendererObject$RendererObject = materialCache.CloneAtlasRegionWithMaterial(Bridge.cast(renderableAttachment.Spine$IHasRendererObject$RendererObject, Spine.AtlasRegion), templateMaterial);
                                    }
                                }
                            } finally {
                                if (Bridge.is($t1, System.IDisposable)) {
                                    $t1.System$IDisposable$Dispose();
                                }
                            }
                        }

                    }
                    finally {
                        if (Bridge.hasValue(materialCache)) {
                            materialCache.System$IDisposable$Dispose();
                        }
                    }
                    //attachmentBuffer.Clear();
                },
                /*Spine.Unity.BlendModeMaterialsAsset.ApplyMaterials:static end.*/


            }
        },
        fields: {
            multiplyMaterialTemplate: null,
            screenMaterialTemplate: null,
            additiveMaterialTemplate: null,
            applyAdditiveMaterial: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset#init", this ); }

                this.applyAdditiveMaterial = true;
            }
        },
        methods: {
            /*Spine.Unity.BlendModeMaterialsAsset.Apply start.*/
            Apply: function (skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset#Apply", this ); }

                Spine.Unity.BlendModeMaterialsAsset.ApplyMaterials(skeletonData, this.multiplyMaterialTemplate, this.screenMaterialTemplate, this.additiveMaterialTemplate, this.applyAdditiveMaterial);
            },
            /*Spine.Unity.BlendModeMaterialsAsset.Apply end.*/


        }
    });
    /*Spine.Unity.BlendModeMaterialsAsset end.*/

    /*Spine.Unity.MaterialsTextureLoader start.*/
    Bridge.define("Spine.Unity.MaterialsTextureLoader", {
        inherits: [Spine.TextureLoader],
        fields: {
            atlasAsset: null
        },
        alias: [
            "Load", "Spine$TextureLoader$Load",
            "Unload", "Spine$TextureLoader$Unload"
        ],
        ctors: {
            ctor: function (atlasAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.MaterialsTextureLoader#ctor", this ); }

                this.$initialize();
                this.atlasAsset = atlasAsset;
            }
        },
        methods: {
            /*Spine.Unity.MaterialsTextureLoader.Load start.*/
            Load: function (page, path) {
if ( TRACE ) { TRACE( "Spine.Unity.MaterialsTextureLoader#Load", this ); }

                var $t;
                var name = System.IO.Path.GetFileNameWithoutExtension(path);
                var material = null;
                $t = Bridge.getEnumerator(this.atlasAsset.materials);
                try {
                    while ($t.moveNext()) {
                        var other = $t.Current;
                        if (other.mainTexture == null) {
                            UnityEngine.Debug.LogError$2("Material is missing texture: " + (other.name || ""), other);
                            return;
                        }
                        if (Bridge.referenceEquals(other.mainTexture.name, name)) {
                            material = other;
                            break;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                if (material == null) {
                    UnityEngine.Debug.LogError$2("Material with texture name \"" + (name || "") + "\" not found for atlas asset: " + (this.atlasAsset.name || ""), this.atlasAsset);
                    return;
                }
                page.rendererObject = material;

                // Very old atlas files expected the texture's actual size to be used at runtime.
                if (page.width === 0 || page.height === 0) {
                    page.width = material.mainTexture.width;
                    page.height = material.mainTexture.height;
                }
            },
            /*Spine.Unity.MaterialsTextureLoader.Load end.*/

            /*Spine.Unity.MaterialsTextureLoader.Unload start.*/
            Unload: function (texture) {
if ( TRACE ) { TRACE( "Spine.Unity.MaterialsTextureLoader#Unload", this ); }
 },
            /*Spine.Unity.MaterialsTextureLoader.Unload end.*/


        }
    });
    /*Spine.Unity.MaterialsTextureLoader end.*/

    /*Spine.Unity.PointFollower start.*/
    Bridge.define("Spine.Unity.PointFollower", {
        inherits: [UnityEngine.MonoBehaviour,Spine.Unity.IHasSkeletonRenderer,Spine.Unity.IHasSkeletonComponent],
        fields: {
            skeletonRenderer: null,
            slotName: null,
            pointAttachmentName: null,
            followRotation: false,
            followSkeletonFlip: false,
            followSkeletonZPosition: false,
            skeletonTransform: null,
            skeletonTransformIsParent: false,
            point: null,
            bone: null,
            valid: false
        },
        props: {
            SkeletonRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#SkeletonRenderer#get", this ); }

                    return this.skeletonRenderer;
                }
            },
            SkeletonComponent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#SkeletonComponent#get", this ); }

                    return Bridge.as(this.skeletonRenderer, Spine.Unity.ISkeletonComponent);
                }
            },
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#IsValid#get", this ); }

                    return this.valid;
                }
            }
        },
        alias: [
            "SkeletonRenderer", "Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer",
            "SkeletonComponent", "Spine$Unity$IHasSkeletonComponent$SkeletonComponent"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#init", this ); }

                this.followRotation = true;
                this.followSkeletonFlip = true;
                this.followSkeletonZPosition = false;
            }
        },
        methods: {
            /*Spine.Unity.PointFollower.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#Initialize", this ); }

                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) && this.skeletonRenderer.valid;
                if (!this.valid) {
                    return;
                }

                this.UpdateReferences();

            },
            /*Spine.Unity.PointFollower.Initialize end.*/

            /*Spine.Unity.PointFollower.HandleRebuildRenderer start.*/
            HandleRebuildRenderer: function (skeletonRenderer) {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#HandleRebuildRenderer", this ); }

                this.Initialize();
            },
            /*Spine.Unity.PointFollower.HandleRebuildRenderer end.*/

            /*Spine.Unity.PointFollower.UpdateReferences start.*/
            UpdateReferences: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#UpdateReferences", this ); }

                var $t;
                this.skeletonTransform = this.skeletonRenderer.transform;
                this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonTransformIsParent = Bridge.referenceEquals(this.skeletonTransform, this.transform.parent);

                this.bone = null;
                this.point = null;
                if (!System.String.isNullOrEmpty(this.pointAttachmentName)) {
                    var skeleton = this.skeletonRenderer.Skeleton;

                    var slotIndex = skeleton.FindSlotIndex(this.slotName);
                    if (slotIndex >= 0) {
                        var slot = ($t = skeleton.slots.Items)[slotIndex];
                        this.bone = slot.bone;
                        this.point = Bridge.as(skeleton.GetAttachment(slotIndex, this.pointAttachmentName), Spine.PointAttachment);
                    }
                }
            },
            /*Spine.Unity.PointFollower.UpdateReferences end.*/

            /*Spine.Unity.PointFollower.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#OnDestroy", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                }
            },
            /*Spine.Unity.PointFollower.OnDestroy end.*/

            /*Spine.Unity.PointFollower.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#LateUpdate", this ); }

                var $t;

                if (this.point == null) {
                    if (System.String.isNullOrEmpty(this.pointAttachmentName)) {
                        return;
                    }
                    this.UpdateReferences();
                    if (this.point == null) {
                        return;
                    }
                }

                var worldPos = new UnityEngine.Vector2();
                this.point.ComputeWorldPosition(this.bone, Bridge.ref(worldPos, "x"), Bridge.ref(worldPos, "y"));
                var rotation = this.point.ComputeWorldRotation(this.bone);

                var thisTransform = this.transform;
                if (this.skeletonTransformIsParent) {
                    // Recommended setup: Use local transform properties if Spine GameObject is the immediate parent
                    thisTransform.localPosition = new pc.Vec3( worldPos.x, worldPos.y, this.followSkeletonZPosition ? 0.0 : thisTransform.localPosition.z );
                    if (this.followRotation) {
                        var halfRotation = rotation * 0.5 * UnityEngine.Mathf.Deg2Rad;

                        var q = Bridge.getDefaultValue(UnityEngine.Quaternion);
                        q.z = Math.sin(halfRotation);
                        q.w = Math.cos(halfRotation);
                        thisTransform.localRotation = q.$clone();
                    }
                } else {
                    // For special cases: Use transform world properties if transform relationship is complicated
                    var targetWorldPosition = this.skeletonTransform.TransformPoint$1(new pc.Vec3( worldPos.x, worldPos.y, 0.0 ));
                    if (!this.followSkeletonZPosition) {
                        targetWorldPosition.z = thisTransform.position.z;
                    }

                    var transformParent = thisTransform.parent;
                    if (UnityEngine.Component.op_Inequality(transformParent, null)) {
                        var m = transformParent.localToWorldMatrix.$clone();
                        if (m.e00 * m.e11 - m.e01 * m.e10 < 0) {
                            rotation = -rotation;
                        }
                    }

                    if (this.followRotation) {
                        var transformWorldRotation = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                        thisTransform.SetPositionAndRotation(targetWorldPosition.$clone(), new pc.Quat().setFromEulerAngles_Unity( transformWorldRotation.x, transformWorldRotation.y, transformWorldRotation.z + rotation ));
                    } else {
                        thisTransform.position = targetWorldPosition.$clone();
                    }
                }

                if (this.followSkeletonFlip) {
                    var localScale = thisTransform.localScale.$clone();
                    localScale.y = Math.abs(localScale.y) * ($t = this.bone.skeleton.ScaleX * this.bone.skeleton.ScaleY, ($t === 0 ? 1 : Math.sign($t)));
                    thisTransform.localScale = localScale.$clone();
                }
            },
            /*Spine.Unity.PointFollower.LateUpdate end.*/


        }
    });
    /*Spine.Unity.PointFollower end.*/

    /*Spine.Unity.RegionlessAttachmentLoader start.*/
    Bridge.define("Spine.Unity.RegionlessAttachmentLoader", {
        inherits: [Spine.AttachmentLoader],
        statics: {
            fields: {
                emptyRegion: null
            },
            props: {
                EmptyRegion: {
                    get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#EmptyRegion#get", this ); }

                        var $t, $t1, $t2;
                        if (Spine.Unity.RegionlessAttachmentLoader.emptyRegion == null) {
                            Spine.Unity.RegionlessAttachmentLoader.emptyRegion = ($t = new Spine.AtlasRegion(), $t.name = "Empty AtlasRegion", $t.page = ($t1 = new Spine.AtlasPage(), $t1.name = "Empty AtlasPage", $t1.rendererObject = ($t2 = new UnityEngine.Material.$ctor2(UnityEngine.Shader.Find("Spine/Special/HiddenPass")), $t2.name = "NoRender Material", $t2), $t1), $t);
                        }
                        return Spine.Unity.RegionlessAttachmentLoader.emptyRegion;
                    }
                }
            }
        },
        alias: [
            "NewRegionAttachment", "Spine$AttachmentLoader$NewRegionAttachment",
            "NewMeshAttachment", "Spine$AttachmentLoader$NewMeshAttachment",
            "NewBoundingBoxAttachment", "Spine$AttachmentLoader$NewBoundingBoxAttachment",
            "NewPathAttachment", "Spine$AttachmentLoader$NewPathAttachment",
            "NewPointAttachment", "Spine$AttachmentLoader$NewPointAttachment",
            "NewClippingAttachment", "Spine$AttachmentLoader$NewClippingAttachment"
        ],
        methods: {
            /*Spine.Unity.RegionlessAttachmentLoader.NewRegionAttachment start.*/
            NewRegionAttachment: function (skin, name, path) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewRegionAttachment", this ); }

                var $t;
                var attachment = ($t = new Spine.RegionAttachment(name), $t.RendererObject = Spine.Unity.RegionlessAttachmentLoader.EmptyRegion, $t);
                return attachment;
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewRegionAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewMeshAttachment start.*/
            NewMeshAttachment: function (skin, name, path) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewMeshAttachment", this ); }

                var $t;
                var attachment = ($t = new Spine.MeshAttachment(name), $t.RendererObject = Spine.Unity.RegionlessAttachmentLoader.EmptyRegion, $t);
                return attachment;
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewMeshAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewBoundingBoxAttachment start.*/
            NewBoundingBoxAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewBoundingBoxAttachment", this ); }

                return new Spine.BoundingBoxAttachment(name);
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewBoundingBoxAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewPathAttachment start.*/
            NewPathAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewPathAttachment", this ); }

                return new Spine.PathAttachment(name);
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewPathAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewPointAttachment start.*/
            NewPointAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewPointAttachment", this ); }

                return new Spine.PointAttachment(name);
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewPointAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewClippingAttachment start.*/
            NewClippingAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewClippingAttachment", this ); }

                return new Spine.ClippingAttachment(name);
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewClippingAttachment end.*/


        }
    });
    /*Spine.Unity.RegionlessAttachmentLoader end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonRenderer.InstructionDelegate
     * @param   {Spine.Unity.SkeletonRendererInstruction}    instruction
     * @return  {void}
     */

    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.MeshGeneratorDelegate
     * @param   {Spine.Unity.MeshGeneratorBuffers}    buffers
     * @return  {void}
     */


    /*Spine.Unity.SkeletonRenderer start.*/
    /**
     * Base class of animated Spine skeleton components. This component manages and renders a skeleton.
     *
     * @public
     * @class Spine.Unity.SkeletonRenderer
     * @augments UnityEngine.MonoBehaviour
     * @implements  Spine.Unity.ISkeletonComponent
     * @implements  Spine.Unity.IHasSkeletonDataAsset
     */
    Bridge.define("Spine.Unity.SkeletonRenderer", {
        inherits: [UnityEngine.MonoBehaviour,Spine.Unity.ISkeletonComponent,Spine.Unity.IHasSkeletonDataAsset],
        statics: {
            fields: {
                /**
                 * Shader property value used as Stencil comparison function for {@link }.
                 *
                 * @static
                 * @public
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @constant
                 * @default 8
                 * @type UnityEngine.Rendering.CompareFunction
                 */
                STENCIL_COMP_MASKINTERACTION_NONE: 0,
                /**
                 * Shader property value used as Stencil comparison function for {@link }.
                 *
                 * @static
                 * @public
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @constant
                 * @default 4
                 * @type UnityEngine.Rendering.CompareFunction
                 */
                STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE: 0,
                /**
                 * Shader property value used as Stencil comparison function for {@link }.
                 *
                 * @static
                 * @public
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @constant
                 * @default 5
                 * @type UnityEngine.Rendering.CompareFunction
                 */
                STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE: 0,
                /**
                 * Shader property ID used for the Stencil comparison function.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @type number
                 */
                STENCIL_COMP_PARAM_ID: 0,
                SUBMESH_DUMMY_PARAM_ID: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#init", this ); }

                    this.STENCIL_COMP_MASKINTERACTION_NONE = UnityEngine.Rendering.CompareFunction.Always;
                    this.STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE = UnityEngine.Rendering.CompareFunction.LessEqual;
                    this.STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE = UnityEngine.Rendering.CompareFunction.Greater;
                    this.STENCIL_COMP_PARAM_ID = UnityEngine.Shader.PropertyToID("_StencilComp");
                    this.SUBMESH_DUMMY_PARAM_ID = UnityEngine.Shader.PropertyToID("_Submesh");
                }
            },
            methods: {
                /*Spine.Unity.SkeletonRenderer.NewSpineGameObject:static start.*/
                NewSpineGameObject: function (T, skeletonDataAsset, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#NewSpineGameObject", this ); }

                    if (quiet === void 0) { quiet = false; }
                    return Spine.Unity.SkeletonRenderer.AddSpineComponent(T, new UnityEngine.GameObject.$ctor2("New Spine GameObject"), skeletonDataAsset, quiet);
                },
                /*Spine.Unity.SkeletonRenderer.NewSpineGameObject:static end.*/

                /*Spine.Unity.SkeletonRenderer.AddSpineComponent:static start.*/
                /**
                 * Add and prepare a Spine component that derives from SkeletonRenderer to a GameObject at runtime.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonRenderer
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @param   {Function}                         T                    T should be SkeletonRenderer or any of its derived classes.
                 * @param   {UnityEngine.GameObject}           gameObject           
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {boolean}                          quiet
                 * @return  {T}
                 */
                AddSpineComponent: function (T, gameObject, skeletonDataAsset, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#AddSpineComponent", this ); }

                    if (quiet === void 0) { quiet = false; }
                    var c = Bridge.rValue(gameObject.AddComponent(T));
                    if (skeletonDataAsset != null) {
Bridge.rValue(                        c).skeletonDataAsset = skeletonDataAsset;
Bridge.rValue(                        c).Initialize(false, quiet);
                    }
                    return Bridge.rValue(c);
                },
                /*Spine.Unity.SkeletonRenderer.AddSpineComponent:static end.*/


            }
        },
        fields: {
            skeletonDataAsset: null,
            /**
             * Skin name to use when the Skeleton is initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type string
             */
            initialSkinName: null,
            /**
             * Enable this parameter when overwriting the Skeleton's skin from an editor script.
             Otherwise any changes will be overwritten by the next inspector update.
             * Flip X and Y to use when the Skeleton is initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type boolean
             */
            initialFlipX: false,
            /**
             * Enable this parameter when overwriting the Skeleton's skin from an editor script.
             Otherwise any changes will be overwritten by the next inspector update.
             * Flip X and Y to use when the Skeleton is initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type boolean
             */
            initialFlipY: false,
            updateMode: 0,
            /**
             * Update mode used when the MeshRenderer becomes invisible
             (when <pre><code>OnBecameInvisible()</code></pre> is called). Update mode is automatically
             reset to <pre><code>UpdateMode.FullUpdate</code></pre> when the mesh becomes visible again.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type Spine.Unity.UpdateMode
             */
            updateWhenInvisible: 0,
            /**
             * Slot names used to populate separatorSlots list when the Skeleton is initialized. Changing this after initialization does nothing.
             *
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonRenderer
             * @type Array.<string>
             */
            separatorSlotNames: null,
            /**
             * Slots that determine where the render is split. This is used by components such as SkeletonRenderSeparator so that the skeleton can be rendered by two separate renderers on different GameObjects.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRenderer
             * @type System.Collections.Generic.List$1
             */
            separatorSlots: null,
            zSpacing: 0,
            /**
             * Use Spine's clipping feature. If false, ClippingAttachments will be ignored.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default true
             * @type boolean
             */
            useClipping: false,
            /**
             * If true, triangles will not be updated. Enable this as an optimization if the skeleton does not make use of attachment swapping or hiding, or draw order keys. Otherwise, setting this to false may cause errors in rendering.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            immutableTriangles: false,
            /**
             * Multiply vertex color RGB with vertex color alpha. Set this to true if the shader used for rendering is a premultiplied alpha shader. Setting this to false disables single-batch additive slots.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default true
             * @type boolean
             */
            pmaVertexColors: false,
            /**
             * Clears the state of the render and skeleton when this component or its GameObject is disabled. This prevents previous state from being retained when it is enabled again. When pooling your skeleton, setting this to true can be helpful.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            clearStateOnDisable: false,
            /**
             * If true, second colors on slots will be added to the output Mesh as UV2 and UV3. A special "tint black" shader that interprets UV2 and UV3 as black point colors is required to render this properly.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            tintBlack: false,
            /**
             * If true, the renderer assumes the skeleton only requires one Material and one submesh to render. This allows the MeshGenerator to skip checking for changes in Materials. Enable this as an optimization if the skeleton only uses one Material.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            singleSubmesh: false,
            /**
             * Applies only when 3+ submeshes are used (2+ materials with alternating order, e.g. "A B A").
             If true, GPU instancing is disabled at all materials and MaterialPropertyBlocks are assigned at each
             material to prevent aggressive batching of submeshes by e.g. the LWRP renderer, leading to incorrect
             draw order (e.g. "A1 B A2" changed to "A1A2 B").
             You can disable this parameter when everything is drawn correctly to save the additional performance cost.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            fixDrawOrder: false,
            /**
             * If true, the mesh generator adds normals to the output mesh. For better performance and reduced memory requirements, use a shader that assumes the desired normal.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            addNormals: false,
            /**
             * If true, tangents are calculated every frame and added to the Mesh. Enable this when using a shader that uses lighting that requires tangents.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            calculateTangents: false,
            /**
             * This enum controls the mode under which the sprite will interact with the masking system.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type UnityEngine.SpriteMaskInteraction
             */
            maskInteraction: 0,
            /**
             * Material references for switching material sets at runtime when {@link } changes.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
             */
            maskMaterials: null,
            disableRenderingOnOverride: false,
            customMaterialOverride: null,
            customSlotMaterials: null,
            currentInstructions: null,
            meshGenerator: null,
            rendererBuffers: null,
            meshRenderer: null,
            meshFilter: null,
            valid: false,
            skeleton: null,
            reusedPropertyBlock: null
        },
        events: {
            generateMeshOverride: null,
            /**
             * Occurs after the vertex data is populated every frame, before the vertices are pushed into the mesh.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function addOnPostProcessVertices
             * @param   {Spine.Unity.MeshGeneratorDelegate}    value
             * @return  {void}
             */
            /**
             * Occurs after the vertex data is populated every frame, before the vertices are pushed into the mesh.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function removeOnPostProcessVertices
             * @param   {Spine.Unity.MeshGeneratorDelegate}    value
             * @return  {void}
             */
            OnPostProcessVertices: null,
            /**
             * OnRebuild is raised after the Skeleton is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function addOnRebuild
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnRebuild is raised after the Skeleton is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function removeOnRebuild
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnRebuild: null,
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function addOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function removeOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnMeshAndMaterialsUpdated: null
        },
        props: {
            /**
             * Update mode to optionally limit updates to e.g. only apply animations but not update the mesh.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @function UpdateMode
             * @type Spine.Unity.UpdateMode
             */
            UpdateMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#UpdateMode#get", this ); }

                    return this.updateMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#UpdateMode#set", this ); }

                    this.updateMode = value;
                }
            },
            /**
             * Use this Dictionary to override a Material with a different Material.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRenderer
             * @function CustomMaterialOverride
             * @type System.Collections.Generic.Dictionary$2
             */
            CustomMaterialOverride: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#CustomMaterialOverride#get", this ); }

                    return this.customMaterialOverride;
                }
            },
            /**
             * Use this Dictionary to use a different Material to render specific Slots.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRenderer
             * @function CustomSlotMaterials
             * @type System.Collections.Generic.Dictionary$2
             */
            CustomSlotMaterials: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#CustomSlotMaterials#get", this ); }

                    return this.customSlotMaterials;
                }
            },
            Skeleton: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#Skeleton#get", this ); }

                    this.Initialize(false);
                    return this.skeleton;
                }
            },
            SkeletonDataAsset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#SkeletonDataAsset#get", this ); }

                    return this.skeletonDataAsset;
                }
            }
        },
        alias: [
            "Skeleton", "Spine$Unity$ISkeletonComponent$Skeleton",
            "SkeletonDataAsset", "Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset",
            "SkeletonDataAsset", "Spine$Unity$ISkeletonComponent$SkeletonDataAsset"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#init", this ); }

                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                this.updateWhenInvisible = Spine.Unity.UpdateMode.FullUpdate;
                this.separatorSlotNames = System.Array.init(0, null, System.String);
                this.separatorSlots = new (System.Collections.Generic.List$1(Spine.Slot)).ctor();
                this.useClipping = true;
                this.immutableTriangles = false;
                this.pmaVertexColors = true;
                this.clearStateOnDisable = false;
                this.tintBlack = false;
                this.singleSubmesh = false;
                this.fixDrawOrder = false;
                this.addNormals = false;
                this.calculateTangents = false;
                this.maskInteraction = UnityEngine.SpriteMaskInteraction.None;
                this.maskMaterials = new Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials();
                this.disableRenderingOnOverride = true;
                this.customMaterialOverride = new (System.Collections.Generic.Dictionary$2(UnityEngine.Material,UnityEngine.Material)).ctor();
                this.customSlotMaterials = new (System.Collections.Generic.Dictionary$2(Spine.Slot,UnityEngine.Material)).ctor();
                this.currentInstructions = new Spine.Unity.SkeletonRendererInstruction();
                this.meshGenerator = new Spine.Unity.MeshGenerator();
                this.rendererBuffers = new Spine.Unity.MeshRendererBuffers();
            }
        },
        methods: {
            /**
             * Allows separate code to take over rendering for this SkeletonRenderer component. The subscriber is passed a SkeletonRendererInstruction argument to determine how to render a skeleton.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @event Spine.Unity.SkeletonRenderer#GenerateMeshOverride
             * @return  {Spine.Unity.SkeletonRenderer.InstructionDelegate}
             */
            addGenerateMeshOverride: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#addGenerateMeshOverride", this ); }

                this.addgenerateMeshOverride(value);
                if (this.disableRenderingOnOverride && !Bridge.staticEquals(this.generateMeshOverride, null)) {
                    this.Initialize(false);
                    if (UnityEngine.Object.op_Implicit(this.meshRenderer)) {
                        this.meshRenderer.enabled = false;
                    }
                }
            },
            /**
             * Allows separate code to take over rendering for this SkeletonRenderer component. The subscriber is passed a SkeletonRendererInstruction argument to determine how to render a skeleton.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @event Spine.Unity.SkeletonRenderer#GenerateMeshOverride
             * @return  {Spine.Unity.SkeletonRenderer.InstructionDelegate}
             */
            removeGenerateMeshOverride: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#removeGenerateMeshOverride", this ); }

                this.removegenerateMeshOverride(value);
                if (this.disableRenderingOnOverride && Bridge.staticEquals(this.generateMeshOverride, null)) {
                    this.Initialize(false);
                    if (UnityEngine.Object.op_Implicit(this.meshRenderer)) {
                        this.meshRenderer.enabled = true;
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderer.SetMeshSettings start.*/
            /**
             * Applies MeshGenerator settings to the SkeletonRenderer and its internal MeshGenerator.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @param   {Spine.Unity.MeshGenerator.Settings}    settings
             * @return  {void}
             */
            SetMeshSettings: function (settings) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#SetMeshSettings", this ); }

                this.calculateTangents = settings.calculateTangents;
                this.immutableTriangles = settings.immutableTriangles;
                this.pmaVertexColors = settings.pmaVertexColors;
                this.tintBlack = settings.tintBlack;
                this.useClipping = settings.useClipping;
                this.zSpacing = settings.zSpacing;

                this.meshGenerator.settings = settings.$clone();
            },
            /*Spine.Unity.SkeletonRenderer.SetMeshSettings end.*/

            /*Spine.Unity.SkeletonRenderer.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#Awake", this ); }

                this.Initialize(false);
                this.updateMode = this.updateWhenInvisible;
            },
            /*Spine.Unity.SkeletonRenderer.Awake end.*/

            /*Spine.Unity.SkeletonRenderer.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#OnDisable", this ); }

                if (this.clearStateOnDisable && this.valid) {
                    this.ClearState();
                }
            },
            /*Spine.Unity.SkeletonRenderer.OnDisable end.*/

            /*Spine.Unity.SkeletonRenderer.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#OnDestroy", this ); }

                this.rendererBuffers.Dispose();
                this.valid = false;
            },
            /*Spine.Unity.SkeletonRenderer.OnDestroy end.*/

            /*Spine.Unity.SkeletonRenderer.ClearState start.*/
            /**
             * Clears the previously generated mesh and resets the skeleton's pose.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @return  {void}
             */
            ClearState: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#ClearState", this ); }

                var meshFilter = this.GetComponent(UnityEngine.MeshFilter);
                if (UnityEngine.Component.op_Inequality(meshFilter, null)) {
                    meshFilter.sharedMesh = null;
                }
                this.currentInstructions.Clear();
                if (this.skeleton != null) {
                    this.skeleton.SetToSetupPose();
                }
            },
            /*Spine.Unity.SkeletonRenderer.ClearState end.*/

            /*Spine.Unity.SkeletonRenderer.EnsureMeshGeneratorCapacity start.*/
            /**
             * Sets a minimum buffer size for the internal MeshGenerator to prevent excess allocations during animation.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @param   {number}    minimumVertexCount
             * @return  {void}
             */
            EnsureMeshGeneratorCapacity: function (minimumVertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#EnsureMeshGeneratorCapacity", this ); }

                this.meshGenerator.EnsureVertexCapacity(minimumVertexCount);
            },
            /*Spine.Unity.SkeletonRenderer.EnsureMeshGeneratorCapacity end.*/

            /*Spine.Unity.SkeletonRenderer.Initialize start.*/
            /**
             * Initialize this component. Attempts to load the SkeletonData and creates the internal Skeleton object and buffers.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @param   {boolean}    overwrite    If set to <pre><code>true</code></pre>, it will overwrite internal objects if they were already generated. Otherwise, the initialized component will ignore subsequent calls to initialize.
             * @param   {boolean}    quiet
             * @return  {void}
             */
            Initialize: function (overwrite, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#Initialize", this ); }

                var $t;
                if (quiet === void 0) { quiet = false; }
                if (this.valid && !overwrite) {
                    return;
                }

                // Clear
                {
                    // Note: do not reset meshFilter.sharedMesh or meshRenderer.sharedMaterial to null,
                    // otherwise constant reloading will be triggered at prefabs.
                    this.currentInstructions.Clear();
                    this.rendererBuffers.Clear();
                    this.meshGenerator.Begin();
                    this.skeleton = null;
                    this.valid = false;
                }

                if (this.skeletonDataAsset == null) {
                    return;
                }

                var skeletonData = this.skeletonDataAsset.GetSkeletonData(false);
                if (skeletonData == null) {
                    return;
                }
                this.valid = true;

                this.meshFilter = this.GetComponent(UnityEngine.MeshFilter);
                this.meshRenderer = this.GetComponent(UnityEngine.MeshRenderer);
                this.rendererBuffers.Initialize();

                this.skeleton = ($t = new Spine.Skeleton(skeletonData), $t.ScaleX = this.initialFlipX ? -1 : 1, $t.ScaleY = this.initialFlipY ? -1 : 1, $t);

                if (!System.String.isNullOrEmpty(this.initialSkinName) && !System.String.equals(this.initialSkinName, "default", 4)) {
                    this.skeleton.SetSkin$1(this.initialSkinName);
                }

                this.separatorSlots.clear();
                for (var i = 0; i < this.separatorSlotNames.length; i = (i + 1) | 0) {
                    this.separatorSlots.add(this.skeleton.FindSlot(this.separatorSlotNames[i]));
                }

                this.LateUpdate(); // Generate mesh for the first frame it exists.

                if (!Bridge.staticEquals(this.OnRebuild, null)) {
                    this.OnRebuild(this);
                }

            },
            /*Spine.Unity.SkeletonRenderer.Initialize end.*/

            /*Spine.Unity.SkeletonRenderer.LateUpdate start.*/
            /**
             * Generates a new UnityEngine.Mesh from the internal Skeleton.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @return  {void}
             */
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#LateUpdate", this ); }

                var $t, $t1;
                if (!this.valid) {
                    return;
                }


                if (this.updateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    return;
                }

                var doMeshOverride = !Bridge.staticEquals(this.generateMeshOverride, null);
                if ((!this.meshRenderer.enabled) && !doMeshOverride) {
                    return;
                }
                var currentInstructions = this.currentInstructions;
                var workingSubmeshInstructions = currentInstructions.submeshInstructions;
                var currentSmartMesh = this.rendererBuffers.GetNextMesh(); // Double-buffer for performance.

                var updateTriangles;

                if (this.singleSubmesh) {
                    // STEP 1. Determine a SmartMesh.Instruction. Split up instructions into submeshes. =============================================
                    Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction(currentInstructions, this.skeleton, ($t = this.skeletonDataAsset.atlasAssets)[0].PrimaryMaterial);

                    // STEP 1.9. Post-process workingInstructions. ==================================================================================
                    if (this.customMaterialOverride.Count > 0) {
                        Spine.Unity.MeshGenerator.TryReplaceMaterials(workingSubmeshInstructions, this.customMaterialOverride);
                    }

                    // STEP 2. Update vertex buffer based on verts from the attachments. ===========================================================
                    this.meshGenerator.settings = ($t1 = new Spine.Unity.MeshGenerator.Settings(), $t1.pmaVertexColors = this.pmaVertexColors, $t1.zSpacing = this.zSpacing, $t1.useClipping = this.useClipping, $t1.tintBlack = this.tintBlack, $t1.calculateTangents = this.calculateTangents, $t1.addNormals = this.addNormals, $t1);
                    this.meshGenerator.Begin();
                    updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(currentInstructions, currentSmartMesh.instructionUsed);
                    if (currentInstructions.hasActiveClipping) {
                        this.meshGenerator.AddSubmesh(workingSubmeshInstructions.Items[0].$clone(), updateTriangles);
                    } else {
                        this.meshGenerator.BuildMeshWithArrays(currentInstructions, updateTriangles);
                    }

                } else {
                    // STEP 1. Determine a SmartMesh.Instruction. Split up instructions into submeshes. =============================================
                    Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction(currentInstructions, this.skeleton, this.customSlotMaterials, this.separatorSlots, doMeshOverride, this.immutableTriangles);

                    // STEP 1.9. Post-process workingInstructions. ==================================================================================
                    if (this.customMaterialOverride.Count > 0) {
                        Spine.Unity.MeshGenerator.TryReplaceMaterials(workingSubmeshInstructions, this.customMaterialOverride);
                    }

                    if (doMeshOverride) {
                        this.generateMeshOverride(currentInstructions);
                        if (this.disableRenderingOnOverride) {
                            return;
                        }
                    }

                    updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(currentInstructions, currentSmartMesh.instructionUsed);

                    // STEP 2. Update vertex buffer based on verts from the attachments. ===========================================================
                    this.meshGenerator.settings = ($t1 = new Spine.Unity.MeshGenerator.Settings(), $t1.pmaVertexColors = this.pmaVertexColors, $t1.zSpacing = this.zSpacing, $t1.useClipping = this.useClipping, $t1.tintBlack = this.tintBlack, $t1.calculateTangents = this.calculateTangents, $t1.addNormals = this.addNormals, $t1);
                    this.meshGenerator.Begin();
                    if (currentInstructions.hasActiveClipping) {
                        this.meshGenerator.BuildMesh(currentInstructions, updateTriangles);
                    } else {
                        this.meshGenerator.BuildMeshWithArrays(currentInstructions, updateTriangles);
                    }
                }

                if (!Bridge.staticEquals(this.OnPostProcessVertices, null)) {
                    this.OnPostProcessVertices(this.meshGenerator.Buffers.$clone());
                }

                // STEP 3. Move the mesh data into a UnityEngine.Mesh ===========================================================================
                var currentMesh = currentSmartMesh.mesh;
                this.meshGenerator.FillVertexData(currentMesh);

                this.rendererBuffers.UpdateSharedMaterials(workingSubmeshInstructions);

                var materialsChanged = this.rendererBuffers.MaterialsChangedInLastUpdate();
                if (updateTriangles) { // Check if the triangles should also be updated.
                    this.meshGenerator.FillTriangles(currentMesh);
                    this.meshRenderer.sharedMaterials = this.rendererBuffers.GetUpdatedSharedMaterialsArray();
                } else if (materialsChanged) {
                    this.meshRenderer.sharedMaterials = this.rendererBuffers.GetUpdatedSharedMaterialsArray();
                }
                if (materialsChanged && (this.maskMaterials.AnyMaterialCreated)) {
                    this.maskMaterials = new Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials();
                }

                this.meshGenerator.FillLateVertexData(currentMesh);

                // STEP 4. The UnityEngine.Mesh is ready. Set it as the MeshFilter's mesh. Store the instructions used for that mesh. ===========
                this.meshFilter.sharedMesh = currentMesh;
                currentSmartMesh.instructionUsed.Set(currentInstructions);

                if (UnityEngine.Component.op_Inequality(this.meshRenderer, null)) {
                    this.AssignSpriteMaskMaterials();
                }

                if (this.fixDrawOrder && this.meshRenderer.sharedMaterials.length > 2) {
                    this.SetMaterialSettingsToFixDrawOrder();
                }

                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this);
                }
            },
            /*Spine.Unity.SkeletonRenderer.LateUpdate end.*/

            /*Spine.Unity.SkeletonRenderer.OnBecameVisible start.*/
            OnBecameVisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#OnBecameVisible", this ); }

                var previousUpdateMode = this.updateMode;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    this.LateUpdate();
                } // OnBecameVisible is called after LateUpdate()
            },
            /*Spine.Unity.SkeletonRenderer.OnBecameVisible end.*/

            /*Spine.Unity.SkeletonRenderer.OnBecameInvisible start.*/
            OnBecameInvisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#OnBecameInvisible", this ); }

                this.updateMode = this.updateWhenInvisible;
            },
            /*Spine.Unity.SkeletonRenderer.OnBecameInvisible end.*/

            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots$1 start.*/
            FindAndApplySeparatorSlots$1: function (startsWith, clearExistingSeparators, updateStringArray) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#FindAndApplySeparatorSlots$1", this ); }

                if (clearExistingSeparators === void 0) { clearExistingSeparators = true; }
                if (updateStringArray === void 0) { updateStringArray = false; }
                if (System.String.isNullOrEmpty(startsWith)) {
                    return;
                }

                this.FindAndApplySeparatorSlots(function (slotName) {
                    return System.String.startsWith(slotName, startsWith);
                }, clearExistingSeparators, updateStringArray);
            },
            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots$1 end.*/

            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots start.*/
            FindAndApplySeparatorSlots: function (slotNamePredicate, clearExistingSeparators, updateStringArray) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#FindAndApplySeparatorSlots", this ); }

                var $t, $t1, $t2;
                if (clearExistingSeparators === void 0) { clearExistingSeparators = true; }
                if (updateStringArray === void 0) { updateStringArray = false; }
                if (Bridge.staticEquals(slotNamePredicate, null)) {
                    return;
                }
                if (!this.valid) {
                    return;
                }

                if (clearExistingSeparators) {
                    this.separatorSlots.clear();
                }

                var slots = this.skeleton.slots;
                $t = Bridge.getEnumerator(slots);
                try {
                    while ($t.moveNext()) {
                        var slot = $t.Current;
                        if (slotNamePredicate(slot.data.name)) {
                            this.separatorSlots.add(slot);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                if (updateStringArray) {
                    var detectedSeparatorNames = new (System.Collections.Generic.List$1(System.String)).ctor();
                    $t1 = Bridge.getEnumerator(this.skeleton.slots);
                    try {
                        while ($t1.moveNext()) {
                            var slot1 = $t1.Current;
                            var slotName = slot1.data.name;
                            if (slotNamePredicate(slotName)) {
                                detectedSeparatorNames.add(slotName);
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    if (!clearExistingSeparators) {
                        var originalNames = this.separatorSlotNames;
                        $t2 = Bridge.getEnumerator(originalNames);
                        try {
                            while ($t2.moveNext()) {
                                var originalName = $t2.Current;
                                detectedSeparatorNames.add(originalName);
                            }
                        } finally {
                            if (Bridge.is($t2, System.IDisposable)) {
                                $t2.System$IDisposable$Dispose();
                            }
                        }
                    }

                    this.separatorSlotNames = detectedSeparatorNames.ToArray();
                }

            },
            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots end.*/

            /*Spine.Unity.SkeletonRenderer.ReapplySeparatorSlotNames start.*/
            ReapplySeparatorSlotNames: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#ReapplySeparatorSlotNames", this ); }

                if (!this.valid) {
                    return;
                }

                this.separatorSlots.clear();
                for (var i = 0, n = this.separatorSlotNames.length; i < n; i = (i + 1) | 0) {
                    var slot = this.skeleton.FindSlot(this.separatorSlotNames[i]);
                    if (slot != null) {
                        this.separatorSlots.add(slot);
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderer.ReapplySeparatorSlotNames end.*/

            /*Spine.Unity.SkeletonRenderer.AssignSpriteMaskMaterials start.*/
            AssignSpriteMaskMaterials: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#AssignSpriteMaskMaterials", this ); }

                var $t, $t1, $t2;

                if (UnityEngine.Application.isPlaying) {
                    if (this.maskInteraction !== UnityEngine.SpriteMaskInteraction.None && this.maskMaterials.materialsMaskDisabled.length === 0) {
                        this.maskMaterials.materialsMaskDisabled = this.meshRenderer.sharedMaterials;
                    }
                }

                if (this.maskMaterials.materialsMaskDisabled.length > 0 && ($t = this.maskMaterials.materialsMaskDisabled)[0] != null && this.maskInteraction === UnityEngine.SpriteMaskInteraction.None) {
                    this.meshRenderer.materials = this.maskMaterials.materialsMaskDisabled;
                } else if (this.maskInteraction === UnityEngine.SpriteMaskInteraction.VisibleInsideMask) {
                    if (this.maskMaterials.materialsInsideMask.length === 0 || ($t1 = this.maskMaterials.materialsInsideMask)[0] == null) {
                        if (!this.InitSpriteMaskMaterialsInsideMask()) {
                            return;
                        }
                    }
                    this.meshRenderer.materials = this.maskMaterials.materialsInsideMask;
                } else if (this.maskInteraction === UnityEngine.SpriteMaskInteraction.VisibleOutsideMask) {
                    if (this.maskMaterials.materialsOutsideMask.length === 0 || ($t2 = this.maskMaterials.materialsOutsideMask)[0] == null) {
                        if (!this.InitSpriteMaskMaterialsOutsideMask()) {
                            return;
                        }
                    }
                    this.meshRenderer.materials = this.maskMaterials.materialsOutsideMask;
                }
            },
            /*Spine.Unity.SkeletonRenderer.AssignSpriteMaskMaterials end.*/

            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsInsideMask start.*/
            InitSpriteMaskMaterialsInsideMask: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsInsideMask", this ); }

                return this.InitSpriteMaskMaterialsForMaskType(Spine.Unity.SkeletonRenderer.STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE, Bridge.ref(this.maskMaterials, "materialsInsideMask"));
            },
            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsInsideMask end.*/

            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsOutsideMask start.*/
            InitSpriteMaskMaterialsOutsideMask: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsOutsideMask", this ); }

                return this.InitSpriteMaskMaterialsForMaskType(Spine.Unity.SkeletonRenderer.STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE, Bridge.ref(this.maskMaterials, "materialsOutsideMask"));
            },
            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsOutsideMask end.*/

            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsForMaskType start.*/
            InitSpriteMaskMaterialsForMaskType: function (maskFunction, materialsToFill) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsForMaskType", this ); }


                var originalMaterials = this.maskMaterials.materialsMaskDisabled;
                materialsToFill.v = System.Array.init(originalMaterials.length, null, UnityEngine.Material);
                for (var i = 0; i < originalMaterials.length; i = (i + 1) | 0) {
                    var newMaterial = new UnityEngine.Material.$ctor1(originalMaterials[i]);
                    newMaterial.SetFloat(Spine.Unity.SkeletonRenderer.STENCIL_COMP_PARAM_ID, maskFunction);
                    materialsToFill.v[i] = newMaterial;
                }
                return true;
            },
            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsForMaskType end.*/

            /*Spine.Unity.SkeletonRenderer.SetMaterialSettingsToFixDrawOrder start.*/
            /**
             * This method was introduced as a workaround for too aggressive submesh draw call batching,
             leading to incorrect draw order when 3+ materials are used at submeshes in alternating order.
             Otherwise, e.g. when using Lightweight Render Pipeline, deliberately separated draw calls
             "A1 B A2" are reordered to "A1A2 B", regardless of batching-related project settings.
             *
             * @instance
             * @private
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @return  {void}
             */
            SetMaterialSettingsToFixDrawOrder: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#SetMaterialSettingsToFixDrawOrder", this ); }

                var $t, $t1;
                if (this.reusedPropertyBlock == null) {
                    this.reusedPropertyBlock = new UnityEngine.MaterialPropertyBlock();
                }

                var hasPerRendererBlock = this.meshRenderer.HasPropertyBlock();
                if (hasPerRendererBlock) {
                    this.meshRenderer.GetPropertyBlock(this.reusedPropertyBlock);
                }

                for (var i = 0; i < this.meshRenderer.sharedMaterials.length; i = (i + 1) | 0) {
                    if (!UnityEngine.Object.op_Implicit(($t = this.meshRenderer.sharedMaterials)[i])) {
                        continue;
                    }

                    if (!hasPerRendererBlock) {
                        this.meshRenderer.GetPropertyBlock$1(this.reusedPropertyBlock, i);
                    }
                    // Note: this parameter shall not exist at any shader, then Unity will create separate
                    // material instances (not in terms of memory cost or leakage).
                    this.reusedPropertyBlock.SetFloat(Spine.Unity.SkeletonRenderer.SUBMESH_DUMMY_PARAM_ID, i);
                    this.meshRenderer.SetPropertyBlock$1(this.reusedPropertyBlock, i);

                    ($t1 = this.meshRenderer.sharedMaterials)[i].enableInstancing = false;
                }
            },
            /*Spine.Unity.SkeletonRenderer.SetMaterialSettingsToFixDrawOrder end.*/


        },
        overloads: {
            "FindAndApplySeparatorSlots(string, bool, bool)": "FindAndApplySeparatorSlots$1"
        }
    });
    /*Spine.Unity.SkeletonRenderer end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate
     * @param   {Spine.Unity.SkeletonGraphic}    skeletonGraphic
     * @return  {void}
     */


    /*Spine.Unity.SkeletonGraphic start.*/
    Bridge.define("Spine.Unity.SkeletonGraphic", {
        inherits: [UnityEngine.UI.MaskableGraphic,Spine.Unity.ISkeletonComponent,Spine.Unity.IAnimationStateComponent,Spine.Unity.ISkeletonAnimation,Spine.Unity.IHasSkeletonDataAsset],
        statics: {
            fields: {
                SeparatorPartGameObjectName: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#init", this ); }

                    this.SeparatorPartGameObjectName = "Part";
                }
            },
            methods: {
                /*Spine.Unity.SkeletonGraphic.NewSkeletonGraphicGameObject:static start.*/
                /**
                 * Create a new GameObject with a SkeletonGraphic component.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonGraphic
                 * @memberof Spine.Unity.SkeletonGraphic
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {UnityEngine.Transform}            parent               
                 * @param   {UnityEngine.Material}             material             Material for the canvas renderer to use. Usually, the default SkeletonGraphic material will work.
                 * @return  {Spine.Unity.SkeletonGraphic}
                 */
                NewSkeletonGraphicGameObject: function (skeletonDataAsset, parent, material) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#NewSkeletonGraphicGameObject", this ); }

                    var sg = Spine.Unity.SkeletonGraphic.AddSkeletonGraphicComponent(new UnityEngine.GameObject.$ctor2("New Spine GameObject"), skeletonDataAsset, material);
                    if (UnityEngine.Component.op_Inequality(parent, null)) {
                        sg.transform.SetParent(parent, false);
                    }
                    return sg;
                },
                /*Spine.Unity.SkeletonGraphic.NewSkeletonGraphicGameObject:static end.*/

                /*Spine.Unity.SkeletonGraphic.AddSkeletonGraphicComponent:static start.*/
                /**
                 * Add a SkeletonGraphic component to a GameObject.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonGraphic
                 * @memberof Spine.Unity.SkeletonGraphic
                 * @param   {UnityEngine.GameObject}           gameObject           
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {UnityEngine.Material}             material             Material for the canvas renderer to use. Usually, the default SkeletonGraphic material will work.
                 * @return  {Spine.Unity.SkeletonGraphic}
                 */
                AddSkeletonGraphicComponent: function (gameObject, skeletonDataAsset, material) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#AddSkeletonGraphicComponent", this ); }

                    var c = gameObject.AddComponent(Spine.Unity.SkeletonGraphic);
                    if (skeletonDataAsset != null) {
                        c.material = material;
                        c.skeletonDataAsset = skeletonDataAsset;
                        c.Initialize(false);
                    }
                    return c;
                },
                /*Spine.Unity.SkeletonGraphic.AddSkeletonGraphicComponent:static end.*/


            }
        },
        fields: {
            skeletonDataAsset: null,
            initialSkinName: null,
            initialFlipX: false,
            initialFlipY: false,
            startingAnimation: null,
            startingLoop: false,
            timeScale: 0,
            freeze: false,
            updateMode: 0,
            /**
             * Update mode used when the MeshRenderer becomes invisible
             (when <pre><code>OnBecameInvisible()</code></pre> is called). Update mode is automatically
             reset to <pre><code>UpdateMode.FullUpdate</code></pre> when the mesh becomes visible again.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @type Spine.Unity.UpdateMode
             */
            updateWhenInvisible: 0,
            unscaledTime: false,
            allowMultipleCanvasRenderers: false,
            canvasRenderers: null,
            rawImages: null,
            usedRenderersCount: 0,
            /**
             * Slot names used to populate separatorSlots list when the Skeleton is initialized. Changing this after initialization does nothing.
             *
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonGraphic
             * @type Array.<string>
             */
            separatorSlotNames: null,
            /**
             * Slots that determine where the render is split. This is used by components such as SkeletonRenderSeparator so that the skeleton can be rendered by two separate renderers on different GameObjects.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonGraphic
             * @type System.Collections.Generic.List$1
             */
            separatorSlots: null,
            enableSeparatorSlots: false,
            separatorParts: null,
            updateSeparatorPartLocation: false,
            wasUpdatedAfterInit: false,
            baseTexture: null,
            customTextureOverride: null,
            customMaterialOverride: null,
            overrideTexture: null,
            skeleton: null,
            state: null,
            meshGenerator: null,
            meshBuffers: null,
            currentInstructions: null,
            meshes: null
        },
        events: {
            /**
             * OnRebuild is raised after the Skeleton is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnRebuild
             * @param   {Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnRebuild is raised after the Skeleton is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnRebuild
             * @param   {Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnRebuild: null,
            /**
             * OnMeshAndMaterialsUpdated is at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnMeshAndMaterialsUpdated is at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnMeshAndMaterialsUpdated: null,
            BeforeApply: null,
            UpdateLocal: null,
            UpdateWorld: null,
            UpdateComplete: null,
            /**
             * Occurs after the vertex data populated every frame, before the vertices are pushed into the mesh.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnPostProcessVertices
             * @param   {Spine.Unity.MeshGeneratorDelegate}    value
             * @return  {void}
             */
            /**
             * Occurs after the vertex data populated every frame, before the vertices are pushed into the mesh.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnPostProcessVertices
             * @param   {Spine.Unity.MeshGeneratorDelegate}    value
             * @return  {void}
             */
            OnPostProcessVertices: null
        },
        props: {
            SkeletonDataAsset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SkeletonDataAsset#get", this ); }

                    return this.skeletonDataAsset;
                }
            },
            /**
             * Update mode to optionally limit updates to e.g. only apply animations but not update the mesh.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @function UpdateMode
             * @type Spine.Unity.UpdateMode
             */
            UpdateMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMode#get", this ); }

                    return this.updateMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMode#set", this ); }

                    this.updateMode = value;
                }
            },
            SeparatorParts: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SeparatorParts#get", this ); }

                    return this.separatorParts;
                }
            },
            /**
             * Use this Dictionary to override a Texture with a different Texture.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonGraphic
             * @function CustomTextureOverride
             * @type System.Collections.Generic.Dictionary$2
             */
            CustomTextureOverride: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#CustomTextureOverride#get", this ); }

                    return this.customTextureOverride;
                }
            },
            /**
             * Use this Dictionary to override the Material where the Texture was used at the original atlas.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonGraphic
             * @function CustomMaterialOverride
             * @type System.Collections.Generic.Dictionary$2
             */
            CustomMaterialOverride: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#CustomMaterialOverride#get", this ); }

                    return this.customMaterialOverride;
                }
            },
            OverrideTexture: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OverrideTexture#get", this ); }

                    return this.overrideTexture;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OverrideTexture#set", this ); }

                    this.overrideTexture = value;
                    this.canvasRenderer.SetTexture(this.mainTexture); // Refresh canvasRenderer's texture. Make sure it handles null.
                }
            },
            mainTexture: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#mainTexture#get", this ); }

                    if (this.overrideTexture != null) {
                        return this.overrideTexture;
                    }
                    return this.baseTexture;
                }
            },
            Skeleton: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Skeleton#get", this ); }

                    this.Initialize(false);
                    return this.skeleton;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Skeleton#set", this ); }

                    this.skeleton = value;
                }
            },
            SkeletonData: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SkeletonData#get", this ); }

                    return this.skeleton == null ? null : this.skeleton.data;
                }
            },
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#IsValid#get", this ); }

                    return this.skeleton != null;
                }
            },
            AnimationState: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#AnimationState#get", this ); }

                    this.Initialize(false);
                    return this.state;
                }
            },
            MeshGenerator: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MeshGenerator#get", this ); }

                    return this.meshGenerator;
                }
            }
        },
        alias: [
            "SkeletonDataAsset", "Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset",
            "SkeletonDataAsset", "Spine$Unity$ISkeletonComponent$SkeletonDataAsset",
            "Rebuild", "UnityEngine$UI$ICanvasElement$Rebuild",
            "Skeleton", "Spine$Unity$ISkeletonAnimation$Skeleton",
            "Skeleton", "Spine$Unity$ISkeletonComponent$Skeleton",
            "AnimationState", "Spine$Unity$IAnimationStateComponent$AnimationState",
            "addUpdateLocal", "Spine$Unity$ISkeletonAnimation$addUpdateLocal",
            "removeUpdateLocal", "Spine$Unity$ISkeletonAnimation$removeUpdateLocal",
            "addUpdateWorld", "Spine$Unity$ISkeletonAnimation$addUpdateWorld",
            "removeUpdateWorld", "Spine$Unity$ISkeletonAnimation$removeUpdateWorld",
            "addUpdateComplete", "Spine$Unity$ISkeletonAnimation$addUpdateComplete",
            "removeUpdateComplete", "Spine$Unity$ISkeletonAnimation$removeUpdateComplete"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#init", this ); }

                this.timeScale = 1.0;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                this.updateWhenInvisible = Spine.Unity.UpdateMode.FullUpdate;
                this.allowMultipleCanvasRenderers = false;
                this.canvasRenderers = new (System.Collections.Generic.List$1(UnityEngine.CanvasRenderer)).ctor();
                this.rawImages = new (System.Collections.Generic.List$1(UnityEngine.UI.RawImage)).ctor();
                this.usedRenderersCount = 0;
                this.separatorSlotNames = System.Array.init(0, null, System.String);
                this.separatorSlots = new (System.Collections.Generic.List$1(Spine.Slot)).ctor();
                this.enableSeparatorSlots = false;
                this.separatorParts = new (System.Collections.Generic.List$1(UnityEngine.Transform)).ctor();
                this.updateSeparatorPartLocation = true;
                this.wasUpdatedAfterInit = true;
                this.customTextureOverride = new (System.Collections.Generic.Dictionary$2(UnityEngine.Texture,UnityEngine.Texture)).ctor();
                this.customMaterialOverride = new (System.Collections.Generic.Dictionary$2(UnityEngine.Texture,UnityEngine.Material)).ctor();
                this.meshGenerator = new Spine.Unity.MeshGenerator();
                this.currentInstructions = new Spine.Unity.SkeletonRendererInstruction();
                this.meshes = new (Spine.ExposedList$1(UnityEngine.Mesh)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonGraphic.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Awake", this ); }


                UnityEngine.UI.MaskableGraphic.prototype.Awake.call(this);
                this.onCullStateChanged.AddListener(Bridge.fn.cacheBind(this, this.OnCullStateChanged));

                this.SyncRawImagesWithCanvasRenderers();
                if (!this.IsValid) {
                    this.Initialize(false);
                    this.Rebuild(UnityEngine.UI.CanvasUpdate.PreRender);
                }
            },
            /*Spine.Unity.SkeletonGraphic.Awake end.*/

            /*Spine.Unity.SkeletonGraphic.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnDestroy", this ); }

                this.Clear();
                UnityEngine.UI.MaskableGraphic.prototype.OnDestroy.call(this);
            },
            /*Spine.Unity.SkeletonGraphic.OnDestroy end.*/

            /*Spine.Unity.SkeletonGraphic.Rebuild start.*/
            Rebuild: function (update) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Rebuild", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.Rebuild.call(this, update);
                if (this.canvasRenderer.cull) {
                    return;
                }
                if (update === UnityEngine.UI.CanvasUpdate.PreRender) {
                    this.UpdateMesh(true);
                }
                if (this.allowMultipleCanvasRenderers) {
                    this.canvasRenderer.Clear();
                }
            },
            /*Spine.Unity.SkeletonGraphic.Rebuild end.*/

            /*Spine.Unity.SkeletonGraphic.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnDisable", this ); }

                var $t;
                UnityEngine.UI.MaskableGraphic.prototype.OnDisable.call(this);
                $t = Bridge.getEnumerator(this.canvasRenderers);
                try {
                    while ($t.moveNext()) {
                        var canvasRenderer = $t.Current;
                        canvasRenderer.Clear();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.OnDisable end.*/

            /*Spine.Unity.SkeletonGraphic.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Update", this ); }


                if (this.freeze) {
                    return;
                }
                this.Update$1(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
            },
            /*Spine.Unity.SkeletonGraphic.Update end.*/

            /*Spine.Unity.SkeletonGraphic.Update$1 start.*/
            Update$1: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Update$1", this ); }

                if (!this.IsValid) {
                    return;
                }

                this.wasUpdatedAfterInit = true;
                if (this.updateMode < Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    return;
                }
                this.UpdateAnimationStatus(deltaTime);

                if (this.updateMode === Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    return;
                }
                this.ApplyAnimation();
            },
            /*Spine.Unity.SkeletonGraphic.Update$1 end.*/

            /*Spine.Unity.SkeletonGraphic.SyncRawImagesWithCanvasRenderers start.*/
            SyncRawImagesWithCanvasRenderers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SyncRawImagesWithCanvasRenderers", this ); }

                var $t;
                this.rawImages.clear();
                $t = Bridge.getEnumerator(this.canvasRenderers);
                try {
                    while ($t.moveNext()) {
                        var canvasRenderer = $t.Current;
                        var rawImage = canvasRenderer.GetComponent(UnityEngine.UI.RawImage);
                        if (UnityEngine.MonoBehaviour.op_Equality(rawImage, null)) {
                            rawImage = canvasRenderer.gameObject.AddComponent(UnityEngine.UI.RawImage);
                            rawImage.maskable = this.maskable;
                            rawImage.raycastTarget = false;
                        }
                        this.rawImages.add(rawImage);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.SyncRawImagesWithCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateAnimationStatus start.*/
            UpdateAnimationStatus: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateAnimationStatus", this ); }

                deltaTime *= this.timeScale;
                this.skeleton.Update(deltaTime);
                this.state.Update(deltaTime);
            },
            /*Spine.Unity.SkeletonGraphic.UpdateAnimationStatus end.*/

            /*Spine.Unity.SkeletonGraphic.ApplyAnimation start.*/
            ApplyAnimation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#ApplyAnimation", this ); }

                if (!Bridge.staticEquals(this.BeforeApply, null)) {
                    this.BeforeApply(this);
                }

                if (this.updateMode !== Spine.Unity.UpdateMode.OnlyEventTimelines) {
                    this.state.Apply(this.skeleton);
                } else {
                    this.state.ApplyEventTimelinesOnly(this.skeleton);
                }

                if (!Bridge.staticEquals(this.UpdateLocal, null)) {
                    this.UpdateLocal(this);
                }

                this.skeleton.UpdateWorldTransform();

                if (!Bridge.staticEquals(this.UpdateWorld, null)) {
                    this.UpdateWorld(this);
                    this.skeleton.UpdateWorldTransform();
                }

                if (!Bridge.staticEquals(this.UpdateComplete, null)) {
                    this.UpdateComplete(this);
                }
            },
            /*Spine.Unity.SkeletonGraphic.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonGraphic.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#LateUpdate", this ); }

                // instantiation can happen from Update() after this component, leading to a missing Update() call.
                if (!this.wasUpdatedAfterInit) {
                    this.Update$1(0);
                }
                if (this.freeze) {
                    return;
                }
                if (this.updateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    return;
                }

                this.UpdateMesh();
            },
            /*Spine.Unity.SkeletonGraphic.LateUpdate end.*/

            /*Spine.Unity.SkeletonGraphic.OnCullStateChanged start.*/
            OnCullStateChanged: function (culled) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnCullStateChanged", this ); }

                if (culled) {
                    this.OnBecameInvisible();
                } else {
                    this.OnBecameVisible();
                }
            },
            /*Spine.Unity.SkeletonGraphic.OnCullStateChanged end.*/

            /*Spine.Unity.SkeletonGraphic.OnBecameVisible start.*/
            OnBecameVisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnBecameVisible", this ); }

                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
            },
            /*Spine.Unity.SkeletonGraphic.OnBecameVisible end.*/

            /*Spine.Unity.SkeletonGraphic.OnBecameInvisible start.*/
            OnBecameInvisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnBecameInvisible", this ); }

                this.updateMode = this.updateWhenInvisible;
            },
            /*Spine.Unity.SkeletonGraphic.OnBecameInvisible end.*/

            /*Spine.Unity.SkeletonGraphic.ReapplySeparatorSlotNames start.*/
            ReapplySeparatorSlotNames: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#ReapplySeparatorSlotNames", this ); }

                if (!this.IsValid) {
                    return;
                }

                this.separatorSlots.clear();
                for (var i = 0, n = this.separatorSlotNames.length; i < n; i = (i + 1) | 0) {
                    var slotName = this.separatorSlotNames[i];
                    if (Bridge.referenceEquals(slotName, "")) {
                        continue;
                    }
                    var slot = this.skeleton.FindSlot(slotName);
                    if (slot != null) {
                        this.separatorSlots.add(slot);
                    }
                }
                this.UpdateSeparatorPartParents();
            },
            /*Spine.Unity.SkeletonGraphic.ReapplySeparatorSlotNames end.*/

            /*Spine.Unity.SkeletonGraphic.GetLastMesh start.*/
            GetLastMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#GetLastMesh", this ); }

                return this.meshBuffers.GetCurrent().mesh;
            },
            /*Spine.Unity.SkeletonGraphic.GetLastMesh end.*/

            /*Spine.Unity.SkeletonGraphic.MatchRectTransformWithBounds start.*/
            MatchRectTransformWithBounds: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MatchRectTransformWithBounds", this ); }

                this.UpdateMesh();

                if (!this.allowMultipleCanvasRenderers) {
                    return this.MatchRectTransformSingleRenderer();
                } else {
                    return this.MatchRectTransformMultipleRenderers();
                }
            },
            /*Spine.Unity.SkeletonGraphic.MatchRectTransformWithBounds end.*/

            /*Spine.Unity.SkeletonGraphic.MatchRectTransformSingleRenderer start.*/
            MatchRectTransformSingleRenderer: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MatchRectTransformSingleRenderer", this ); }

                var mesh = this.GetLastMesh();
                if (mesh == null) {
                    return false;
                }
                if (mesh.vertexCount === 0) {
                    this.rectTransform.sizeDelta = new pc.Vec2( 50.0, 50.0 );
                    this.rectTransform.pivot = new pc.Vec2( 0.5, 0.5 );
                    return false;
                }
                mesh.RecalculateBounds();
                this.SetRectTransformBounds(mesh.bounds);
                return true;
            },
            /*Spine.Unity.SkeletonGraphic.MatchRectTransformSingleRenderer end.*/

            /*Spine.Unity.SkeletonGraphic.MatchRectTransformMultipleRenderers start.*/
            MatchRectTransformMultipleRenderers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MatchRectTransformMultipleRenderers", this ); }

                var $t;
                var anyBoundsAdded = false;
                var combinedBounds = new pc.BoundingBox.ctor();
                for (var i = 0; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                    var canvasRenderer = this.canvasRenderers.getItem(i);
                    if (!canvasRenderer.gameObject.activeSelf) {
                        continue;
                    }

                    var mesh = ($t = this.meshes.Items)[i];
                    if (mesh == null || mesh.vertexCount === 0) {
                        continue;
                    }

                    mesh.RecalculateBounds();
                    var bounds = mesh.bounds;
                    if (anyBoundsAdded) {
                        combinedBounds.add( bounds );
                    } else {
                        anyBoundsAdded = true;
                        combinedBounds = bounds;
                    }
                }

                if (!anyBoundsAdded) {
                    this.rectTransform.sizeDelta = new pc.Vec2( 50.0, 50.0 );
                    this.rectTransform.pivot = new pc.Vec2( 0.5, 0.5 );
                    return false;
                }

                this.SetRectTransformBounds(combinedBounds);
                return true;
            },
            /*Spine.Unity.SkeletonGraphic.MatchRectTransformMultipleRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.SetRectTransformBounds start.*/
            SetRectTransformBounds: function (combinedBounds) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SetRectTransformBounds", this ); }

                var size = combinedBounds.halfExtents.$clone().scale( 2 ).$clone();
                var center = combinedBounds.center.$clone();
                var p = new pc.Vec2( 0.5 - (center.x / size.x), 0.5 - (center.y / size.y) );

                this.rectTransform.sizeDelta = UnityEngine.Vector2.FromVector3(size.$clone());
                this.rectTransform.pivot = p.$clone();
            },
            /*Spine.Unity.SkeletonGraphic.SetRectTransformBounds end.*/

            /*Spine.Unity.SkeletonGraphic.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Clear", this ); }

                this.skeleton = null;
                this.canvasRenderer.Clear();

                for (var i = 0; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                    this.canvasRenderers.getItem(i).Clear();
                }
                this.DestroyMeshes();
                this.DisposeMeshBuffers();
            },
            /*Spine.Unity.SkeletonGraphic.Clear end.*/

            /*Spine.Unity.SkeletonGraphic.TrimRenderers start.*/
            TrimRenderers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#TrimRenderers", this ); }

                var $t;
                var newList = new (System.Collections.Generic.List$1(UnityEngine.CanvasRenderer)).ctor();
                $t = Bridge.getEnumerator(this.canvasRenderers);
                try {
                    while ($t.moveNext()) {
                        var canvasRenderer = $t.Current;
                        if (canvasRenderer.gameObject.activeSelf) {
                            newList.add(canvasRenderer);
                        } else {
                            if (UnityEngine.Application.isEditor && !UnityEngine.Application.isPlaying) {
                                UnityEngine.Object.DestroyImmediate(canvasRenderer.gameObject);
                            } else {
                                UnityEngine.MonoBehaviour.Destroy(canvasRenderer.gameObject);
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.canvasRenderers = newList;
                this.SyncRawImagesWithCanvasRenderers();
            },
            /*Spine.Unity.SkeletonGraphic.TrimRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.Initialize start.*/
            Initialize: function (overwrite) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Initialize", this ); }

                var $t, $t1;
                if (this.IsValid && !overwrite) {
                    return;
                }

                if (this.skeletonDataAsset == null) {
                    return;
                }
                var skeletonData = this.skeletonDataAsset.GetSkeletonData(false);
                if (skeletonData == null) {
                    return;
                }

                if (this.skeletonDataAsset.atlasAssets.length <= 0 || ($t = this.skeletonDataAsset.atlasAssets)[0].MaterialCount <= 0) {
                    return;
                }

                this.state = new Spine.AnimationState(this.skeletonDataAsset.GetAnimationStateData());
                if (this.state == null) {
                    this.Clear();
                    return;
                }

                this.skeleton = ($t1 = new Spine.Skeleton(skeletonData), $t1.ScaleX = this.initialFlipX ? -1 : 1, $t1.ScaleY = this.initialFlipY ? -1 : 1, $t1);

                this.InitMeshBuffers();
                this.baseTexture = ($t1 = this.skeletonDataAsset.atlasAssets)[0].PrimaryMaterial.mainTexture;
                this.canvasRenderer.SetTexture(this.mainTexture); // Needed for overwriting initializations.

                // Set the initial Skin and Animation
                if (!System.String.isNullOrEmpty(this.initialSkinName)) {
                    this.skeleton.SetSkin$1(this.initialSkinName);
                }

                this.separatorSlots.clear();
                for (var i = 0; i < this.separatorSlotNames.length; i = (i + 1) | 0) {
                    this.separatorSlots.add(this.skeleton.FindSlot(this.separatorSlotNames[i]));
                }

                this.wasUpdatedAfterInit = false;
                if (!System.String.isNullOrEmpty(this.startingAnimation)) {
                    var animationObject = this.skeletonDataAsset.GetSkeletonData(false).FindAnimation(this.startingAnimation);
                    if (animationObject != null) {
                        this.state.SetAnimation(0, animationObject, this.startingLoop);
                    }
                }

                if (!Bridge.staticEquals(this.OnRebuild, null)) {
                    this.OnRebuild(this);
                }
            },
            /*Spine.Unity.SkeletonGraphic.Initialize end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMesh start.*/
            UpdateMesh: function (keepRendererCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMesh", this ); }

                if (keepRendererCount === void 0) { keepRendererCount = false; }
                if (!this.IsValid) {
                    return;
                }

                Spine.Unity.SkeletonExtensions.SetColor$4(this.skeleton, this.color.$clone());

                var currentInstructions = this.currentInstructions;
                if (!this.allowMultipleCanvasRenderers) {
                    this.UpdateMeshSingleCanvasRenderer();
                } else {
                    this.UpdateMeshMultipleCanvasRenderers(currentInstructions, keepRendererCount);
                }

                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this);
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMesh end.*/

            /*Spine.Unity.SkeletonGraphic.HasMultipleSubmeshInstructions start.*/
            HasMultipleSubmeshInstructions: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#HasMultipleSubmeshInstructions", this ); }

                if (!this.IsValid) {
                    return false;
                }
                return Spine.Unity.MeshGenerator.RequiresMultipleSubmeshesByDrawOrder(this.skeleton);
            },
            /*Spine.Unity.SkeletonGraphic.HasMultipleSubmeshInstructions end.*/

            /*Spine.Unity.SkeletonGraphic.InitMeshBuffers start.*/
            InitMeshBuffers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#InitMeshBuffers", this ); }

                if (this.meshBuffers != null) {
                    this.meshBuffers.GetNext().Clear();
                    this.meshBuffers.GetNext().Clear();
                } else {
                    this.meshBuffers = new (Spine.Unity.DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh))();
                }
            },
            /*Spine.Unity.SkeletonGraphic.InitMeshBuffers end.*/

            /*Spine.Unity.SkeletonGraphic.DisposeMeshBuffers start.*/
            DisposeMeshBuffers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#DisposeMeshBuffers", this ); }

                if (this.meshBuffers != null) {
                    this.meshBuffers.GetNext().Dispose();
                    this.meshBuffers.GetNext().Dispose();
                    this.meshBuffers = null;
                }
            },
            /*Spine.Unity.SkeletonGraphic.DisposeMeshBuffers end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMeshSingleCanvasRenderer start.*/
            UpdateMeshSingleCanvasRenderer: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMeshSingleCanvasRenderer", this ); }

                var $t, $t1;
                if (this.canvasRenderers.Count > 0) {
                    this.DisableUnusedCanvasRenderers(0);
                }

                var smartMesh = this.meshBuffers.GetNext();
                Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction(this.currentInstructions, this.skeleton, null);
                var updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(this.currentInstructions, smartMesh.instructionUsed);

                this.meshGenerator.Begin();
                if (this.currentInstructions.hasActiveClipping && this.currentInstructions.submeshInstructions.Count > 0) {
                    this.meshGenerator.AddSubmesh(($t = this.currentInstructions.submeshInstructions.Items)[0].$clone(), updateTriangles);
                } else {
                    this.meshGenerator.BuildMeshWithArrays(this.currentInstructions, updateTriangles);
                }

                if (UnityEngine.Component.op_Inequality(this.canvas, null)) {
                    this.meshGenerator.ScaleVertexData(this.canvas.referencePixelsPerUnit);
                }
                if (!Bridge.staticEquals(this.OnPostProcessVertices, null)) {
                    this.OnPostProcessVertices(this.meshGenerator.Buffers.$clone());
                }

                var mesh = smartMesh.mesh;
                this.meshGenerator.FillVertexData(mesh);
                if (updateTriangles) {
                    this.meshGenerator.FillTriangles(mesh);
                }
                this.meshGenerator.FillLateVertexData(mesh);

                this.canvasRenderer.SetMesh(mesh);
                smartMesh.instructionUsed.Set(this.currentInstructions);

                if (this.currentInstructions.submeshInstructions.Count > 0) {
                    var material = ($t1 = this.currentInstructions.submeshInstructions.Items)[0].material;
                    if (material != null && !Bridge.referenceEquals(this.baseTexture, material.mainTexture)) {
                        this.baseTexture = material.mainTexture;
                        if (this.overrideTexture == null) {
                            this.canvasRenderer.SetTexture(this.mainTexture);
                        }
                    }
                }

                //this.UpdateMaterial(); // note: This would allocate memory.
                this.usedRenderersCount = 0;
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMeshSingleCanvasRenderer end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMeshMultipleCanvasRenderers start.*/
            UpdateMeshMultipleCanvasRenderers: function (currentInstructions, keepRendererCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMeshMultipleCanvasRenderers", this ); }

                var $t;
                Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction(currentInstructions, this.skeleton, null, this.enableSeparatorSlots ? this.separatorSlots : null, this.enableSeparatorSlots ? this.separatorSlots.Count > 0 : false, false);

                var submeshCount = currentInstructions.submeshInstructions.Count;
                if (keepRendererCount && submeshCount !== this.usedRenderersCount) {
                    return;
                }
                this.EnsureCanvasRendererCount(submeshCount);
                this.EnsureMeshesCount(submeshCount);
                this.EnsureSeparatorPartCount();

                var c = this.canvas;
                var scale = (UnityEngine.Component.op_Equality(c, null)) ? 100 : c.referencePixelsPerUnit;

                // Generate meshes.
                var meshesItems = this.meshes.Items;
                var useOriginalTextureAndMaterial = (this.customMaterialOverride.Count === 0 && this.customTextureOverride.Count === 0);
                var separatorSlotGroupIndex = 0;
                var parent = this.separatorSlots.Count === 0 ? this.transform : this.separatorParts.getItem(0);

                if (this.updateSeparatorPartLocation) {
                    for (var p = 0; p < this.separatorParts.Count; p = (p + 1) | 0) {
                        this.separatorParts.getItem(p).position = this.transform.position.$clone();
                        this.separatorParts.getItem(p).rotation = this.transform.rotation.$clone();
                    }
                }

                var targetSiblingIndex = 0;
                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    var submeshInstructionItem = ($t = currentInstructions.submeshInstructions.Items)[i].$clone();
                    this.meshGenerator.Begin();
                    this.meshGenerator.AddSubmesh(submeshInstructionItem.$clone());

                    var targetMesh = meshesItems[i];
                    this.meshGenerator.ScaleVertexData(scale);
                    if (!Bridge.staticEquals(this.OnPostProcessVertices, null)) {
                        this.OnPostProcessVertices(this.meshGenerator.Buffers.$clone());
                    }
                    this.meshGenerator.FillVertexData(targetMesh);
                    this.meshGenerator.FillTriangles(targetMesh);
                    this.meshGenerator.FillLateVertexData(targetMesh);

                    var submeshMaterial = submeshInstructionItem.material;
                    var canvasRenderer = this.canvasRenderers.getItem(i);
                    if (i >= this.usedRenderersCount) {
                        canvasRenderer.gameObject.SetActive(true);
                    }

                    canvasRenderer.SetMesh(targetMesh);
                    canvasRenderer.materialCount = 1;

                    if (UnityEngine.Component.op_Inequality(canvasRenderer.transform.parent, parent.transform)) {
                        canvasRenderer.transform.SetParent(parent.transform, false);
                        canvasRenderer.transform.localPosition = pc.Vec3.ZERO.clone();
                    }
                    canvasRenderer.transform.SetSiblingIndex(Bridge.identity(targetSiblingIndex, ((targetSiblingIndex = (targetSiblingIndex + 1) | 0))));
                    if (submeshInstructionItem.forceSeparate) {
                        targetSiblingIndex = 0;
                        parent = this.separatorParts.getItem(((separatorSlotGroupIndex = (separatorSlotGroupIndex + 1) | 0)));
                    }

                    if (useOriginalTextureAndMaterial) {
                        canvasRenderer.SetMaterial$1(this.materialForRendering, submeshMaterial.mainTexture);
                    } else {
                        var originalTexture = submeshMaterial.mainTexture;
                        var usedMaterial = { };
                        var usedTexture = { };
                        if (!this.customMaterialOverride.tryGetValue(originalTexture, usedMaterial)) {
                            usedMaterial.v = this.material;
                        }
                        if (!this.customTextureOverride.tryGetValue(originalTexture, usedTexture)) {
                            usedTexture.v = originalTexture;
                        }
                        canvasRenderer.SetMaterial$1(usedMaterial.v, usedTexture.v);
                    }
                }

                this.DisableUnusedCanvasRenderers(submeshCount);
                this.usedRenderersCount = submeshCount;
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMeshMultipleCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureCanvasRendererCount start.*/
            EnsureCanvasRendererCount: function (targetCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#EnsureCanvasRendererCount", this ); }

                var currentCount = this.canvasRenderers.Count;
                for (var i = currentCount; i < targetCount; i = (i + 1) | 0) {
                    var go = new UnityEngine.GameObject.$ctor3(System.String.format("Renderer{0}", [Bridge.box(i, System.Int32)]), UnityEngine.RectTransform);
                    go.transform.SetParent(this.transform, false);
                    go.transform.localPosition = pc.Vec3.ZERO.clone();
                    var canvasRenderer = go.AddComponent(UnityEngine.CanvasRenderer);
                    this.canvasRenderers.add(canvasRenderer);
                    var rawImage = go.AddComponent(UnityEngine.UI.RawImage);
                    rawImage.maskable = this.maskable;
                    rawImage.raycastTarget = false;
                    this.rawImages.add(rawImage);
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureCanvasRendererCount end.*/

            /*Spine.Unity.SkeletonGraphic.DisableUnusedCanvasRenderers start.*/
            DisableUnusedCanvasRenderers: function (usedCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#DisableUnusedCanvasRenderers", this ); }

                for (var i = usedCount; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                    this.canvasRenderers.getItem(i).Clear();
                    this.canvasRenderers.getItem(i).gameObject.SetActive(false);
                }
            },
            /*Spine.Unity.SkeletonGraphic.DisableUnusedCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureMeshesCount start.*/
            EnsureMeshesCount: function (targetCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#EnsureMeshesCount", this ); }

                var oldCount = this.meshes.Count;
                this.meshes.EnsureCapacity(targetCount);
                for (var i = oldCount; i < targetCount; i = (i + 1) | 0) {
                    this.meshes.Add(Spine.Unity.SpineMesh.NewSkeletonMesh());
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureMeshesCount end.*/

            /*Spine.Unity.SkeletonGraphic.DestroyMeshes start.*/
            DestroyMeshes: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#DestroyMeshes", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.meshes);
                try {
                    while ($t.moveNext()) {
                        var mesh = $t.Current;
                        UnityEngine.Object.Destroy(mesh);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.meshes.Clear();
            },
            /*Spine.Unity.SkeletonGraphic.DestroyMeshes end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureSeparatorPartCount start.*/
            EnsureSeparatorPartCount: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#EnsureSeparatorPartCount", this ); }

                var targetCount = (this.separatorSlots.Count + 1) | 0;
                if (targetCount === 1) {
                    return;
                }

                var currentCount = this.separatorParts.Count;
                for (var i = currentCount; i < targetCount; i = (i + 1) | 0) {
                    var go = new UnityEngine.GameObject.$ctor3(System.String.format("{0}[{1}]", Spine.Unity.SkeletonGraphic.SeparatorPartGameObjectName, Bridge.box(i, System.Int32)), UnityEngine.RectTransform);
                    go.transform.SetParent(this.transform, false);
                    go.transform.localPosition = pc.Vec3.ZERO.clone();
                    this.separatorParts.add(go.transform);
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureSeparatorPartCount end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateSeparatorPartParents start.*/
            UpdateSeparatorPartParents: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateSeparatorPartParents", this ); }

                var usedCount = (this.separatorSlots.Count + 1) | 0;
                if (usedCount === 1) {
                    usedCount = 0; // placed directly at the SkeletonGraphic parent
                    for (var i = 0; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                        var canvasRenderer = this.canvasRenderers.getItem(i);
                        if (System.String.contains(canvasRenderer.transform.parent.name,Spine.Unity.SkeletonGraphic.SeparatorPartGameObjectName)) {
                            canvasRenderer.transform.SetParent(this.transform, false);
                            canvasRenderer.transform.localPosition = pc.Vec3.ZERO.clone();
                        }
                    }
                }
                for (var i1 = 0; i1 < this.separatorParts.Count; i1 = (i1 + 1) | 0) {
                    var isUsed = i1 < usedCount;
                    this.separatorParts.getItem(i1).gameObject.SetActive(isUsed);
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateSeparatorPartParents end.*/


        },
        overloads: {
            "Update(float)": "Update$1"
        }
    });
    /*Spine.Unity.SkeletonGraphic end.*/

    /*Spine.Unity.SkeletonMecanimRootMotion start.*/
    /**
     * Add this component to a SkeletonMecanim GameObject
     to turn motion of a selected root bone into Transform or RigidBody motion.
     Local bone translation movement is used as motion.
     All top-level bones of the skeleton are moved to compensate the root
     motion bone location, keeping the distance relationship between bones intact.
     *
     * @public
     * @class Spine.Unity.SkeletonMecanimRootMotion
     * @augments Spine.Unity.SkeletonRootMotionBase
     */
    Bridge.define("Spine.Unity.SkeletonMecanimRootMotion", {
        inherits: [Spine.Unity.SkeletonRootMotionBase],
        statics: {
            fields: {
                DefaultMecanimLayerFlags: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#init", this ); }

                    this.DefaultMecanimLayerFlags = -1;
                }
            }
        },
        fields: {
            mecanimLayerFlags: 0,
            movementDelta: null,
            skeletonMecanim: null
        },
        props: {
            SkeletonMecanim: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#SkeletonMecanim#get", this ); }

                    return UnityEngine.Object.op_Implicit(this.skeletonMecanim) ? this.skeletonMecanim : (this.skeletonMecanim = this.GetComponent(Spine.Unity.SkeletonMecanim));
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#init", this ); }

                this.movementDelta = new UnityEngine.Vector2();
                this.mecanimLayerFlags = -1;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonMecanimRootMotion.GetRemainingRootMotion start.*/
            GetRemainingRootMotion: function (layerIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#GetRemainingRootMotion", this ); }

                var pair = this.skeletonMecanim.Translator.GetActiveAnimationAndTime(layerIndex);
                var animation = pair.key;
                var time = pair.value;
                if (animation == null) {
                    return pc.Vec2.ZERO.clone();
                }

                var start = time;
                var end = animation.duration;
                return this.GetAnimationRootMotion$1(start, end, animation);
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.GetRemainingRootMotion end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.GetRootMotionInfo start.*/
            GetRootMotionInfo: function (layerIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#GetRootMotionInfo", this ); }

                var pair = this.skeletonMecanim.Translator.GetActiveAnimationAndTime(layerIndex);
                var animation = pair.key;
                var time = pair.value;
                if (animation == null) {
                    return new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                }
                return this.GetAnimationRootMotionInfo(animation, time);
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.GetRootMotionInfo end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#Reset", this ); }

                Spine.Unity.SkeletonRootMotionBase.prototype.Reset.call(this);
                this.mecanimLayerFlags = Spine.Unity.SkeletonMecanimRootMotion.DefaultMecanimLayerFlags;
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.Reset end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#Start", this ); }

                Spine.Unity.SkeletonRootMotionBase.prototype.Start.call(this);
                this.skeletonMecanim = this.GetComponent(Spine.Unity.SkeletonMecanim);
                if (UnityEngine.Object.op_Implicit(this.skeletonMecanim)) {
                    this.skeletonMecanim.Translator.removeOnClipApplied(Bridge.fn.cacheBind(this, this.OnClipApplied));
                    this.skeletonMecanim.Translator.addOnClipApplied(Bridge.fn.cacheBind(this, this.OnClipApplied));
                }
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.Start end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.OnClipApplied start.*/
            OnClipApplied: function (animation, layerIndex, weight, time, lastTime, playsBackward) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#OnClipApplied", this ); }


                if (((this.mecanimLayerFlags & 1 << layerIndex) === 0) || weight === 0) {
                    return;
                }

                if (!playsBackward) {
                    this.movementDelta = this.movementDelta.$clone().add( this.GetAnimationRootMotion$1(lastTime, time, animation).scale( weight ) );
                } else {
                    this.movementDelta = this.movementDelta.$clone().sub( this.GetAnimationRootMotion$1(time, lastTime, animation).scale( weight ) );
                }
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.OnClipApplied end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.CalculateAnimationsMovementDelta start.*/
            CalculateAnimationsMovementDelta: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#CalculateAnimationsMovementDelta", this ); }

                // Note: movement delta is not gather after animation but
                // in OnClipApplied after every applied animation.
                var result = this.movementDelta.$clone();
                this.movementDelta = pc.Vec2.ZERO.clone();
                return result.$clone();
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.CalculateAnimationsMovementDelta end.*/


        }
    });
    /*Spine.Unity.SkeletonMecanimRootMotion end.*/

    /*Spine.Unity.SkeletonRootMotion start.*/
    /**
     * Add this component to a SkeletonAnimation or SkeletonGraphic GameObject
     to turn motion of a selected root bone into Transform or RigidBody motion.
     Local bone translation movement is used as motion.
     All top-level bones of the skeleton are moved to compensate the root
     motion bone location, keeping the distance relationship between bones intact.
     *
     * @public
     * @class Spine.Unity.SkeletonRootMotion
     * @augments Spine.Unity.SkeletonRootMotionBase
     */
    Bridge.define("Spine.Unity.SkeletonRootMotion", {
        inherits: [Spine.Unity.SkeletonRootMotionBase],
        statics: {
            fields: {
                DefaultAnimationTrackFlags: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#init", this ); }

                    this.DefaultAnimationTrackFlags = -1;
                }
            }
        },
        fields: {
            animationTrackFlags: 0,
            animationState: null,
            canvas: null
        },
        props: {
            AdditionalScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#AdditionalScale#get", this ); }

                    return UnityEngine.Object.op_Implicit(this.canvas) ? this.canvas.referencePixelsPerUnit : 1.0;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#init", this ); }

                this.animationTrackFlags = -1;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRootMotion.GetRemainingRootMotion start.*/
            GetRemainingRootMotion: function (trackIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#GetRemainingRootMotion", this ); }

                var track = this.animationState.GetCurrent(trackIndex);
                if (track == null) {
                    return pc.Vec2.ZERO.clone();
                }

                var animation = track.Animation;
                var start = track.AnimationTime;
                var end = animation.duration;
                return this.GetAnimationRootMotion$1(start, end, animation);
            },
            /*Spine.Unity.SkeletonRootMotion.GetRemainingRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotion.GetRootMotionInfo start.*/
            GetRootMotionInfo: function (trackIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#GetRootMotionInfo", this ); }

                var track = this.animationState.GetCurrent(trackIndex);
                if (track == null) {
                    return new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                }

                var animation = track.Animation;
                var time = track.AnimationTime;
                return this.GetAnimationRootMotionInfo(track.Animation, time);
            },
            /*Spine.Unity.SkeletonRootMotion.GetRootMotionInfo end.*/

            /*Spine.Unity.SkeletonRootMotion.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#Reset", this ); }

                Spine.Unity.SkeletonRootMotionBase.prototype.Reset.call(this);
                this.animationTrackFlags = Spine.Unity.SkeletonRootMotion.DefaultAnimationTrackFlags;
            },
            /*Spine.Unity.SkeletonRootMotion.Reset end.*/

            /*Spine.Unity.SkeletonRootMotion.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#Start", this ); }

                Spine.Unity.SkeletonRootMotionBase.prototype.Start.call(this);
                var animstateComponent = Bridge.as(this.skeletonComponent, Spine.Unity.IAnimationStateComponent);
                this.animationState = (animstateComponent != null) ? animstateComponent.Spine$Unity$IAnimationStateComponent$AnimationState : null;

                if (UnityEngine.Component.op_Inequality(this.GetComponent(UnityEngine.CanvasRenderer), null)) {
                    this.canvas = this.GetComponentInParent(UnityEngine.Canvas);
                }
            },
            /*Spine.Unity.SkeletonRootMotion.Start end.*/

            /*Spine.Unity.SkeletonRootMotion.CalculateAnimationsMovementDelta start.*/
            CalculateAnimationsMovementDelta: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#CalculateAnimationsMovementDelta", this ); }

                var localDelta = pc.Vec2.ZERO.clone();
                var trackCount = this.animationState.Tracks.Count;

                for (var trackIndex = 0; trackIndex < trackCount; trackIndex = (trackIndex + 1) | 0) {
                    // note: animationTrackFlags != -1 below covers trackIndex >= 32,
                    // with -1 corresponding to entry "everything" of the dropdown list.
                    if (this.animationTrackFlags !== -1 && (this.animationTrackFlags & 1 << trackIndex) === 0) {
                        continue;
                    }

                    var track = this.animationState.GetCurrent(trackIndex);
                    var next = null;
                    while (track != null) {
                        var animation = track.Animation;
                        var start = track.animationLast;
                        var end = track.AnimationTime;
                        var currentDelta = { v : this.GetAnimationRootMotion$1(start, end, animation) };
                        if (!pc.Vec2.equals( currentDelta.v, pc.Vec2.ZERO.clone() )) {
                            this.ApplyMixAlphaToDelta(currentDelta, next, track);
                            localDelta = localDelta.$clone().add( currentDelta.v.$clone() );
                        }

                        // Traverse mixingFrom chain.
                        next = track;
                        track = track.mixingFrom;
                    }
                }
                return localDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotion.CalculateAnimationsMovementDelta end.*/

            /*Spine.Unity.SkeletonRootMotion.ApplyMixAlphaToDelta start.*/
            ApplyMixAlphaToDelta: function (currentDelta, next, track) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#ApplyMixAlphaToDelta", this ); }

                // Apply mix alpha to the delta position (based on AnimationState.cs).
                var mix;
                if (next != null) {
                    if (next.mixDuration === 0) { // Single frame mix to undo mixingFrom changes.
                        mix = 1;
                    } else {
                        mix = next.mixTime / next.mixDuration;
                        if (mix > 1) {
                            mix = 1;
                        }
                    }
                    var mixAndAlpha = track.alpha * next.interruptAlpha * (1 - mix);
                    currentDelta.v = currentDelta.v.$clone().scale( mixAndAlpha );
                } else {
                    if (track.mixDuration === 0) {
                        mix = 1;
                    } else {
                        mix = track.alpha * (track.mixTime / track.mixDuration);
                        if (mix > 1) {
                            mix = 1;
                        }
                    }
                    currentDelta.v = currentDelta.v.$clone().scale( mix );
                }
            },
            /*Spine.Unity.SkeletonRootMotion.ApplyMixAlphaToDelta end.*/


        }
    });
    /*Spine.Unity.SkeletonRootMotion end.*/

    /*Spine.Unity.SpineAnimation start.*/
    Bridge.define("Spine.Unity.SpineAnimation", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAnimation#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineAnimation end.*/

    /*Spine.Unity.SpineAtlasAsset start.*/
    /**
     * Loads and stores a Spine atlas and list of materials.
     *
     * @public
     * @class Spine.Unity.SpineAtlasAsset
     * @augments Spine.Unity.AtlasAssetBase
     */
    Bridge.define("Spine.Unity.SpineAtlasAsset", {
        inherits: [Spine.Unity.AtlasAssetBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance:static start.*/
                /**
                 * Creates a runtime AtlasAsset
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineAtlasAsset
                 * @memberof Spine.Unity.SpineAtlasAsset
                 * @param   {UnityEngine.TextAsset}           atlasText     
                 * @param   {Array.<UnityEngine.Material>}    materials     
                 * @param   {boolean}                         initialize
                 * @return  {Spine.Unity.SpineAtlasAsset}
                 */
                CreateRuntimeInstance: function (atlasText, materials, initialize) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance", this ); }

                    var atlasAsset = UnityEngine.ScriptableObject.CreateInstance(Spine.Unity.SpineAtlasAsset);
                    atlasAsset.Reset();
                    atlasAsset.atlasFile = atlasText;
                    atlasAsset.materials = materials;

                    if (initialize) {
                        atlasAsset.GetAtlas();
                    }

                    return atlasAsset;
                },
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance:static end.*/

                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$1:static start.*/
                /**
                 * Creates a runtime AtlasAsset. Only providing the textures is slower because it has to search for atlas page matches. <seealso cref="Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance(TextAsset, Material[], bool)" />
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineAtlasAsset
                 * @memberof Spine.Unity.SpineAtlasAsset
                 * @param   {UnityEngine.TextAsset}            atlasText                 
                 * @param   {Array.<UnityEngine.Texture2D>}    textures                  
                 * @param   {UnityEngine.Material}             materialPropertySource    
                 * @param   {boolean}                          initialize
                 * @return  {Spine.Unity.SpineAtlasAsset}
                 * @see {@link Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance(TextAsset, Material[], bool)}
                 */
                CreateRuntimeInstance$1: function (atlasText, textures, materialPropertySource, initialize) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance$1", this ); }

                    // Get atlas page names.
                    var atlasString = atlasText.text;
                    atlasString = System.String.replaceAll(atlasString, "\r", "");
                    var atlasLines = System.String.split(atlasString, [10].map(function (i) {{ return String.fromCharCode(i); }}));
                    var pages = new (System.Collections.Generic.List$1(System.String)).ctor();
                    for (var i = 0; i < ((atlasLines.length - 1) | 0); i = (i + 1) | 0) {
                        if (atlasLines[i].trim().length === 0) {
                            pages.add(System.String.replaceAll(atlasLines[((i + 1) | 0)].trim(), ".png", ""));
                        }
                    }

                    // Populate Materials[] by matching texture names with page names.
                    var materials = System.Array.init(pages.Count, null, UnityEngine.Material);
                    for (var i1 = 0, n = pages.Count; i1 < n; i1 = (i1 + 1) | 0) {
                        var mat = null;

                        // Search for a match.
                        var pageName = pages.getItem(i1);
                        for (var j = 0, m = textures.length; j < m; j = (j + 1) | 0) {
                            if (System.String.equals(pageName, textures[j].name, 5)) {
                                // Match found.
                                mat = new UnityEngine.Material.$ctor1(materialPropertySource);
                                mat.mainTexture = textures[j];
                                break;
                            }
                        }

                        if (mat != null) {
                            materials[i1] = mat;
                        } else {
                            throw new System.ArgumentException.$ctor1("Could not find matching atlas page in the texture array.");
                        }
                    }

                    // Create AtlasAsset normally
                    return Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance(atlasText, materials, initialize);
                },
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$1:static end.*/

                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$2:static start.*/
                /**
                 * Creates a runtime AtlasAsset. Only providing the textures is slower because it has to search for atlas page matches. <seealso cref="Spine.Unity.AtlasAssetBase.CreateRuntimeInstance(TextAsset, Material[], bool)" />
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineAtlasAsset
                 * @memberof Spine.Unity.SpineAtlasAsset
                 * @param   {UnityEngine.TextAsset}            atlasText     
                 * @param   {Array.<UnityEngine.Texture2D>}    textures      
                 * @param   {UnityEngine.Shader}               shader        
                 * @param   {boolean}                          initialize
                 * @return  {Spine.Unity.SpineAtlasAsset}
                 * @see {@link Spine.Unity.AtlasAssetBase.CreateRuntimeInstance(TextAsset, Material[], bool)}
                 */
                CreateRuntimeInstance$2: function (atlasText, textures, shader, initialize) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance$2", this ); }

                    if (shader == null) {
                        shader = UnityEngine.Shader.Find("Spine/Skeleton");
                    }

                    var materialProperySource = new UnityEngine.Material.$ctor2(shader);
                    var oa = Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$1(atlasText, textures, materialProperySource, initialize);

                    return oa;
                },
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$2:static end.*/


            }
        },
        fields: {
            atlasFile: null,
            materials: null,
            atlas: null
        },
        props: {
            IsLoaded: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#IsLoaded#get", this ); }

                    return this.atlas != null;
                }
            },
            Materials: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#Materials#get", this ); }

                    return this.materials;
                }
            },
            MaterialCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#MaterialCount#get", this ); }

                    return this.materials == null ? 0 : this.materials.length;
                }
            },
            PrimaryMaterial: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#PrimaryMaterial#get", this ); }

                    return this.materials[0];
                }
            }
        },
        methods: {
            /*Spine.Unity.SpineAtlasAsset.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#Reset", this ); }

                this.Clear();
            },
            /*Spine.Unity.SpineAtlasAsset.Reset end.*/

            /*Spine.Unity.SpineAtlasAsset.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#Clear", this ); }

                this.atlas = null;
            },
            /*Spine.Unity.SpineAtlasAsset.Clear end.*/

            /*Spine.Unity.SpineAtlasAsset.GetAtlas start.*/
            /**
             * @instance
             * @public
             * @override
             * @this Spine.Unity.SpineAtlasAsset
             * @memberof Spine.Unity.SpineAtlasAsset
             * @return  {Spine.Atlas}        The atlas or null if it could not be loaded.
             */
            GetAtlas: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#GetAtlas", this ); }

                if (this.atlasFile == null) {
                    UnityEngine.Debug.LogError$2("Atlas file not set for atlas asset: " + (this.name || ""), this);
                    this.Clear();
                    return null;
                }

                if (this.materials == null || this.materials.length === 0) {
                    UnityEngine.Debug.LogError$2("Materials not set for atlas asset: " + (this.name || ""), this);
                    this.Clear();
                    return null;
                }

                if (this.atlas != null) {
                    return this.atlas;
                }

                try {
                    this.atlas = new Spine.Atlas.$ctor1(new System.IO.StringReader(this.atlasFile.text), "", new Spine.Unity.MaterialsTextureLoader(this));
                    this.atlas.FlipV();
                    return this.atlas;
                } catch (ex) {
                    ex = System.Exception.create(ex);
                    UnityEngine.Debug.LogError$2("Error reading atlas file for atlas asset: " + (this.name || "") + "\n" + (ex.Message || "") + "\n" + (ex.StackTrace || ""), this);
                    return null;
                }
            },
            /*Spine.Unity.SpineAtlasAsset.GetAtlas end.*/

            /*Spine.Unity.SpineAtlasAsset.GenerateMesh start.*/
            GenerateMesh: function (name, mesh, material, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#GenerateMesh", this ); }

                if (scale === void 0) { scale = 0.01; }
                var region = this.atlas.FindRegion(name);
                material.v = null;
                if (region != null) {
                    if (mesh == null) {
                        mesh = new UnityEngine.Mesh.ctor();
                        mesh.name = name;
                    }

                    var verts = System.Array.init(4, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    var uvs = System.Array.init(4, function (){
                        return new UnityEngine.Vector2();
                    }, UnityEngine.Vector2);
                    var colors = System.Array.init([
                        new pc.Color( 1, 1, 1, 1 ), 
                        new pc.Color( 1, 1, 1, 1 ), 
                        new pc.Color( 1, 1, 1, 1 ), 
                        new pc.Color( 1, 1, 1, 1 )
                    ], UnityEngine.Color);
                    var triangles = System.Array.init([
                        0, 
                        1, 
                        2, 
                        2, 
                        3, 
                        0
                    ], System.Int32);

                    var left, right, top, bottom;
                    left = region.width / -2.0;
                    right = left * -1.0;
                    top = region.height / 2.0;
                    bottom = top * -1;

                    verts[0] = new pc.Vec3( left, bottom, 0 ).clone().scale( scale );
                    verts[1] = new pc.Vec3( left, top, 0 ).clone().scale( scale );
                    verts[2] = new pc.Vec3( right, top, 0 ).clone().scale( scale );
                    verts[3] = new pc.Vec3( right, bottom, 0 ).clone().scale( scale );
                    var u, v, u2, v2;
                    u = region.u;
                    v = region.v;
                    u2 = region.u2;
                    v2 = region.v2;

                    if (!region.rotate) {
                        uvs[0] = new pc.Vec2( u, v2 );
                        uvs[1] = new pc.Vec2( u, v );
                        uvs[2] = new pc.Vec2( u2, v );
                        uvs[3] = new pc.Vec2( u2, v2 );
                    } else {
                        uvs[0] = new pc.Vec2( u2, v2 );
                        uvs[1] = new pc.Vec2( u, v2 );
                        uvs[2] = new pc.Vec2( u, v );
                        uvs[3] = new pc.Vec2( u2, v );
                    }

                    mesh.triangles = System.Array.init(0, 0, System.Int32);
                    mesh.vertices = verts;
                    mesh.uv = uvs;
                    mesh.colors = colors;
                    mesh.triangles = triangles;
                    mesh.RecalculateNormals();
                    mesh.RecalculateBounds();

                    material.v = Bridge.cast(region.page.rendererObject, UnityEngine.Material);
                } else {
                    mesh = null;
                }

                return mesh;
            },
            /*Spine.Unity.SpineAtlasAsset.GenerateMesh end.*/


        }
    });
    /*Spine.Unity.SpineAtlasAsset end.*/

    /*Spine.Unity.SpineAttachment start.*/
    Bridge.define("Spine.Unity.SpineAttachment", {
        inherits: [Spine.Unity.SpineAttributeBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineAttachment.getHierarchy:static start.*/
                getHierarchy: function (fullPath) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#getHierarchy", this ); }

                    return new Spine.Unity.SpineAttachment.Hierarchy.$ctor1(fullPath);
                },
                /*Spine.Unity.SpineAttachment.getHierarchy:static end.*/

                /*Spine.Unity.SpineAttachment.getAttachment:static start.*/
                getAttachment: function (attachmentPath, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#getAttachment", this ); }

                    var hierarchy = Spine.Unity.SpineAttachment.getHierarchy(attachmentPath);
                    return System.String.isNullOrEmpty(hierarchy.name) ? null : skeletonData.FindSkin(hierarchy.skin).GetAttachment(skeletonData.FindSlotIndex(hierarchy.slot), hierarchy.name);
                },
                /*Spine.Unity.SpineAttachment.getAttachment:static end.*/

                /*Spine.Unity.SpineAttachment.getAttachment$1:static start.*/
                getAttachment$1: function (attachmentPath, skeletonDataAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#getAttachment$1", this ); }

                    return Spine.Unity.SpineAttachment.getAttachment(attachmentPath, skeletonDataAsset.GetSkeletonData(true));
                },
                /*Spine.Unity.SpineAttachment.getAttachment$1:static end.*/


            }
        },
        fields: {
            returnAttachmentPath: false,
            currentSkinOnly: false,
            placeholdersOnly: false,
            skinField: null,
            slotField: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#init", this ); }

                this.returnAttachmentPath = false;
                this.currentSkinOnly = false;
                this.placeholdersOnly = false;
                this.skinField = "";
                this.slotField = "";
            },
            
            ctor: function (currentSkinOnly, returnAttachmentPath, placeholdersOnly, slotField, dataField, skinField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#ctor", this ); }

                if (currentSkinOnly === void 0) { currentSkinOnly = true; }
                if (returnAttachmentPath === void 0) { returnAttachmentPath = false; }
                if (placeholdersOnly === void 0) { placeholdersOnly = false; }
                if (slotField === void 0) { slotField = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (skinField === void 0) { skinField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.currentSkinOnly = currentSkinOnly;
                this.returnAttachmentPath = returnAttachmentPath;
                this.placeholdersOnly = placeholdersOnly;
                this.slotField = slotField;
                this.dataField = dataField;
                this.skinField = skinField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineAttachment end.*/

    /*Spine.Unity.SpineBone start.*/
    Bridge.define("Spine.Unity.SpineBone", {
        inherits: [Spine.Unity.SpineAttributeBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineBone.getBone:static start.*/
                getBone: function (boneName, renderer) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineBone#getBone", this ); }

                    return renderer.skeleton == null ? null : renderer.skeleton.FindBone(boneName);
                },
                /*Spine.Unity.SpineBone.getBone:static end.*/

                /*Spine.Unity.SpineBone.getBoneData:static start.*/
                getBoneData: function (boneName, skeletonDataAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineBone#getBoneData", this ); }

                    var data = skeletonDataAsset.GetSkeletonData(true);
                    return data.FindBone(boneName);
                },
                /*Spine.Unity.SpineBone.getBoneData:static end.*/


            }
        },
        ctors: {
            
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineBone#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineBone end.*/

    /*Spine.Unity.SpineEvent start.*/
    Bridge.define("Spine.Unity.SpineEvent", {
        inherits: [Spine.Unity.SpineAttributeBase],
        fields: {
            /**
             * Smart popup menu for Spine Events (Spine.EventData)
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SpineEvent
             * @default false
             * @type boolean
             */
            audioOnly: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineEvent#init", this ); }

                this.audioOnly = false;
            },
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField, audioOnly) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineEvent#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }
                if (audioOnly === void 0) { audioOnly = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
                this.audioOnly = audioOnly;
            }
        }
    });
    /*Spine.Unity.SpineEvent end.*/

    /*Spine.Unity.SpineIkConstraint start.*/
    Bridge.define("Spine.Unity.SpineIkConstraint", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            /**
             * Smart popup menu for Spine IK Constraints (Spine.IkConstraint)
             *
             * @instance
             * @public
             * @this Spine.Unity.SpineIkConstraint
             * @memberof Spine.Unity.SpineIkConstraint
             * @param   {string}     startsWith             Filters popup results to elements that begin with supplied string.
             * @param   {string}     dataField              If specified, a locally scoped field with the name supplied by in dataField will be used to fill the popup results.
             Valid types are SkeletonDataAsset and SkeletonRenderer (and derivatives).
             If left empty and the script the attribute is applied to is derived from Component, GetComponent(SkeletonRenderer)() will be called as a fallback.
             * @param   {boolean}    includeNone            If true, the dropdown list will include a "none" option which stored as an empty string.
             * @param   {boolean}    fallbackToTextField    If true, and an animation list source can't be found, the field will fall back to a normal text field. If false, it will show an error.
             * @return  {void}
             */
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineIkConstraint#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineIkConstraint end.*/

    /*Spine.Unity.SpinePathConstraint start.*/
    Bridge.define("Spine.Unity.SpinePathConstraint", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            /**
             * Smart popup menu for Spine Events (Spine.PathConstraint)
             *
             * @instance
             * @public
             * @this Spine.Unity.SpinePathConstraint
             * @memberof Spine.Unity.SpinePathConstraint
             * @param   {string}     startsWith             Filters popup results to elements that begin with supplied string.
             * @param   {string}     dataField              If specified, a locally scoped field with the name supplied by in dataField will be used to fill the popup results.
             Valid types are SkeletonDataAsset and SkeletonRenderer (and derivatives).
             If left empty and the script the attribute is applied to is derived from Component, GetComponent(SkeletonRenderer)() will be called as a fallback.
             * @param   {boolean}    includeNone            If true, the dropdown list will include a "none" option which stored as an empty string.
             * @param   {boolean}    fallbackToTextField
             * @return  {void}
             */
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpinePathConstraint#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpinePathConstraint end.*/

    /*Spine.Unity.SpineSkin start.*/
    Bridge.define("Spine.Unity.SpineSkin", {
        inherits: [Spine.Unity.SpineAttributeBase],
        fields: {
            
            defaultAsEmptyString: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSkin#init", this ); }

                this.defaultAsEmptyString = false;
            },
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField, defaultAsEmptyString) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSkin#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }
                if (defaultAsEmptyString === void 0) { defaultAsEmptyString = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
                this.defaultAsEmptyString = defaultAsEmptyString;
            }
        }
    });
    /*Spine.Unity.SpineSkin end.*/

    /*Spine.Unity.SpineSlot start.*/
    Bridge.define("Spine.Unity.SpineSlot", {
        inherits: [Spine.Unity.SpineAttributeBase],
        fields: {
            containsBoundingBoxes: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSlot#init", this ); }

                this.containsBoundingBoxes = false;
            },
            
            ctor: function (startsWith, dataField, containsBoundingBoxes, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSlot#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (containsBoundingBoxes === void 0) { containsBoundingBoxes = false; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.containsBoundingBoxes = containsBoundingBoxes;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineSlot end.*/

    /*Spine.Unity.SpineSpriteAtlasAsset start.*/
    /**
     * Loads and stores a Spine atlas and list of materials.
     *
     * @public
     * @class Spine.Unity.SpineSpriteAtlasAsset
     * @augments Spine.Unity.AtlasAssetBase
     */
    Bridge.define("Spine.Unity.SpineSpriteAtlasAsset", {
        inherits: [Spine.Unity.AtlasAssetBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineSpriteAtlasAsset.CreateRuntimeInstance:static start.*/
                /**
                 * Creates a runtime AtlasAsset
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineSpriteAtlasAsset
                 * @memberof Spine.Unity.SpineSpriteAtlasAsset
                 * @param   {UnityEngine.U2D.SpriteAtlas}          spriteAtlasFile    
                 * @param   {Array.<UnityEngine.Material>}         materials          
                 * @param   {boolean}                              initialize
                 * @return  {Spine.Unity.SpineSpriteAtlasAsset}
                 */
                CreateRuntimeInstance: function (spriteAtlasFile, materials, initialize) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#CreateRuntimeInstance", this ); }

                    var atlasAsset = UnityEngine.ScriptableObject.CreateInstance(Spine.Unity.SpineSpriteAtlasAsset);
                    atlasAsset.Reset();
                    atlasAsset.spriteAtlasFile = spriteAtlasFile;
                    atlasAsset.materials = materials;

                    if (initialize) {
                        atlasAsset.GetAtlas();
                    }

                    return atlasAsset;
                },
                /*Spine.Unity.SpineSpriteAtlasAsset.CreateRuntimeInstance:static end.*/

                /*Spine.Unity.SpineSpriteAtlasAsset.AccessPackedTexture:static start.*/
                AccessPackedTexture: function (sprites) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#AccessPackedTexture", this ); }

                    return sprites[0].texture;
                },
                /*Spine.Unity.SpineSpriteAtlasAsset.AccessPackedTexture:static end.*/

                /*Spine.Unity.SpineSpriteAtlasAsset.AccessPackedSprites:static start.*/
                AccessPackedSprites: function (spriteAtlas) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#AccessPackedSprites", this ); }

                    var sprites = null;
                    if (sprites == null) {
                        sprites = System.Array.init(spriteAtlas.spriteCount, null, UnityEngine.Sprite);
                        spriteAtlas.GetSprites(sprites);
                        if (sprites.length === 0) {
                            return null;
                        }
                    }
                    return sprites;
                },
                /*Spine.Unity.SpineSpriteAtlasAsset.AccessPackedSprites:static end.*/


            }
        },
        fields: {
            spriteAtlasFile: null,
            materials: null,
            atlas: null,
            updateRegionsInPlayMode: false,
            savedRegions: null
        },
        props: {
            IsLoaded: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#IsLoaded#get", this ); }

                    return this.atlas != null;
                }
            },
            Materials: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#Materials#get", this ); }

                    return this.materials;
                }
            },
            MaterialCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#MaterialCount#get", this ); }

                    return this.materials == null ? 0 : this.materials.length;
                }
            },
            PrimaryMaterial: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#PrimaryMaterial#get", this ); }

                    return this.materials[0];
                }
            }
        },
        methods: {
            /*Spine.Unity.SpineSpriteAtlasAsset.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#Reset", this ); }

                this.Clear();
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.Reset end.*/

            /*Spine.Unity.SpineSpriteAtlasAsset.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#Clear", this ); }

                this.atlas = null;
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.Clear end.*/

            /*Spine.Unity.SpineSpriteAtlasAsset.GetAtlas start.*/
            /**
             * @instance
             * @public
             * @override
             * @this Spine.Unity.SpineSpriteAtlasAsset
             * @memberof Spine.Unity.SpineSpriteAtlasAsset
             * @return  {Spine.Atlas}        The atlas or null if it could not be loaded.
             */
            GetAtlas: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#GetAtlas", this ); }

                if (this.spriteAtlasFile == null) {
                    UnityEngine.Debug.LogError$2("SpriteAtlas file not set for SpineSpriteAtlasAsset: " + (this.name || ""), this);
                    this.Clear();
                    return null;
                }

                if (this.materials == null || this.materials.length === 0) {
                    UnityEngine.Debug.LogError$2("Materials not set for SpineSpriteAtlasAsset: " + (this.name || ""), this);
                    this.Clear();
                    return null;
                }

                if (this.atlas != null) {
                    return this.atlas;
                }

                try {
                    this.atlas = this.LoadAtlas(this.spriteAtlasFile);
                    return this.atlas;
                } catch (ex) {
                    ex = System.Exception.create(ex);
                    UnityEngine.Debug.LogError$2("Error analyzing SpriteAtlas for SpineSpriteAtlasAsset: " + (this.name || "") + "\n" + (ex.Message || "") + "\n" + (ex.StackTrace || ""), this);
                    return null;
                }
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.GetAtlas end.*/

            /*Spine.Unity.SpineSpriteAtlasAsset.AssignRegionsFromSavedRegions start.*/
            AssignRegionsFromSavedRegions: function (sprites, usedAtlas) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#AssignRegionsFromSavedRegions", this ); }

                var $t;

                if (this.savedRegions == null || this.savedRegions.length !== sprites.length) {
                    return;
                }

                var i = 0;
                $t = Bridge.getEnumerator(usedAtlas);
                try {
                    while ($t.moveNext()) {
                        var region = $t.Current;
                        var savedRegion = this.savedRegions[i];
                        var page = region.page;

                        region.degrees = savedRegion.packingRotation === UnityEngine.SpritePackingRotation.None ? 0 : 90;
                        region.rotate = region.degrees !== 0;

                        var x = savedRegion.x;
                        var y = savedRegion.y;
                        var width = savedRegion.width;
                        var height = savedRegion.height;

                        region.u = x / page.width;
                        region.v = y / page.height;
                        if (region.rotate) {
                            region.u2 = (x + height) / page.width;
                            region.v2 = (y + width) / page.height;
                        } else {
                            region.u2 = (x + width) / page.width;
                            region.v2 = (y + height) / page.height;
                        }
                        region.x = Bridge.Int.clip32(x);
                        region.y = Bridge.Int.clip32(y);
                        region.width = Math.abs(Bridge.Int.clip32(width));
                        region.height = Math.abs(Bridge.Int.clip32(height));

                        // flip upside down
                        var temp = region.v;
                        region.v = region.v2;
                        region.v2 = temp;

                        region.originalWidth = Bridge.Int.clip32(width);
                        region.originalHeight = Bridge.Int.clip32(height);

                        // note: currently sprite pivot offsets are ignored.
                        // var sprite = sprites[i];
                        region.offsetX = 0; //sprite.pivot.x;
                        region.offsetY = 0; //sprite.pivot.y;

                        i = (i + 1) | 0;
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.AssignRegionsFromSavedRegions end.*/

            /*Spine.Unity.SpineSpriteAtlasAsset.LoadAtlas start.*/
            LoadAtlas: function (spriteAtlas) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#LoadAtlas", this ); }


                var pages = new (System.Collections.Generic.List$1(Spine.AtlasPage)).ctor();
                var regions = new (System.Collections.Generic.List$1(Spine.AtlasRegion)).ctor();

                var sprites = System.Array.init(spriteAtlas.spriteCount, null, UnityEngine.Sprite);
                spriteAtlas.GetSprites(sprites);
                if (sprites.length === 0) {
                    return new Spine.Atlas.ctor(pages, regions);
                }

                var texture = null;
                texture = Spine.Unity.SpineSpriteAtlasAsset.AccessPackedTexture(sprites);

                var material = this.materials[0];
                material.mainTexture = texture;

                var page = new Spine.AtlasPage();
                page.name = spriteAtlas.name;
                page.width = texture.width;
                page.height = texture.height;
                page.format = Spine.Format.RGBA8888;

                page.minFilter = Spine.TextureFilter.Linear;
                page.magFilter = Spine.TextureFilter.Linear;
                page.uWrap = Spine.TextureWrap.ClampToEdge;
                page.vWrap = Spine.TextureWrap.ClampToEdge;
                page.rendererObject = material;
                pages.add(page);

                sprites = Spine.Unity.SpineSpriteAtlasAsset.AccessPackedSprites(spriteAtlas);

                var i = 0;
                for (; i < sprites.length; i = (i + 1) | 0) {
                    var sprite = sprites[i];
                    var region = new Spine.AtlasRegion();
                    region.name = System.String.replaceAll(sprite.name, "(Clone)", "");
                    region.page = page;
                    region.degrees = sprite.packingRotation === UnityEngine.SpritePackingRotation.None ? 0 : 90;
                    region.rotate = region.degrees !== 0;

                    region.u2 = 1;
                    region.v2 = 1;
                    region.width = page.width;
                    region.height = page.height;
                    region.originalWidth = page.width;
                    region.originalHeight = page.height;

                    region.index = i;
                    regions.add(region);
                }

                var atlas = new Spine.Atlas.ctor(pages, regions);
                this.AssignRegionsFromSavedRegions(sprites, atlas);

                return atlas;
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.LoadAtlas end.*/


        }
    });
    /*Spine.Unity.SpineSpriteAtlasAsset end.*/

    /*Spine.Unity.SpineTransformConstraint start.*/
    Bridge.define("Spine.Unity.SpineTransformConstraint", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineTransformConstraint#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineTransformConstraint end.*/

    /*Spine.Unity.WaitForSpineAnimationComplete start.*/
    /**
     * Use this as a condition-blocking yield instruction for Unity Coroutines.
     The routine will pause until the AnimationState.TrackEntry fires its Complete event.
     It can be configured to trigger on the End event as well to cover interruption.
     <p />
     See the {@link }
     and {@link }
     for more information on when track events will be triggered.
     *
     * @public
     * @class Spine.Unity.WaitForSpineAnimationComplete
     * @augments Spine.Unity.WaitForSpineAnimation
     * @implements  System.Collections.IEnumerator
     */
    Bridge.define("Spine.Unity.WaitForSpineAnimationComplete", {
        inherits: [Spine.Unity.WaitForSpineAnimation,System.Collections.IEnumerator],
        ctors: {
            ctor: function (trackEntry, includeEndEvent) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimationComplete#ctor", this ); }

                if (includeEndEvent === void 0) { includeEndEvent = false; }

                this.$initialize();
                Spine.Unity.WaitForSpineAnimation.ctor.call(this, trackEntry, includeEndEvent ? (20) : Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Complete);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineAnimationComplete.NowWaitFor$1 start.*/
            /**
             * One optimization high-frequency YieldInstruction returns is to cache instances to minimize GC pressure.
             Use NowWaitFor to reuse the same instance of WaitForSpineAnimationComplete.
             *
             * @instance
             * @public
             * @this Spine.Unity.WaitForSpineAnimationComplete
             * @memberof Spine.Unity.WaitForSpineAnimationComplete
             * @param   {Spine.TrackEntry}                             trackEntry         
             * @param   {boolean}                                      includeEndEvent
             * @return  {Spine.Unity.WaitForSpineAnimationComplete}
             */
            NowWaitFor$1: function (trackEntry, includeEndEvent) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimationComplete#NowWaitFor$1", this ); }

                if (includeEndEvent === void 0) { includeEndEvent = false; }
                this.SafeSubscribe(trackEntry, includeEndEvent ? (20) : Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Complete);
                return this;
            },
            /*Spine.Unity.WaitForSpineAnimationComplete.NowWaitFor$1 end.*/


        },
        overloads: {
            "NowWaitFor(Spine.TrackEntry, bool)": "NowWaitFor$1"
        }
    });
    /*Spine.Unity.WaitForSpineAnimationComplete end.*/

    /*Spine.Unity.WaitForSpineAnimationEnd start.*/
    /**
     * Use this as a condition-blocking yield instruction for Unity Coroutines.
     The routine will pause until the AnimationState.TrackEntry fires its End event.
     <p />
     See the {@link }
     and {@link }
     for more information on when track events will be triggered.
     *
     * @public
     * @class Spine.Unity.WaitForSpineAnimationEnd
     * @augments Spine.Unity.WaitForSpineAnimation
     * @implements  System.Collections.IEnumerator
     */
    Bridge.define("Spine.Unity.WaitForSpineAnimationEnd", {
        inherits: [Spine.Unity.WaitForSpineAnimation,System.Collections.IEnumerator],
        ctors: {
            ctor: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimationEnd#ctor", this ); }

                this.$initialize();
                Spine.Unity.WaitForSpineAnimation.ctor.call(this, trackEntry, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.End);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineAnimationEnd.NowWaitFor$1 start.*/
            /**
             * One optimization high-frequency YieldInstruction returns is to cache instances to minimize GC pressure.
             Use NowWaitFor to reuse the same instance of WaitForSpineAnimationComplete.
             *
             * @instance
             * @public
             * @this Spine.Unity.WaitForSpineAnimationEnd
             * @memberof Spine.Unity.WaitForSpineAnimationEnd
             * @param   {Spine.TrackEntry}                        trackEntry
             * @return  {Spine.Unity.WaitForSpineAnimationEnd}
             */
            NowWaitFor$1: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimationEnd#NowWaitFor$1", this ); }

                this.SafeSubscribe(trackEntry, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.End);
                return this;
            },
            /*Spine.Unity.WaitForSpineAnimationEnd.NowWaitFor$1 end.*/


        },
        overloads: {
            "NowWaitFor(Spine.TrackEntry)": "NowWaitFor$1"
        }
    });
    /*Spine.Unity.WaitForSpineAnimationEnd end.*/

    /*GameManager1 start.*/
    Bridge.define("GameManager1", {
        inherits: function () {
if ( TRACE ) { TRACE( "GameManager1#inherits", this ); }
 return [Singleton$1(GameManager1)]; },
        fields: {
            endGame: false,
            panelChoose: null,
            faucet: null,
            lstIngredient: null,
            toppingHolder: null,
            btnAll: null,
            guide: null,
            btnDrink: null,
            currentIndexBeverage: 0,
            firstTouch: false,
            canSpawn: false,
            count: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "GameManager1#init", this ); }

                this.currentIndexBeverage = 0;
                this.canSpawn = true;
                this.count = 0;
            }
        },
        methods: {
            /*GameManager1.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "GameManager1#Start", this ); }

                Luna.Unity.LifeCycle.GameStarted();
            },
            /*GameManager1.Start end.*/

            /*GameManager1.InitBeverageToFill start.*/
            InitBeverageToFill: function (i) {
if ( TRACE ) { TRACE( "GameManager1#InitBeverageToFill", this ); }

                // panelChoose.SetActive(false);
                this.faucet.SetColor(this.lstIngredient.getItem(i).waterColor.$clone());
                this.lstIngredient.getItem(i).glass.gameObject.SetActive(true);
                this.faucet.gameObject.SetActive(true);
            },
            /*GameManager1.InitBeverageToFill end.*/

            /*GameManager1.OnClickBtnDrink start.*/
            OnClickBtnDrink: function () {
if ( TRACE ) { TRACE( "GameManager1#OnClickBtnDrink", this ); }

                Luna.Unity.LifeCycle.GameEnded();
                this.btnAll.SetActive(true);
                this.InstallFullGame();
            },
            /*GameManager1.OnClickBtnDrink end.*/

            /*GameManager1.OnFill start.*/
            OnFill: function (typeBeverage) {
if ( TRACE ) { TRACE( "GameManager1#OnFill", this ); }

                if (!this.firstTouch) {
                    this.guide.SetActive(false);
                    this.btnDrink.SetActive(true);
                    this.firstTouch = true;
                    Luna.Unity.Analytics.LogEvent(Luna.Unity.Analytics.EventType.TutorialComplete);
                }
                Luna.Unity.Analytics.LogEvent$1("Choose Beverage", 1);
                SingletonMono$1(SoundManager).instance.PlaySound(0);
                this.ResetBeverage();
                switch (typeBeverage) {
                    case TypeBeverage.Coca: 
                        this.currentIndexBeverage = 0;
                        this.StartCoroutine$1(this.StartFill(0));
                        break;
                    case TypeBeverage.Lemon: 
                        this.currentIndexBeverage = 1;
                        this.StartCoroutine$1(this.StartFill(1));
                        break;
                    case TypeBeverage.MilkTea: 
                        this.currentIndexBeverage = 2;
                        this.StartCoroutine$1(this.StartFill(2));
                        break;
                    default: 
                        break;
                }

            },
            /*GameManager1.OnFill end.*/

            /*GameManager1.StartFillGlass start.*/
            StartFillGlass: function (i) {
if ( TRACE ) { TRACE( "GameManager1#StartFillGlass", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    _timeFillWater,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    Singleton$1(SoundManager).Instance.pouring.Play();
                                        _timeFillWater = this.lstIngredient.getItem(i).timeFillWater;
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( _timeFillWater > 0 ) {
                                            $step = 2;
                                            continue;
                                        } 
                                        $step = 4;
                                        continue;
                                }
                                case 2: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(UnityEngine.Time.deltaTime);
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    _timeFillWater -= UnityEngine.Time.deltaTime;
                                        this.faucet.Spawn();

                                        $step = 1;
                                        continue;
                                }
                                case 4: {
                                    if (_timeFillWater < 0) {
                                            $step = 5;
                                            continue;
                                        } 
                                        $step = 6;
                                        continue;
                                }
                                case 5: {
                                    this.faucet.StopSpawning();
                                        Singleton$1(SoundManager).Instance.pouring.Stop();
                                        return false;
                                    $step = 6;
                                    continue;
                                }
                                case 6: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*GameManager1.StartFillGlass end.*/

            /*GameManager1.StartDropTopping start.*/
            StartDropTopping: function (i) {
if ( TRACE ) { TRACE( "GameManager1#StartDropTopping", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    lengtLstTopping,
                    timeToSpanwNewTopping,
                    index,
                    prefab,
                    amount,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    lengtLstTopping = this.lstIngredient.getItem(i).lstTopping.Count;
                                        timeToSpanwNewTopping = this.lstIngredient.getItem(i).timeFillTopping;
                                        index = 0;
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( index < lengtLstTopping ) {
                                            $step = 2;
                                            continue;
                                        } 
                                        $step = 8;
                                        continue;
                                }
                                case 2: {
                                    if (timeToSpanwNewTopping < 0) {
                                            $step = 3;
                                            continue;
                                        } else  {
                                            $step = 5;
                                            continue;
                                        }
                                }
                                case 3: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(UnityEngine.Random.Range$1(0.1, 0.2));
                                        $step = 4;
                                        return true;
                                }
                                case 4: {
                                    index = (index + 1) | 0;
                                        timeToSpanwNewTopping = this.lstIngredient.getItem(i).timeFillTopping;
                                        this.canSpawn = true;
                                    $step = 7;
                                    continue;
                                }
                                case 5: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(UnityEngine.Time.deltaTime);
                                        $step = 6;
                                        return true;
                                }
                                case 6: {
                                    timeToSpanwNewTopping -= UnityEngine.Time.deltaTime;
                                        prefab = this.lstIngredient.getItem(i).lstTopping.getItem(index).prefebTopping;
                                        amount = this.lstIngredient.getItem(i).lstTopping.getItem(index).number;
                                        if (this.canSpawn) {
                                            this.StartCoroutine$1(this.SpawnTopping(prefab, amount));
                                            this.canSpawn = false;
                                        }
                                        //  Instantiate(lstIngredient[i].lstTopping[index].gameObject, faucet.transform.position + Vector3.down * 0.2f, Quaternion.identity, toppingHolder.transform);
                                    $step = 7;
                                    continue;
                                }
                                case 7: {
                                    
                                        $step = 1;
                                        continue;
                                }
                                case 8: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*GameManager1.StartDropTopping end.*/

            /*GameManager1.SpawnTopping start.*/
            SpawnTopping: function (prefab, amount) {
if ( TRACE ) { TRACE( "GameManager1#SpawnTopping", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if ( amount > 0 ) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 3;
                                        continue;
                                }
                                case 1: {
                                    amount = (amount - 1) | 0;
                                        $enumerator.current = new UnityEngine.WaitForSeconds(0.05);
                                        $step = 2;
                                        return true;
                                }
                                case 2: {
                                    UnityEngine.Object.Instantiate$3(UnityEngine.GameObject, prefab, this.faucet.GetComponent(UnityEngine.RectTransform).position.$clone().add( pc.Vec3.DOWN.clone().clone().scale( 0.2 ) ), pc.Quat.IDENTITY.clone(), this.toppingHolder.transform);


                                        $step = 0;
                                        continue;
                                }
                                case 3: {
                                    if (amount <= 0) {
                                            $step = 4;
                                            continue;
                                        } 
                                        $step = 5;
                                        continue;
                                }
                                case 4: {
                                    return false;
                                }
                                case 5: {
                                    //for (int i = 0; i < amount; i++)
                                        //{
                                        //    Instantiate(prefab, faucet.transform.position + Vector3.down * 0.2f, Quaternion.identity, toppingHolder.transform);
                                        //}

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*GameManager1.SpawnTopping end.*/

            /*GameManager1.StartFill start.*/
            StartFill: function (i) {
if ( TRACE ) { TRACE( "GameManager1#StartFill", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    this.InitBeverageToFill(i);
                                        $enumerator.current = new UnityEngine.WaitForSeconds(0.5);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    this.StartCoroutine$1(this.StartFillGlass(i));
                                        $enumerator.current = new UnityEngine.WaitForSeconds(0.5);
                                        $step = 2;
                                        return true;
                                }
                                case 2: {
                                    this.StartCoroutine$1(this.StartDropTopping(i));

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*GameManager1.StartFill end.*/

            /*GameManager1.ResetBeverage start.*/
            ResetBeverage: function () {
if ( TRACE ) { TRACE( "GameManager1#ResetBeverage", this ); }

                this.StopAllCoroutines();
                this.lstIngredient.getItem(this.currentIndexBeverage).glass.gameObject.SetActive(false);
                for (var i = 0; i < this.toppingHolder.transform.childCount; i = (i + 1) | 0) {
                    if (UnityEngine.Object.op_Implicit(this.toppingHolder.transform.GetChild(i).GetComponent(DrinkMaterial))) {
                        this.toppingHolder.transform.GetChild(i).GetComponent(DrinkMaterial).Destroying();
                    }
                }
                //GameObject waterHolder = GameObject.Find("Liquid_");
                //if (waterHolder != null)
                //    Destroy(waterHolder);
                this.faucet.Clean();

            },
            /*GameManager1.ResetBeverage end.*/

            /*GameManager1.InstallFullGame start.*/
            InstallFullGame: function () {
if ( TRACE ) { TRACE( "GameManager1#InstallFullGame", this ); }

                Luna.Unity.Playable.InstallFullGame();
            },
            /*GameManager1.InstallFullGame end.*/

            /*GameManager1.CheckShowEndcard start.*/
            CheckShowEndcard: function () {
if ( TRACE ) { TRACE( "GameManager1#CheckShowEndcard", this ); }

                this.count = (this.count + 1) | 0;
                return this.count > 2;

            },
            /*GameManager1.CheckShowEndcard end.*/


        }
    });
    /*GameManager1 end.*/

    /*GameManager2 start.*/
    Bridge.define("GameManager2", {
        inherits: function () {
if ( TRACE ) { TRACE( "GameManager2#inherits", this ); }
 return [Singleton$1(GameManager2)]; },
        fields: {
            lstFaucet: null,
            faucet: null,
            faucet1: null,
            faucet2: null
        },
        methods: {
            /*GameManager2.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "GameManager2#Start", this ); }

                Luna.Unity.LifeCycle.GameStarted();
                Luna.Unity.LifeCycle.GameEnded();
                this.StartCoroutine$1(this.FillGlass());
            },
            /*GameManager2.Start end.*/

            /*GameManager2.InstallFullGame start.*/
            InstallFullGame: function () {
if ( TRACE ) { TRACE( "GameManager2#InstallFullGame", this ); }

                Luna.Unity.Playable.InstallFullGame();
            },
            /*GameManager2.InstallFullGame end.*/

            /*GameManager2.FillGlass start.*/
            FillGlass: function () {
if ( TRACE ) { TRACE( "GameManager2#FillGlass", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(1);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    this.StartCoroutine$1(this.StartFillGlass(0, 2.0));
                                        $enumerator.current = new UnityEngine.WaitForSeconds(3);
                                        $step = 2;
                                        return true;
                                }
                                case 2: {
                                    this.StartCoroutine$1(this.StartFillGlass(2, 1.0));
                                        $enumerator.current = new UnityEngine.WaitForSeconds(5);
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    this.StartCoroutine$1(this.StartFillGlass(1, 1.0));

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*GameManager2.FillGlass end.*/

            /*GameManager2.StartFillGlass start.*/
            StartFillGlass: function (i, timeFillWater) {
if ( TRACE ) { TRACE( "GameManager2#StartFillGlass", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    _timeFillWater,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    Singleton$1(SoundManager).Instance.pouring.Play();
                                        _timeFillWater = timeFillWater;
                                        this.faucet = this.lstFaucet.getItem(i);
                                        // if (faucet != null) faucet.Clean();
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( _timeFillWater > 0 ) {
                                            $step = 2;
                                            continue;
                                        } 
                                        $step = 4;
                                        continue;
                                }
                                case 2: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(UnityEngine.Time.deltaTime);
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    _timeFillWater -= UnityEngine.Time.deltaTime;
                                        this.faucet.Spawn();

                                        $step = 1;
                                        continue;
                                }
                                case 4: {
                                    if (_timeFillWater < 0) {
                                            $step = 5;
                                            continue;
                                        } 
                                        $step = 6;
                                        continue;
                                }
                                case 5: {
                                    this.faucet.StopSpawning();
                                        Singleton$1(SoundManager).Instance.pouring.Stop();
                                        return false;
                                    $step = 6;
                                    continue;
                                }
                                case 6: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*GameManager2.StartFillGlass end.*/


        }
    });
    /*GameManager2 end.*/

    /*GlobalInstance start.*/
    Bridge.define("GlobalInstance", {
        inherits: function () {
if ( TRACE ) { TRACE( "GlobalInstance#inherits", this ); }
 return [Singleton$1(GlobalInstance)]; },
        fields: {
            gameManager: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "GlobalInstance#init", this ); }

                this.gameManager = Singleton$1(GameManager1).Instance;
            }
        }
    });
    /*GlobalInstance end.*/

    /*SingletonDontDestroyOnLoad$1 start.*/
    Bridge.define("SingletonDontDestroyOnLoad$1", function (T) { return {
        inherits: [Singleton$1(T)],
        methods: {
            /*SingletonDontDestroyOnLoad$1.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "SingletonDontDestroyOnLoad$1#Awake", this ); }

                UnityEngine.Object.DontDestroyOnLoad(this.gameObject);
                Singleton$1(T).prototype.Awake.call(this);
            },
            /*SingletonDontDestroyOnLoad$1.Awake end.*/


        }
    }; });
    /*SingletonDontDestroyOnLoad$1 end.*/

    /*SoundManager start.*/
    Bridge.define("SoundManager", {
        inherits: function () {
if ( TRACE ) { TRACE( "SoundManager#inherits", this ); }
 return [Singleton$1(SoundManager)]; },
        fields: {
            audioConfigs: null,
            pouring: null
        },
        methods: {
            /*SoundManager.PlaySound start.*/
            PlaySound: function (i) {
if ( TRACE ) { TRACE( "SoundManager#PlaySound", this ); }

                this.audioConfigs.getItem(i).audioSource.PlayOneShot$1(this.audioConfigs.getItem(i).clip, this.audioConfigs.getItem(i).volume);
            },
            /*SoundManager.PlaySound end.*/


        }
    });
    /*SoundManager end.*/

    /*Spine.BoundingBoxAttachment start.*/
    /**
     * Attachment that has a polygon for bounds checking.
     *
     * @public
     * @class Spine.BoundingBoxAttachment
     * @augments Spine.VertexAttachment
     */
    Bridge.define("Spine.BoundingBoxAttachment", {
        inherits: [Spine.VertexAttachment],
        ctors: {
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.BoundingBoxAttachment#ctor", this ); }

                this.$initialize();
                Spine.VertexAttachment.ctor.call(this, name);
            }
        },
        methods: {
            /*Spine.BoundingBoxAttachment.Copy start.*/
            Copy: function () {
if ( TRACE ) { TRACE( "Spine.BoundingBoxAttachment#Copy", this ); }

                var copy = new Spine.BoundingBoxAttachment(this.Name);
                this.CopyTo(copy);
                return copy;
            },
            /*Spine.BoundingBoxAttachment.Copy end.*/


        }
    });
    /*Spine.BoundingBoxAttachment end.*/

    /*Spine.ClippingAttachment start.*/
    Bridge.define("Spine.ClippingAttachment", {
        inherits: [Spine.VertexAttachment],
        fields: {
            endSlot: null
        },
        props: {
            EndSlot: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ClippingAttachment#EndSlot#get", this ); }

                    return this.endSlot;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.ClippingAttachment#EndSlot#set", this ); }

                    this.endSlot = value;
                }
            }
        },
        ctors: {
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.ClippingAttachment#ctor", this ); }

                this.$initialize();
                Spine.VertexAttachment.ctor.call(this, name);
            }
        },
        methods: {
            /*Spine.ClippingAttachment.Copy start.*/
            Copy: function () {
if ( TRACE ) { TRACE( "Spine.ClippingAttachment#Copy", this ); }

                var copy = new Spine.ClippingAttachment(this.Name);
                this.CopyTo(copy);
                copy.endSlot = this.endSlot;
                return copy;
            },
            /*Spine.ClippingAttachment.Copy end.*/


        }
    });
    /*Spine.ClippingAttachment end.*/

    /*Spine.ColorTimeline start.*/
    /**
     * Changes a slot's {@link }.
     *
     * @public
     * @class Spine.ColorTimeline
     * @augments Spine.CurveTimeline
     * @implements  Spine.ISlotTimeline
     */
    Bridge.define("Spine.ColorTimeline", {
        inherits: [Spine.CurveTimeline,Spine.ISlotTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                PREV_TIME: 0,
                PREV_R: 0,
                PREV_G: 0,
                PREV_B: 0,
                PREV_A: 0,
                R: 0,
                G: 0,
                B: 0,
                A: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.ColorTimeline#init", this ); }

                    this.ENTRIES = 5;
                    this.PREV_TIME = -5;
                    this.PREV_R = -4;
                    this.PREV_G = -3;
                    this.PREV_B = -2;
                    this.PREV_A = -1;
                    this.R = 1;
                    this.G = 2;
                    this.B = 3;
                    this.A = 4;
                }
            }
        },
        fields: {
            slotIndex: 0,
            frames: null
        },
        props: {
            PropertyId: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ColorTimeline#PropertyId#get", this ); }

                    return (((83886080) + this.slotIndex) | 0);
                }
            },
            /**
             * The index of the slot in {@link } that will be changed.
             *
             * @instance
             * @public
             * @memberof Spine.ColorTimeline
             * @function SlotIndex
             * @type number
             */
            SlotIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ColorTimeline#SlotIndex#get", this ); }

                    return this.slotIndex;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.ColorTimeline#SlotIndex#set", this ); }

                    if (value < 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("index must be >= 0.");
                    }
                    this.slotIndex = value;
                }
            },
            /**
             * The time in seconds, red, green, blue, and alpha values for each key frame.
             *
             * @instance
             * @public
             * @memberof Spine.ColorTimeline
             * @function Frames
             * @type Array.<number>
             */
            Frames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ColorTimeline#Frames#get", this ); }

                    return this.frames;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.ColorTimeline#Frames#set", this ); }

                    this.frames = value;
                }
            }
        },
        alias: [
            "PropertyId", "Spine$Timeline$PropertyId",
            "SlotIndex", "Spine$ISlotTimeline$SlotIndex",
            "Apply", "Spine$Timeline$Apply"
        ],
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.ColorTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount);
                this.frames = System.Array.init(Bridge.Int.mul(frameCount, Spine.ColorTimeline.ENTRIES), 0, System.Single);
            }
        },
        methods: {
            /*Spine.ColorTimeline.SetFrame start.*/
            /**
             * Sets the time in seconds, red, green, blue, and alpha for the specified key frame.
             *
             * @instance
             * @public
             * @this Spine.ColorTimeline
             * @memberof Spine.ColorTimeline
             * @param   {number}    frameIndex    
             * @param   {number}    time          
             * @param   {number}    r             
             * @param   {number}    g             
             * @param   {number}    b             
             * @param   {number}    a
             * @return  {void}
             */
            SetFrame: function (frameIndex, time, r, g, b, a) {
if ( TRACE ) { TRACE( "Spine.ColorTimeline#SetFrame", this ); }

                frameIndex = Bridge.Int.mul(frameIndex, Spine.ColorTimeline.ENTRIES);
                this.frames[frameIndex] = time;
                this.frames[((frameIndex + Spine.ColorTimeline.R) | 0)] = r;
                this.frames[((frameIndex + Spine.ColorTimeline.G) | 0)] = g;
                this.frames[((frameIndex + Spine.ColorTimeline.B) | 0)] = b;
                this.frames[((frameIndex + Spine.ColorTimeline.A) | 0)] = a;
            },
            /*Spine.ColorTimeline.SetFrame end.*/

            /*Spine.ColorTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.ColorTimeline#Apply", this ); }

                var $t;
                var slot = ($t = skeleton.slots.Items)[this.slotIndex];
                if (!slot.bone.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) { // Time is before first frame.
                    var slotData = slot.data;
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            slot.r = slotData.r;
                            slot.g = slotData.g;
                            slot.b = slotData.b;
                            slot.a = slotData.a;
                            return;
                        case Spine.MixBlend.First: 
                            slot.r += (slotData.r - slot.r) * alpha;
                            slot.g += (slotData.g - slot.g) * alpha;
                            slot.b += (slotData.b - slot.b) * alpha;
                            slot.a += (slotData.a - slot.a) * alpha;
                            slot.ClampColor();
                            return;
                    }
                    return;
                }

                var r, g, b, a;
                if (time >= frames[((frames.length - Spine.ColorTimeline.ENTRIES) | 0)]) { // Time is after last frame.
                    var i = frames.length;
                    r = frames[((i + Spine.ColorTimeline.PREV_R) | 0)];
                    g = frames[((i + Spine.ColorTimeline.PREV_G) | 0)];
                    b = frames[((i + Spine.ColorTimeline.PREV_B) | 0)];
                    a = frames[((i + Spine.ColorTimeline.PREV_A) | 0)];
                } else {
                    // Interpolate between the previous frame and the current frame.
                    var frame = Spine.Animation.BinarySearch$1(frames, time, Spine.ColorTimeline.ENTRIES);
                    r = frames[((frame + Spine.ColorTimeline.PREV_R) | 0)];
                    g = frames[((frame + Spine.ColorTimeline.PREV_G) | 0)];
                    b = frames[((frame + Spine.ColorTimeline.PREV_B) | 0)];
                    a = frames[((frame + Spine.ColorTimeline.PREV_A) | 0)];
                    var frameTime = frames[frame];
                    var percent = this.GetCurvePercent(((((Bridge.Int.div(frame, Spine.ColorTimeline.ENTRIES)) | 0) - 1) | 0), 1 - (time - frameTime) / (frames[((frame + Spine.ColorTimeline.PREV_TIME) | 0)] - frameTime));

                    r += (frames[((frame + Spine.ColorTimeline.R) | 0)] - r) * percent;
                    g += (frames[((frame + Spine.ColorTimeline.G) | 0)] - g) * percent;
                    b += (frames[((frame + Spine.ColorTimeline.B) | 0)] - b) * percent;
                    a += (frames[((frame + Spine.ColorTimeline.A) | 0)] - a) * percent;
                }
                if (alpha === 1) {
                    slot.r = r;
                    slot.g = g;
                    slot.b = b;
                    slot.a = a;
                    slot.ClampColor();
                } else {
                    var br, bg, bb, ba;
                    if (blend === Spine.MixBlend.Setup) {
                        br = slot.data.r;
                        bg = slot.data.g;
                        bb = slot.data.b;
                        ba = slot.data.a;
                    } else {
                        br = slot.r;
                        bg = slot.g;
                        bb = slot.b;
                        ba = slot.a;
                    }
                    slot.r = br + ((r - br) * alpha);
                    slot.g = bg + ((g - bg) * alpha);
                    slot.b = bb + ((b - bb) * alpha);
                    slot.a = ba + ((a - ba) * alpha);
                    slot.ClampColor();
                }
            },
            /*Spine.ColorTimeline.Apply end.*/


        }
    });
    /*Spine.ColorTimeline end.*/

    /*Spine.DeformTimeline start.*/
    /**
     * Changes a slot's {@link } to deform a {@link }.
     *
     * @public
     * @class Spine.DeformTimeline
     * @augments Spine.CurveTimeline
     * @implements  Spine.ISlotTimeline
     */
    Bridge.define("Spine.DeformTimeline", {
        inherits: [Spine.CurveTimeline,Spine.ISlotTimeline],
        fields: {
            slotIndex: 0,
            attachment: null,
            frames: null,
            frameVertices: null
        },
        props: {
            PropertyId: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#PropertyId#get", this ); }

                    return (((((805306368) + this.attachment.id) | 0) + this.slotIndex) | 0);
                }
            },
            /**
             * The index of the slot in {@link } that will be changed.
             *
             * @instance
             * @public
             * @memberof Spine.DeformTimeline
             * @function SlotIndex
             * @type number
             */
            SlotIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#SlotIndex#get", this ); }

                    return this.slotIndex;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#SlotIndex#set", this ); }

                    if (value < 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("index must be >= 0.");
                    }
                    this.slotIndex = value;
                }
            },
            /**
             * The attachment that will be deformed.
             *
             * @instance
             * @public
             * @memberof Spine.DeformTimeline
             * @function Attachment
             * @type Spine.VertexAttachment
             */
            Attachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#Attachment#get", this ); }

                    return this.attachment;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#Attachment#set", this ); }

                    this.attachment = value;
                }
            },
            /**
             * The time in seconds for each key frame.
             *
             * @instance
             * @public
             * @memberof Spine.DeformTimeline
             * @function Frames
             * @type Array.<number>
             */
            Frames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#Frames#get", this ); }

                    return this.frames;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#Frames#set", this ); }

                    this.frames = value;
                }
            },
            /**
             * The vertices for each key frame.
             *
             * @instance
             * @public
             * @memberof Spine.DeformTimeline
             * @function Vertices
             * @type Array.<Array.<number>>
             */
            Vertices: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#Vertices#get", this ); }

                    return this.frameVertices;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#Vertices#set", this ); }

                    this.frameVertices = value;
                }
            }
        },
        alias: [
            "PropertyId", "Spine$Timeline$PropertyId",
            "SlotIndex", "Spine$ISlotTimeline$SlotIndex",
            "Apply", "Spine$Timeline$Apply"
        ],
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount);
                this.frames = System.Array.init(frameCount, 0, System.Single);
                this.frameVertices = System.Array.init(frameCount, null, System.Array.type(System.Single));
            }
        },
        methods: {
            /*Spine.DeformTimeline.SetFrame start.*/
            /**
             * Sets the time in seconds and the vertices for the specified key frame.
             *
             * @instance
             * @public
             * @this Spine.DeformTimeline
             * @memberof Spine.DeformTimeline
             * @param   {number}            frameIndex    
             * @param   {number}            time          
             * @param   {Array.<number>}    vertices      Vertex positions for an unweighted VertexAttachment, or deform offsets if it has weights.
             * @return  {void}
             */
            SetFrame: function (frameIndex, time, vertices) {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#SetFrame", this ); }

                this.frames[frameIndex] = time;
                this.frameVertices[frameIndex] = vertices;
            },
            /*Spine.DeformTimeline.SetFrame end.*/

            /*Spine.DeformTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#Apply", this ); }

                var $t;
                var slot = ($t = skeleton.slots.Items)[this.slotIndex];
                if (!slot.bone.active) {
                    return;
                }
                var vertexAttachment = Bridge.as(slot.attachment, Spine.VertexAttachment);
                if (vertexAttachment == null || !Bridge.referenceEquals(vertexAttachment.DeformAttachment, this.attachment)) {
                    return;
                }

                var deformArray = slot.Deform;
                if (deformArray.Count === 0) {
                    blend = Spine.MixBlend.Setup;
                }

                var frameVertices = this.frameVertices;
                var vertexCount = frameVertices[0].length;
                var frames = this.frames;
                var deform;

                if (time < frames[0]) { // Time is before first frame.

                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            deformArray.Clear();
                            return;
                        case Spine.MixBlend.First: 
                            if (alpha === 1) {
                                deformArray.Clear();
                                return;
                            }
                            // deformArray.SetSize(vertexCount) // Ensure size and preemptively set count.
                            if (deformArray.Capacity < vertexCount) {
                                deformArray.Capacity = vertexCount;
                            }
                            deformArray.Count = vertexCount;
                            deform = deformArray.Items;
                            if (vertexAttachment.bones == null) {
                                // Unweighted vertex positions.
                                var setupVertices = vertexAttachment.vertices;
                                for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                                    deform[i] += (setupVertices[i] - deform[i]) * alpha;
                                }
                            } else {
                                // Weighted deform offsets.
                                alpha = 1 - alpha;
                                for (var i1 = 0; i1 < vertexCount; i1 = (i1 + 1) | 0) {
                                    deform[i1] *= alpha;
                                }
                            }
                            return;
                        default: 
                            return;
                    }

                }

                // deformArray.SetSize(vertexCount) // Ensure size and preemptively set count.
                if (deformArray.Capacity < vertexCount) {
                    deformArray.Capacity = vertexCount;
                }
                deformArray.Count = vertexCount;
                deform = deformArray.Items;

                if (time >= frames[((frames.length - 1) | 0)]) { // Time is after last frame.

                    var lastVertices = frameVertices[((frames.length - 1) | 0)];
                    if (alpha === 1) {
                        if (blend === Spine.MixBlend.Add) {
                            if (vertexAttachment.bones == null) {
                                // Unweighted vertex positions, no alpha.
                                var setupVertices1 = vertexAttachment.vertices;
                                for (var i2 = 0; i2 < vertexCount; i2 = (i2 + 1) | 0) {
                                    deform[i2] += lastVertices[i2] - setupVertices1[i2];
                                }
                            } else {
                                // Weighted deform offsets, no alpha.
                                for (var i3 = 0; i3 < vertexCount; i3 = (i3 + 1) | 0) {
                                    deform[i3] += lastVertices[i3];
                                }
                            }
                        } else {
                            // Vertex positions or deform offsets, no alpha.
                            System.Array.copy(lastVertices, 0, deform, 0, vertexCount);
                        }
                    } else {
                        switch (blend) {
                            case Spine.MixBlend.Setup: 
                                {
                                    if (vertexAttachment.bones == null) {
                                        // Unweighted vertex positions, with alpha.
                                        var setupVertices2 = vertexAttachment.vertices;
                                        for (var i4 = 0; i4 < vertexCount; i4 = (i4 + 1) | 0) {
                                            var setup = setupVertices2[i4];
                                            deform[i4] = setup + (lastVertices[i4] - setup) * alpha;
                                        }
                                    } else {
                                        // Weighted deform offsets, with alpha.
                                        for (var i5 = 0; i5 < vertexCount; i5 = (i5 + 1) | 0) {
                                            deform[i5] = lastVertices[i5] * alpha;
                                        }
                                    }
                                    break;
                                }
                            case Spine.MixBlend.First: 
                            case Spine.MixBlend.Replace: 
                                // Vertex positions or deform offsets, with alpha.
                                for (var i6 = 0; i6 < vertexCount; i6 = (i6 + 1) | 0) {
                                    deform[i6] += (lastVertices[i6] - deform[i6]) * alpha;
                                }
                                break;
                            case Spine.MixBlend.Add: 
                                if (vertexAttachment.bones == null) {
                                    // Unweighted vertex positions, no alpha.
                                    var setupVertices3 = vertexAttachment.vertices;
                                    for (var i7 = 0; i7 < vertexCount; i7 = (i7 + 1) | 0) {
                                        deform[i7] += (lastVertices[i7] - setupVertices3[i7]) * alpha;
                                    }
                                } else {
                                    // Weighted deform offsets, alpha.
                                    for (var i8 = 0; i8 < vertexCount; i8 = (i8 + 1) | 0) {
                                        deform[i8] += lastVertices[i8] * alpha;
                                    }
                                }
                                break;
                        }
                    }
                    return;
                }

                // Interpolate between the previous frame and the current frame.
                var frame = Spine.Animation.BinarySearch(frames, time);
                var prevVertices = frameVertices[((frame - 1) | 0)];
                var nextVertices = frameVertices[frame];
                var frameTime = frames[frame];
                var percent = this.GetCurvePercent(((frame - 1) | 0), 1 - (time - frameTime) / (frames[((frame - 1) | 0)] - frameTime));

                if (alpha === 1) {
                    if (blend === Spine.MixBlend.Add) {
                        if (vertexAttachment.bones == null) {
                            // Unweighted vertex positions, no alpha.
                            var setupVertices4 = vertexAttachment.vertices;
                            for (var i9 = 0; i9 < vertexCount; i9 = (i9 + 1) | 0) {
                                var prev = prevVertices[i9];
                                deform[i9] += prev + (nextVertices[i9] - prev) * percent - setupVertices4[i9];
                            }
                        } else {
                            // Weighted deform offsets, no alpha.
                            for (var i10 = 0; i10 < vertexCount; i10 = (i10 + 1) | 0) {
                                var prev1 = prevVertices[i10];
                                deform[i10] += prev1 + (nextVertices[i10] - prev1) * percent;
                            }
                        }
                    } else {
                        // Vertex positions or deform offsets, no alpha.
                        for (var i11 = 0; i11 < vertexCount; i11 = (i11 + 1) | 0) {
                            var prev2 = prevVertices[i11];
                            deform[i11] = prev2 + (nextVertices[i11] - prev2) * percent;
                        }
                    }
                } else {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            {
                                if (vertexAttachment.bones == null) {
                                    // Unweighted vertex positions, with alpha.
                                    var setupVertices5 = vertexAttachment.vertices;
                                    for (var i12 = 0; i12 < vertexCount; i12 = (i12 + 1) | 0) {
                                        var prev3 = prevVertices[i12], setup1 = setupVertices5[i12];
                                        deform[i12] = setup1 + (prev3 + (nextVertices[i12] - prev3) * percent - setup1) * alpha;
                                    }
                                } else {
                                    // Weighted deform offsets, with alpha.
                                    for (var i13 = 0; i13 < vertexCount; i13 = (i13 + 1) | 0) {
                                        var prev4 = prevVertices[i13];
                                        deform[i13] = (prev4 + (nextVertices[i13] - prev4) * percent) * alpha;
                                    }
                                }
                                break;
                            }
                        case Spine.MixBlend.First: 
                        case Spine.MixBlend.Replace: 
                            {
                                // Vertex positions or deform offsets, with alpha.
                                for (var i14 = 0; i14 < vertexCount; i14 = (i14 + 1) | 0) {
                                    var prev5 = prevVertices[i14];
                                    deform[i14] += (prev5 + (nextVertices[i14] - prev5) * percent - deform[i14]) * alpha;
                                }
                                break;
                            }
                        case Spine.MixBlend.Add: 
                            {
                                if (vertexAttachment.bones == null) {
                                    // Unweighted vertex positions, with alpha.
                                    var setupVertices6 = vertexAttachment.vertices;
                                    for (var i15 = 0; i15 < vertexCount; i15 = (i15 + 1) | 0) {
                                        var prev6 = prevVertices[i15];
                                        deform[i15] += (prev6 + (nextVertices[i15] - prev6) * percent - setupVertices6[i15]) * alpha;
                                    }
                                } else {
                                    // Weighted deform offsets, with alpha.
                                    for (var i16 = 0; i16 < vertexCount; i16 = (i16 + 1) | 0) {
                                        var prev7 = prevVertices[i16];
                                        deform[i16] += (prev7 + (nextVertices[i16] - prev7) * percent) * alpha;
                                    }
                                }
                                break;
                            }
                    }
                }
            },
            /*Spine.DeformTimeline.Apply end.*/


        }
    });
    /*Spine.DeformTimeline end.*/

    /*Spine.IkConstraintTimeline start.*/
    /**
     * Changes an IK constraint's {@link }, {@link },
     {@link }, {@link }, and {@link }.
     *
     * @public
     * @class Spine.IkConstraintTimeline
     * @augments Spine.CurveTimeline
     */
    Bridge.define("Spine.IkConstraintTimeline", {
        inherits: [Spine.CurveTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                PREV_TIME: 0,
                PREV_MIX: 0,
                PREV_SOFTNESS: 0,
                PREV_BEND_DIRECTION: 0,
                PREV_COMPRESS: 0,
                PREV_STRETCH: 0,
                MIX: 0,
                SOFTNESS: 0,
                BEND_DIRECTION: 0,
                COMPRESS: 0,
                STRETCH: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintTimeline#init", this ); }

                    this.ENTRIES = 6;
                    this.PREV_TIME = -6;
                    this.PREV_MIX = -5;
                    this.PREV_SOFTNESS = -4;
                    this.PREV_BEND_DIRECTION = -3;
                    this.PREV_COMPRESS = -2;
                    this.PREV_STRETCH = -1;
                    this.MIX = 1;
                    this.SOFTNESS = 2;
                    this.BEND_DIRECTION = 3;
                    this.COMPRESS = 4;
                    this.STRETCH = 5;
                }
            }
        },
        fields: {
            ikConstraintIndex: 0,
            frames: null
        },
        props: {
            PropertyId: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintTimeline#PropertyId#get", this ); }

                    return (((150994944) + this.ikConstraintIndex) | 0);
                }
            },
            /**
             * The index of the IK constraint slot in {@link } that will be changed.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraintTimeline
             * @function IkConstraintIndex
             * @type number
             */
            IkConstraintIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintTimeline#IkConstraintIndex#get", this ); }

                    return this.ikConstraintIndex;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraintTimeline#IkConstraintIndex#set", this ); }

                    if (value < 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("index must be >= 0.");
                    }
                    this.ikConstraintIndex = value;
                }
            },
            /**
             * The time in seconds, mix, softness, bend direction, compress, and stretch for each key frame.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraintTimeline
             * @function Frames
             * @type Array.<number>
             */
            Frames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintTimeline#Frames#get", this ); }

                    return this.frames;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraintTimeline#Frames#set", this ); }

                    this.frames = value;
                }
            }
        },
        alias: [
            "PropertyId", "Spine$Timeline$PropertyId",
            "Apply", "Spine$Timeline$Apply"
        ],
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.IkConstraintTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount);
                this.frames = System.Array.init(Bridge.Int.mul(frameCount, Spine.IkConstraintTimeline.ENTRIES), 0, System.Single);
            }
        },
        methods: {
            /*Spine.IkConstraintTimeline.SetFrame start.*/
            /**
             * Sets the time in seconds, mix, softness, bend direction, compress, and stretch for the specified key frame.
             *
             * @instance
             * @public
             * @this Spine.IkConstraintTimeline
             * @memberof Spine.IkConstraintTimeline
             * @param   {number}     frameIndex       
             * @param   {number}     time             
             * @param   {number}     mix              
             * @param   {number}     softness         
             * @param   {number}     bendDirection    
             * @param   {boolean}    compress         
             * @param   {boolean}    stretch
             * @return  {void}
             */
            SetFrame: function (frameIndex, time, mix, softness, bendDirection, compress, stretch) {
if ( TRACE ) { TRACE( "Spine.IkConstraintTimeline#SetFrame", this ); }

                frameIndex = Bridge.Int.mul(frameIndex, Spine.IkConstraintTimeline.ENTRIES);
                this.frames[frameIndex] = time;
                this.frames[((frameIndex + Spine.IkConstraintTimeline.MIX) | 0)] = mix;
                this.frames[((frameIndex + Spine.IkConstraintTimeline.SOFTNESS) | 0)] = softness;
                this.frames[((frameIndex + Spine.IkConstraintTimeline.BEND_DIRECTION) | 0)] = bendDirection;
                this.frames[((frameIndex + Spine.IkConstraintTimeline.COMPRESS) | 0)] = compress ? 1 : 0;
                this.frames[((frameIndex + Spine.IkConstraintTimeline.STRETCH) | 0)] = stretch ? 1 : 0;
            },
            /*Spine.IkConstraintTimeline.SetFrame end.*/

            /*Spine.IkConstraintTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.IkConstraintTimeline#Apply", this ); }

                var $t;
                var constraint = ($t = skeleton.ikConstraints.Items)[this.ikConstraintIndex];
                if (!constraint.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) { // Time is before first frame.
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            constraint.mix = constraint.data.mix;
                            constraint.softness = constraint.data.softness;
                            constraint.bendDirection = constraint.data.bendDirection;
                            constraint.compress = constraint.data.compress;
                            constraint.stretch = constraint.data.stretch;
                            return;
                        case Spine.MixBlend.First: 
                            constraint.mix += (constraint.data.mix - constraint.mix) * alpha;
                            constraint.softness += (constraint.data.softness - constraint.softness) * alpha;
                            constraint.bendDirection = constraint.data.bendDirection;
                            constraint.compress = constraint.data.compress;
                            constraint.stretch = constraint.data.stretch;
                            return;
                    }
                    return;
                }

                if (time >= frames[((frames.length - Spine.IkConstraintTimeline.ENTRIES) | 0)]) { // Time is after last frame.
                    if (blend === Spine.MixBlend.Setup) {
                        constraint.mix = constraint.data.mix + (frames[((frames.length + Spine.IkConstraintTimeline.PREV_MIX) | 0)] - constraint.data.mix) * alpha;
                        constraint.softness = constraint.data.softness + (frames[((frames.length + Spine.IkConstraintTimeline.PREV_SOFTNESS) | 0)] - constraint.data.softness) * alpha;
                        if (direction === Spine.MixDirection.Out) {
                            constraint.bendDirection = constraint.data.bendDirection;
                            constraint.compress = constraint.data.compress;
                            constraint.stretch = constraint.data.stretch;
                        } else {
                            constraint.bendDirection = Bridge.Int.clip32(frames[((frames.length + Spine.IkConstraintTimeline.PREV_BEND_DIRECTION) | 0)]);
                            constraint.compress = frames[((frames.length + Spine.IkConstraintTimeline.PREV_COMPRESS) | 0)] !== 0;
                            constraint.stretch = frames[((frames.length + Spine.IkConstraintTimeline.PREV_STRETCH) | 0)] !== 0;
                        }
                    } else {
                        constraint.mix += (frames[((frames.length + Spine.IkConstraintTimeline.PREV_MIX) | 0)] - constraint.mix) * alpha;
                        constraint.softness += (frames[((frames.length + Spine.IkConstraintTimeline.PREV_SOFTNESS) | 0)] - constraint.softness) * alpha;
                        if (direction === Spine.MixDirection.In) {
                            constraint.bendDirection = Bridge.Int.clip32(frames[((frames.length + Spine.IkConstraintTimeline.PREV_BEND_DIRECTION) | 0)]);
                            constraint.compress = frames[((frames.length + Spine.IkConstraintTimeline.PREV_COMPRESS) | 0)] !== 0;
                            constraint.stretch = frames[((frames.length + Spine.IkConstraintTimeline.PREV_STRETCH) | 0)] !== 0;
                        }
                    }
                    return;
                }

                // Interpolate between the previous frame and the current frame.
                var frame = Spine.Animation.BinarySearch$1(frames, time, Spine.IkConstraintTimeline.ENTRIES);
                var mix = frames[((frame + Spine.IkConstraintTimeline.PREV_MIX) | 0)];
                var softness = frames[((frame + Spine.IkConstraintTimeline.PREV_SOFTNESS) | 0)];
                var frameTime = frames[frame];
                var percent = this.GetCurvePercent(((((Bridge.Int.div(frame, Spine.IkConstraintTimeline.ENTRIES)) | 0) - 1) | 0), 1 - (time - frameTime) / (frames[((frame + Spine.IkConstraintTimeline.PREV_TIME) | 0)] - frameTime));

                if (blend === Spine.MixBlend.Setup) {
                    constraint.mix = constraint.data.mix + (mix + (frames[((frame + Spine.IkConstraintTimeline.MIX) | 0)] - mix) * percent - constraint.data.mix) * alpha;
                    constraint.softness = constraint.data.softness + (softness + (frames[((frame + Spine.IkConstraintTimeline.SOFTNESS) | 0)] - softness) * percent - constraint.data.softness) * alpha;
                    if (direction === Spine.MixDirection.Out) {
                        constraint.bendDirection = constraint.data.bendDirection;
                        constraint.compress = constraint.data.compress;
                        constraint.stretch = constraint.data.stretch;
                    } else {
                        constraint.bendDirection = Bridge.Int.clip32(frames[((frame + Spine.IkConstraintTimeline.PREV_BEND_DIRECTION) | 0)]);
                        constraint.compress = frames[((frame + Spine.IkConstraintTimeline.PREV_COMPRESS) | 0)] !== 0;
                        constraint.stretch = frames[((frame + Spine.IkConstraintTimeline.PREV_STRETCH) | 0)] !== 0;
                    }
                } else {
                    constraint.mix += (mix + (frames[((frame + Spine.IkConstraintTimeline.MIX) | 0)] - mix) * percent - constraint.mix) * alpha;
                    constraint.softness += (softness + (frames[((frame + Spine.IkConstraintTimeline.SOFTNESS) | 0)] - softness) * percent - constraint.softness) * alpha;
                    if (direction === Spine.MixDirection.In) {
                        constraint.bendDirection = Bridge.Int.clip32(frames[((frame + Spine.IkConstraintTimeline.PREV_BEND_DIRECTION) | 0)]);
                        constraint.compress = frames[((frame + Spine.IkConstraintTimeline.PREV_COMPRESS) | 0)] !== 0;
                        constraint.stretch = frames[((frame + Spine.IkConstraintTimeline.PREV_STRETCH) | 0)] !== 0;
                    }
                }
            },
            /*Spine.IkConstraintTimeline.Apply end.*/


        }
    });
    /*Spine.IkConstraintTimeline end.*/

    /*Spine.MeshAttachment start.*/
    /**
     * Attachment that displays a texture region using a mesh.
     *
     * @public
     * @class Spine.MeshAttachment
     * @augments Spine.VertexAttachment
     * @implements  Spine.IHasRendererObject
     */
    Bridge.define("Spine.MeshAttachment", {
        inherits: [Spine.VertexAttachment,Spine.IHasRendererObject],
        fields: {
            regionOffsetX: 0,
            regionOffsetY: 0,
            regionWidth: 0,
            regionHeight: 0,
            regionOriginalWidth: 0,
            regionOriginalHeight: 0,
            parentMesh: null,
            uvs: null,
            regionUVs: null,
            triangles: null,
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            hulllength: 0,
            Path: null,
            RendererObject: null,
            RegionU: 0,
            RegionV: 0,
            RegionU2: 0,
            RegionV2: 0,
            RegionRotate: false,
            RegionDegrees: 0,
            Edges: null,
            Width: 0,
            Height: 0
        },
        props: {
            HullLength: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#HullLength#get", this ); }

                    return this.hulllength;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#HullLength#set", this ); }

                    this.hulllength = value;
                }
            },
            RegionUVs: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#RegionUVs#get", this ); }

                    return this.regionUVs;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#RegionUVs#set", this ); }

                    this.regionUVs = value;
                }
            },
            /**
             * The UV pair for each vertex, normalized within the entire texture. <seealso cref="MeshAttachment.UpdateUVs" />
             *
             * @instance
             * @public
             * @memberof Spine.MeshAttachment
             * @function UVs
             * @type Array.<number>
             * @see {@link MeshAttachment.UpdateUVs}
             */
            UVs: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#UVs#get", this ); }

                    return this.uvs;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#UVs#set", this ); }

                    this.uvs = value;
                }
            },
            Triangles: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#Triangles#get", this ); }

                    return this.triangles;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#Triangles#set", this ); }

                    this.triangles = value;
                }
            },
            R: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#R#get", this ); }

                    return this.r;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#R#set", this ); }

                    this.r = value;
                }
            },
            G: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#G#get", this ); }

                    return this.g;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#G#set", this ); }

                    this.g = value;
                }
            },
            B: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#B#get", this ); }

                    return this.b;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#B#set", this ); }

                    this.b = value;
                }
            },
            A: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#A#get", this ); }

                    return this.a;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#A#set", this ); }

                    this.a = value;
                }
            },
            RegionOffsetX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#RegionOffsetX#get", this ); }

                    return this.regionOffsetX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#RegionOffsetX#set", this ); }

                    this.regionOffsetX = value;
                }
            },
            RegionOffsetY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#RegionOffsetY#get", this ); }

                    return this.regionOffsetY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#RegionOffsetY#set", this ); }

                    this.regionOffsetY = value;
                }
            },
            RegionWidth: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#RegionWidth#get", this ); }

                    return this.regionWidth;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#RegionWidth#set", this ); }

                    this.regionWidth = value;
                }
            },
            RegionHeight: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#RegionHeight#get", this ); }

                    return this.regionHeight;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#RegionHeight#set", this ); }

                    this.regionHeight = value;
                }
            },
            RegionOriginalWidth: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#RegionOriginalWidth#get", this ); }

                    return this.regionOriginalWidth;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#RegionOriginalWidth#set", this ); }

                    this.regionOriginalWidth = value;
                }
            },
            RegionOriginalHeight: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#RegionOriginalHeight#get", this ); }

                    return this.regionOriginalHeight;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#RegionOriginalHeight#set", this ); }

                    this.regionOriginalHeight = value;
                }
            },
            ParentMesh: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#ParentMesh#get", this ); }

                    return this.parentMesh;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#ParentMesh#set", this ); }

                    this.parentMesh = value;
                    if (value != null) {
                        this.bones = value.bones;
                        this.vertices = value.vertices;
                        this.worldVerticesLength = value.worldVerticesLength;
                        this.regionUVs = value.regionUVs;
                        this.triangles = value.triangles;
                        this.HullLength = value.HullLength;
                        this.Edges = value.Edges;
                        this.Width = value.Width;
                        this.Height = value.Height;
                    }
                }
            }
        },
        alias: ["RendererObject", "Spine$IHasRendererObject$RendererObject"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#init", this ); }

                this.r = 1;
                this.g = 1;
                this.b = 1;
                this.a = 1;
            },
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#ctor", this ); }

                this.$initialize();
                Spine.VertexAttachment.ctor.call(this, name);
            }
        },
        methods: {
            /*Spine.MeshAttachment.UpdateUVs start.*/
            UpdateUVs: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#UpdateUVs", this ); }

                var regionUVs = this.regionUVs;
                if (this.uvs == null || this.uvs.length !== regionUVs.length) {
                    this.uvs = System.Array.init(regionUVs.length, 0, System.Single);
                }
                var uvs = this.uvs;
                var u = this.RegionU, v = this.RegionV, width = 0, height = 0;

                if (this.RegionDegrees === 90) {
                    var textureHeight = this.regionWidth / (this.RegionV2 - this.RegionV);
                    var textureWidth = this.regionHeight / (this.RegionU2 - this.RegionU);
                    u -= (this.RegionOriginalHeight - this.RegionOffsetY - this.RegionHeight) / textureWidth;
                    v -= (this.RegionOriginalWidth - this.RegionOffsetX - this.RegionWidth) / textureHeight;
                    width = this.RegionOriginalHeight / textureWidth;
                    height = this.RegionOriginalWidth / textureHeight;

                    for (var i = 0, n = uvs.length; i < n; i = (i + 2) | 0) {
                        uvs[i] = u + regionUVs[((i + 1) | 0)] * width;
                        uvs[((i + 1) | 0)] = v + (1 - regionUVs[i]) * height;
                    }
                } else if (this.RegionDegrees === 180) {
                    var textureWidth1 = this.regionWidth / (this.RegionU2 - this.RegionU);
                    var textureHeight1 = this.regionHeight / (this.RegionV2 - this.RegionV);
                    u -= (this.RegionOriginalWidth - this.RegionOffsetX - this.RegionWidth) / textureWidth1;
                    v -= this.RegionOffsetY / textureHeight1;
                    width = this.RegionOriginalWidth / textureWidth1;
                    height = this.RegionOriginalHeight / textureHeight1;

                    for (var i1 = 0, n1 = uvs.length; i1 < n1; i1 = (i1 + 2) | 0) {
                        uvs[i1] = u + (1 - regionUVs[i1]) * width;
                        uvs[((i1 + 1) | 0)] = v + (1 - regionUVs[((i1 + 1) | 0)]) * height;
                    }
                } else if (this.RegionDegrees === 270) {
                    var textureWidth2 = this.regionWidth / (this.RegionU2 - this.RegionU);
                    var textureHeight2 = this.regionHeight / (this.RegionV2 - this.RegionV);
                    u -= this.RegionOffsetY / textureWidth2;
                    v -= this.RegionOffsetX / textureHeight2;
                    width = this.RegionOriginalHeight / textureWidth2;
                    height = this.RegionOriginalWidth / textureHeight2;

                    for (var i2 = 0, n2 = uvs.length; i2 < n2; i2 = (i2 + 2) | 0) {
                        uvs[i2] = u + (1 - regionUVs[((i2 + 1) | 0)]) * width;
                        uvs[((i2 + 1) | 0)] = v + regionUVs[i2] * height;
                    }
                } else {
                    var textureWidth3 = this.regionWidth / (this.RegionU2 - this.RegionU);
                    var textureHeight3 = this.regionHeight / (this.RegionV2 - this.RegionV);
                    u -= this.RegionOffsetX / textureWidth3;
                    v -= (this.RegionOriginalHeight - this.RegionOffsetY - this.RegionHeight) / textureHeight3;
                    width = this.RegionOriginalWidth / textureWidth3;
                    height = this.RegionOriginalHeight / textureHeight3;

                    for (var i3 = 0, n3 = uvs.length; i3 < n3; i3 = (i3 + 2) | 0) {
                        uvs[i3] = u + regionUVs[i3] * width;
                        uvs[((i3 + 1) | 0)] = v + regionUVs[((i3 + 1) | 0)] * height;
                    }
                }
            },
            /*Spine.MeshAttachment.UpdateUVs end.*/

            /*Spine.MeshAttachment.Copy start.*/
            Copy: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#Copy", this ); }

                if (this.parentMesh != null) {
                    return this.NewLinkedMesh();
                }

                var copy = new Spine.MeshAttachment(this.Name);
                copy.RendererObject = this.RendererObject;
                copy.regionOffsetX = this.regionOffsetX;
                copy.regionOffsetY = this.regionOffsetY;
                copy.regionWidth = this.regionWidth;
                copy.regionHeight = this.regionHeight;
                copy.regionOriginalWidth = this.regionOriginalWidth;
                copy.regionOriginalHeight = this.regionOriginalHeight;
                copy.RegionRotate = this.RegionRotate;
                copy.RegionDegrees = this.RegionDegrees;
                copy.RegionU = this.RegionU;
                copy.RegionV = this.RegionV;
                copy.RegionU2 = this.RegionU2;
                copy.RegionV2 = this.RegionV2;

                copy.Path = this.Path;
                copy.r = this.r;
                copy.g = this.g;
                copy.b = this.b;
                copy.a = this.a;

                this.CopyTo(copy);
                copy.regionUVs = System.Array.init(this.regionUVs.length, 0, System.Single);
                System.Array.copy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);
                copy.uvs = System.Array.init(this.uvs.length, 0, System.Single);
                System.Array.copy(this.uvs, 0, copy.uvs, 0, this.uvs.length);
                copy.triangles = System.Array.init(this.triangles.length, 0, System.Int32);
                System.Array.copy(this.triangles, 0, copy.triangles, 0, this.triangles.length);
                copy.HullLength = this.HullLength;

                // Nonessential.
                if (this.Edges != null) {
                    copy.Edges = System.Array.init(this.Edges.length, 0, System.Int32);
                    System.Array.copy(this.Edges, 0, copy.Edges, 0, this.Edges.length);
                }
                copy.Width = this.Width;
                copy.Height = this.Height;
                return copy;
            },
            /*Spine.MeshAttachment.Copy end.*/

            /*Spine.MeshAttachment.NewLinkedMesh start.*/
            
            NewLinkedMesh: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#NewLinkedMesh", this ); }

                var mesh = new Spine.MeshAttachment(this.Name);
                mesh.RendererObject = this.RendererObject;
                mesh.regionOffsetX = this.regionOffsetX;
                mesh.regionOffsetY = this.regionOffsetY;
                mesh.regionWidth = this.regionWidth;
                mesh.regionHeight = this.regionHeight;
                mesh.regionOriginalWidth = this.regionOriginalWidth;
                mesh.regionOriginalHeight = this.regionOriginalHeight;
                mesh.RegionDegrees = this.RegionDegrees;
                mesh.RegionRotate = this.RegionRotate;
                mesh.RegionU = this.RegionU;
                mesh.RegionV = this.RegionV;
                mesh.RegionU2 = this.RegionU2;
                mesh.RegionV2 = this.RegionV2;

                mesh.Path = this.Path;
                mesh.r = this.r;
                mesh.g = this.g;
                mesh.b = this.b;
                mesh.a = this.a;

                mesh.deformAttachment = this.deformAttachment;
                mesh.ParentMesh = this.parentMesh != null ? this.parentMesh : this;
                mesh.UpdateUVs();
                return mesh;
            },
            /*Spine.MeshAttachment.NewLinkedMesh end.*/


        }
    });
    /*Spine.MeshAttachment end.*/

    /*Spine.PathAttachment start.*/
    Bridge.define("Spine.PathAttachment", {
        inherits: [Spine.VertexAttachment],
        fields: {
            lengths: null,
            closed: false,
            constantSpeed: false
        },
        props: {
            /**
             * The length in the setup pose from the start of the path to the end of each curve.
             *
             * @instance
             * @public
             * @memberof Spine.PathAttachment
             * @function Lengths
             * @type Array.<number>
             */
            Lengths: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathAttachment#Lengths#get", this ); }

                    return this.lengths;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathAttachment#Lengths#set", this ); }

                    this.lengths = value;
                }
            },
            Closed: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathAttachment#Closed#get", this ); }

                    return this.closed;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathAttachment#Closed#set", this ); }

                    this.closed = value;
                }
            },
            ConstantSpeed: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathAttachment#ConstantSpeed#get", this ); }

                    return this.constantSpeed;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathAttachment#ConstantSpeed#set", this ); }

                    this.constantSpeed = value;
                }
            }
        },
        ctors: {
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.PathAttachment#ctor", this ); }

                this.$initialize();
                Spine.VertexAttachment.ctor.call(this, name);
            }
        },
        methods: {
            /*Spine.PathAttachment.Copy start.*/
            Copy: function () {
if ( TRACE ) { TRACE( "Spine.PathAttachment#Copy", this ); }

                var copy = new Spine.PathAttachment(this.Name);
                this.CopyTo(copy);
                copy.lengths = System.Array.init(this.lengths.length, 0, System.Single);
                System.Array.copy(this.lengths, 0, copy.lengths, 0, this.lengths.length);
                copy.closed = this.closed;
                copy.constantSpeed = this.constantSpeed;
                return copy;
            },
            /*Spine.PathAttachment.Copy end.*/


        }
    });
    /*Spine.PathAttachment end.*/

    /*Spine.PathConstraintMixTimeline start.*/
    /**
     * Changes a path constraint's mixes.
     *
     * @public
     * @class Spine.PathConstraintMixTimeline
     * @augments Spine.CurveTimeline
     */
    Bridge.define("Spine.PathConstraintMixTimeline", {
        inherits: [Spine.CurveTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                PREV_TIME: 0,
                PREV_ROTATE: 0,
                PREV_TRANSLATE: 0,
                ROTATE: 0,
                TRANSLATE: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintMixTimeline#init", this ); }

                    this.ENTRIES = 3;
                    this.PREV_TIME = -3;
                    this.PREV_ROTATE = -2;
                    this.PREV_TRANSLATE = -1;
                    this.ROTATE = 1;
                    this.TRANSLATE = 2;
                }
            }
        },
        fields: {
            pathConstraintIndex: 0,
            frames: null
        },
        props: {
            PropertyId: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintMixTimeline#PropertyId#get", this ); }

                    return (((218103808) + this.pathConstraintIndex) | 0);
                }
            },
            /**
             * The index of the path constraint slot in {@link } that will be changed.
             *
             * @instance
             * @public
             * @memberof Spine.PathConstraintMixTimeline
             * @function PathConstraintIndex
             * @type number
             */
            PathConstraintIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintMixTimeline#PathConstraintIndex#get", this ); }

                    return this.pathConstraintIndex;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintMixTimeline#PathConstraintIndex#set", this ); }

                    if (value < 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("index must be >= 0.");
                    }
                    this.pathConstraintIndex = value;
                }
            },
            /**
             * The time in seconds, rotate mix, and translate mix for each key frame.
             *
             * @instance
             * @public
             * @memberof Spine.PathConstraintMixTimeline
             * @function Frames
             * @type Array.<number>
             */
            Frames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintMixTimeline#Frames#get", this ); }

                    return this.frames;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintMixTimeline#Frames#set", this ); }

                    this.frames = value;
                }
            }
        },
        alias: [
            "PropertyId", "Spine$Timeline$PropertyId",
            "Apply", "Spine$Timeline$Apply"
        ],
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.PathConstraintMixTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount);
                this.frames = System.Array.init(Bridge.Int.mul(frameCount, Spine.PathConstraintMixTimeline.ENTRIES), 0, System.Single);
            }
        },
        methods: {
            /*Spine.PathConstraintMixTimeline.SetFrame start.*/
            /**
             * The time in seconds, rotate mix, and translate mix for the specified key frame.
             *
             * @instance
             * @public
             * @this Spine.PathConstraintMixTimeline
             * @memberof Spine.PathConstraintMixTimeline
             * @param   {number}    frameIndex      
             * @param   {number}    time            
             * @param   {number}    rotateMix       
             * @param   {number}    translateMix
             * @return  {void}
             */
            SetFrame: function (frameIndex, time, rotateMix, translateMix) {
if ( TRACE ) { TRACE( "Spine.PathConstraintMixTimeline#SetFrame", this ); }

                frameIndex = Bridge.Int.mul(frameIndex, Spine.PathConstraintMixTimeline.ENTRIES);
                this.frames[frameIndex] = time;
                this.frames[((frameIndex + Spine.PathConstraintMixTimeline.ROTATE) | 0)] = rotateMix;
                this.frames[((frameIndex + Spine.PathConstraintMixTimeline.TRANSLATE) | 0)] = translateMix;
            },
            /*Spine.PathConstraintMixTimeline.SetFrame end.*/

            /*Spine.PathConstraintMixTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.PathConstraintMixTimeline#Apply", this ); }

                var $t;
                var constraint = ($t = skeleton.pathConstraints.Items)[this.pathConstraintIndex];
                if (!constraint.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) { // Time is before first frame.
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            constraint.rotateMix = constraint.data.rotateMix;
                            constraint.translateMix = constraint.data.translateMix;
                            return;
                        case Spine.MixBlend.First: 
                            constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;
                            constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;
                            return;
                    }
                    return;
                }

                var rotate, translate;
                if (time >= frames[((frames.length - Spine.PathConstraintMixTimeline.ENTRIES) | 0)]) { // Time is after last frame.
                    rotate = frames[((frames.length + Spine.PathConstraintMixTimeline.PREV_ROTATE) | 0)];
                    translate = frames[((frames.length + Spine.PathConstraintMixTimeline.PREV_TRANSLATE) | 0)];
                } else {
                    // Interpolate between the previous frame and the current frame.
                    var frame = Spine.Animation.BinarySearch$1(frames, time, Spine.PathConstraintMixTimeline.ENTRIES);
                    rotate = frames[((frame + Spine.PathConstraintMixTimeline.PREV_ROTATE) | 0)];
                    translate = frames[((frame + Spine.PathConstraintMixTimeline.PREV_TRANSLATE) | 0)];
                    var frameTime = frames[frame];
                    var percent = this.GetCurvePercent(((((Bridge.Int.div(frame, Spine.PathConstraintMixTimeline.ENTRIES)) | 0) - 1) | 0), 1 - (time - frameTime) / (frames[((frame + Spine.PathConstraintMixTimeline.PREV_TIME) | 0)] - frameTime));

                    rotate += (frames[((frame + Spine.PathConstraintMixTimeline.ROTATE) | 0)] - rotate) * percent;
                    translate += (frames[((frame + Spine.PathConstraintMixTimeline.TRANSLATE) | 0)] - translate) * percent;
                }

                if (blend === Spine.MixBlend.Setup) {
                    constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;
                    constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;
                } else {
                    constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
                    constraint.translateMix += (translate - constraint.translateMix) * alpha;
                }
            },
            /*Spine.PathConstraintMixTimeline.Apply end.*/


        }
    });
    /*Spine.PathConstraintMixTimeline end.*/

    /*Spine.PathConstraintPositionTimeline start.*/
    /**
     * Changes a path constraint's {@link }.
     *
     * @public
     * @class Spine.PathConstraintPositionTimeline
     * @augments Spine.CurveTimeline
     */
    Bridge.define("Spine.PathConstraintPositionTimeline", {
        inherits: [Spine.CurveTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                PREV_TIME: 0,
                PREV_VALUE: 0,
                VALUE: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintPositionTimeline#init", this ); }

                    this.ENTRIES = 2;
                    this.PREV_TIME = -2;
                    this.PREV_VALUE = -1;
                    this.VALUE = 1;
                }
            }
        },
        fields: {
            pathConstraintIndex: 0,
            frames: null
        },
        props: {
            PropertyId: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintPositionTimeline#PropertyId#get", this ); }

                    return (((184549376) + this.pathConstraintIndex) | 0);
                }
            },
            /**
             * The index of the path constraint slot in {@link } that will be changed.
             *
             * @instance
             * @public
             * @memberof Spine.PathConstraintPositionTimeline
             * @function PathConstraintIndex
             * @type number
             */
            PathConstraintIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintPositionTimeline#PathConstraintIndex#get", this ); }

                    return this.pathConstraintIndex;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintPositionTimeline#PathConstraintIndex#set", this ); }

                    if (value < 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("index must be >= 0.");
                    }
                    this.pathConstraintIndex = value;
                }
            },
            /**
             * The time in seconds and path constraint position for each key frame.
             *
             * @instance
             * @public
             * @memberof Spine.PathConstraintPositionTimeline
             * @function Frames
             * @type Array.<number>
             */
            Frames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintPositionTimeline#Frames#get", this ); }

                    return this.frames;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintPositionTimeline#Frames#set", this ); }

                    this.frames = value;
                }
            }
        },
        alias: [
            "PropertyId", "Spine$Timeline$PropertyId",
            "Apply", "Spine$Timeline$Apply"
        ],
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.PathConstraintPositionTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount);
                this.frames = System.Array.init(Bridge.Int.mul(frameCount, Spine.PathConstraintPositionTimeline.ENTRIES), 0, System.Single);
            }
        },
        methods: {
            /*Spine.PathConstraintPositionTimeline.SetFrame start.*/
            /**
             * Sets the time in seconds and path constraint position for the specified key frame.
             *
             * @instance
             * @public
             * @this Spine.PathConstraintPositionTimeline
             * @memberof Spine.PathConstraintPositionTimeline
             * @param   {number}    frameIndex    
             * @param   {number}    time          
             * @param   {number}    position
             * @return  {void}
             */
            SetFrame: function (frameIndex, time, position) {
if ( TRACE ) { TRACE( "Spine.PathConstraintPositionTimeline#SetFrame", this ); }

                frameIndex = Bridge.Int.mul(frameIndex, Spine.PathConstraintPositionTimeline.ENTRIES);
                this.frames[frameIndex] = time;
                this.frames[((frameIndex + Spine.PathConstraintPositionTimeline.VALUE) | 0)] = position;
            },
            /*Spine.PathConstraintPositionTimeline.SetFrame end.*/

            /*Spine.PathConstraintPositionTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.PathConstraintPositionTimeline#Apply", this ); }

                var $t;
                var constraint = ($t = skeleton.pathConstraints.Items)[this.pathConstraintIndex];
                if (!constraint.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) { // Time is before first frame.
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            constraint.position = constraint.data.position;
                            return;
                        case Spine.MixBlend.First: 
                            constraint.position += (constraint.data.position - constraint.position) * alpha;
                            return;
                    }
                    return;
                }

                var position;
                if (time >= frames[((frames.length - Spine.PathConstraintPositionTimeline.ENTRIES) | 0)]) {
                    position = frames[((frames.length + Spine.PathConstraintPositionTimeline.PREV_VALUE) | 0)];
                } else {
                    // Interpolate between the previous frame and the current frame.
                    var frame = Spine.Animation.BinarySearch$1(frames, time, Spine.PathConstraintPositionTimeline.ENTRIES);
                    position = frames[((frame + Spine.PathConstraintPositionTimeline.PREV_VALUE) | 0)];
                    var frameTime = frames[frame];
                    var percent = this.GetCurvePercent(((((Bridge.Int.div(frame, Spine.PathConstraintPositionTimeline.ENTRIES)) | 0) - 1) | 0), 1 - (time - frameTime) / (frames[((frame + Spine.PathConstraintPositionTimeline.PREV_TIME) | 0)] - frameTime));

                    position += (frames[((frame + Spine.PathConstraintPositionTimeline.VALUE) | 0)] - position) * percent;
                }
                if (blend === Spine.MixBlend.Setup) {
                    constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;
                } else {
                    constraint.position += (position - constraint.position) * alpha;
                }
            },
            /*Spine.PathConstraintPositionTimeline.Apply end.*/


        }
    });
    /*Spine.PathConstraintPositionTimeline end.*/

    /*Spine.PowOut start.*/
    Bridge.define("Spine.PowOut", {
        inherits: [Spine.Pow],
        ctors: {
            ctor: function (power) {
if ( TRACE ) { TRACE( "Spine.PowOut#ctor", this ); }

                this.$initialize();
                Spine.Pow.ctor.call(this, power);
            }
        },
        methods: {
            /*Spine.PowOut.Apply$1 start.*/
            Apply$1: function (a) {
if ( TRACE ) { TRACE( "Spine.PowOut#Apply$1", this ); }

                return Math.pow(a - 1, this.Power) * (this.Power % 2 === 0 ? -1 : 1) + 1;
            },
            /*Spine.PowOut.Apply$1 end.*/


        },
        overloads: {
            "Apply(float)": "Apply$1"
        }
    });
    /*Spine.PowOut end.*/

    /*Spine.RotateTimeline start.*/
    /**
     * Changes a bone's local {@link }.
     *
     * @public
     * @class Spine.RotateTimeline
     * @augments Spine.CurveTimeline
     * @implements  Spine.IBoneTimeline
     */
    Bridge.define("Spine.RotateTimeline", {
        inherits: [Spine.CurveTimeline,Spine.IBoneTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                PREV_TIME: 0,
                PREV_ROTATION: 0,
                ROTATION: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.RotateTimeline#init", this ); }

                    this.ENTRIES = 2;
                    this.PREV_TIME = -2;
                    this.PREV_ROTATION = -1;
                    this.ROTATION = 1;
                }
            }
        },
        fields: {
            boneIndex: 0,
            frames: null
        },
        props: {
            PropertyId: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RotateTimeline#PropertyId#get", this ); }

                    return (((0) + this.boneIndex) | 0);
                }
            },
            /**
             * The index of the bone in {@link } that will be changed.
             *
             * @instance
             * @public
             * @memberof Spine.RotateTimeline
             * @function BoneIndex
             * @type number
             */
            BoneIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RotateTimeline#BoneIndex#get", this ); }

                    return this.boneIndex;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RotateTimeline#BoneIndex#set", this ); }

                    if (value < 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("index must be >= 0.");
                    }
                    this.boneIndex = value;
                }
            },
            /**
             * The time in seconds and rotation in degrees for each key frame.
             *
             * @instance
             * @public
             * @memberof Spine.RotateTimeline
             * @function Frames
             * @type Array.<number>
             */
            Frames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RotateTimeline#Frames#get", this ); }

                    return this.frames;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RotateTimeline#Frames#set", this ); }

                    this.frames = value;
                }
            }
        },
        alias: [
            "PropertyId", "Spine$Timeline$PropertyId",
            "BoneIndex", "Spine$IBoneTimeline$BoneIndex",
            "Apply", "Spine$Timeline$Apply"
        ],
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.RotateTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount);
                this.frames = System.Array.init(frameCount << 1, 0, System.Single);
            }
        },
        methods: {
            /*Spine.RotateTimeline.SetFrame start.*/
            /**
             * Sets the time in seconds and the rotation in degrees for the specified key frame.
             *
             * @instance
             * @public
             * @this Spine.RotateTimeline
             * @memberof Spine.RotateTimeline
             * @param   {number}    frameIndex    
             * @param   {number}    time          
             * @param   {number}    degrees
             * @return  {void}
             */
            SetFrame: function (frameIndex, time, degrees) {
if ( TRACE ) { TRACE( "Spine.RotateTimeline#SetFrame", this ); }

                frameIndex = frameIndex << 1;
                this.frames[frameIndex] = time;
                this.frames[((frameIndex + Spine.RotateTimeline.ROTATION) | 0)] = degrees;
            },
            /*Spine.RotateTimeline.SetFrame end.*/

            /*Spine.RotateTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.RotateTimeline#Apply", this ); }

                var $step = 0,
                    $jumpFromFinally, 
                    bone, 
                    $t, 
                    frames, 
                    r, 
                    r1, 
                    frame, 
                    prevRotation, 
                    frameTime, 
                    percent, 
                    r2, 
                    $asyncBody = Bridge.fn.bind(this, function () {
                        for (;;) {
                            $step = System.Array.min([0,1,2,3,4,5,6,7,8,9,10], $step);
                            switch ($step) {
                                case 0: {
                                    bone = ($t = skeleton.bones.Items)[this.boneIndex];
                                    if (!bone.active) {
                                        return;
                                    }
                                    frames = this.frames;
                                    if (time < frames[0]) { // Time is before first frame.
                                        switch (blend) {
                                            case Spine.MixBlend.Setup: 
                                                bone.rotation = bone.data.rotation;
                                                return;
                                            case Spine.MixBlend.First: 
                                                r = bone.data.rotation - bone.rotation;
                                                bone.rotation += (r - Bridge.Int.mul((((16384 - Bridge.Int.clip32((16384.499999999996 - r / 360))) | 0)), 360)) * alpha;
                                                return;
                                        }
                                        return;
                                    }

                                    if (time >= frames[((frames.length - Spine.RotateTimeline.ENTRIES) | 0)]) {
                                        $step = 1;
                                        continue;
                                    } 
                                    $step = 6;
                                    continue;
                                }
                                case 1: {
                                    // Time is after last frame.
                                    r1 = frames[((frames.length + Spine.RotateTimeline.PREV_ROTATION) | 0)];
                                    if (blend === Spine.MixBlend.Setup) {
                                        $step = 2;
                                        continue;
                                    }
                                    else if (blend === Spine.MixBlend.First || blend === Spine.MixBlend.Replace) {
                                        $step = 3;
                                        continue;
                                    }
                                    else if (blend === Spine.MixBlend.Add) {
                                        $step = 4;
                                        continue;
                                    }
                                    $step = 5;
                                    continue;
                                }
                                case 2: {
                                    bone.rotation = bone.data.rotation + r1 * alpha;
                                    $step = 5;
                                    continue;
                                }
                                case 3: {
                                    r1 += bone.data.rotation - bone.rotation;
                                    r1 -= Bridge.Int.mul((((16384 - Bridge.Int.clip32((16384.499999999996 - r1 / 360))) | 0)), 360);
                                    $step = 4;
                                    continue;
                                }
                                case 4: {
                                    bone.rotation += r1 * alpha;
                                    $step = 5;
                                    continue;
                                }
                                case 5: {
                                    return;
                                }
                                case 6: {
                                    // Interpolate between the previous frame and the current frame.
                                    frame = Spine.Animation.BinarySearch$1(frames, time, Spine.RotateTimeline.ENTRIES);
                                    prevRotation = frames[((frame + Spine.RotateTimeline.PREV_ROTATION) | 0)];
                                    frameTime = frames[frame];
                                    percent = this.GetCurvePercent((((frame >> 1) - 1) | 0), 1 - (time - frameTime) / (frames[((frame + Spine.RotateTimeline.PREV_TIME) | 0)] - frameTime));
                                    // scope for 'r' to prevent compile error.
                                    r2 = frames[((frame + Spine.RotateTimeline.ROTATION) | 0)] - prevRotation;
                                    r2 = prevRotation + (r2 - Bridge.Int.mul((((16384 - Bridge.Int.clip32((16384.499999999996 - r2 / 360))) | 0)), 360)) * percent;
                                    if (blend === Spine.MixBlend.Setup) {
                                        $step = 7;
                                        continue;
                                    }
                                    else if (blend === Spine.MixBlend.First || blend === Spine.MixBlend.Replace) {
                                        $step = 8;
                                        continue;
                                    }
                                    else if (blend === Spine.MixBlend.Add) {
                                        $step = 9;
                                        continue;
                                    }
                                    $step = 10;
                                    continue;
                                }
                                case 7: {
                                    bone.rotation = bone.data.rotation + (r2 - Bridge.Int.mul((((16384 - Bridge.Int.clip32((16384.499999999996 - r2 / 360))) | 0)), 360)) * alpha;
                                    $step = 10;
                                    continue;
                                }
                                case 8: {
                                    r2 += bone.data.rotation - bone.rotation;
                                    $step = 9;
                                    continue;
                                }
                                case 9: {
                                    bone.rotation += (r2 - Bridge.Int.mul((((16384 - Bridge.Int.clip32((16384.499999999996 - r2 / 360))) | 0)), 360)) * alpha;
                                    $step = 10;
                                    continue;
                                }
                                case 10: {
                                    return;
                                }
                                default: {
                                    return;
                                }
                            }
                        }
                    }, arguments);

                return $asyncBody();
            },
            /*Spine.RotateTimeline.Apply end.*/


        }
    });
    /*Spine.RotateTimeline end.*/

    /*Spine.TranslateTimeline start.*/
    
    Bridge.define("Spine.TranslateTimeline", {
        inherits: [Spine.CurveTimeline,Spine.IBoneTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                PREV_TIME: 0,
                PREV_X: 0,
                PREV_Y: 0,
                X: 0,
                Y: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.TranslateTimeline#init", this ); }

                    this.ENTRIES = 3;
                    this.PREV_TIME = -3;
                    this.PREV_X = -2;
                    this.PREV_Y = -1;
                    this.X = 1;
                    this.Y = 2;
                }
            }
        },
        fields: {
            boneIndex: 0,
            frames: null
        },
        props: {
            PropertyId: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TranslateTimeline#PropertyId#get", this ); }

                    return (((16777216) + this.boneIndex) | 0);
                }
            },
            /**
             * The index of the bone in {@link } that will be changed.
             *
             * @instance
             * @public
             * @memberof Spine.TranslateTimeline
             * @function BoneIndex
             * @type number
             */
            BoneIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TranslateTimeline#BoneIndex#get", this ); }

                    return this.boneIndex;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TranslateTimeline#BoneIndex#set", this ); }

                    if (value < 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("index must be >= 0.");
                    }
                    this.boneIndex = value;
                }
            },
            /**
             * The time in seconds, x, and y values for each key frame.
             *
             * @instance
             * @public
             * @memberof Spine.TranslateTimeline
             * @function Frames
             * @type Array.<number>
             */
            Frames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TranslateTimeline#Frames#get", this ); }

                    return this.frames;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TranslateTimeline#Frames#set", this ); }

                    this.frames = value;
                }
            }
        },
        alias: [
            "PropertyId", "Spine$Timeline$PropertyId",
            "BoneIndex", "Spine$IBoneTimeline$BoneIndex",
            "Apply", "Spine$Timeline$Apply"
        ],
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.TranslateTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount);
                this.frames = System.Array.init(Bridge.Int.mul(frameCount, Spine.TranslateTimeline.ENTRIES), 0, System.Single);
            }
        },
        methods: {
            /*Spine.TranslateTimeline.SetFrame start.*/
            /**
             * Sets the time in seconds, x, and y values for the specified key frame.
             *
             * @instance
             * @public
             * @this Spine.TranslateTimeline
             * @memberof Spine.TranslateTimeline
             * @param   {number}    frameIndex    
             * @param   {number}    time          
             * @param   {number}    x             
             * @param   {number}    y
             * @return  {void}
             */
            SetFrame: function (frameIndex, time, x, y) {
if ( TRACE ) { TRACE( "Spine.TranslateTimeline#SetFrame", this ); }

                frameIndex = Bridge.Int.mul(frameIndex, Spine.TranslateTimeline.ENTRIES);
                this.frames[frameIndex] = time;
                this.frames[((frameIndex + Spine.TranslateTimeline.X) | 0)] = x;
                this.frames[((frameIndex + Spine.TranslateTimeline.Y) | 0)] = y;
            },
            /*Spine.TranslateTimeline.SetFrame end.*/

            /*Spine.TranslateTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.TranslateTimeline#Apply", this ); }

                var $t;
                var bone = ($t = skeleton.bones.Items)[this.boneIndex];
                if (!bone.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) { // Time is before first frame.
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            bone.x = bone.data.x;
                            bone.y = bone.data.y;
                            return;
                        case Spine.MixBlend.First: 
                            bone.x += (bone.data.x - bone.x) * alpha;
                            bone.y += (bone.data.y - bone.y) * alpha;
                            return;
                    }
                    return;
                }

                var x, y;
                if (time >= frames[((frames.length - Spine.TranslateTimeline.ENTRIES) | 0)]) { // Time is after last frame.
                    x = frames[((frames.length + Spine.TranslateTimeline.PREV_X) | 0)];
                    y = frames[((frames.length + Spine.TranslateTimeline.PREV_Y) | 0)];
                } else {
                    // Interpolate between the previous frame and the current frame.
                    var frame = Spine.Animation.BinarySearch$1(frames, time, Spine.TranslateTimeline.ENTRIES);
                    x = frames[((frame + Spine.TranslateTimeline.PREV_X) | 0)];
                    y = frames[((frame + Spine.TranslateTimeline.PREV_Y) | 0)];
                    var frameTime = frames[frame];
                    var percent = this.GetCurvePercent(((((Bridge.Int.div(frame, Spine.TranslateTimeline.ENTRIES)) | 0) - 1) | 0), 1 - (time - frameTime) / (frames[((frame + Spine.TranslateTimeline.PREV_TIME) | 0)] - frameTime));

                    x += (frames[((frame + Spine.TranslateTimeline.X) | 0)] - x) * percent;
                    y += (frames[((frame + Spine.TranslateTimeline.Y) | 0)] - y) * percent;
                }
                switch (blend) {
                    case Spine.MixBlend.Setup: 
                        bone.x = bone.data.x + x * alpha;
                        bone.y = bone.data.y + y * alpha;
                        break;
                    case Spine.MixBlend.First: 
                    case Spine.MixBlend.Replace: 
                        bone.x += (bone.data.x + x - bone.x) * alpha;
                        bone.y += (bone.data.y + y - bone.y) * alpha;
                        break;
                    case Spine.MixBlend.Add: 
                        bone.x += x * alpha;
                        bone.y += y * alpha;
                        break;
                }
            },
            /*Spine.TranslateTimeline.Apply end.*/


        }
    });
    /*Spine.TranslateTimeline end.*/

    /*Spine.TransformConstraintTimeline start.*/
    /**
     * Changes a transform constraint's mixes.
     *
     * @public
     * @class Spine.TransformConstraintTimeline
     * @augments Spine.CurveTimeline
     */
    Bridge.define("Spine.TransformConstraintTimeline", {
        inherits: [Spine.CurveTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                PREV_TIME: 0,
                PREV_ROTATE: 0,
                PREV_TRANSLATE: 0,
                PREV_SCALE: 0,
                PREV_SHEAR: 0,
                ROTATE: 0,
                TRANSLATE: 0,
                SCALE: 0,
                SHEAR: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintTimeline#init", this ); }

                    this.ENTRIES = 5;
                    this.PREV_TIME = -5;
                    this.PREV_ROTATE = -4;
                    this.PREV_TRANSLATE = -3;
                    this.PREV_SCALE = -2;
                    this.PREV_SHEAR = -1;
                    this.ROTATE = 1;
                    this.TRANSLATE = 2;
                    this.SCALE = 3;
                    this.SHEAR = 4;
                }
            }
        },
        fields: {
            transformConstraintIndex: 0,
            frames: null
        },
        props: {
            PropertyId: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintTimeline#PropertyId#get", this ); }

                    return (((167772160) + this.transformConstraintIndex) | 0);
                }
            },
            /**
             * The index of the transform constraint slot in {@link } that will be changed.
             *
             * @instance
             * @public
             * @memberof Spine.TransformConstraintTimeline
             * @function TransformConstraintIndex
             * @type number
             */
            TransformConstraintIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintTimeline#TransformConstraintIndex#get", this ); }

                    return this.transformConstraintIndex;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintTimeline#TransformConstraintIndex#set", this ); }

                    if (value < 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("index must be >= 0.");
                    }
                    this.transformConstraintIndex = value;
                }
            },
            /**
             * The time in seconds, rotate mix, translate mix, scale mix, and shear mix for each key frame.
             *
             * @instance
             * @public
             * @memberof Spine.TransformConstraintTimeline
             * @function Frames
             * @type Array.<number>
             */
            Frames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintTimeline#Frames#get", this ); }

                    return this.frames;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintTimeline#Frames#set", this ); }

                    this.frames = value;
                }
            }
        },
        alias: [
            "PropertyId", "Spine$Timeline$PropertyId",
            "Apply", "Spine$Timeline$Apply"
        ],
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount);
                this.frames = System.Array.init(Bridge.Int.mul(frameCount, Spine.TransformConstraintTimeline.ENTRIES), 0, System.Single);
            }
        },
        methods: {
            /*Spine.TransformConstraintTimeline.SetFrame start.*/
            /**
             * The time in seconds, rotate mix, translate mix, scale mix, and shear mix for the specified key frame.
             *
             * @instance
             * @public
             * @this Spine.TransformConstraintTimeline
             * @memberof Spine.TransformConstraintTimeline
             * @param   {number}    frameIndex      
             * @param   {number}    time            
             * @param   {number}    rotateMix       
             * @param   {number}    translateMix    
             * @param   {number}    scaleMix        
             * @param   {number}    shearMix
             * @return  {void}
             */
            SetFrame: function (frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintTimeline#SetFrame", this ); }

                frameIndex = Bridge.Int.mul(frameIndex, Spine.TransformConstraintTimeline.ENTRIES);
                this.frames[frameIndex] = time;
                this.frames[((frameIndex + Spine.TransformConstraintTimeline.ROTATE) | 0)] = rotateMix;
                this.frames[((frameIndex + Spine.TransformConstraintTimeline.TRANSLATE) | 0)] = translateMix;
                this.frames[((frameIndex + Spine.TransformConstraintTimeline.SCALE) | 0)] = scaleMix;
                this.frames[((frameIndex + Spine.TransformConstraintTimeline.SHEAR) | 0)] = shearMix;
            },
            /*Spine.TransformConstraintTimeline.SetFrame end.*/

            /*Spine.TransformConstraintTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintTimeline#Apply", this ); }

                var $t;
                var constraint = ($t = skeleton.transformConstraints.Items)[this.transformConstraintIndex];
                if (!constraint.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) { // Time is before first frame.
                    var data = constraint.data;
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            constraint.rotateMix = data.rotateMix;
                            constraint.translateMix = data.translateMix;
                            constraint.scaleMix = data.scaleMix;
                            constraint.shearMix = data.shearMix;
                            return;
                        case Spine.MixBlend.First: 
                            constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;
                            constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;
                            constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;
                            constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;
                            return;
                    }
                    return;
                }

                var rotate, translate, scale, shear;
                if (time >= frames[((frames.length - Spine.TransformConstraintTimeline.ENTRIES) | 0)]) { // Time is after last frame.
                    var i = frames.length;
                    rotate = frames[((i + Spine.TransformConstraintTimeline.PREV_ROTATE) | 0)];
                    translate = frames[((i + Spine.TransformConstraintTimeline.PREV_TRANSLATE) | 0)];
                    scale = frames[((i + Spine.TransformConstraintTimeline.PREV_SCALE) | 0)];
                    shear = frames[((i + Spine.TransformConstraintTimeline.PREV_SHEAR) | 0)];
                } else {
                    // Interpolate between the previous frame and the current frame.
                    var frame = Spine.Animation.BinarySearch$1(frames, time, Spine.TransformConstraintTimeline.ENTRIES);
                    rotate = frames[((frame + Spine.TransformConstraintTimeline.PREV_ROTATE) | 0)];
                    translate = frames[((frame + Spine.TransformConstraintTimeline.PREV_TRANSLATE) | 0)];
                    scale = frames[((frame + Spine.TransformConstraintTimeline.PREV_SCALE) | 0)];
                    shear = frames[((frame + Spine.TransformConstraintTimeline.PREV_SHEAR) | 0)];
                    var frameTime = frames[frame];
                    var percent = this.GetCurvePercent(((((Bridge.Int.div(frame, Spine.TransformConstraintTimeline.ENTRIES)) | 0) - 1) | 0), 1 - (time - frameTime) / (frames[((frame + Spine.TransformConstraintTimeline.PREV_TIME) | 0)] - frameTime));

                    rotate += (frames[((frame + Spine.TransformConstraintTimeline.ROTATE) | 0)] - rotate) * percent;
                    translate += (frames[((frame + Spine.TransformConstraintTimeline.TRANSLATE) | 0)] - translate) * percent;
                    scale += (frames[((frame + Spine.TransformConstraintTimeline.SCALE) | 0)] - scale) * percent;
                    shear += (frames[((frame + Spine.TransformConstraintTimeline.SHEAR) | 0)] - shear) * percent;
                }
                if (blend === Spine.MixBlend.Setup) {
                    var data1 = constraint.data;
                    constraint.rotateMix = data1.rotateMix + (rotate - data1.rotateMix) * alpha;
                    constraint.translateMix = data1.translateMix + (translate - data1.translateMix) * alpha;
                    constraint.scaleMix = data1.scaleMix + (scale - data1.scaleMix) * alpha;
                    constraint.shearMix = data1.shearMix + (shear - data1.shearMix) * alpha;
                } else {
                    constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
                    constraint.translateMix += (translate - constraint.translateMix) * alpha;
                    constraint.scaleMix += (scale - constraint.scaleMix) * alpha;
                    constraint.shearMix += (shear - constraint.shearMix) * alpha;
                }
            },
            /*Spine.TransformConstraintTimeline.Apply end.*/


        }
    });
    /*Spine.TransformConstraintTimeline end.*/

    /*Spine.TwoColorTimeline start.*/
    /**
     * Changes a slot's {@link } and {@link } for two color tinting.
     *
     * @public
     * @class Spine.TwoColorTimeline
     * @augments Spine.CurveTimeline
     * @implements  Spine.ISlotTimeline
     */
    Bridge.define("Spine.TwoColorTimeline", {
        inherits: [Spine.CurveTimeline,Spine.ISlotTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                PREV_TIME: 0,
                PREV_R: 0,
                PREV_G: 0,
                PREV_B: 0,
                PREV_A: 0,
                PREV_R2: 0,
                PREV_G2: 0,
                PREV_B2: 0,
                R: 0,
                G: 0,
                B: 0,
                A: 0,
                R2: 0,
                G2: 0,
                B2: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.TwoColorTimeline#init", this ); }

                    this.ENTRIES = 8;
                    this.PREV_TIME = -8;
                    this.PREV_R = -7;
                    this.PREV_G = -6;
                    this.PREV_B = -5;
                    this.PREV_A = -4;
                    this.PREV_R2 = -3;
                    this.PREV_G2 = -2;
                    this.PREV_B2 = -1;
                    this.R = 1;
                    this.G = 2;
                    this.B = 3;
                    this.A = 4;
                    this.R2 = 5;
                    this.G2 = 6;
                    this.B2 = 7;
                }
            }
        },
        fields: {
            slotIndex: 0,
            frames: null
        },
        props: {
            PropertyId: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TwoColorTimeline#PropertyId#get", this ); }

                    return (((234881024) + this.slotIndex) | 0);
                }
            },
            /**
             * The index of the slot in {@link } that will be changed.
             *
             * @instance
             * @public
             * @memberof Spine.TwoColorTimeline
             * @function SlotIndex
             * @type number
             */
            SlotIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TwoColorTimeline#SlotIndex#get", this ); }

                    return this.slotIndex;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TwoColorTimeline#SlotIndex#set", this ); }

                    if (value < 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("index must be >= 0.");
                    }
                    this.slotIndex = value;
                }
            },
            /**
             * The time in seconds, red, green, blue, and alpha values for each key frame.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TwoColorTimeline
             * @function Frames
             * @type Array.<number>
             */
            Frames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TwoColorTimeline#Frames#get", this ); }

                    return this.frames;
                }
            }
        },
        alias: [
            "PropertyId", "Spine$Timeline$PropertyId",
            "SlotIndex", "Spine$ISlotTimeline$SlotIndex",
            "Apply", "Spine$Timeline$Apply"
        ],
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.TwoColorTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount);
                this.frames = System.Array.init(Bridge.Int.mul(frameCount, Spine.TwoColorTimeline.ENTRIES), 0, System.Single);
            }
        },
        methods: {
            /*Spine.TwoColorTimeline.SetFrame start.*/
            /**
             * Sets the time in seconds, light, and dark colors for the specified key frame..
             *
             * @instance
             * @public
             * @this Spine.TwoColorTimeline
             * @memberof Spine.TwoColorTimeline
             * @param   {number}    frameIndex    
             * @param   {number}    time          
             * @param   {number}    r             
             * @param   {number}    g             
             * @param   {number}    b             
             * @param   {number}    a             
             * @param   {number}    r2            
             * @param   {number}    g2            
             * @param   {number}    b2
             * @return  {void}
             */
            SetFrame: function (frameIndex, time, r, g, b, a, r2, g2, b2) {
if ( TRACE ) { TRACE( "Spine.TwoColorTimeline#SetFrame", this ); }

                frameIndex = Bridge.Int.mul(frameIndex, Spine.TwoColorTimeline.ENTRIES);
                this.frames[frameIndex] = time;
                this.frames[((frameIndex + Spine.TwoColorTimeline.R) | 0)] = r;
                this.frames[((frameIndex + Spine.TwoColorTimeline.G) | 0)] = g;
                this.frames[((frameIndex + Spine.TwoColorTimeline.B) | 0)] = b;
                this.frames[((frameIndex + Spine.TwoColorTimeline.A) | 0)] = a;
                this.frames[((frameIndex + Spine.TwoColorTimeline.R2) | 0)] = r2;
                this.frames[((frameIndex + Spine.TwoColorTimeline.G2) | 0)] = g2;
                this.frames[((frameIndex + Spine.TwoColorTimeline.B2) | 0)] = b2;
            },
            /*Spine.TwoColorTimeline.SetFrame end.*/

            /*Spine.TwoColorTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.TwoColorTimeline#Apply", this ); }

                var $t;
                var slot = ($t = skeleton.slots.Items)[this.slotIndex];
                if (!slot.bone.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) { // Time is before first frame.
                    var slotData = slot.data;
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            //	slot.color.set(slot.data.color);
                            //	slot.darkColor.set(slot.data.darkColor);
                            slot.r = slotData.r;
                            slot.g = slotData.g;
                            slot.b = slotData.b;
                            slot.a = slotData.a;
                            slot.ClampColor();
                            slot.r2 = slotData.r2;
                            slot.g2 = slotData.g2;
                            slot.b2 = slotData.b2;
                            slot.ClampSecondColor();
                            return;
                        case Spine.MixBlend.First: 
                            slot.r += (slot.r - slotData.r) * alpha;
                            slot.g += (slot.g - slotData.g) * alpha;
                            slot.b += (slot.b - slotData.b) * alpha;
                            slot.a += (slot.a - slotData.a) * alpha;
                            slot.ClampColor();
                            slot.r2 += (slot.r2 - slotData.r2) * alpha;
                            slot.g2 += (slot.g2 - slotData.g2) * alpha;
                            slot.b2 += (slot.b2 - slotData.b2) * alpha;
                            slot.ClampSecondColor();
                            return;
                    }
                    return;
                }

                var r, g, b, a, r2, g2, b2;
                if (time >= frames[((frames.length - Spine.TwoColorTimeline.ENTRIES) | 0)]) { // Time is after last frame.
                    var i = frames.length;
                    r = frames[((i + Spine.TwoColorTimeline.PREV_R) | 0)];
                    g = frames[((i + Spine.TwoColorTimeline.PREV_G) | 0)];
                    b = frames[((i + Spine.TwoColorTimeline.PREV_B) | 0)];
                    a = frames[((i + Spine.TwoColorTimeline.PREV_A) | 0)];
                    r2 = frames[((i + Spine.TwoColorTimeline.PREV_R2) | 0)];
                    g2 = frames[((i + Spine.TwoColorTimeline.PREV_G2) | 0)];
                    b2 = frames[((i + Spine.TwoColorTimeline.PREV_B2) | 0)];
                } else {
                    // Interpolate between the previous frame and the current frame.
                    var frame = Spine.Animation.BinarySearch$1(frames, time, Spine.TwoColorTimeline.ENTRIES);
                    r = frames[((frame + Spine.TwoColorTimeline.PREV_R) | 0)];
                    g = frames[((frame + Spine.TwoColorTimeline.PREV_G) | 0)];
                    b = frames[((frame + Spine.TwoColorTimeline.PREV_B) | 0)];
                    a = frames[((frame + Spine.TwoColorTimeline.PREV_A) | 0)];
                    r2 = frames[((frame + Spine.TwoColorTimeline.PREV_R2) | 0)];
                    g2 = frames[((frame + Spine.TwoColorTimeline.PREV_G2) | 0)];
                    b2 = frames[((frame + Spine.TwoColorTimeline.PREV_B2) | 0)];
                    var frameTime = frames[frame];
                    var percent = this.GetCurvePercent(((((Bridge.Int.div(frame, Spine.TwoColorTimeline.ENTRIES)) | 0) - 1) | 0), 1 - (time - frameTime) / (frames[((frame + Spine.TwoColorTimeline.PREV_TIME) | 0)] - frameTime));

                    r += (frames[((frame + Spine.TwoColorTimeline.R) | 0)] - r) * percent;
                    g += (frames[((frame + Spine.TwoColorTimeline.G) | 0)] - g) * percent;
                    b += (frames[((frame + Spine.TwoColorTimeline.B) | 0)] - b) * percent;
                    a += (frames[((frame + Spine.TwoColorTimeline.A) | 0)] - a) * percent;
                    r2 += (frames[((frame + Spine.TwoColorTimeline.R2) | 0)] - r2) * percent;
                    g2 += (frames[((frame + Spine.TwoColorTimeline.G2) | 0)] - g2) * percent;
                    b2 += (frames[((frame + Spine.TwoColorTimeline.B2) | 0)] - b2) * percent;
                }
                if (alpha === 1) {
                    slot.r = r;
                    slot.g = g;
                    slot.b = b;
                    slot.a = a;
                    slot.ClampColor();
                    slot.r2 = r2;
                    slot.g2 = g2;
                    slot.b2 = b2;
                    slot.ClampSecondColor();
                } else {
                    var br, bg, bb, ba, br2, bg2, bb2;
                    if (blend === Spine.MixBlend.Setup) {
                        br = slot.data.r;
                        bg = slot.data.g;
                        bb = slot.data.b;
                        ba = slot.data.a;
                        br2 = slot.data.r2;
                        bg2 = slot.data.g2;
                        bb2 = slot.data.b2;
                    } else {
                        br = slot.r;
                        bg = slot.g;
                        bb = slot.b;
                        ba = slot.a;
                        br2 = slot.r2;
                        bg2 = slot.g2;
                        bb2 = slot.b2;
                    }
                    slot.r = br + ((r - br) * alpha);
                    slot.g = bg + ((g - bg) * alpha);
                    slot.b = bb + ((b - bb) * alpha);
                    slot.a = ba + ((a - ba) * alpha);
                    slot.ClampColor();
                    slot.r2 = br2 + ((r2 - br2) * alpha);
                    slot.g2 = bg2 + ((g2 - bg2) * alpha);
                    slot.b2 = bb2 + ((b2 - bb2) * alpha);
                    slot.ClampSecondColor();
                }
            },
            /*Spine.TwoColorTimeline.Apply end.*/


        }
    });
    /*Spine.TwoColorTimeline end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.UpdateBonesDelegate
     * @param   {Spine.Unity.ISkeletonAnimation}    animated
     * @return  {void}
     */


    /*Spine.Unity.SkeletonAnimation start.*/
    Bridge.define("Spine.Unity.SkeletonAnimation", {
        inherits: [Spine.Unity.SkeletonRenderer,Spine.Unity.ISkeletonAnimation,Spine.Unity.IAnimationStateComponent],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonAnimation.AddToGameObject:static start.*/
                /**
                 * Adds and prepares a SkeletonAnimation component to a GameObject at runtime.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonAnimation
                 * @memberof Spine.Unity.SkeletonAnimation
                 * @param   {UnityEngine.GameObject}           gameObject           
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {boolean}                          quiet
                 * @return  {Spine.Unity.SkeletonAnimation}                         The newly instantiated SkeletonAnimation
                 */
                AddToGameObject: function (gameObject, skeletonDataAsset, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AddToGameObject", this ); }

                    if (quiet === void 0) { quiet = false; }
                    return Spine.Unity.SkeletonRenderer.AddSpineComponent(Spine.Unity.SkeletonAnimation, gameObject, skeletonDataAsset, quiet);
                },
                /*Spine.Unity.SkeletonAnimation.AddToGameObject:static end.*/

                /*Spine.Unity.SkeletonAnimation.NewSkeletonAnimationGameObject:static start.*/
                /**
                 * Instantiates a new UnityEngine.GameObject and adds a prepared SkeletonAnimation component to it.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonAnimation
                 * @memberof Spine.Unity.SkeletonAnimation
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {boolean}                          quiet
                 * @return  {Spine.Unity.SkeletonAnimation}                         The newly instantiated SkeletonAnimation component.
                 */
                NewSkeletonAnimationGameObject: function (skeletonDataAsset, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#NewSkeletonAnimationGameObject", this ); }

                    if (quiet === void 0) { quiet = false; }
                    return Spine.Unity.SkeletonRenderer.NewSpineGameObject(Spine.Unity.SkeletonAnimation, skeletonDataAsset, quiet);
                },
                /*Spine.Unity.SkeletonAnimation.NewSkeletonAnimationGameObject:static end.*/


            }
        },
        fields: {
            /**
             * This is the Spine.AnimationState object of this SkeletonAnimation. You can control animations through it.
             Note that this object, like .skeleton, is not guaranteed to exist in Awake. Do all accesses and caching to it in Start
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @type Spine.AnimationState
             */
            state: null,
            wasUpdatedAfterInit: false,
            _animationName: null,
            /**
             * Whether or not {@link } should loop. This only applies to the initial animation specified in the inspector, or any subsequent Animations played through .AnimationName. Animations set through state.SetAnimation are unaffected.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @type boolean
             */
            loop: false,
            /**
             * The rate at which animations progress over time. 1 means 100%. 0.5 means 50%.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @default 1
             * @type number
             */
            timeScale: 0
        },
        events: {
            _BeforeApply: null,
            _UpdateLocal: null,
            _UpdateWorld: null,
            _UpdateComplete: null
        },
        props: {
            /**
             * This is the Spine.AnimationState object of this SkeletonAnimation. You can control animations through it.
             Note that this object, like .skeleton, is not guaranteed to exist in Awake. Do all accesses and caching to it in Start
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonAnimation
             * @function AnimationState
             * @type Spine.AnimationState
             */
            AnimationState: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AnimationState#get", this ); }

                    this.Initialize(false);
                    return this.state;
                }
            },
            /**
             * Setting this property sets the animation of the skeleton. If invalid, it will store the animation name for the next time the skeleton is properly initialized.
             Getting this property gets the name of the currently playing animation. If invalid, it will return the last stored animation name set through this property.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @function AnimationName
             * @type string
             */
            AnimationName: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AnimationName#get", this ); }

                    if (!this.valid) {
                        return this._animationName;
                    } else {
                        var entry = this.state.GetCurrent(0);
                        return entry == null ? null : entry.Animation.Name;
                    }
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AnimationName#set", this ); }

                    this.Initialize(false);
                    if (Bridge.referenceEquals(this._animationName, value)) {
                        var entry = this.state.GetCurrent(0);
                        if (entry != null && entry.loop === this.loop) {
                            return;
                        }
                    }
                    this._animationName = value;

                    if (System.String.isNullOrEmpty(value)) {
                        this.state.ClearTrack(0);
                    } else {
                        var animationObject = this.skeletonDataAsset.GetSkeletonData(false).FindAnimation(value);
                        if (animationObject != null) {
                            this.state.SetAnimation(0, animationObject, this.loop);
                        }
                    }
                }
            }
        },
        alias: [
            "AnimationState", "Spine$Unity$IAnimationStateComponent$AnimationState",
            "addUpdateLocal", "Spine$Unity$ISkeletonAnimation$addUpdateLocal",
            "removeUpdateLocal", "Spine$Unity$ISkeletonAnimation$removeUpdateLocal",
            "addUpdateWorld", "Spine$Unity$ISkeletonAnimation$addUpdateWorld",
            "removeUpdateWorld", "Spine$Unity$ISkeletonAnimation$removeUpdateWorld",
            "addUpdateComplete", "Spine$Unity$ISkeletonAnimation$addUpdateComplete",
            "removeUpdateComplete", "Spine$Unity$ISkeletonAnimation$removeUpdateComplete",
            "Skeleton", "Spine$Unity$ISkeletonAnimation$Skeleton"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#init", this ); }

                this.wasUpdatedAfterInit = true;
                this.timeScale = 1;
            }
        },
        methods: {
            /**
             * Occurs before the animations are applied.
             Use this callback when you want to change the skeleton state before animations are applied on top.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#BeforeApply
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addBeforeApply: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addBeforeApply", this ); }

                this.add_BeforeApply(value);
            },
            /**
             * Occurs before the animations are applied.
             Use this callback when you want to change the skeleton state before animations are applied on top.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#BeforeApply
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeBeforeApply: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeBeforeApply", this ); }

                this.remove_BeforeApply(value);
            },
            /**
             * Occurs after the animations are applied and before world space values are resolved.
             Use this callback when you want to set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateLocal
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateLocal: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addUpdateLocal", this ); }

                this.add_UpdateLocal(value);
            },
            /**
             * Occurs after the animations are applied and before world space values are resolved.
             Use this callback when you want to set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateLocal
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateLocal: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeUpdateLocal", this ); }

                this.remove_UpdateLocal(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Using this callback will cause the world space values to be solved an extra time.
             Use this callback if want to use bone world space values, and also set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateWorld
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateWorld: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addUpdateWorld", this ); }

                this.add_UpdateWorld(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Using this callback will cause the world space values to be solved an extra time.
             Use this callback if want to use bone world space values, and also set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateWorld
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateWorld: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeUpdateWorld", this ); }

                this.remove_UpdateWorld(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
             This callback can also be used when setting world position and the bone matrix.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateComplete
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateComplete: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addUpdateComplete", this ); }

                this.add_UpdateComplete(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
             This callback can also be used when setting world position and the bone matrix.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateComplete
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateComplete: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeUpdateComplete", this ); }

                this.remove_UpdateComplete(value);
            },
            /*Spine.Unity.SkeletonAnimation.ClearState start.*/
            /**
             * Clears the previously generated mesh, resets the skeleton's pose, and clears all previously active animations.
             *
             * @instance
             * @public
             * @override
             * @this Spine.Unity.SkeletonAnimation
             * @memberof Spine.Unity.SkeletonAnimation
             * @return  {void}
             */
            ClearState: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#ClearState", this ); }

                Spine.Unity.SkeletonRenderer.prototype.ClearState.call(this);
                if (this.state != null) {
                    this.state.ClearTracks();
                }
            },
            /*Spine.Unity.SkeletonAnimation.ClearState end.*/

            /*Spine.Unity.SkeletonAnimation.Initialize start.*/
            /**
             * Initialize this component. Attempts to load the SkeletonData and creates the internal Spine objects and buffers.
             *
             * @instance
             * @public
             * @override
             * @this Spine.Unity.SkeletonAnimation
             * @memberof Spine.Unity.SkeletonAnimation
             * @param   {boolean}    overwrite    If set to <pre><code>true</code></pre>, force overwrite an already initialized object.
             * @param   {boolean}    quiet
             * @return  {void}
             */
            Initialize: function (overwrite, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#Initialize", this ); }

                if (quiet === void 0) { quiet = false; }
                if (this.valid && !overwrite) {
                    return;
                }
                Spine.Unity.SkeletonRenderer.prototype.Initialize.call(this, overwrite, quiet);

                if (!this.valid) {
                    return;
                }
                this.state = new Spine.AnimationState(this.skeletonDataAsset.GetAnimationStateData());
                this.wasUpdatedAfterInit = false;

                if (!System.String.isNullOrEmpty(this._animationName)) {
                    var animationObject = this.skeletonDataAsset.GetSkeletonData(false).FindAnimation(this._animationName);
                    if (animationObject != null) {
                        this.state.SetAnimation(0, animationObject, this.loop);
                    }
                }
            },
            /*Spine.Unity.SkeletonAnimation.Initialize end.*/

            /*Spine.Unity.SkeletonAnimation.Update$1 start.*/
            Update$1: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#Update$1", this ); }


                this.Update(UnityEngine.Time.deltaTime);
            },
            /*Spine.Unity.SkeletonAnimation.Update$1 end.*/

            /*Spine.Unity.SkeletonAnimation.Update start.*/
            /**
             * Progresses the AnimationState according to the given deltaTime, and applies it to the Skeleton. Use Time.deltaTime to update manually. Use deltaTime 0 to update without progressing the time.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonAnimation
             * @memberof Spine.Unity.SkeletonAnimation
             * @param   {number}    deltaTime
             * @return  {void}
             */
            Update: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#Update", this ); }

                if (!this.valid || this.state == null) {
                    return;
                }

                this.wasUpdatedAfterInit = true;
                if (this.updateMode < Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    return;
                }
                this.UpdateAnimationStatus(deltaTime);

                if (this.updateMode === Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    return;
                }
                this.ApplyAnimation();
            },
            /*Spine.Unity.SkeletonAnimation.Update end.*/

            /*Spine.Unity.SkeletonAnimation.UpdateAnimationStatus start.*/
            UpdateAnimationStatus: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#UpdateAnimationStatus", this ); }

                deltaTime *= this.timeScale;
                this.skeleton.Update(deltaTime);
                this.state.Update(deltaTime);
            },
            /*Spine.Unity.SkeletonAnimation.UpdateAnimationStatus end.*/

            /*Spine.Unity.SkeletonAnimation.ApplyAnimation start.*/
            ApplyAnimation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#ApplyAnimation", this ); }

                if (!Bridge.staticEquals(this._BeforeApply, null)) {
                    this._BeforeApply(this);
                }

                if (this.updateMode !== Spine.Unity.UpdateMode.OnlyEventTimelines) {
                    this.state.Apply(this.skeleton);
                } else {
                    this.state.ApplyEventTimelinesOnly(this.skeleton);
                }

                if (!Bridge.staticEquals(this._UpdateLocal, null)) {
                    this._UpdateLocal(this);
                }

                this.skeleton.UpdateWorldTransform();

                if (!Bridge.staticEquals(this._UpdateWorld, null)) {
                    this._UpdateWorld(this);
                    this.skeleton.UpdateWorldTransform();
                }

                if (!Bridge.staticEquals(this._UpdateComplete, null)) {
                    this._UpdateComplete(this);
                }
            },
            /*Spine.Unity.SkeletonAnimation.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonAnimation.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#LateUpdate", this ); }

                // instantiation can happen from Update() after this component, leading to a missing Update() call.
                if (!this.wasUpdatedAfterInit) {
                    this.Update(0);
                }
                Spine.Unity.SkeletonRenderer.prototype.LateUpdate.call(this);
            },
            /*Spine.Unity.SkeletonAnimation.LateUpdate end.*/


        },
        overloads: {
            "Update()": "Update$1"
        }
    });
    /*Spine.Unity.SkeletonAnimation end.*/

    /*Spine.Unity.SkeletonMecanim start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim", {
        inherits: [Spine.Unity.SkeletonRenderer,Spine.Unity.ISkeletonAnimation],
        fields: {
            translator: null,
            wasUpdatedAfterInit: false
        },
        events: {
            _BeforeApply: null,
            _UpdateLocal: null,
            _UpdateWorld: null,
            _UpdateComplete: null
        },
        props: {
            Translator: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#Translator#get", this ); }

                    return this.translator;
                }
            }
        },
        alias: [
            "addUpdateLocal", "Spine$Unity$ISkeletonAnimation$addUpdateLocal",
            "removeUpdateLocal", "Spine$Unity$ISkeletonAnimation$removeUpdateLocal",
            "addUpdateWorld", "Spine$Unity$ISkeletonAnimation$addUpdateWorld",
            "removeUpdateWorld", "Spine$Unity$ISkeletonAnimation$removeUpdateWorld",
            "addUpdateComplete", "Spine$Unity$ISkeletonAnimation$addUpdateComplete",
            "removeUpdateComplete", "Spine$Unity$ISkeletonAnimation$removeUpdateComplete",
            "Skeleton", "Spine$Unity$ISkeletonAnimation$Skeleton"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#init", this ); }

                this.wasUpdatedAfterInit = true;
            }
        },
        methods: {
            /**
             * Occurs before the animations are applied.
             Use this callback when you want to change the skeleton state before animations are applied on top.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#BeforeApply
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addBeforeApply: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addBeforeApply", this ); }

                this.add_BeforeApply(value);
            },
            /**
             * Occurs before the animations are applied.
             Use this callback when you want to change the skeleton state before animations are applied on top.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#BeforeApply
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeBeforeApply: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeBeforeApply", this ); }

                this.remove_BeforeApply(value);
            },
            /**
             * Occurs after the animations are applied and before world space values are resolved.
             Use this callback when you want to set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateLocal
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateLocal: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addUpdateLocal", this ); }

                this.add_UpdateLocal(value);
            },
            /**
             * Occurs after the animations are applied and before world space values are resolved.
             Use this callback when you want to set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateLocal
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateLocal: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeUpdateLocal", this ); }

                this.remove_UpdateLocal(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Using this callback will cause the world space values to be solved an extra time.
             Use this callback if want to use bone world space values, and also set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateWorld
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateWorld: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addUpdateWorld", this ); }

                this.add_UpdateWorld(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Using this callback will cause the world space values to be solved an extra time.
             Use this callback if want to use bone world space values, and also set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateWorld
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateWorld: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeUpdateWorld", this ); }

                this.remove_UpdateWorld(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
             This callback can also be used when setting world position and the bone matrix.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateComplete
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateComplete: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addUpdateComplete", this ); }

                this.add_UpdateComplete(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
             This callback can also be used when setting world position and the bone matrix.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateComplete
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateComplete: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeUpdateComplete", this ); }

                this.remove_UpdateComplete(value);
            },
            /*Spine.Unity.SkeletonMecanim.Initialize start.*/
            Initialize: function (overwrite, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#Initialize", this ); }

                if (quiet === void 0) { quiet = false; }
                if (this.valid && !overwrite) {
                    return;
                }

                Spine.Unity.SkeletonRenderer.prototype.Initialize.call(this, overwrite, quiet);

                if (!this.valid) {
                    return;
                }

                if (this.translator == null) {
                    this.translator = new Spine.Unity.SkeletonMecanim.MecanimTranslator();
                }
                this.translator.Initialize(this.GetComponent(UnityEngine.Animator), this.skeletonDataAsset);
                this.wasUpdatedAfterInit = false;
            },
            /*Spine.Unity.SkeletonMecanim.Initialize end.*/

            /*Spine.Unity.SkeletonMecanim.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#Update", this ); }

                if (!this.valid) {
                    return;
                }

                this.wasUpdatedAfterInit = true;
                // animation status is kept by Mecanim Animator component
                if (this.updateMode <= Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    return;
                }
                this.ApplyAnimation();
            },
            /*Spine.Unity.SkeletonMecanim.Update end.*/

            /*Spine.Unity.SkeletonMecanim.ApplyAnimation start.*/
            ApplyAnimation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#ApplyAnimation", this ); }

                if (!Bridge.staticEquals(this._BeforeApply, null)) {
                    this._BeforeApply(this);
                }

                this.translator.Apply(this.skeleton);

                // UpdateWorldTransform and Bone Callbacks
                {
                    if (!Bridge.staticEquals(this._UpdateLocal, null)) {
                        this._UpdateLocal(this);
                    }

                    this.skeleton.UpdateWorldTransform();

                    if (!Bridge.staticEquals(this._UpdateWorld, null)) {
                        this._UpdateWorld(this);
                        this.skeleton.UpdateWorldTransform();
                    }

                    if (!Bridge.staticEquals(this._UpdateComplete, null)) {
                        this._UpdateComplete(this);
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonMecanim.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#LateUpdate", this ); }

                // instantiation can happen from Update() after this component, leading to a missing Update() call.
                if (!this.wasUpdatedAfterInit) {
                    this.Update();
                }
                Spine.Unity.SkeletonRenderer.prototype.LateUpdate.call(this);
            },
            /*Spine.Unity.SkeletonMecanim.LateUpdate end.*/


        }
    });
    /*Spine.Unity.SkeletonMecanim end.*/

    /*Spine.PathConstraintSpacingTimeline start.*/
    /**
     * Changes a path constraint's {@link }.
     *
     * @public
     * @class Spine.PathConstraintSpacingTimeline
     * @augments Spine.PathConstraintPositionTimeline
     */
    Bridge.define("Spine.PathConstraintSpacingTimeline", {
        inherits: [Spine.PathConstraintPositionTimeline],
        props: {
            PropertyId: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintSpacingTimeline#PropertyId#get", this ); }

                    return (((201326592) + this.pathConstraintIndex) | 0);
                }
            }
        },
        alias: [
            "PropertyId", "Spine$Timeline$PropertyId",
            "Apply", "Spine$Timeline$Apply"
        ],
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.PathConstraintSpacingTimeline#ctor", this ); }

                this.$initialize();
                Spine.PathConstraintPositionTimeline.ctor.call(this, frameCount);
            }
        },
        methods: {
            /*Spine.PathConstraintSpacingTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, events, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.PathConstraintSpacingTimeline#Apply", this ); }

                var $t;
                var constraint = ($t = skeleton.pathConstraints.Items)[this.pathConstraintIndex];
                if (!constraint.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) { // Time is before first frame.
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            constraint.spacing = constraint.data.spacing;
                            return;
                        case Spine.MixBlend.First: 
                            constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;
                            return;
                    }
                    return;
                }

                var spacing;
                if (time >= frames[((frames.length - Spine.PathConstraintPositionTimeline.ENTRIES) | 0)]) {
                    spacing = frames[((frames.length + Spine.PathConstraintPositionTimeline.PREV_VALUE) | 0)];
                } else {
                    // Interpolate between the previous frame and the current frame.
                    var frame = Spine.Animation.BinarySearch$1(frames, time, Spine.PathConstraintPositionTimeline.ENTRIES);
                    spacing = frames[((frame + Spine.PathConstraintPositionTimeline.PREV_VALUE) | 0)];
                    var frameTime = frames[frame];
                    var percent = this.GetCurvePercent(((((Bridge.Int.div(frame, Spine.PathConstraintPositionTimeline.ENTRIES)) | 0) - 1) | 0), 1 - (time - frameTime) / (frames[((frame + Spine.PathConstraintPositionTimeline.PREV_TIME) | 0)] - frameTime));

                    spacing += (frames[((frame + Spine.PathConstraintPositionTimeline.VALUE) | 0)] - spacing) * percent;
                }

                if (blend === Spine.MixBlend.Setup) {
                    constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;
                } else {
                    constraint.spacing += (spacing - constraint.spacing) * alpha;
                }
            },
            /*Spine.PathConstraintSpacingTimeline.Apply end.*/


        }
    });
    /*Spine.PathConstraintSpacingTimeline end.*/

    /*Spine.ScaleTimeline start.*/
    
    Bridge.define("Spine.ScaleTimeline", {
        inherits: [Spine.TranslateTimeline,Spine.IBoneTimeline],
        props: {
            PropertyId: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ScaleTimeline#PropertyId#get", this ); }

                    return (((33554432) + this.boneIndex) | 0);
                }
            }
        },
        alias: [
            "PropertyId", "Spine$Timeline$PropertyId",
            "Apply", "Spine$Timeline$Apply"
        ],
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.ScaleTimeline#ctor", this ); }

                this.$initialize();
                Spine.TranslateTimeline.ctor.call(this, frameCount);
            }
        },
        methods: {
            /*Spine.ScaleTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.ScaleTimeline#Apply", this ); }

                var $t;
                var bone = ($t = skeleton.bones.Items)[this.boneIndex];
                if (!bone.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) { // Time is before first frame.
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            bone.scaleX = bone.data.scaleX;
                            bone.scaleY = bone.data.scaleY;
                            return;
                        case Spine.MixBlend.First: 
                            bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;
                            bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;
                            return;
                    }
                    return;
                }

                var x, y;
                if (time >= frames[((frames.length - Spine.TranslateTimeline.ENTRIES) | 0)]) { // Time is after last frame.
                    x = frames[((frames.length + Spine.TranslateTimeline.PREV_X) | 0)] * bone.data.scaleX;
                    y = frames[((frames.length + Spine.TranslateTimeline.PREV_Y) | 0)] * bone.data.scaleY;
                } else {
                    // Interpolate between the previous frame and the current frame.
                    var frame = Spine.Animation.BinarySearch$1(frames, time, Spine.TranslateTimeline.ENTRIES);
                    x = frames[((frame + Spine.TranslateTimeline.PREV_X) | 0)];
                    y = frames[((frame + Spine.TranslateTimeline.PREV_Y) | 0)];
                    var frameTime = frames[frame];
                    var percent = this.GetCurvePercent(((((Bridge.Int.div(frame, Spine.TranslateTimeline.ENTRIES)) | 0) - 1) | 0), 1 - (time - frameTime) / (frames[((frame + Spine.TranslateTimeline.PREV_TIME) | 0)] - frameTime));

                    x = (x + (frames[((frame + Spine.TranslateTimeline.X) | 0)] - x) * percent) * bone.data.scaleX;
                    y = (y + (frames[((frame + Spine.TranslateTimeline.Y) | 0)] - y) * percent) * bone.data.scaleY;
                }
                if (alpha === 1) {
                    if (blend === Spine.MixBlend.Add) {
                        bone.scaleX += x - bone.data.scaleX;
                        bone.scaleY += y - bone.data.scaleY;
                    } else {
                        bone.scaleX = x;
                        bone.scaleY = y;
                    }
                } else {
                    // Mixing out uses sign of setup or current pose, else use sign of key.
                    var bx, by;
                    if (direction === Spine.MixDirection.Out) {
                        switch (blend) {
                            case Spine.MixBlend.Setup: 
                                bx = bone.data.scaleX;
                                by = bone.data.scaleY;
                                bone.scaleX = bx + (Math.abs(x) * Bridge.Int.sign(bx) - bx) * alpha;
                                bone.scaleY = by + (Math.abs(y) * Bridge.Int.sign(by) - by) * alpha;
                                break;
                            case Spine.MixBlend.First: 
                            case Spine.MixBlend.Replace: 
                                bx = bone.scaleX;
                                by = bone.scaleY;
                                bone.scaleX = bx + (Math.abs(x) * Bridge.Int.sign(bx) - bx) * alpha;
                                bone.scaleY = by + (Math.abs(y) * Bridge.Int.sign(by) - by) * alpha;
                                break;
                            case Spine.MixBlend.Add: 
                                bx = bone.scaleX;
                                by = bone.scaleY;
                                bone.scaleX = bx + (Math.abs(x) * Bridge.Int.sign(bx) - bone.data.scaleX) * alpha;
                                bone.scaleY = by + (Math.abs(y) * Bridge.Int.sign(by) - bone.data.scaleY) * alpha;
                                break;
                        }
                    } else {
                        switch (blend) {
                            case Spine.MixBlend.Setup: 
                                bx = Math.abs(bone.data.scaleX) * Bridge.Int.sign(x);
                                by = Math.abs(bone.data.scaleY) * Bridge.Int.sign(y);
                                bone.scaleX = bx + (x - bx) * alpha;
                                bone.scaleY = by + (y - by) * alpha;
                                break;
                            case Spine.MixBlend.First: 
                            case Spine.MixBlend.Replace: 
                                bx = Math.abs(bone.scaleX) * Bridge.Int.sign(x);
                                by = Math.abs(bone.scaleY) * Bridge.Int.sign(y);
                                bone.scaleX = bx + (x - bx) * alpha;
                                bone.scaleY = by + (y - by) * alpha;
                                break;
                            case Spine.MixBlend.Add: 
                                bx = Bridge.Int.sign(x);
                                by = Bridge.Int.sign(y);
                                bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;
                                bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;
                                break;
                        }
                    }
                }
            },
            /*Spine.ScaleTimeline.Apply end.*/


        }
    });
    /*Spine.ScaleTimeline end.*/

    /*Spine.ShearTimeline start.*/
    /**
     * Changes a bone's local {@link } and {@link }.
     *
     * @public
     * @class Spine.ShearTimeline
     * @augments Spine.TranslateTimeline
     * @implements  Spine.IBoneTimeline
     */
    Bridge.define("Spine.ShearTimeline", {
        inherits: [Spine.TranslateTimeline,Spine.IBoneTimeline],
        props: {
            PropertyId: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ShearTimeline#PropertyId#get", this ); }

                    return (((50331648) + this.boneIndex) | 0);
                }
            }
        },
        alias: [
            "PropertyId", "Spine$Timeline$PropertyId",
            "Apply", "Spine$Timeline$Apply"
        ],
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.ShearTimeline#ctor", this ); }

                this.$initialize();
                Spine.TranslateTimeline.ctor.call(this, frameCount);
            }
        },
        methods: {
            /*Spine.ShearTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.ShearTimeline#Apply", this ); }

                var $t;
                var bone = ($t = skeleton.bones.Items)[this.boneIndex];
                if (!bone.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) { // Time is before first frame.
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            bone.shearX = bone.data.shearX;
                            bone.shearY = bone.data.shearY;
                            return;
                        case Spine.MixBlend.First: 
                            bone.shearX += (bone.data.shearX - bone.shearX) * alpha;
                            bone.shearY += (bone.data.shearY - bone.shearY) * alpha;
                            return;
                    }
                    return;
                }

                var x, y;
                if (time >= frames[((frames.length - Spine.TranslateTimeline.ENTRIES) | 0)]) { // Time is after last frame.
                    x = frames[((frames.length + Spine.TranslateTimeline.PREV_X) | 0)];
                    y = frames[((frames.length + Spine.TranslateTimeline.PREV_Y) | 0)];
                } else {
                    // Interpolate between the previous frame and the current frame.
                    var frame = Spine.Animation.BinarySearch$1(frames, time, Spine.TranslateTimeline.ENTRIES);
                    x = frames[((frame + Spine.TranslateTimeline.PREV_X) | 0)];
                    y = frames[((frame + Spine.TranslateTimeline.PREV_Y) | 0)];
                    var frameTime = frames[frame];
                    var percent = this.GetCurvePercent(((((Bridge.Int.div(frame, Spine.TranslateTimeline.ENTRIES)) | 0) - 1) | 0), 1 - (time - frameTime) / (frames[((frame + Spine.TranslateTimeline.PREV_TIME) | 0)] - frameTime));

                    x = x + (frames[((frame + Spine.TranslateTimeline.X) | 0)] - x) * percent;
                    y = y + (frames[((frame + Spine.TranslateTimeline.Y) | 0)] - y) * percent;
                }
                switch (blend) {
                    case Spine.MixBlend.Setup: 
                        bone.shearX = bone.data.shearX + x * alpha;
                        bone.shearY = bone.data.shearY + y * alpha;
                        break;
                    case Spine.MixBlend.First: 
                    case Spine.MixBlend.Replace: 
                        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;
                        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;
                        break;
                    case Spine.MixBlend.Add: 
                        bone.shearX += x * alpha;
                        bone.shearY += y * alpha;
                        break;
                }
            },
            /*Spine.ShearTimeline.Apply end.*/


        }
    });
    /*Spine.ShearTimeline end.*/

    if ( MODULE_reflection ) {
    var $m = Bridge.setMetadata,
        $n = ["System","UnityEngine","UnityEngine.EventSystems","UnityEngine.UI","Water2D","System.Collections.Generic","System.Collections","UnityEngine.Events","SharpJson","Spine","System.IO","Spine.Collections","Spine.Unity","UnityEngine.U2D","UnityEngine.Rendering","Spine.Unity.AttachmentTools","Spine.Unity.Deprecated","UnityEngine.Audio","DG.Tweening.Core","DG.Tweening","DG.Tweening.Plugins.Core.PathCore","System.Globalization","DG.Tweening.Plugins.Options"];

    /*ButtonBeverage start.*/
    $m("ButtonBeverage", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"EffectOnClick","t":8,"sn":"EffectOnClick","rt":$n[0].Void},{"a":2,"n":"OnClick","t":8,"sn":"OnClick","rt":$n[0].Void},{"a":2,"n":"typeBeverage","t":4,"rt":TypeBeverage,"sn":"typeBeverage","box":function ($v) { return Bridge.box($v, TypeBeverage, System.Enum.toStringFn(TypeBeverage));}}]}; }, $n);
    /*ButtonBeverage end.*/

    /*DrinkMaterial start.*/
    $m("DrinkMaterial", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"Destroying","t":8,"sn":"Destroying","rt":$n[0].Void},{"v":true,"a":3,"n":"FallsOutOfView","t":8,"sn":"FallsOutOfView","rt":$n[0].Void},{"a":1,"n":"IsInView","t":8,"sn":"IsInView","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"OnBecameInvisible","t":8,"sn":"OnBecameInvisible","rt":$n[0].Void},{"a":1,"n":"OnCollisionEnter2D","t":8,"pi":[{"n":"collision","pt":$n[1].Collision2D,"ps":0}],"sn":"OnCollisionEnter2D","rt":$n[0].Void,"p":[$n[1].Collision2D]},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"v":true,"a":3,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"PlaySound","t":8,"pi":[{"n":"collision","pt":$n[1].Collision2D,"ps":0}],"sn":"PlaySound","rt":$n[0].Void,"p":[$n[1].Collision2D]},{"a":2,"n":"Set","t":8,"pi":[{"n":"scale","pt":$n[0].Single,"ps":0}],"sn":"Set","rt":$n[0].Void,"p":[$n[0].Single]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"AllowCollisionWithWater","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_AllowCollisionWithWater","t":8,"rt":$n[0].Boolean,"fg":"AllowCollisionWithWater","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_AllowCollisionWithWater","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"AllowCollisionWithWater"},"fn":"AllowCollisionWithWater"},{"a":2,"n":"Rb","t":16,"rt":$n[1].Rigidbody2D,"g":{"a":2,"n":"get_Rb","t":8,"rt":$n[1].Rigidbody2D,"fg":"Rb"},"fn":"Rb"},{"a":1,"n":"GlassLayer","is":true,"t":4,"rt":$n[0].Int32,"sn":"GlassLayer","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"IceLayer","is":true,"t":4,"rt":$n[0].Int32,"sn":"IceLayer","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"ToppingsLayer","is":true,"t":4,"rt":$n[0].Int32,"sn":"ToppingsLayer","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"WaterLayer","is":true,"t":4,"rt":$n[0].Int32,"sn":"WaterLayer","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"__Property__Initializer__AllowCollisionWithWater","t":4,"rt":$n[0].Boolean,"sn":"__Property__Initializer__AllowCollisionWithWater","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"currentHeight","t":4,"rt":$n[0].Int32,"sn":"currentHeight","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"currentWidth","t":4,"rt":$n[0].Int32,"sn":"currentWidth","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"isCollided","t":4,"rt":$n[0].Boolean,"sn":"isCollided","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"isNeverInView","t":4,"rt":$n[0].Boolean,"sn":"isNeverInView","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"isRectTransformNull","t":4,"rt":$n[0].Boolean,"sn":"isRectTransformNull","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"rb","t":4,"rt":$n[1].Rigidbody2D,"sn":"rb"},{"a":1,"n":"rectTransform","t":4,"rt":$n[1].RectTransform,"sn":"rectTransform"},{"a":1,"backing":true,"n":"<AllowCollisionWithWater>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"AllowCollisionWithWater","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*DrinkMaterial end.*/

    /*Faucet start.*/
    $m("Faucet", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"Clean","t":8,"sn":"Clean","rt":$n[0].Void},{"a":1,"n":"OnPointerDown","t":8,"pi":[{"n":"arg0","pt":$n[2].BaseEventData,"ps":0}],"sn":"OnPointerDown","rt":$n[0].Void,"p":[$n[2].BaseEventData]},{"a":1,"n":"OnPointerUp","t":8,"pi":[{"n":"arg0","pt":$n[2].BaseEventData,"ps":0}],"sn":"OnPointerUp","rt":$n[0].Void,"p":[$n[2].BaseEventData]},{"a":1,"n":"OnValidate","t":8,"sn":"OnValidate","rt":$n[0].Void},{"a":2,"n":"SetColor","t":8,"pi":[{"n":"color","pt":$n[1].Color,"ps":0}],"sn":"SetColor","rt":$n[0].Void,"p":[$n[1].Color]},{"a":2,"n":"Spawn","t":8,"sn":"Spawn","rt":$n[0].Void},{"a":2,"n":"StopSpawning","t":8,"sn":"StopSpawning","rt":$n[0].Void},{"a":2,"n":"Color","t":16,"rt":$n[1].Color,"g":{"a":2,"n":"get_Color","t":8,"rt":$n[1].Color,"fg":"Color"},"fn":"Color"},{"a":2,"n":"particleCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_particleCount","t":8,"rt":$n[0].Int32,"fg":"particleCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"particleCount"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"color","t":4,"rt":$n[1].Color,"sn":"color"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"eventTrigger","t":4,"rt":$n[2].EventTrigger,"sn":"eventTrigger"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"image","t":4,"rt":$n[3].Image,"sn":"image"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"spawner","t":4,"rt":$n[4].Water2D_Spawner,"sn":"spawner"}]}; }, $n);
    /*Faucet end.*/

    /*FaucetManager start.*/
    $m("FaucetManager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"Clean","t":8,"sn":"Clean","rt":$n[0].Void},{"a":1,"n":"CreateFaucetWithAmount","t":8,"pi":[{"n":"count","pt":$n[0].Int32,"ps":0}],"sn":"CreateFaucetWithAmount","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"SetColors","t":8,"pi":[{"n":"colors","ip":true,"pt":System.Array.type(UnityEngine.Color),"ps":0}],"sn":"SetColors","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Color)]},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":2,"n":"CanvasGroup","t":16,"rt":$n[1].CanvasGroup,"g":{"a":2,"n":"get_CanvasGroup","t":8,"rt":$n[1].CanvasGroup,"fg":"CanvasGroup"},"s":{"a":1,"n":"set_CanvasGroup","t":8,"p":[$n[1].CanvasGroup],"rt":$n[0].Void,"fs":"CanvasGroup"},"fn":"CanvasGroup"},{"a":2,"n":"Faucets","t":16,"rt":$n[5].List$1(Faucet),"g":{"a":2,"n":"get_Faucets","t":8,"rt":$n[5].List$1(Faucet),"fg":"Faucets"},"fn":"Faucets"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"faucetPrefab","t":4,"rt":Faucet,"sn":"faucetPrefab"},{"a":1,"n":"faucets","t":4,"rt":$n[5].List$1(Faucet),"sn":"faucets"},{"a":1,"backing":true,"n":"<CanvasGroup>k__BackingField","t":4,"rt":$n[1].CanvasGroup,"sn":"CanvasGroup"}]}; }, $n);
    /*FaucetManager end.*/

    /*Glass start.*/
    $m("Glass", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"v":true,"a":2,"n":"SetUp","t":8,"sn":"SetUp","rt":$n[0].Void},{"v":true,"a":2,"n":"TearDown","t":8,"sn":"TearDown","rt":$n[0].Void}]}; }, $n);
    /*Glass end.*/

    /*Ice start.*/
    $m("Ice", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.Rigidbody2D),new UnityEngine.RequireComponent.ctor(UnityEngine.BoxCollider2D)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"GetDistance","t":8,"pi":[{"n":"colliderCount","pt":$n[0].Int32,"ps":0}],"sn":"GetDistance","rt":$n[0].Single,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"OnDrawGizmosSelected","t":8,"sn":"OnDrawGizmosSelected","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"OnValidate","t":8,"sn":"OnValidate","rt":$n[0].Void},{"a":1,"n":"gravityDirection","t":16,"rt":$n[1].Vector2,"g":{"a":1,"n":"get_gravityDirection","t":8,"rt":$n[1].Vector2,"fg":"gravityDirection"},"fn":"gravityDirection"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"buoyancyForce","t":4,"rt":$n[0].Single,"sn":"buoyancyForce","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"collider2Ds","t":4,"rt":System.Array.type(UnityEngine.Collider2D),"sn":"collider2Ds","ro":true},{"a":1,"n":"contactFilter2D","t":4,"rt":$n[1].ContactFilter2D,"sn":"contactFilter2D","ro":true},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"feetOffset","t":4,"rt":$n[1].Vector2,"sn":"feetOffset"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"image","t":4,"rt":$n[3].Image,"sn":"image"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"lerpDistance","t":4,"rt":$n[0].Single,"sn":"lerpDistance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"maxVelocityY","t":4,"rt":$n[0].Single,"sn":"maxVelocityY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"size","t":4,"rt":$n[1].Vector2,"sn":"size"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"sprites","t":4,"rt":System.Array.type(UnityEngine.Sprite),"sn":"sprites"}]}; }, $n);
    /*Ice end.*/

    /*Liquid start.*/
    $m("Liquid", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":3,"n":"FallsOutOfView","t":8,"sn":"FallsOutOfView","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"OnTriggerEnter2D","t":8,"pi":[{"n":"other","pt":$n[1].Collider2D,"ps":0}],"sn":"OnTriggerEnter2D","rt":$n[0].Void,"p":[$n[1].Collider2D]},{"a":1,"n":"OnValidate","t":8,"sn":"OnValidate","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"collider2d","t":4,"rt":$n[1].Collider2D,"sn":"collider2d"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"collider2dLiquid","t":4,"rt":$n[1].Collider2D,"sn":"collider2dLiquid"},{"a":2,"n":"defaultColor","is":true,"t":4,"rt":$n[1].Color,"sn":"defaultColor","ro":true},{"a":1,"n":"firstHit","t":4,"rt":$n[0].Boolean,"sn":"firstHit","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"metaballParticleClass","t":4,"rt":MetaballParticleClass,"sn":"metaballParticleClass"}]}; }, $n);
    /*Liquid end.*/

    /*LunaPool start.*/
    $m("LunaPool", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"Despawn","t":8,"pi":[{"n":"obj","pt":$n[1].GameObject,"ps":0}],"sn":"Despawn","rt":$n[0].Void,"p":[$n[1].GameObject]},{"a":2,"n":"Spawn","t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0},{"n":"position","pt":$n[1].Vector3,"ps":1},{"n":"rotation","pt":$n[1].Quaternion,"ps":2}],"sn":"Spawn","rt":$n[1].GameObject,"p":[$n[1].GameObject,$n[1].Vector3,$n[1].Quaternion]},{"a":2,"n":"Instance","is":true,"t":16,"rt":LunaPool,"g":{"a":2,"n":"get_Instance","t":8,"rt":LunaPool,"fg":"Instance","is":true},"s":{"a":1,"n":"set_Instance","t":8,"p":[LunaPool],"rt":$n[0].Void,"fs":"Instance","is":true},"fn":"Instance"},{"a":1,"n":"POOL_SIZE","is":true,"t":4,"rt":$n[0].Int32,"sn":"POOL_SIZE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"pooledObjects","t":4,"rt":$n[5].Dictionary$2(UnityEngine.GameObject,System.Collections.Generic.Queue$1(UnityEngine.GameObject)),"sn":"pooledObjects"},{"a":1,"backing":true,"n":"<Instance>k__BackingField","is":true,"t":4,"rt":LunaPool,"sn":"Instance"}]}; }, $n);
    /*LunaPool end.*/

    /*TypeBeverage start.*/
    $m("TypeBeverage", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Coca","is":true,"t":4,"rt":TypeBeverage,"sn":"Coca","box":function ($v) { return Bridge.box($v, TypeBeverage, System.Enum.toStringFn(TypeBeverage));}},{"a":2,"n":"Lemon","is":true,"t":4,"rt":TypeBeverage,"sn":"Lemon","box":function ($v) { return Bridge.box($v, TypeBeverage, System.Enum.toStringFn(TypeBeverage));}},{"a":2,"n":"MilkTea","is":true,"t":4,"rt":TypeBeverage,"sn":"MilkTea","box":function ($v) { return Bridge.box($v, TypeBeverage, System.Enum.toStringFn(TypeBeverage));}}]}; }, $n);
    /*TypeBeverage end.*/

    /*ElementTopping start.*/
    $m("ElementTopping", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"number","t":4,"rt":$n[0].Int32,"sn":"number","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"prefebTopping","t":4,"rt":$n[1].GameObject,"sn":"prefebTopping"}]}; }, $n);
    /*ElementTopping end.*/

    /*Ingredient start.*/
    $m("Ingredient", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"glass","t":4,"rt":Glass,"sn":"glass"},{"a":2,"n":"lstTopping","t":4,"rt":$n[5].List$1(ElementTopping),"sn":"lstTopping"},{"a":2,"n":"timeFillTopping","t":4,"rt":$n[0].Single,"sn":"timeFillTopping","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"timeFillWater","t":4,"rt":$n[0].Single,"sn":"timeFillWater","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"typeBeverage","t":4,"rt":TypeBeverage,"sn":"typeBeverage","box":function ($v) { return Bridge.box($v, TypeBeverage, System.Enum.toStringFn(TypeBeverage));}},{"a":2,"n":"waterColor","t":4,"rt":$n[1].Color,"sn":"waterColor"}]}; }, $n);
    /*Ingredient end.*/

    /*GameManager1 start.*/
    $m("GameManager1", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"CheckShowEndcard","t":8,"sn":"CheckShowEndcard","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"InitBeverageToFill","t":8,"pi":[{"n":"i","pt":$n[0].Int32,"ps":0}],"sn":"InitBeverageToFill","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"InstallFullGame","t":8,"sn":"InstallFullGame","rt":$n[0].Void},{"a":2,"n":"OnClickBtnDrink","t":8,"sn":"OnClickBtnDrink","rt":$n[0].Void},{"a":2,"n":"OnFill","t":8,"pi":[{"n":"typeBeverage","pt":TypeBeverage,"ps":0}],"sn":"OnFill","rt":$n[0].Void,"p":[TypeBeverage]},{"a":2,"n":"ResetBeverage","t":8,"sn":"ResetBeverage","rt":$n[0].Void},{"a":2,"n":"SpawnTopping","t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0},{"n":"amount","pt":$n[0].Int32,"ps":1}],"sn":"SpawnTopping","rt":$n[6].IEnumerator,"p":[$n[1].GameObject,$n[0].Int32]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"StartDropTopping","t":8,"pi":[{"n":"i","pt":$n[0].Int32,"ps":0}],"sn":"StartDropTopping","rt":$n[6].IEnumerator,"p":[$n[0].Int32]},{"a":1,"n":"StartFill","t":8,"pi":[{"n":"i","pt":$n[0].Int32,"ps":0}],"sn":"StartFill","rt":$n[6].IEnumerator,"p":[$n[0].Int32]},{"a":1,"n":"StartFillGlass","t":8,"pi":[{"n":"i","pt":$n[0].Int32,"ps":0}],"sn":"StartFillGlass","rt":$n[6].IEnumerator,"p":[$n[0].Int32]},{"a":2,"n":"btnAll","t":4,"rt":$n[1].GameObject,"sn":"btnAll"},{"a":2,"n":"btnDrink","t":4,"rt":$n[1].GameObject,"sn":"btnDrink"},{"a":1,"n":"canSpawn","t":4,"rt":$n[0].Boolean,"sn":"canSpawn","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"count","t":4,"rt":$n[0].Int32,"sn":"count","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"currentIndexBeverage","t":4,"rt":$n[0].Int32,"sn":"currentIndexBeverage","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"endGame","t":4,"rt":$n[0].Boolean,"sn":"endGame","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"faucet","t":4,"rt":Faucet,"sn":"faucet"},{"a":1,"n":"firstTouch","t":4,"rt":$n[0].Boolean,"sn":"firstTouch","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"guide","t":4,"rt":$n[1].GameObject,"sn":"guide"},{"a":2,"n":"lstIngredient","t":4,"rt":$n[5].List$1(Ingredient),"sn":"lstIngredient"},{"a":2,"n":"panelChoose","t":4,"rt":$n[1].GameObject,"sn":"panelChoose"},{"a":2,"n":"toppingHolder","t":4,"rt":$n[1].GameObject,"sn":"toppingHolder"}]}; }, $n);
    /*GameManager1 end.*/

    /*GameManager2 start.*/
    $m("GameManager2", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"FillGlass","t":8,"sn":"FillGlass","rt":$n[6].IEnumerator},{"a":2,"n":"InstallFullGame","t":8,"sn":"InstallFullGame","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"StartFillGlass","t":8,"pi":[{"n":"i","pt":$n[0].Int32,"ps":0},{"n":"timeFillWater","pt":$n[0].Single,"ps":1}],"sn":"StartFillGlass","rt":$n[6].IEnumerator,"p":[$n[0].Int32,$n[0].Single]},{"a":1,"n":"faucet","t":4,"rt":Faucet,"sn":"faucet"},{"a":1,"n":"faucet1","t":4,"rt":Faucet,"sn":"faucet1"},{"a":1,"n":"faucet2","t":4,"rt":Faucet,"sn":"faucet2"},{"a":2,"n":"lstFaucet","t":4,"rt":$n[5].List$1(Faucet),"sn":"lstFaucet"}]}; }, $n);
    /*GameManager2 end.*/

    /*AudioConfig start.*/
    $m("AudioConfig", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"audioSource","t":4,"rt":$n[1].AudioSource,"sn":"audioSource"},{"a":2,"n":"clip","t":4,"rt":$n[1].AudioClip,"sn":"clip"},{"a":2,"n":"keySound","t":4,"rt":$n[0].String,"sn":"keySound"},{"at":[new UnityEngine.RangeAttribute(0.0, 1.0)],"a":2,"n":"volume","t":4,"rt":$n[0].Single,"sn":"volume","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*AudioConfig end.*/

    /*SoundManager start.*/
    $m("SoundManager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"PlaySound","t":8,"pi":[{"n":"i","pt":$n[0].Int32,"ps":0}],"sn":"PlaySound","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"audioConfigs","t":4,"rt":$n[5].List$1(AudioConfig),"sn":"audioConfigs"},{"a":2,"n":"pouring","t":4,"rt":$n[1].AudioSource,"sn":"pouring"}]}; }, $n);
    /*SoundManager end.*/

    /*TypeDestroy start.*/
    $m("TypeDestroy", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"DESTROY","is":true,"t":4,"rt":TypeDestroy,"sn":"DESTROY","box":function ($v) { return Bridge.box($v, TypeDestroy, System.Enum.toStringFn(TypeDestroy));}},{"a":2,"n":"DISABLE","is":true,"t":4,"rt":TypeDestroy,"sn":"DISABLE","box":function ($v) { return Bridge.box($v, TypeDestroy, System.Enum.toStringFn(TypeDestroy));}},{"a":2,"n":"RESPAWNER","is":true,"t":4,"rt":TypeDestroy,"sn":"RESPAWNER","box":function ($v) { return Bridge.box($v, TypeDestroy, System.Enum.toStringFn(TypeDestroy));}}]}; }, $n);
    /*TypeDestroy end.*/

    /*AutoDestroy start.*/
    $m("AutoDestroy", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":2,"n":"timeOut","t":4,"rt":$n[0].Single,"sn":"timeOut","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"timeStart","t":4,"rt":$n[0].Single,"sn":"timeStart","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"typeDestroy","t":4,"rt":TypeDestroy,"sn":"typeDestroy","box":function ($v) { return Bridge.box($v, TypeDestroy, System.Enum.toStringFn(TypeDestroy));}}]}; }, $n);
    /*AutoDestroy end.*/

    /*AutoDestructor start.*/
    $m("AutoDestructor", function () { return {"nested":[AutoDestructor.TypeDestroy],"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AutoDestroy","t":8,"sn":"AutoDestroy","rt":$n[0].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isPutToPool","t":4,"rt":$n[0].Boolean,"sn":"isPutToPool","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"timeDestroy","t":4,"rt":$n[0].Single,"sn":"timeDestroy","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"typeDestroy","t":4,"rt":AutoDestructor.TypeDestroy,"sn":"typeDestroy","box":function ($v) { return Bridge.box($v, AutoDestructor.TypeDestroy, System.Enum.toStringFn(AutoDestructor.TypeDestroy));}}]}; }, $n);
    /*AutoDestructor end.*/

    /*AutoDestructor+TypeDestroy start.*/
    $m("AutoDestructor.TypeDestroy", function () { return {"td":AutoDestructor,"att":259,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Destroy","is":true,"t":4,"rt":AutoDestructor.TypeDestroy,"sn":"Destroy","box":function ($v) { return Bridge.box($v, AutoDestructor.TypeDestroy, System.Enum.toStringFn(AutoDestructor.TypeDestroy));}},{"a":2,"n":"Disable","is":true,"t":4,"rt":AutoDestructor.TypeDestroy,"sn":"Disable","box":function ($v) { return Bridge.box($v, AutoDestructor.TypeDestroy, System.Enum.toStringFn(AutoDestructor.TypeDestroy));}},{"a":2,"n":"PutToPool","is":true,"t":4,"rt":AutoDestructor.TypeDestroy,"sn":"PutToPool","box":function ($v) { return Bridge.box($v, AutoDestructor.TypeDestroy, System.Enum.toStringFn(AutoDestructor.TypeDestroy));}}]}; }, $n);
    /*AutoDestructor+TypeDestroy end.*/

    /*Difficult start.*/
    $m("Difficult", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"EASY","is":true,"t":4,"rt":Difficult,"sn":"EASY","box":function ($v) { return Bridge.box($v, Difficult, System.Enum.toStringFn(Difficult));}},{"a":2,"n":"HARD","is":true,"t":4,"rt":Difficult,"sn":"HARD","box":function ($v) { return Bridge.box($v, Difficult, System.Enum.toStringFn(Difficult));}},{"a":2,"n":"NORMAL","is":true,"t":4,"rt":Difficult,"sn":"NORMAL","box":function ($v) { return Bridge.box($v, Difficult, System.Enum.toStringFn(Difficult));}}]}; }, $n);
    /*Difficult end.*/

    /*DefineHelper start.*/
    $m("DefineHelper", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Attack","is":true,"t":4,"rt":$n[0].String,"sn":"Attack"},{"a":2,"n":"Dead","is":true,"t":4,"rt":$n[0].String,"sn":"Dead"},{"a":2,"n":"Moving","is":true,"t":4,"rt":$n[0].String,"sn":"Moving"}]}; }, $n);
    /*DefineHelper end.*/

    /*NameTag start.*/
    $m("NameTag", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"FakeGround","is":true,"t":4,"rt":$n[0].String,"sn":"FakeGround"},{"a":2,"n":"Player","is":true,"t":4,"rt":$n[0].String,"sn":"Player"}]}; }, $n);
    /*NameTag end.*/

    /*EventID start.*/
    $m("EventID", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"CheckMerge","is":true,"t":4,"rt":EventID,"sn":"CheckMerge","box":function ($v) { return Bridge.box($v, EventID, System.Enum.toStringFn(EventID));}},{"a":2,"n":"Destroy","is":true,"t":4,"rt":EventID,"sn":"Destroy","box":function ($v) { return Bridge.box($v, EventID, System.Enum.toStringFn(EventID));}},{"a":2,"n":"EndGame","is":true,"t":4,"rt":EventID,"sn":"EndGame","box":function ($v) { return Bridge.box($v, EventID, System.Enum.toStringFn(EventID));}}]}; }, $n);
    /*EventID end.*/

    /*EventDispatcher start.*/
    $m("EventDispatcher", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"ClearAllListener","t":8,"sn":"ClearAllListener","rt":$n[0].Void},{"a":2,"n":"HasInstance","is":true,"t":8,"sn":"HasInstance","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":2,"n":"PostEvent","t":8,"pi":[{"n":"eventID","pt":EventID,"ps":0},{"n":"param","dv":null,"o":true,"pt":$n[0].Object,"ps":1}],"sn":"PostEvent","rt":$n[0].Void,"p":[EventID,$n[0].Object]},{"a":2,"n":"RegisterListener","t":8,"pi":[{"n":"eventID","pt":EventID,"ps":0},{"n":"callback","pt":Function,"ps":1}],"sn":"RegisterListener","rt":$n[0].Void,"p":[EventID,Function]},{"a":2,"n":"RemoveListener","t":8,"pi":[{"n":"eventID","pt":EventID,"ps":0},{"n":"callback","pt":Function,"ps":1}],"sn":"RemoveListener","rt":$n[0].Void,"p":[EventID,Function]},{"a":2,"n":"Instance","is":true,"t":16,"rt":EventDispatcher,"g":{"a":2,"n":"get_Instance","t":8,"rt":EventDispatcher,"fg":"Instance","is":true},"s":{"a":1,"n":"set_Instance","t":8,"p":[EventDispatcher],"rt":$n[0].Void,"fs":"Instance","is":true},"fn":"Instance"},{"a":1,"n":"_listeners","t":4,"rt":$n[5].Dictionary$2(EventID,Function),"sn":"_listeners"},{"a":1,"n":"s_instance","is":true,"t":4,"rt":EventDispatcher,"sn":"s_instance"}]}; }, $n);
    /*EventDispatcher end.*/

    /*EventDispatcherExtension start.*/
    $m("EventDispatcherExtension", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"PostEvent","is":true,"t":8,"pi":[{"n":"sender","pt":$n[1].MonoBehaviour,"ps":0},{"n":"eventID","pt":EventID,"ps":1}],"sn":"PostEvent","rt":$n[0].Void,"p":[$n[1].MonoBehaviour,EventID]},{"a":2,"n":"PostEvent","is":true,"t":8,"pi":[{"n":"listener","pt":$n[1].MonoBehaviour,"ps":0},{"n":"eventID","pt":EventID,"ps":1},{"n":"param","pt":$n[0].Object,"ps":2}],"sn":"PostEvent$1","rt":$n[0].Void,"p":[$n[1].MonoBehaviour,EventID,$n[0].Object]},{"a":2,"n":"RegisterListener","is":true,"t":8,"pi":[{"n":"listener","pt":$n[1].MonoBehaviour,"ps":0},{"n":"eventID","pt":EventID,"ps":1},{"n":"callback","pt":Function,"ps":2}],"sn":"RegisterListener","rt":$n[0].Void,"p":[$n[1].MonoBehaviour,EventID,Function]},{"a":2,"n":"RemoveListener","is":true,"t":8,"pi":[{"n":"sender","pt":$n[1].MonoBehaviour,"ps":0},{"n":"eventID","pt":EventID,"ps":1},{"n":"callback","pt":Function,"ps":2}],"sn":"RemoveListener","rt":$n[0].Void,"p":[$n[1].MonoBehaviour,EventID,Function]}]}; }, $n);
    /*EventDispatcherExtension end.*/

    /*GlobalInstance start.*/
    $m("GlobalInstance", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"gameManager","t":4,"rt":GameManager1,"sn":"gameManager"}]}; }, $n);
    /*GlobalInstance end.*/

    /*HelperUtility start.*/
    $m("HelperUtility", function () { return {"nested":[Function],"att":1048961,"a":2,"s":true,"m":[{"a":1,"n":"CountCornersVisibleFrom","is":true,"t":8,"pi":[{"n":"rectTransform","pt":$n[1].RectTransform,"ps":0},{"n":"camera","pt":$n[1].Camera,"ps":1}],"sn":"CountCornersVisibleFrom","rt":$n[0].Int32,"p":[$n[1].RectTransform,$n[1].Camera],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOLocalRotateQuaternion","is":true,"t":8,"pi":[{"n":"endValue","pt":$n[1].Quaternion,"ps":0},{"n":"speedRotate","pt":$n[0].Single,"ps":1},{"n":"objLookAt","pt":$n[1].GameObject,"ps":2},{"n":"actionComplete","pt":Function,"ps":3}],"sn":"DOLocalRotateQuaternion","rt":$n[6].IEnumerator,"p":[$n[1].Quaternion,$n[0].Single,$n[1].GameObject,Function]},{"a":2,"n":"DecimalRounding","is":true,"t":8,"pi":[{"n":"Num","pt":$n[0].Single,"ps":0},{"n":"Round","pt":$n[0].Int32,"ps":1}],"sn":"DecimalRounding","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"DisruptiveArrayObject","is":true,"t":8,"pi":[{"n":"array","pt":System.Array.type(System.Object),"ps":0}],"tpc":1,"tprm":["T"],"sn":"DisruptiveArrayObject","rt":System.Array.type(System.Object),"p":[System.Array.type(System.Object)]},{"a":2,"n":"DisruptiveList","is":true,"t":8,"pi":[{"n":"array","pt":$n[5].List$1(System.Object),"ps":0}],"tpc":1,"tprm":["T"],"sn":"DisruptiveList","rt":$n[5].List$1(System.Object),"p":[$n[5].List$1(System.Object)]},{"a":2,"n":"DisruptiveListObject","is":true,"t":8,"pi":[{"n":"array","pt":$n[5].List$1(System.Object),"ps":0}],"sn":"DisruptiveListObject$1","rt":$n[5].List$1(System.Object),"p":[$n[5].List$1(System.Object)]},{"a":2,"n":"DisruptiveListObject","is":true,"t":8,"pi":[{"n":"array","pt":$n[5].List$1(System.Object),"ps":0}],"tpc":1,"tprm":["T"],"sn":"DisruptiveListObject","rt":$n[5].List$1(System.Object),"p":[$n[5].List$1(System.Object)]},{"a":2,"n":"DisruptiveListSelf","is":true,"t":8,"pi":[{"n":"array","pt":$n[5].List$1(System.Object),"ps":0}],"tpc":1,"tprm":["T"],"sn":"DisruptiveListSelf","rt":$n[5].List$1(System.Object),"p":[$n[5].List$1(System.Object)]},{"a":2,"n":"GetDirectionFromAngle","is":true,"t":8,"pi":[{"n":"vectorP","pt":$n[1].Vector3,"ps":0},{"n":"angle","pt":$n[0].Single,"ps":1},{"n":"positionStart","pt":$n[1].Vector3,"ps":2}],"sn":"GetDirectionFromAngle","rt":$n[1].Vector3,"p":[$n[1].Vector3,$n[0].Single,$n[1].Vector3]},{"a":2,"n":"GetDirectionFromAngle_2","is":true,"t":8,"pi":[{"n":"vectorP","pt":$n[1].Vector3,"ps":0},{"n":"angle","pt":$n[0].Single,"ps":1},{"n":"positionStart","pt":$n[1].Vector3,"ps":2}],"sn":"GetDirectionFromAngle_2","rt":$n[1].Vector3,"p":[$n[1].Vector3,$n[0].Single,$n[1].Vector3]},{"a":2,"n":"GetPointDistanceFromObject","is":true,"t":8,"pi":[{"n":"distance","pt":$n[0].Single,"ps":0},{"n":"direction","pt":$n[1].Vector3,"ps":1},{"n":"fromPoint","pt":$n[1].Vector3,"ps":2}],"sn":"GetPointDistanceFromObject","rt":$n[1].Vector3,"p":[$n[0].Single,$n[1].Vector3,$n[1].Vector3]},{"a":2,"n":"GetRandom","is":true,"t":8,"pi":[{"n":"deck","pt":System.Array.type(System.Object),"ps":0}],"tpc":1,"tprm":["T"],"sn":"GetRandom","rt":System.Object,"p":[System.Array.type(System.Object)]},{"a":2,"n":"GetRotateDirection","is":true,"t":8,"pi":[{"n":"from","pt":$n[1].Quaternion,"ps":0},{"n":"to","pt":$n[1].Quaternion,"ps":1}],"sn":"GetRotateDirection","rt":$n[0].Boolean,"p":[$n[1].Quaternion,$n[1].Quaternion],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsEmpty","is":true,"t":8,"pi":[{"n":"deck","pt":System.Array.type(System.Object),"ps":0}],"tpc":1,"tprm":["T"],"sn":"IsEmpty","rt":$n[0].Boolean,"p":[System.Array.type(System.Object)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsVisibleFrom","is":true,"t":8,"pi":[{"n":"rectTransform","pt":$n[1].RectTransform,"ps":0},{"n":"camera","pt":$n[1].Camera,"ps":1}],"sn":"IsVisibleFrom","rt":$n[0].Boolean,"p":[$n[1].RectTransform,$n[1].Camera],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"LookAtToDirection","is":true,"t":8,"pi":[{"n":"diretion","pt":$n[1].Vector3,"ps":0},{"n":"objLookAt","pt":$n[1].GameObject,"ps":1},{"n":"speedLockAt","dv":500.0,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"LookAtToDirection","rt":$n[0].Void,"p":[$n[1].Vector3,$n[1].GameObject,$n[0].Single]},{"a":2,"n":"LookAtToDirectionAngleDetal","is":true,"t":8,"pi":[{"n":"diretion","pt":$n[1].Vector3,"ps":0},{"n":"objLookAt","pt":$n[1].GameObject,"ps":1},{"n":"AngleDetal","pt":$n[0].Single,"ps":2},{"n":"speedLockAt","dv":500.0,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"LookAtToDirectionAngleDetal","rt":$n[0].Void,"p":[$n[1].Vector3,$n[1].GameObject,$n[0].Single,$n[0].Single]},{"a":2,"n":"LookAtToPosition","is":true,"t":8,"pi":[{"n":"position","pt":$n[1].Vector3,"ps":0},{"n":"objLookAt","pt":$n[1].GameObject,"ps":1},{"n":"speedRotate","dv":500.0,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"LookAtToPosition","rt":$n[0].Void,"p":[$n[1].Vector3,$n[1].GameObject,$n[0].Single]},{"a":2,"n":"LookAtToPositionAngleDetal","is":true,"t":8,"pi":[{"n":"position","pt":$n[1].Vector3,"ps":0},{"n":"objLookAt","pt":$n[1].GameObject,"ps":1},{"n":"AngleDetal","pt":$n[0].Single,"ps":2},{"n":"speedRotate","dv":500.0,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"LookAtToPositionAngleDetal","rt":$n[0].Void,"p":[$n[1].Vector3,$n[1].GameObject,$n[0].Single,$n[0].Single]},{"a":1,"n":"PosHandle","is":true,"t":8,"pi":[{"n":"numCount","pt":$n[0].Int32,"ps":0},{"n":"MaxERow","pt":$n[0].Int32,"ps":1}],"sn":"PosHandle","rt":$n[5].List$1(System.Int32),"p":[$n[0].Int32,$n[0].Int32]},{"a":2,"n":"RandomCustom","is":true,"t":8,"pi":[{"n":"first","pt":$n[0].Int32,"ps":0},{"n":"last","pt":$n[0].Int32,"ps":1},{"n":"diff","pt":$n[5].List$1(System.Int32),"ps":2}],"sn":"RandomCustom","rt":$n[0].Int32,"p":[$n[0].Int32,$n[0].Int32,$n[5].List$1(System.Int32)],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"RandomUnduplicated","is":true,"t":8,"pi":[{"n":"diff","pt":$n[5].List$1(System.Int32),"ps":0},{"n":"oldValues","ip":true,"pt":$n[0].Array.type(System.Int32),"ps":1}],"sn":"RandomUnduplicated","rt":$n[0].Int32,"p":[$n[5].List$1(System.Int32),$n[0].Array.type(System.Int32)],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"RandomUnduplicated","is":true,"t":8,"pi":[{"n":"oldValue","pt":$n[0].Int32,"ps":0},{"n":"diff","pt":$n[5].List$1(System.Int32),"ps":1}],"sn":"RandomUnduplicated$1","rt":$n[0].Int32,"p":[$n[0].Int32,$n[5].List$1(System.Int32)],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"SelectionSortList","is":true,"t":8,"pi":[{"n":"A","pt":$n[5].List$1(System.Object),"ps":0},{"n":"compareElementList","pt":Function,"ps":1}],"sn":"SelectionSortList","rt":$n[5].List$1(System.Object),"p":[$n[5].List$1(System.Object),Function]},{"a":2,"n":"SetPos","is":true,"t":8,"pi":[{"n":"numCount","pt":$n[0].Int32,"ps":0},{"n":"MaxERow","pt":$n[0].Int32,"ps":1}],"sn":"SetPos","rt":$n[5].List$1(System.Int32),"p":[$n[0].Int32,$n[0].Int32]},{"a":2,"n":"StartAction","is":true,"t":8,"pi":[{"n":"action","pt":Function,"ps":0},{"n":"condition","pt":Function,"ps":1}],"sn":"StartAction","rt":$n[6].IEnumerator,"p":[Function,Function]},{"a":2,"n":"StartAction","is":true,"t":8,"pi":[{"n":"action","pt":Function,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1}],"sn":"StartAction$1","rt":$n[6].IEnumerator,"p":[Function,$n[0].Single]},{"a":2,"n":"StartActionNotUseCorutines","is":true,"t":8,"pi":[{"n":"action","pt":Function,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1}],"sn":"StartActionNotUseCorutines","rt":$n[0].Void,"p":[Function,$n[0].Single]},{"a":2,"n":"StartActionRealTime","is":true,"t":8,"pi":[{"n":"action","pt":Function,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1}],"sn":"StartActionRealTime","rt":$n[6].IEnumerator,"p":[Function,$n[0].Single]},{"a":2,"n":"StartThread","is":true,"t":8,"pi":[{"n":"action","pt":Function,"ps":0},{"n":"timeToStop","pt":$n[0].Single,"ps":1},{"n":"actionStop","dv":null,"o":true,"pt":Function,"ps":2}],"sn":"StartThread$1","rt":$n[6].IEnumerator,"p":[Function,$n[0].Single,Function]},{"a":2,"n":"StartThread","is":true,"t":8,"pi":[{"n":"action","pt":Function,"ps":0},{"n":"conditionStop","pt":Function,"ps":1},{"n":"actionStop","dv":null,"o":true,"pt":Function,"ps":2},{"n":"time","dv":0.01,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"StartThread","rt":$n[6].IEnumerator,"p":[Function,Function,Function,$n[0].Single]}]}; }, $n);
    /*HelperUtility end.*/

    /*SelfDefine start.*/
    $m("SelfDefine", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*SelfDefine end.*/

    /*MMMaths start.*/
    $m("MMMaths", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"Approach","is":true,"t":8,"pi":[{"n":"from","pt":$n[0].Single,"ps":0},{"n":"to","pt":$n[0].Single,"ps":1},{"n":"amount","pt":$n[0].Single,"ps":2}],"sn":"Approach","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Chance","is":true,"t":8,"pi":[{"n":"percent","pt":$n[0].Int32,"ps":0}],"sn":"Chance","rt":$n[0].Boolean,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"RandomVector3","is":true,"t":8,"pi":[{"n":"minimum","pt":$n[1].Vector3,"ps":0},{"n":"maximum","pt":$n[1].Vector3,"ps":1}],"sn":"RandomVector3","rt":$n[1].Vector3,"p":[$n[1].Vector3,$n[1].Vector3]},{"a":2,"n":"RollADice","is":true,"t":8,"pi":[{"n":"numberOfSides","pt":$n[0].Int32,"ps":0}],"sn":"RollADice","rt":$n[0].Int32,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"RotatePointAroundPivot","is":true,"t":8,"pi":[{"n":"point","pt":$n[1].Vector3,"ps":0},{"n":"pivot","pt":$n[1].Vector3,"ps":1},{"n":"angle","pt":$n[0].Single,"ps":2}],"sn":"RotatePointAroundPivot","rt":$n[1].Vector3,"p":[$n[1].Vector3,$n[1].Vector3,$n[0].Single]},{"a":2,"n":"RotatePointAroundPivot","is":true,"t":8,"pi":[{"n":"point","pt":$n[1].Vector3,"ps":0},{"n":"pivot","pt":$n[1].Vector3,"ps":1},{"n":"angle","pt":$n[1].Vector3,"ps":2}],"sn":"RotatePointAroundPivot$1","rt":$n[1].Vector3,"p":[$n[1].Vector3,$n[1].Vector3,$n[1].Vector3]},{"a":2,"n":"Sum","is":true,"t":8,"pi":[{"n":"thingsToAdd","ip":true,"pt":$n[0].Array.type(System.Int32),"ps":0}],"sn":"Sum","rt":$n[0].Int32,"p":[$n[0].Array.type(System.Int32)],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"Vector2ToVector3","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Vector2,"ps":0}],"sn":"Vector2ToVector3","rt":$n[1].Vector3,"p":[$n[1].Vector2]},{"a":2,"n":"Vector2ToVector3","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Vector2,"ps":0},{"n":"newZValue","pt":$n[0].Single,"ps":1}],"sn":"Vector2ToVector3$1","rt":$n[1].Vector3,"p":[$n[1].Vector2,$n[0].Single]},{"a":2,"n":"Vector3ToVector2","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Vector3,"ps":0}],"sn":"Vector3ToVector2","rt":$n[1].Vector2,"p":[$n[1].Vector3]}]}; }, $n);
    /*MMMaths end.*/

    /*RotateObject start.*/
    $m("RotateObject", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"angle","t":4,"rt":$n[0].Single,"sn":"angle","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"duration","t":4,"rt":$n[0].Single,"sn":"duration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*RotateObject end.*/

    /*SimplePool start.*/
    $m("SimplePool", function () { return {"nested":[SimplePool.Pool],"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"ClearPool","is":true,"t":8,"sn":"ClearPool","rt":$n[0].Void},{"a":2,"n":"Despawn","is":true,"t":8,"pi":[{"n":"obj","pt":$n[1].GameObject,"ps":0}],"sn":"Despawn","rt":$n[0].Void,"p":[$n[1].GameObject]},{"a":2,"n":"GetStackCount","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0}],"sn":"GetStackCount","rt":$n[0].Int32,"p":[$n[1].GameObject],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"Init","is":true,"t":8,"pi":[{"n":"prefab","dv":null,"o":true,"pt":$n[1].GameObject,"ps":0},{"n":"qty","dv":3,"o":true,"pt":$n[0].Int32,"ps":1}],"sn":"Init","rt":$n[0].Void,"p":[$n[1].GameObject,$n[0].Int32]},{"a":2,"n":"PoolPreLoad","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0},{"n":"qty","pt":$n[0].Int32,"ps":1},{"n":"newParent","dv":null,"o":true,"pt":$n[1].Transform,"ps":2}],"sn":"PoolPreLoad","rt":$n[0].Void,"p":[$n[1].GameObject,$n[0].Int32,$n[1].Transform]},{"a":2,"n":"Preload","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0},{"n":"qty","dv":1,"o":true,"pt":$n[0].Int32,"ps":1},{"n":"newParent","dv":null,"o":true,"pt":$n[1].Transform,"ps":2}],"sn":"Preload","rt":System.Array.type(UnityEngine.GameObject),"p":[$n[1].GameObject,$n[0].Int32,$n[1].Transform]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0}],"tpc":1,"tprm":["T"],"sn":"Spawn","rt":System.Object,"p":[System.Object]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0}],"sn":"Spawn$2","rt":$n[1].GameObject,"p":[$n[1].GameObject]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0},{"n":"pos","pt":$n[1].Vector3,"ps":1},{"n":"rot","pt":$n[1].Quaternion,"ps":2}],"tpc":1,"tprm":["T"],"sn":"Spawn$1","rt":System.Object,"p":[System.Object,$n[1].Vector3,$n[1].Quaternion]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0},{"n":"pos","pt":$n[1].Vector3,"ps":1},{"n":"rot","pt":$n[1].Quaternion,"ps":2}],"sn":"Spawn$3","rt":$n[1].GameObject,"p":[$n[1].GameObject,$n[1].Vector3,$n[1].Quaternion]},{"a":1,"n":"DEFAULT_POOL_SIZE","is":true,"t":4,"rt":$n[0].Int32,"sn":"DEFAULT_POOL_SIZE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"_pools","is":true,"t":4,"rt":$n[5].Dictionary$2(System.Int32,SimplePool.Pool),"sn":"_pools"}]}; }, $n);
    /*SimplePool end.*/

    /*SimplePool+Pool start.*/
    $m("SimplePool.Pool", function () { return {"td":SimplePool,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[1].GameObject,$n[0].Int32],"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0},{"n":"initialQty","pt":$n[0].Int32,"ps":1}],"sn":"ctor"},{"a":2,"n":"Despawn","t":8,"pi":[{"n":"obj","pt":$n[1].GameObject,"ps":0}],"sn":"Despawn","rt":$n[0].Void,"p":[$n[1].GameObject]},{"a":2,"n":"Preload","t":8,"pi":[{"n":"initialQty","pt":$n[0].Int32,"ps":0},{"n":"parent","dv":null,"o":true,"pt":$n[1].Transform,"ps":1}],"sn":"Preload","rt":$n[0].Void,"p":[$n[0].Int32,$n[1].Transform]},{"a":2,"n":"Spawn","t":8,"pi":[{"n":"pos","pt":$n[1].Vector3,"ps":0},{"n":"rot","pt":$n[1].Quaternion,"ps":1}],"tpc":1,"tprm":["T"],"sn":"Spawn","rt":System.Object,"p":[$n[1].Vector3,$n[1].Quaternion]},{"a":2,"n":"Spawn","t":8,"pi":[{"n":"pos","pt":$n[1].Vector3,"ps":0},{"n":"rot","pt":$n[1].Quaternion,"ps":1}],"sn":"Spawn$1","rt":$n[1].GameObject,"p":[$n[1].Vector3,$n[1].Quaternion]},{"a":2,"n":"StackCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_StackCount","t":8,"rt":$n[0].Int32,"fg":"StackCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"StackCount"},{"a":2,"n":"MemberIDs","t":4,"rt":$n[5].HashSet$1(System.Int32),"sn":"MemberIDs","ro":true},{"a":1,"n":"_inactive","t":4,"rt":$n[5].Queue$1(UnityEngine.GameObject),"sn":"_inactive","ro":true},{"a":1,"n":"_nextId","t":4,"rt":$n[0].Int32,"sn":"_nextId","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"_prefab","t":4,"rt":$n[1].GameObject,"sn":"_prefab","ro":true}]}; }, $n);
    /*SimplePool+Pool end.*/

    /*SingletonWithouMono$1 start.*/
    $m("SingletonWithouMono$1", function (T) { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"v":true,"a":3,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"v":true,"a":2,"n":"Preload","t":8,"sn":"Preload","rt":$n[0].Void},{"a":2,"n":"Instance","is":true,"t":16,"rt":T,"g":{"a":2,"n":"get_Instance","t":8,"rt":T,"fg":"Instance","is":true},"fn":"Instance"},{"a":1,"n":"initialized","t":4,"rt":$n[0].Boolean,"sn":"initialized","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"instance","is":true,"t":4,"rt":T,"sn":"instance"}]}; }, $n);
    /*SingletonWithouMono$1 end.*/

    /*SingletonMono$1 start.*/
    $m("SingletonMono$1", function (T) { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"v":true,"a":3,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":3,"n":"instance","is":true,"t":4,"rt":T,"sn":"instance"}]}; }, $n);
    /*SingletonMono$1 end.*/

    /*Singleton$1 start.*/
    $m("Singleton$1", function (T) { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Instance","is":true,"t":16,"rt":T,"g":{"a":2,"n":"get_Instance","t":8,"rt":T,"fg":"Instance","is":true},"fn":"Instance"}]}; }, $n);
    /*Singleton$1 end.*/

    /*SingletonDontDestroyOnLoad$1 start.*/
    $m("SingletonDontDestroyOnLoad$1", function (T) { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":3,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void}]}; }, $n);
    /*SingletonDontDestroyOnLoad$1 end.*/

    /*VectorUlti start.*/
    $m("VectorUlti", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"GetAngleFromVector","is":true,"t":8,"pi":[{"n":"dir","pt":$n[1].Vector3,"ps":0}],"sn":"GetAngleFromVector","rt":$n[0].Single,"p":[$n[1].Vector3],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GetVectorFromAngle","is":true,"t":8,"pi":[{"n":"angle","pt":$n[0].Single,"ps":0}],"sn":"GetVectorFromAngle","rt":$n[1].Vector3,"p":[$n[0].Single]},{"a":2,"n":"Move","is":true,"t":8,"pi":[{"n":"vector3","pt":$n[1].Vector3,"ps":0},{"n":"direction","pt":$n[1].Vector3,"ps":1}],"sn":"Move","rt":$n[1].Vector3,"p":[$n[1].Vector3,$n[1].Vector3]},{"a":2,"n":"Set","is":true,"t":8,"pi":[{"n":"vector2","pt":$n[1].Vector2,"ps":0},{"n":"x","dv":null,"o":true,"pt":$n[0].Nullable$1(System.Single),"ps":1},{"n":"y","dv":null,"o":true,"pt":$n[0].Nullable$1(System.Single),"ps":2}],"sn":"Set","rt":$n[1].Vector2,"p":[$n[1].Vector2,$n[0].Nullable$1(System.Single),$n[0].Nullable$1(System.Single)]},{"a":2,"n":"Set","is":true,"t":8,"pi":[{"n":"vector3","pt":$n[1].Vector3,"ps":0},{"n":"x","dv":null,"o":true,"pt":$n[0].Nullable$1(System.Single),"ps":1},{"n":"y","dv":null,"o":true,"pt":$n[0].Nullable$1(System.Single),"ps":2},{"n":"z","dv":null,"o":true,"pt":$n[0].Nullable$1(System.Single),"ps":3}],"sn":"Set$1","rt":$n[1].Vector3,"p":[$n[1].Vector3,$n[0].Nullable$1(System.Single),$n[0].Nullable$1(System.Single),$n[0].Nullable$1(System.Single)]},{"a":2,"n":"ToVectorXZ","is":true,"t":8,"pi":[{"n":"vector3","pt":$n[1].Vector3,"ps":0}],"sn":"ToVectorXZ","rt":$n[1].Vector2,"p":[$n[1].Vector3]}]}; }, $n);
    /*VectorUlti end.*/

    /*MetaballParticleClass start.*/
    $m("MetaballParticleClass", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteInEditModeAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AnimInEditor","t":8,"sn":"AnimInEditor","rt":$n[0].Void},{"a":1,"n":"Blend","t":8,"sn":"Blend","rt":$n[0].Void},{"a":1,"n":"Blend2","t":8,"sn":"Blend2","rt":$n[0].Void},{"a":2,"n":"GetFreeze","t":8,"sn":"GetFreeze","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"OnCollisionEnter2D","t":8,"pi":[{"n":"collision","pt":$n[1].Collision2D,"ps":0}],"sn":"OnCollisionEnter2D","rt":$n[0].Void,"p":[$n[1].Collision2D]},{"a":1,"n":"OnCollisionEnter2DEditor","t":8,"sn":"OnCollisionEnter2DEditor","rt":$n[0].Void},{"a":1,"n":"ScaleDownPerform","t":8,"sn":"ScaleDownPerform","rt":$n[0].Void},{"a":1,"n":"ScaleItDown","t":8,"sn":"ScaleItDown","rt":$n[0].Void},{"a":2,"n":"SetColor","t":8,"pi":[{"n":"_color","pt":$n[1].Color,"ps":0}],"sn":"SetColor","rt":$n[0].Void,"p":[$n[1].Color]},{"a":2,"n":"SetFreeze","t":8,"pi":[{"n":"_val","dv":true,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"SetFreeze","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"SetHighDensity","t":8,"pi":[{"n":"_val","dv":true,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"SetHighDensity","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"VelocityLimiter","t":8,"sn":"VelocityLimiter","rt":$n[0].Void},{"a":2,"n":"removeGlow","t":8,"sn":"removeGlow","rt":$n[0].Void},{"a":2,"n":"Active","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Active","t":8,"rt":$n[0].Boolean,"fg":"Active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Active","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Active"},"fn":"Active"},{"a":2,"n":"BlendingColor","t":4,"rt":$n[0].Boolean,"sn":"BlendingColor","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"Contacts","t":4,"rt":System.Array.type(UnityEngine.Collider2D),"sn":"Contacts"},{"a":2,"n":"Editor_Velocity","t":4,"rt":$n[1].Vector2,"sn":"Editor_Velocity"},{"a":2,"n":"LifeTime","t":4,"rt":$n[0].Single,"sn":"LifeTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"MObject","t":4,"rt":$n[1].GameObject,"sn":"MObject"},{"a":2,"n":"ScaleDown","t":4,"rt":$n[0].Boolean,"sn":"ScaleDown","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ScaleDownIsPerforming","t":4,"rt":$n[0].Boolean,"sn":"ScaleDownIsPerforming","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SpawnerParent","t":4,"rt":$n[4].Water2D_Spawner,"sn":"SpawnerParent"},{"a":2,"n":"Velocity_Limiter_X","t":4,"rt":$n[1].Vector2,"sn":"Velocity_Limiter_X"},{"a":2,"n":"Velocity_Limiter_Y","t":4,"rt":$n[1].Vector2,"sn":"Velocity_Limiter_Y"},{"a":1,"n":"_active","t":4,"rt":$n[0].Boolean,"sn":"_active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_isFreeze","t":4,"rt":$n[0].Boolean,"sn":"_isFreeze","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"breathFrames","t":4,"rt":$n[0].Int32,"sn":"breathFrames","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"cc","t":4,"rt":$n[1].CircleCollider2D,"sn":"cc"},{"a":1,"n":"delta","t":4,"rt":$n[0].Single,"sn":"delta","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"deltaScale","t":4,"rt":$n[1].Vector2,"sn":"deltaScale"},{"a":1,"n":"deltaSimul","t":4,"rt":$n[0].Single,"sn":"deltaSimul","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"endSize","t":4,"rt":$n[0].Single,"sn":"endSize","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"fixedDeltaSimul","t":4,"rt":$n[0].Single,"sn":"fixedDeltaSimul","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"framesCount","t":4,"rt":$n[0].Int32,"sn":"framesCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"glowSP","t":4,"rt":$n[1].SpriteRenderer,"sn":"glowSP"},{"a":1,"n":"initScale","t":4,"rt":$n[1].Vector2,"sn":"initScale"},{"a":1,"n":"pos_aux","t":4,"rt":$n[1].Vector3,"sn":"pos_aux"},{"a":1,"n":"rb","t":4,"rt":$n[1].Rigidbody2D,"sn":"rb"},{"a":1,"n":"sr","t":4,"rt":$n[1].SpriteRenderer,"sn":"sr"},{"a":1,"n":"tmpScale","t":4,"rt":$n[1].Vector2,"sn":"tmpScale"},{"a":1,"n":"tr","t":4,"rt":$n[1].TrailRenderer,"sn":"tr"},{"a":1,"n":"wakeUpTime","t":4,"rt":$n[0].Single,"sn":"wakeUpTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"witinTarget","t":4,"rt":$n[0].Boolean,"sn":"witinTarget","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*MetaballParticleClass end.*/

    /*ResizeQuadEffectController start.*/
    $m("ResizeQuadEffectController", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AboutToRebuildAll","t":8,"sn":"AboutToRebuildAll","rt":$n[0].Void},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"RebuildRenderTexturesAll","t":8,"sn":"RebuildRenderTexturesAll","rt":$n[0].Void},{"a":2,"n":"RebuildTextures","is":true,"t":8,"pi":[{"n":"flipTex","dv":-1,"o":true,"pt":$n[0].Int32,"ps":0}],"sn":"RebuildTextures","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"SetSorting","t":8,"pi":[{"n":"id","dv":0,"o":true,"pt":$n[0].Int32,"ps":0}],"sn":"SetSorting","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"FlipTexture","t":4,"rt":$n[0].Boolean,"sn":"FlipTexture","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"backTex2d","t":4,"rt":$n[1].RenderTexture,"sn":"backTex2d"},{"a":1,"n":"backgroundCamera","t":4,"rt":$n[1].GameObject,"sn":"backgroundCamera"},{"a":1,"n":"currentHeight","t":4,"rt":$n[0].Int32,"sn":"currentHeight","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"currentWidth","t":4,"rt":$n[0].Int32,"sn":"currentWidth","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"effectCam","t":4,"rt":$n[1].Camera,"sn":"effectCam"},{"a":1,"n":"effectCamera","t":4,"rt":$n[1].GameObject,"sn":"effectCamera"},{"a":1,"n":"effectTex2d","t":4,"rt":$n[1].Texture,"sn":"effectTex2d"},{"a":1,"n":"height","t":4,"rt":$n[0].Int32,"sn":"height","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"instance","is":true,"t":4,"rt":ResizeQuadEffectController,"sn":"instance"},{"a":2,"n":"isHorizontalScreen","t":4,"rt":$n[0].Boolean,"sn":"isHorizontalScreen","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"sorting","t":4,"rt":$n[0].Int32,"sn":"sorting","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"width","t":4,"rt":$n[0].Int32,"sn":"width","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*ResizeQuadEffectController end.*/

    /*ApplyPhysicsForceManager start.*/
    $m("ApplyPhysicsForceManager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ApplyForceToBody","t":8,"pi":[{"n":"g1","pt":$n[1].GameObject,"ps":0},{"n":"g2","pt":$n[1].GameObject,"ps":1}],"sn":"ApplyForceToBody","rt":$n[0].Void,"p":[$n[1].GameObject,$n[1].GameObject]},{"a":1,"n":"PlaySoundLoopEnum","t":8,"sn":"PlaySoundLoopEnum","rt":$n[6].IEnumerator},{"a":2,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"canPlay","t":4,"rt":$n[0].Boolean,"sn":"canPlay","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"fx","t":4,"rt":System.Array.type(UnityEngine.AudioSource),"sn":"fx"},{"a":1,"n":"initPOs","t":4,"rt":$n[1].Vector3,"sn":"initPOs"},{"a":2,"n":"jet1","t":4,"rt":$n[4].Water2D_Spawner,"sn":"jet1"},{"a":2,"n":"jet2","t":4,"rt":$n[4].Water2D_Spawner,"sn":"jet2"},{"a":2,"n":"rb","t":4,"rt":$n[1].Rigidbody2D,"sn":"rb"}]}; }, $n);
    /*ApplyPhysicsForceManager end.*/

    /*DeleteParticles start.*/
    $m("DeleteParticles", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnCollisionEnter2D","t":8,"pi":[{"n":"col","pt":$n[1].Collision2D,"ps":0}],"sn":"OnCollisionEnter2D","rt":$n[0].Void,"p":[$n[1].Collision2D]}]}; }, $n);
    /*DeleteParticles end.*/

    /*LavaColorPicker start.*/
    $m("LavaColorPicker", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[6].IEnumerator},{"a":1,"n":"getColor","t":8,"sn":"getColor","rt":$n[1].Color},{"a":2,"n":"Colors","t":4,"rt":System.Array.type(UnityEngine.Color),"sn":"Colors"},{"a":2,"n":"Spawner","t":4,"rt":$n[4].Water2D_Spawner,"sn":"Spawner"}]}; }, $n);
    /*LavaColorPicker end.*/

    /*LavaEvents start.*/
    $m("LavaEvents", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"OnCollideLava","t":8,"pi":[{"n":"p1","pt":$n[1].GameObject,"ps":0},{"n":"p2","pt":$n[1].GameObject,"ps":1}],"sn":"OnCollideLava","rt":$n[0].Void,"p":[$n[1].GameObject,$n[1].GameObject]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"feverMode","t":4,"rt":$n[0].Boolean,"sn":"feverMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"solidLavaMaterial","t":4,"rt":$n[1].PhysicsMaterial2D,"sn":"solidLavaMaterial"},{"a":2,"n":"steamP","t":4,"rt":System.Array.type(UnityEngine.ParticleSystem),"sn":"steamP"}]}; }, $n);
    /*LavaEvents end.*/

    /*Rotation start.*/
    $m("Rotation", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[6].IEnumerator},{"a":2,"n":"amount","t":4,"rt":$n[0].Single,"sn":"amount","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Rotation end.*/

    /*TransformToMouseDirection start.*/
    $m("TransformToMouseDirection", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"dir","t":4,"rt":$n[1].Vector3,"sn":"dir"},{"a":1,"n":"w2","t":4,"rt":$n[4].Water2D_Spawner,"sn":"w2"}]}; }, $n);
    /*TransformToMouseDirection end.*/

    /*ActionDispatcher start.*/
    $m("ActionDispatcher", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Scored","t":8,"pi":[{"n":"g1","pt":$n[1].GameObject,"ps":0},{"n":"g2","pt":$n[1].GameObject,"ps":1}],"sn":"Scored","rt":$n[0].Void,"p":[$n[1].GameObject,$n[1].GameObject]},{"a":2,"n":"TextScore","t":4,"rt":$n[1].TextMesh,"sn":"TextScore"},{"a":2,"n":"audio","t":4,"rt":$n[1].AudioSource,"sn":"audio"},{"a":2,"n":"confetti","t":4,"rt":$n[1].ParticleSystem,"sn":"confetti"},{"a":1,"n":"score","t":4,"rt":$n[0].Int32,"sn":"score","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*ActionDispatcher end.*/

    /*DecoratorManager start.*/
    $m("DecoratorManager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"Spawner","t":4,"rt":$n[4].Water2D_Spawner,"sn":"Spawner"},{"a":2,"n":"_colors","t":4,"rt":System.Array.type(UnityEngine.Color),"sn":"_colors"}]}; }, $n);
    /*DecoratorManager end.*/

    /*Mover start.*/
    $m("Mover", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":2,"n":"Plates","t":4,"rt":System.Array.type(UnityEngine.GameObject),"sn":"Plates"},{"a":1,"n":"pos","t":4,"rt":$n[1].Vector3,"sn":"pos"},{"a":1,"n":"speed_Amount","t":4,"rt":$n[0].Single,"sn":"speed_Amount","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"vel","t":4,"rt":$n[1].Vector3,"sn":"vel"}]}; }, $n);
    /*Mover end.*/

    /*DeleteTriggerBoundingBox start.*/
    $m("DeleteTriggerBoundingBox", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Delete","t":8,"pi":[{"n":"drop","pt":$n[1].GameObject,"ps":0},{"n":"another","pt":$n[1].GameObject,"ps":1}],"sn":"Delete","rt":$n[0].Void,"p":[$n[1].GameObject,$n[1].GameObject]},{"a":2,"n":"DeleteOnCollide","t":8,"pi":[{"n":"drop","pt":$n[1].GameObject,"ps":0},{"n":"other","pt":$n[1].GameObject,"ps":1}],"sn":"DeleteOnCollide","rt":$n[0].Void,"p":[$n[1].GameObject,$n[1].GameObject]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"SteamPS","t":4,"rt":System.Array.type(UnityEngine.ParticleSystem),"sn":"SteamPS"},{"a":1,"n":"c","t":4,"rt":$n[1].Color,"sn":"c"}]}; }, $n);
    /*DeleteTriggerBoundingBox end.*/

    /*PlaySoundOnEverySpawn start.*/
    $m("PlaySoundOnEverySpawn", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"PlaySound","t":8,"sn":"PlaySound","rt":$n[0].Void},{"a":2,"n":"sfx","t":4,"rt":$n[1].AudioSource,"sn":"sfx"}]}; }, $n);
    /*PlaySoundOnEverySpawn end.*/

    /*SimpleRotation start.*/
    $m("SimpleRotation", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"StartRotation","t":8,"sn":"StartRotation","rt":$n[0].Void},{"a":1,"n":"angle","t":4,"rt":$n[0].Single,"sn":"angle","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"canRotate","t":4,"rt":$n[0].Boolean,"sn":"canRotate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"deadFrames","t":4,"rt":$n[0].Int32,"sn":"deadFrames","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"deadFramesCount","t":4,"rt":$n[0].Int32,"sn":"deadFramesCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"rb","t":4,"rt":$n[1].Rigidbody2D,"sn":"rb"},{"a":2,"n":"water2d","t":4,"rt":$n[4].Water2D_Spawner,"sn":"water2d"},{"a":1,"n":"wise","t":4,"rt":$n[0].Single,"sn":"wise","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*SimpleRotation end.*/

    /*GeneratorController start.*/
    $m("GeneratorController", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"PrintResults","t":8,"pi":[{"n":"rpm","pt":$n[0].Single,"ps":0},{"n":"volts","pt":$n[0].Single,"ps":1}],"sn":"PrintResults","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"_c","t":4,"rt":$n[1].Color,"sn":"_c"},{"a":1,"n":"_frames","t":4,"rt":$n[0].Int32,"sn":"_frames","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"_speed","t":4,"rt":$n[0].Single,"sn":"_speed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"_text","t":4,"rt":$n[3].Text,"sn":"_text"},{"a":2,"n":"_text2","t":4,"rt":$n[3].Text,"sn":"_text2"},{"a":1,"n":"avgRpm","t":4,"rt":$n[0].Single,"sn":"avgRpm","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"avgVolts","t":4,"rt":$n[0].Single,"sn":"avgVolts","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"battery","t":4,"rt":$n[0].Single,"sn":"battery","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"currentLosesCoef","t":4,"rt":$n[0].Single,"sn":"currentLosesCoef","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"glow","t":4,"rt":$n[1].SpriteRenderer,"sn":"glow"},{"a":2,"n":"lamp","t":4,"rt":$n[1].SpriteRenderer,"sn":"lamp"},{"a":2,"n":"point","t":4,"rt":$n[1].Light,"sn":"point"},{"a":1,"n":"rb","t":4,"rt":$n[1].Rigidbody2D,"sn":"rb"},{"a":1,"n":"relaxFrames","t":4,"rt":$n[0].Int32,"sn":"relaxFrames","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"water2d","t":4,"rt":$n[4].Water2D_Spawner,"sn":"water2d"}]}; }, $n);
    /*GeneratorController end.*/

    /*MouseColliderController start.*/
    $m("MouseColliderController", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"col","t":4,"rt":$n[1].CircleCollider2D,"sn":"col"}]}; }, $n);
    /*MouseColliderController end.*/

    /*screenshot start.*/
    $m("screenshot", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteInEditModeAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"TakeAShot","t":4,"rt":$n[0].Boolean,"sn":"TakeAShot","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*screenshot end.*/

    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty start.*/
    $m("IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty end.*/

    /*Water2D.ColliderFiller start.*/
    $m("Water2D.ColliderFiller", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteInEditModeAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"at":[new UnityEngine.ContextMenu.ctor("Clear")],"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"at":[new UnityEngine.ContextMenu.ctor("Fill")],"a":2,"n":"Fill","t":8,"sn":"Fill","rt":$n[0].Void},{"a":1,"n":"FillByGrid","t":8,"pi":[{"n":"collider","pt":$n[1].Collider2D,"ps":0},{"n":"r","pt":$n[0].Single,"ps":1},{"n":"action","pt":Function,"ps":2},{"n":"zPos","dv":0.0,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"FillByGrid","rt":$n[0].Void,"p":[$n[1].Collider2D,$n[0].Single,Function,$n[0].Single]},{"a":2,"n":"GetBoxPoints","is":true,"t":8,"pi":[{"n":"box","pt":$n[1].BoxCollider2D,"ps":0}],"sn":"GetBoxPoints","rt":System.Array.type(UnityEngine.Vector2),"p":[$n[1].BoxCollider2D]},{"a":2,"n":"GetCirclePoints","is":true,"t":8,"pi":[{"n":"circle","pt":$n[1].CircleCollider2D,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1}],"sn":"GetCirclePoints","rt":System.Array.type(UnityEngine.Vector2),"p":[$n[1].CircleCollider2D,$n[0].Int32]},{"a":1,"n":"GetPointsInCollider","t":8,"pi":[{"n":"collider","pt":$n[1].Collider2D,"ps":0},{"n":"r","pt":$n[0].Single,"ps":1},{"n":"_pointsInside","out":true,"pt":System.Array.type(UnityEngine.Vector3),"ps":2},{"n":"_pointsOutside","out":true,"pt":System.Array.type(UnityEngine.Vector3),"ps":3},{"n":"zPos","dv":0.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"masked","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"GetPointsInCollider","rt":$n[0].Void,"p":[$n[1].Collider2D,$n[0].Single,System.Array.type(UnityEngine.Vector3),System.Array.type(UnityEngine.Vector3),$n[0].Single,$n[0].Boolean]},{"a":2,"n":"GetPolygonPoints","is":true,"t":8,"pi":[{"n":"polygon","pt":$n[1].PolygonCollider2D,"ps":0}],"sn":"GetPolygonPoints","rt":System.Array.type(UnityEngine.Vector2),"p":[$n[1].PolygonCollider2D]},{"a":2,"n":"IsPointInPolygon","is":true,"t":8,"pi":[{"n":"point","pt":$n[1].Vector2,"ps":0},{"n":"polygon","pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"masked","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"IsPointInPolygon","rt":$n[0].Boolean,"p":[$n[1].Vector2,System.Array.type(UnityEngine.Vector2),$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.ContextMenu.ctor("Refresh")],"a":2,"n":"Refresh","t":8,"sn":"Refresh","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"InsidePointsCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_InsidePointsCount","t":8,"rt":$n[0].Int32,"fg":"InsidePointsCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"InsidePointsCount"},{"a":2,"n":"OutsidePointsCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_OutsidePointsCount","t":8,"rt":$n[0].Int32,"fg":"OutsidePointsCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"OutsidePointsCount"},{"a":2,"n":"PointsInside","t":16,"rt":System.Array.type(UnityEngine.Vector3),"g":{"a":2,"n":"get_PointsInside","t":8,"rt":System.Array.type(UnityEngine.Vector3),"fg":"PointsInside"},"fn":"PointsInside"},{"a":2,"n":"PointsOutside","t":16,"rt":System.Array.type(UnityEngine.Vector3),"g":{"a":2,"n":"get_PointsOutside","t":8,"rt":System.Array.type(UnityEngine.Vector3),"fg":"PointsOutside"},"fn":"PointsOutside"},{"a":2,"n":"Radius","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Radius","t":8,"rt":$n[0].Single,"fg":"Radius","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"Radius"},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"Masked","t":4,"rt":$n[0].Boolean,"sn":"Masked","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_lastCollider","t":4,"rt":$n[1].Collider2D,"sn":"_lastCollider"},{"a":2,"n":"autoRefresh","t":4,"rt":$n[0].Boolean,"sn":"autoRefresh","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HideInInspector(),new UnityEngine.RangeAttribute(3.0, 100.0)],"a":2,"n":"circleDetailPoints","t":4,"rt":$n[0].Int32,"sn":"circleDetailPoints","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.HeaderAttribute("Main")],"a":2,"n":"collider","t":4,"rt":$n[1].Collider2D,"sn":"collider"},{"a":1,"n":"pointsInside","t":4,"rt":System.Array.type(UnityEngine.Vector3),"sn":"pointsInside"},{"a":1,"n":"pointsOutside","t":4,"rt":System.Array.type(UnityEngine.Vector3),"sn":"pointsOutside"},{"at":[new UnityEngine.HideInInspector(),new UnityEngine.TooltipAttribute("Water2DSpawner overlaps radius multiplying ColliderSize and Size"),new UnityEngine.RangeAttribute(0.05, 1.0)],"a":2,"n":"radius","t":4,"rt":$n[0].Single,"sn":"radius","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"water2D_Spawner","t":4,"rt":$n[4].Water2D_Spawner,"sn":"water2D_Spawner"}]}; }, $n);
    /*Water2D.ColliderFiller end.*/

    /*Water2D.MetaballCameraEffect start.*/
    $m("Water2D.MetaballCameraEffect", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteInEditModeAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"OnRenderImage","t":8,"pi":[{"n":"source","pt":$n[1].RenderTexture,"ps":0},{"n":"destination","pt":$n[1].RenderTexture,"ps":1}],"sn":"OnRenderImage","rt":$n[0].Void,"p":[$n[1].RenderTexture,$n[1].RenderTexture]},{"a":2,"n":"Restart","t":8,"sn":"Restart","rt":$n[0].Void},{"a":3,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"bgCamera","t":4,"rt":$n[1].Camera,"sn":"bgCamera"},{"a":1,"n":"bgTargetTexture","t":4,"rt":$n[1].RenderTexture,"sn":"bgTargetTexture"},{"a":1,"n":"buffer","t":4,"rt":$n[1].RenderTexture,"sn":"buffer"},{"a":2,"n":"cutOutMaterial","t":4,"rt":$n[1].Material,"sn":"cutOutMaterial"}]}; }, $n);
    /*Water2D.MetaballCameraEffect end.*/

    /*Water2D.SpawnersManager start.*/
    $m("Water2D.SpawnersManager", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteInEditModeAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ChangeSpawnerValues","is":true,"t":8,"pi":[{"n":"_spawner","pt":$n[4].Water2D_Spawner,"ps":0}],"sn":"ChangeSpawnerValues","rt":$n[0].Void,"p":[$n[4].Water2D_Spawner]},{"a":2,"n":"DeleteSpawnerValues","is":true,"t":8,"pi":[{"n":"_spawner","pt":$n[4].Water2D_Spawner,"ps":0}],"sn":"DeleteSpawnerValues","rt":$n[0].Void,"p":[$n[4].Water2D_Spawner]},{"a":2,"n":"GetAllParticles","is":true,"t":8,"sn":"GetAllParticles","rt":System.Array.type(MetaballParticleClass)},{"a":1,"n":"Initialize","is":true,"t":8,"pi":[{"n":"_c","pt":$n[1].Color,"ps":0}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[1].Color]},{"a":2,"n":"RegisterSpawner","is":true,"t":8,"pi":[{"n":"_spawner","pt":$n[4].Water2D_Spawner,"ps":0}],"sn":"RegisterSpawner","rt":$n[0].Void,"p":[$n[4].Water2D_Spawner]},{"a":2,"n":"SetFresnelColor","is":true,"t":8,"pi":[{"n":"StrokeColor","pt":$n[1].Color,"ps":0}],"sn":"SetFresnelColor","rt":$n[0].Void,"p":[$n[1].Color]},{"a":2,"n":"SetSorting","is":true,"t":8,"pi":[{"n":"sortingID","pt":$n[0].Int32,"ps":0}],"sn":"SetSorting","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"clearColorBuffers","t":8,"sn":"clearColorBuffers","rt":$n[0].Void},{"a":1,"n":"convertToarrayOfSize","t":8,"pi":[{"n":"_size","pt":$n[0].Int32,"ps":0},{"n":"_list","pt":$n[5].List$1(System.Single),"ps":1}],"sn":"convertToarrayOfSize","rt":$n[0].Array.type(System.Single),"p":[$n[0].Int32,$n[5].List$1(System.Single)]},{"a":1,"n":"convertToarrayOfSize","t":8,"pi":[{"n":"_size","pt":$n[0].Int32,"ps":0},{"n":"_list","pt":$n[5].List$1(UnityEngine.Color),"ps":1}],"sn":"convertToarrayOfSize$1","rt":System.Array.type(UnityEngine.Color),"p":[$n[0].Int32,$n[5].List$1(UnityEngine.Color)]},{"a":2,"n":"fetchAllParticles","t":8,"sn":"fetchAllParticles","rt":$n[0].Void},{"a":1,"n":"isCloseTo","t":8,"pi":[{"n":"value1","pt":$n[0].Single,"ps":0},{"n":"value2","pt":$n[0].Single,"ps":1},{"n":"threshold","pt":$n[0].Single,"ps":2}],"sn":"isCloseTo","rt":$n[0].Boolean,"p":[$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"reloadAllSpawners","t":8,"sn":"reloadAllSpawners","rt":$n[0].Void},{"a":1,"n":"setArraysToShader","t":8,"pi":[{"n":"mat","pt":$n[1].Material,"ps":0}],"sn":"setArraysToShader","rt":$n[0].Void,"p":[$n[1].Material]},{"a":1,"n":"setFloatToShader","t":8,"pi":[{"n":"f","pt":$n[0].Single,"ps":0},{"n":"mat","pt":$n[1].Material,"ps":1}],"sn":"setFloatToShader","rt":$n[0].Void,"p":[$n[0].Single,$n[1].Material]},{"a":2,"n":"CuttOffByID","t":4,"rt":$n[5].List$1(System.Single),"sn":"CuttOffByID"},{"a":2,"n":"FillColorByID","t":4,"rt":$n[5].List$1(UnityEngine.Color),"sn":"FillColorByID"},{"a":2,"n":"FresnelColorByID","t":4,"rt":$n[5].List$1(UnityEngine.Color),"sn":"FresnelColorByID"},{"a":2,"n":"LensSizeByID","t":4,"rt":$n[5].List$1(System.Single),"sn":"LensSizeByID"},{"a":2,"n":"MagnitudeByID","t":4,"rt":$n[5].List$1(System.Single),"sn":"MagnitudeByID"},{"a":2,"n":"MultiplierByID","t":4,"rt":$n[5].List$1(System.Single),"sn":"MultiplierByID"},{"a":2,"n":"SpeedByID","t":4,"rt":$n[5].List$1(System.Single),"sn":"SpeedByID"},{"a":2,"n":"StyleByID","t":4,"rt":$n[5].List$1(System.Single),"sn":"StyleByID"},{"a":2,"n":"_allparticles","t":4,"rt":System.Array.type(MetaballParticleClass),"sn":"_allparticles"},{"a":1,"n":"_arrayColors","t":4,"rt":System.Array.type(UnityEngine.Color),"sn":"_arrayColors"},{"a":1,"n":"_arrayCutOffStroke","t":4,"rt":$n[0].Array.type(System.Single),"sn":"_arrayCutOffStroke"},{"a":1,"n":"_arrayTexture2DColors","t":4,"rt":$n[1].Texture2D,"sn":"_arrayTexture2DColors"},{"a":1,"n":"_scene","is":true,"t":4,"rt":$n[0].String,"sn":"_scene"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"forceToClearColorBuffers","t":4,"rt":$n[0].Boolean,"sn":"forceToClearColorBuffers","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"fresnelCamera","t":4,"rt":$n[1].Camera,"sn":"fresnelCamera"},{"a":2,"n":"instance","is":true,"t":4,"rt":$n[4].SpawnersManager,"sn":"instance"},{"a":1,"n":"quadEffect","t":4,"rt":ResizeQuadEffectController,"sn":"quadEffect"},{"a":2,"n":"spawnersID","t":4,"rt":$n[5].List$1(System.Int32),"sn":"spawnersID"}]}; }, $n);
    /*Water2D.SpawnersManager end.*/

    /*Water2D.microSpawn start.*/
    $m("Water2D.microSpawn", function () { return {"att":1048841,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[1].Vector3,$n[0].Int32,$n[1].Vector2],"pi":[{"n":"pos","pt":$n[1].Vector3,"ps":0},{"n":"amount","pt":$n[0].Int32,"ps":1},{"n":"initVel","pt":$n[1].Vector2,"ps":2}],"sn":"$ctor1"},{"a":2,"n":"amount","t":4,"rt":$n[0].Int32,"sn":"amount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"initVel","t":4,"rt":$n[1].Vector2,"sn":"initVel"},{"a":2,"n":"pos","t":4,"rt":$n[1].Vector3,"sn":"pos"}]}; }, $n);
    /*Water2D.microSpawn end.*/

    /*Water2D.Water2D_Spawner start.*/
    $m("Water2D.Water2D_Spawner", function () { return {"nested":[$n[4].Water2D_Spawner.EmissionType,$n[4].Water2D_Spawner.FillerColliderType,$n[4].Water2D_Spawner.EnumTypes],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteInEditModeAttribute(),new SelectionBase()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"CallShapeFillValidationUpdate","t":8,"sn":"CallShapeFillValidationUpdate","rt":$n[0].Void},{"a":1,"n":"CheckOnFill","t":8,"pi":[{"n":"shapeCollider","pt":System.Array.type(UnityEngine.Collider2D),"ps":0},{"n":"accuracy","dv":0.8,"o":true,"pt":$n[0].Single,"ps":1}],"sn":"CheckOnFill","rt":$n[6].IEnumerator,"p":[System.Array.type(UnityEngine.Collider2D),$n[0].Single]},{"a":2,"n":"GetCurrentMaterial","t":8,"sn":"GetCurrentMaterial","rt":$n[1].Material},{"a":2,"n":"InvokeOnCollisionEnter2D","t":8,"pi":[{"n":"obj","pt":$n[1].GameObject,"ps":0},{"n":"other","pt":$n[1].GameObject,"ps":1}],"sn":"InvokeOnCollisionEnter2D","rt":$n[0].Void,"p":[$n[1].GameObject,$n[1].GameObject]},{"a":2,"n":"InvokeOnShapeFill","t":8,"pi":[{"n":"obj","pt":$n[1].GameObject,"ps":0},{"n":"results","pt":$n[1].GameObject,"ps":1}],"sn":"InvokeOnShapeFill","rt":$n[0].Void,"p":[$n[1].GameObject,$n[1].GameObject]},{"a":2,"n":"InvokeOnSpawnerEmittinEachParticle","t":8,"pi":[{"n":"obj","pt":$n[1].GameObject,"ps":0},{"n":"obj2","pt":$n[1].GameObject,"ps":1}],"sn":"InvokeOnSpawnerEmittinEachParticle","rt":$n[0].Void,"p":[$n[1].GameObject,$n[1].GameObject]},{"a":2,"n":"InvokeOnSpawnerEnd","t":8,"pi":[{"n":"obj","pt":$n[1].GameObject,"ps":0}],"sn":"InvokeOnSpawnerEnd","rt":$n[0].Void,"p":[$n[1].GameObject]},{"a":2,"n":"InvokeOnSpawnerStart","t":8,"pi":[{"n":"obj","pt":$n[1].GameObject,"ps":0}],"sn":"InvokeOnSpawnerStart","rt":$n[0].Void,"p":[$n[1].GameObject]},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":2,"n":"Restore","t":8,"sn":"Restore","rt":$n[0].Void},{"a":2,"n":"RestoreCheckingFillShape","t":8,"sn":"RestoreCheckingFillShape","rt":$n[0].Void},{"a":1,"n":"RunSpawner","t":8,"sn":"RunSpawner","rt":$n[0].Void},{"a":2,"n":"SetRegularWaterparams","t":8,"pi":[{"n":"fill","pt":$n[1].Color,"ps":0},{"n":"fresnel","pt":$n[1].Color,"ps":1},{"n":"alphaCutoff","pt":$n[0].Single,"ps":2},{"n":"multiplier","pt":$n[0].Single,"ps":3}],"sn":"SetRegularWaterparams","rt":$n[0].Void,"p":[$n[1].Color,$n[1].Color,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetupParticles","t":8,"sn":"SetupParticles","rt":$n[0].Void},{"a":2,"n":"Spawn","t":8,"sn":"Spawn","rt":$n[0].Void},{"a":2,"n":"Spawn","t":8,"pi":[{"n":"count","pt":$n[0].Int32,"ps":0}],"sn":"Spawn$1","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"Spawn","t":8,"pi":[{"n":"count","pt":$n[0].Int32,"ps":0},{"n":"pos","pt":$n[1].Vector3,"ps":1}],"sn":"Spawn$2","rt":$n[0].Void,"p":[$n[0].Int32,$n[1].Vector3]},{"a":2,"n":"Spawn","t":8,"pi":[{"n":"count","pt":$n[0].Int32,"ps":0},{"n":"pos","pt":$n[1].Vector3,"ps":1},{"n":"InitVelocity","pt":$n[1].Vector2,"ps":2},{"n":"delay","dv":0.0,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"Spawn$3","rt":$n[0].Void,"p":[$n[0].Int32,$n[1].Vector3,$n[1].Vector2,$n[0].Single]},{"a":2,"n":"SpawnAll","t":8,"sn":"SpawnAll","rt":$n[0].Void},{"a":1,"n":"SpawnAllParticles","t":8,"pi":[{"n":"_pos","pt":$n[1].Vector3,"ps":0},{"n":"_initSpeed","pt":$n[1].Vector2,"ps":1},{"n":"count","dv":-1,"o":true,"pt":$n[0].Int32,"ps":2},{"n":"delay","dv":0.0,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"SpawnAllParticles","rt":$n[0].Void,"p":[$n[1].Vector3,$n[1].Vector2,$n[0].Int32,$n[0].Single]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"StartCheckingFillShape","t":8,"sn":"StartCheckingFillShape","rt":$n[0].Void},{"a":1,"n":"StartEnumerator","t":8,"sn":"StartEnumerator","rt":$n[6].IEnumerator},{"a":1,"n":"StopSpawner","t":8,"sn":"StopSpawner","rt":$n[0].Void},{"a":2,"n":"StopSpawning","t":8,"sn":"StopSpawning","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"UpdateQuietParticleProperties","t":8,"sn":"UpdateQuietParticleProperties","rt":$n[6].IEnumerator},{"a":1,"n":"_restoreCheckingFillShapeEnum","t":8,"sn":"_restoreCheckingFillShapeEnum","rt":$n[6].IEnumerator},{"a":1,"n":"loop","t":8,"pi":[{"n":"_pos","pt":$n[1].Vector3,"ps":0},{"n":"_initSpeed","pt":$n[1].Vector2,"ps":1},{"n":"count","dv":-1,"o":true,"pt":$n[0].Int32,"ps":2},{"n":"delay","dv":0.0,"o":true,"pt":$n[0].Single,"ps":3},{"n":"waitBetweenDropSpawn","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"loop","rt":$n[6].IEnumerator,"p":[$n[1].Vector3,$n[1].Vector2,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":1,"n":"loop_editor","t":8,"pi":[{"n":"_pos","pt":$n[1].Vector3,"ps":0},{"n":"_initSpeed","pt":$n[1].Vector2,"ps":1},{"n":"count","dv":-1,"o":true,"pt":$n[0].Int32,"ps":2},{"n":"delay","dv":0.0,"o":true,"pt":$n[0].Single,"ps":3},{"n":"waitBetweenDropSpawn","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"loop_editor","rt":$n[0].Void,"p":[$n[1].Vector3,$n[1].Vector2,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"AllBallsCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_AllBallsCount","t":8,"rt":$n[0].Int32,"fg":"AllBallsCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":1,"n":"set_AllBallsCount","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"AllBallsCount"},"fn":"AllBallsCount"},{"a":2,"n":"IsSpawning","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsSpawning","t":8,"rt":$n[0].Boolean,"fg":"IsSpawning","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":1,"n":"set_IsSpawning","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"IsSpawning"},"fn":"IsSpawning"},{"a":2,"n":"AlphaCutOff","t":4,"rt":$n[0].Single,"sn":"AlphaCutOff","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"AlphaStroke","t":4,"rt":$n[0].Single,"sn":"AlphaStroke","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"AngularDrag","t":4,"rt":$n[0].Single,"sn":"AngularDrag","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Blending","t":4,"rt":$n[0].Boolean,"sn":"Blending","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"ColliderSize","t":4,"rt":$n[0].Single,"sn":"ColliderSize","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"ColorScheme","t":4,"rt":$n[0].Int32,"sn":"ColorScheme","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"DefaultCount","t":4,"rt":$n[0].Int32,"sn":"DefaultCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DelayBetweenParticles","t":4,"rt":$n[0].Single,"sn":"DelayBetweenParticles","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Distortion","t":4,"rt":$n[0].Single,"sn":"Distortion","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"DistortionSpeed","t":4,"rt":$n[0].Single,"sn":"DistortionSpeed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"DropCount","t":4,"rt":$n[0].Int32,"sn":"DropCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DropObject","t":4,"rt":$n[1].GameObject,"sn":"DropObject"},{"a":2,"n":"DropsUsed","t":4,"rt":$n[0].Int32,"sn":"DropsUsed","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DynamicChanges","t":4,"rt":$n[0].Boolean,"sn":"DynamicChanges","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"FillColor","t":4,"rt":$n[1].Color,"sn":"FillColor"},{"a":2,"n":"FillerColliderMasked","t":4,"rt":$n[0].Boolean,"sn":"FillerColliderMasked","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"FreezeRotation","t":4,"rt":$n[0].Boolean,"sn":"FreezeRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GlowColor","t":4,"rt":$n[1].Color,"sn":"GlowColor"},{"a":2,"n":"GlowEffect","t":4,"rt":$n[0].Boolean,"sn":"GlowEffect","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GlowSize","t":4,"rt":$n[0].Single,"sn":"GlowSize","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GlowSortingOrder","t":4,"rt":$n[0].Int32,"sn":"GlowSortingOrder","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"GravityScale","t":4,"rt":$n[0].Single,"sn":"GravityScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"HashID","t":4,"rt":$n[0].Int32,"sn":"HashID","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"Intensity","t":4,"rt":$n[0].Single,"sn":"Intensity","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"LensMag","t":4,"rt":$n[0].Single,"sn":"LensMag","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"LifeTime","t":4,"rt":$n[0].Single,"sn":"LifeTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"LinearDrag","t":4,"rt":$n[0].Single,"sn":"LinearDrag","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Loop","t":4,"rt":$n[0].Boolean,"sn":"Loop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"OnCollisionEnterList","t":4,"rt":$n[4].Water2DEvents,"sn":"OnCollisionEnterList"},{"a":2,"n":"OnSpawnerAboutEnd","t":4,"rt":$n[4].Water2DEvents,"sn":"OnSpawnerAboutEnd"},{"a":2,"n":"OnSpawnerAboutStart","t":4,"rt":$n[4].Water2DEvents,"sn":"OnSpawnerAboutStart"},{"a":2,"n":"OnSpawnerEmitingParticle","t":4,"rt":$n[4].Water2DEvents,"sn":"OnSpawnerEmitingParticle"},{"a":2,"n":"OnValidateShapeFill","t":4,"rt":$n[4].Water2DEvents,"sn":"OnValidateShapeFill"},{"a":2,"n":"ParticlesTag","t":4,"rt":$n[0].String,"sn":"ParticlesTag"},{"a":2,"n":"PersistentFluid","t":4,"rt":$n[0].Boolean,"sn":"PersistentFluid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"PhysicMat","t":4,"rt":$n[1].PhysicsMaterial2D,"sn":"PhysicMat"},{"a":2,"n":"ScaleDown","t":4,"rt":$n[0].Boolean,"sn":"ScaleDown","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"ShapeFillAccuracy","t":4,"rt":$n[0].Single,"sn":"ShapeFillAccuracy","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"ShapeFillCollider2D","t":4,"rt":System.Array.type(UnityEngine.Collider2D),"sn":"ShapeFillCollider2D"},{"a":2,"n":"ShapeFillCollider2DCount","t":4,"rt":$n[0].Int32,"sn":"ShapeFillCollider2DCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"SimulateInEditor","t":4,"rt":$n[0].Boolean,"sn":"SimulateInEditor","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SimulateInPlayMode","t":4,"rt":$n[0].Boolean,"sn":"SimulateInPlayMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SimulateOnAwake","t":4,"rt":$n[0].Boolean,"sn":"SimulateOnAwake","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Sorting","t":4,"rt":$n[0].Int32,"sn":"Sorting","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"Speed","t":4,"rt":$n[0].Single,"sn":"Speed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"SpeedLimiterX","t":4,"rt":$n[1].Vector2,"sn":"SpeedLimiterX"},{"a":2,"n":"SpeedLimiterY","t":4,"rt":$n[1].Vector2,"sn":"SpeedLimiterY"},{"a":2,"n":"StrokeColor","t":4,"rt":$n[1].Color,"sn":"StrokeColor"},{"a":2,"n":"StyleByID","t":4,"rt":$n[0].Boolean,"sn":"StyleByID","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"TintColor","t":4,"rt":$n[1].Color,"sn":"TintColor"},{"a":2,"n":"TrailDelay","t":4,"rt":$n[0].Single,"sn":"TrailDelay","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"TrailEndSize","t":4,"rt":$n[0].Single,"sn":"TrailEndSize","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"TrailStartSize","t":4,"rt":$n[0].Single,"sn":"TrailStartSize","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Water2DEmissionType","t":4,"rt":$n[4].Water2D_Spawner.EmissionType,"sn":"Water2DEmissionType","box":function ($v) { return Bridge.box($v, Water2D.Water2D_Spawner.EmissionType, System.Enum.toStringFn(Water2D.Water2D_Spawner.EmissionType));}},{"a":2,"n":"Water2DFillerType","t":4,"rt":$n[4].Water2D_Spawner.FillerColliderType,"sn":"Water2DFillerType","box":function ($v) { return Bridge.box($v, Water2D.Water2D_Spawner.FillerColliderType, System.Enum.toStringFn(Water2D.Water2D_Spawner.FillerColliderType));}},{"a":2,"n":"Water2DRenderType","t":4,"rt":$n[0].String,"sn":"Water2DRenderType"},{"a":2,"n":"Water2DType","t":4,"rt":$n[4].Water2D_Spawner.EnumTypes,"sn":"Water2DType","box":function ($v) { return Bridge.box($v, Water2D.Water2D_Spawner.EnumTypes, System.Enum.toStringFn(Water2D.Water2D_Spawner.EnumTypes));}},{"a":2,"n":"Water2DVersion","t":4,"rt":$n[0].String,"sn":"Water2DVersion"},{"a":2,"n":"WaterDropsObjects","t":4,"rt":System.Array.type(UnityEngine.GameObject),"sn":"WaterDropsObjects"},{"a":2,"n":"WaterMaterial","t":4,"rt":$n[1].Material,"sn":"WaterMaterial"},{"a":1,"n":"_breakCheckOnFill","t":4,"rt":$n[0].Boolean,"sn":"_breakCheckOnFill","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_breakLoop","t":4,"rt":$n[0].Boolean,"sn":"_breakLoop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_canInvokeAttheEnd","t":4,"rt":$n[0].Boolean,"sn":"_canInvokeAttheEnd","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_checkOnFillComplete","t":4,"rt":$n[0].Boolean,"sn":"_checkOnFillComplete","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_checkOnFillRunning","t":4,"rt":$n[0].Boolean,"sn":"_checkOnFillRunning","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"_lastBlending","t":4,"rt":$n[0].Boolean,"sn":"_lastBlending","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"_lastDropCount","t":4,"rt":$n[0].Int32,"sn":"_lastDropCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"_lastFillColor","t":4,"rt":$n[1].Color,"sn":"_lastFillColor"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"_lastGlowEnabledValue","t":4,"rt":$n[0].Boolean,"sn":"_lastGlowEnabledValue","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_lastSorting","t":4,"rt":$n[0].Int32,"sn":"_lastSorting","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"_lastStrokeColor","t":4,"rt":$n[1].Color,"sn":"_lastStrokeColor"},{"a":1,"n":"_parent","t":4,"rt":$n[1].GameObject,"sn":"_parent"},{"a":1,"n":"_parentNameID","t":4,"rt":$n[0].String,"sn":"_parentNameID"},{"a":1,"n":"_spawnedDrops","t":4,"rt":$n[0].Int32,"sn":"_spawnedDrops","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"fresnelCamera","t":4,"rt":$n[1].Camera,"sn":"fresnelCamera"},{"a":2,"n":"initSpeed","t":4,"rt":$n[1].Vector2,"sn":"initSpeed"},{"a":2,"n":"instance","t":4,"rt":$n[4].Water2D_Spawner,"sn":"instance"},{"a":2,"n":"isRefractingMaterial","t":4,"rt":$n[0].Boolean,"sn":"isRefractingMaterial","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"size","t":4,"rt":$n[0].Single,"sn":"size","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"usableDropsCount","t":4,"rt":$n[0].Int32,"sn":"usableDropsCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"backing":true,"n":"<AllBallsCount>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"AllBallsCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"backing":true,"n":"<IsSpawning>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"IsSpawning","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Water2D.Water2D_Spawner end.*/

    /*Water2D.Water2D_Spawner+EmissionType start.*/
    $m("Water2D.Water2D_Spawner.EmissionType", function () { return {"td":$n[4].Water2D_Spawner,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"FillerCollider","is":true,"t":4,"rt":$n[4].Water2D_Spawner.EmissionType,"sn":"FillerCollider","box":function ($v) { return Bridge.box($v, Water2D.Water2D_Spawner.EmissionType, System.Enum.toStringFn(Water2D.Water2D_Spawner.EmissionType));}},{"a":2,"n":"ParticleSystem","is":true,"t":4,"rt":$n[4].Water2D_Spawner.EmissionType,"sn":"ParticleSystem","box":function ($v) { return Bridge.box($v, Water2D.Water2D_Spawner.EmissionType, System.Enum.toStringFn(Water2D.Water2D_Spawner.EmissionType));}}]}; }, $n);
    /*Water2D.Water2D_Spawner+EmissionType end.*/

    /*Water2D.Water2D_Spawner+FillerColliderType start.*/
    $m("Water2D.Water2D_Spawner.FillerColliderType", function () { return {"td":$n[4].Water2D_Spawner,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Box","is":true,"t":4,"rt":$n[4].Water2D_Spawner.FillerColliderType,"sn":"Box","box":function ($v) { return Bridge.box($v, Water2D.Water2D_Spawner.FillerColliderType, System.Enum.toStringFn(Water2D.Water2D_Spawner.FillerColliderType));}},{"a":2,"n":"Circle","is":true,"t":4,"rt":$n[4].Water2D_Spawner.FillerColliderType,"sn":"Circle","box":function ($v) { return Bridge.box($v, Water2D.Water2D_Spawner.FillerColliderType, System.Enum.toStringFn(Water2D.Water2D_Spawner.FillerColliderType));}},{"a":2,"n":"Polygon","is":true,"t":4,"rt":$n[4].Water2D_Spawner.FillerColliderType,"sn":"Polygon","box":function ($v) { return Bridge.box($v, Water2D.Water2D_Spawner.FillerColliderType, System.Enum.toStringFn(Water2D.Water2D_Spawner.FillerColliderType));}}]}; }, $n);
    /*Water2D.Water2D_Spawner+FillerColliderType end.*/

    /*Water2D.Water2D_Spawner+EnumTypes start.*/
    $m("Water2D.Water2D_Spawner.EnumTypes", function () { return {"td":$n[4].Water2D_Spawner,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Refracting","is":true,"t":4,"rt":$n[4].Water2D_Spawner.EnumTypes,"sn":"Refracting","box":function ($v) { return Bridge.box($v, Water2D.Water2D_Spawner.EnumTypes, System.Enum.toStringFn(Water2D.Water2D_Spawner.EnumTypes));}},{"a":2,"n":"Regular","is":true,"t":4,"rt":$n[4].Water2D_Spawner.EnumTypes,"sn":"Regular","box":function ($v) { return Bridge.box($v, Water2D.Water2D_Spawner.EnumTypes, System.Enum.toStringFn(Water2D.Water2D_Spawner.EnumTypes));}},{"a":2,"n":"Toon","is":true,"t":4,"rt":$n[4].Water2D_Spawner.EnumTypes,"sn":"Toon","box":function ($v) { return Bridge.box($v, Water2D.Water2D_Spawner.EnumTypes, System.Enum.toStringFn(Water2D.Water2D_Spawner.EnumTypes));}}]}; }, $n);
    /*Water2D.Water2D_Spawner+EnumTypes end.*/

    /*Water2D.Water2DEvents start.*/
    $m("Water2D.Water2DEvents", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*Water2D.Water2DEvents end.*/

    /*Water2D.ColorPicker start.*/
    $m("Water2D.ColorPicker", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"Colors","t":4,"rt":System.Array.type(UnityEngine.Color),"sn":"Colors"},{"a":2,"n":"Delay","t":4,"rt":$n[0].Single,"sn":"Delay","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"W2D","t":4,"rt":$n[4].Water2D_Spawner,"sn":"W2D"},{"a":1,"n":"delta","t":4,"rt":$n[0].Single,"sn":"delta","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Water2D.ColorPicker end.*/

    /*Water2D._SpawnExampleController start.*/
    $m("Water2D._SpawnExampleController", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void}]}; }, $n);
    /*Water2D._SpawnExampleController end.*/

    /*Water2D.Extentions.ColliderTrigger start.*/
    $m("Water2D.Extentions.ColliderTrigger", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Apply","t":8,"pi":[{"n":"active","pt":$n[0].Boolean,"ps":0}],"sn":"Apply","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"CheckFilled","t":8,"sn":"CheckFilled","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"OnTriggerEnter2D","t":8,"pi":[{"n":"collision","pt":$n[1].Collider2D,"ps":0}],"sn":"OnTriggerEnter2D","rt":$n[0].Void,"p":[$n[1].Collider2D]},{"a":1,"n":"OnTriggerExit2D","t":8,"pi":[{"n":"collision","pt":$n[1].Collider2D,"ps":0}],"sn":"OnTriggerExit2D","rt":$n[0].Void,"p":[$n[1].Collider2D]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"check","t":4,"rt":$n[0].Boolean,"sn":"check","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("Main")],"a":2,"n":"colliderFiller","t":4,"rt":$n[4].ColliderFiller,"sn":"colliderFiller"},{"a":1,"n":"inArea","t":4,"rt":$n[5].List$1(UnityEngine.Transform),"sn":"inArea"},{"a":2,"n":"onFalse","t":4,"rt":$n[7].UnityEvent,"sn":"onFalse"},{"at":[new UnityEngine.HeaderAttribute("Events")],"a":2,"n":"onTrue","t":4,"rt":$n[7].UnityEvent,"sn":"onTrue"},{"a":2,"n":"tags","t":4,"rt":$n[5].List$1(System.String),"sn":"tags"}]}; }, $n);
    /*Water2D.Extentions.ColliderTrigger end.*/

    /*SharpJson.Lexer start.*/
    $m("SharpJson.Lexer", function () { return {"nested":[$n[8].Lexer.Token],"att":1048576,"a":4,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"text","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":1,"n":"GetLastIndexOfNumber","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0}],"sn":"GetLastIndexOfNumber","rt":$n[0].Int32,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"GetNumberString","t":8,"sn":"GetNumberString","rt":$n[0].String},{"a":2,"n":"LookAhead","t":8,"sn":"LookAhead","rt":$n[8].Lexer.Token,"box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"NextToken","t":8,"sn":"NextToken","rt":$n[8].Lexer.Token,"box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":1,"n":"NextToken","is":true,"t":8,"pi":[{"n":"json","pt":$n[0].Array.type(System.Char),"ps":0},{"n":"index","ref":true,"pt":$n[0].Int32,"ps":1}],"sn":"NextToken","rt":$n[8].Lexer.Token,"p":[$n[0].Array.type(System.Char),$n[0].Int32],"box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"ParseDoubleNumber","t":8,"sn":"ParseDoubleNumber","rt":$n[0].Double,"box":function ($v) { return Bridge.box($v, System.Double, System.Double.format, System.Double.getHashCode);}},{"a":2,"n":"ParseFloatNumber","t":8,"sn":"ParseFloatNumber","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"ParseString","t":8,"sn":"ParseString","rt":$n[0].String},{"a":2,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":1,"n":"SkipWhiteSpaces","t":8,"sn":"SkipWhiteSpaces","rt":$n[0].Void},{"a":2,"n":"hasError","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_hasError","t":8,"rt":$n[0].Boolean,"fg":"hasError","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"hasError"},{"a":2,"n":"lineNumber","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_lineNumber","t":8,"rt":$n[0].Int32,"fg":"lineNumber","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":1,"n":"set_lineNumber","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"lineNumber"},"fn":"lineNumber"},{"a":2,"n":"parseNumbersAsFloat","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_parseNumbersAsFloat","t":8,"rt":$n[0].Boolean,"fg":"parseNumbersAsFloat","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_parseNumbersAsFloat","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"parseNumbersAsFloat"},"fn":"parseNumbersAsFloat"},{"a":1,"n":"index","t":4,"rt":$n[0].Int32,"sn":"index","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"json","t":4,"rt":$n[0].Array.type(System.Char),"sn":"json"},{"a":1,"n":"stringBuffer","t":4,"rt":$n[0].Array.type(System.Char),"sn":"stringBuffer"},{"a":1,"n":"success","t":4,"rt":$n[0].Boolean,"sn":"success","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"backing":true,"n":"<lineNumber>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"lineNumber","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"backing":true,"n":"<parseNumbersAsFloat>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"parseNumbersAsFloat","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*SharpJson.Lexer end.*/

    /*SharpJson.Lexer+Token start.*/
    $m("SharpJson.Lexer.Token", function () { return {"td":$n[8].Lexer,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Colon","is":true,"t":4,"rt":$n[8].Lexer.Token,"sn":"Colon","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"Comma","is":true,"t":4,"rt":$n[8].Lexer.Token,"sn":"Comma","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"CurlyClose","is":true,"t":4,"rt":$n[8].Lexer.Token,"sn":"CurlyClose","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"CurlyOpen","is":true,"t":4,"rt":$n[8].Lexer.Token,"sn":"CurlyOpen","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"False","is":true,"t":4,"rt":$n[8].Lexer.Token,"sn":"False","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"None","is":true,"t":4,"rt":$n[8].Lexer.Token,"sn":"None","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"Null","is":true,"t":4,"rt":$n[8].Lexer.Token,"sn":"Null","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"Number","is":true,"t":4,"rt":$n[8].Lexer.Token,"sn":"Number","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"SquaredClose","is":true,"t":4,"rt":$n[8].Lexer.Token,"sn":"SquaredClose","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"SquaredOpen","is":true,"t":4,"rt":$n[8].Lexer.Token,"sn":"SquaredOpen","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"String","is":true,"t":4,"rt":$n[8].Lexer.Token,"sn":"String","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"True","is":true,"t":4,"rt":$n[8].Lexer.Token,"sn":"True","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}}]}; }, $n);
    /*SharpJson.Lexer+Token end.*/

    /*SharpJson.JsonDecoder start.*/
    $m("SharpJson.JsonDecoder", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Decode","t":8,"pi":[{"n":"text","pt":$n[0].String,"ps":0}],"sn":"Decode","rt":$n[0].Object,"p":[$n[0].String]},{"a":2,"n":"DecodeText","is":true,"t":8,"pi":[{"n":"text","pt":$n[0].String,"ps":0}],"sn":"DecodeText","rt":$n[0].Object,"p":[$n[0].String]},{"a":1,"n":"EvalLexer","t":8,"pi":[{"n":"value","pt":System.Object,"ps":0}],"tpc":1,"tprm":["T"],"sn":"EvalLexer","rt":System.Object,"p":[System.Object]},{"a":1,"n":"ParseArray","t":8,"sn":"ParseArray","rt":$n[5].IList$1(System.Object)},{"a":1,"n":"ParseObject","t":8,"sn":"ParseObject","rt":$n[5].IDictionary$2(System.String,System.Object)},{"a":1,"n":"ParseValue","t":8,"sn":"ParseValue","rt":$n[0].Object},{"a":1,"n":"TriggerError","t":8,"pi":[{"n":"message","pt":$n[0].String,"ps":0}],"sn":"TriggerError","rt":$n[0].Void,"p":[$n[0].String]},{"a":2,"n":"errorMessage","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_errorMessage","t":8,"rt":$n[0].String,"fg":"errorMessage"},"s":{"a":1,"n":"set_errorMessage","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"errorMessage"},"fn":"errorMessage"},{"a":2,"n":"parseNumbersAsFloat","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_parseNumbersAsFloat","t":8,"rt":$n[0].Boolean,"fg":"parseNumbersAsFloat","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_parseNumbersAsFloat","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"parseNumbersAsFloat"},"fn":"parseNumbersAsFloat"},{"a":1,"n":"lexer","t":4,"rt":$n[8].Lexer,"sn":"lexer"},{"a":1,"backing":true,"n":"<errorMessage>k__BackingField","t":4,"rt":$n[0].String,"sn":"errorMessage"},{"a":1,"backing":true,"n":"<parseNumbersAsFloat>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"parseNumbersAsFloat","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*SharpJson.JsonDecoder end.*/

    /*Spine.Animation start.*/
    $m("Spine.Animation", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[9].ExposedList$1(Spine.Timeline),$n[0].Single],"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"timelines","pt":$n[9].ExposedList$1(Spine.Timeline),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"ctor"},{"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"loop","pt":$n[0].Boolean,"ps":3},{"n":"events","pt":$n[9].ExposedList$1(Spine.Event),"ps":4},{"n":"alpha","pt":$n[0].Single,"ps":5},{"n":"blend","pt":$n[9].MixBlend,"ps":6},{"n":"direction","pt":$n[9].MixDirection,"ps":7}],"sn":"Apply","rt":$n[0].Void,"p":[$n[9].Skeleton,$n[0].Single,$n[0].Single,$n[0].Boolean,$n[9].ExposedList$1(Spine.Event),$n[0].Single,$n[9].MixBlend,$n[9].MixDirection]},{"a":4,"n":"BinarySearch","is":true,"t":8,"pi":[{"n":"values","pt":$n[0].Array.type(System.Single),"ps":0},{"n":"target","pt":$n[0].Single,"ps":1}],"sn":"BinarySearch","rt":$n[0].Int32,"p":[$n[0].Array.type(System.Single),$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"BinarySearch","is":true,"t":8,"pi":[{"n":"values","pt":$n[0].Array.type(System.Single),"ps":0},{"n":"target","pt":$n[0].Single,"ps":1},{"n":"step","pt":$n[0].Int32,"ps":2}],"sn":"BinarySearch$1","rt":$n[0].Int32,"p":[$n[0].Array.type(System.Single),$n[0].Single,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"HasTimeline","t":8,"pi":[{"n":"id","pt":$n[0].Int32,"ps":0}],"sn":"HasTimeline","rt":$n[0].Boolean,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"LinearSearch","is":true,"t":8,"pi":[{"n":"values","pt":$n[0].Array.type(System.Single),"ps":0},{"n":"target","pt":$n[0].Single,"ps":1},{"n":"step","pt":$n[0].Int32,"ps":2}],"sn":"LinearSearch","rt":$n[0].Int32,"p":[$n[0].Array.type(System.Single),$n[0].Single,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Duration","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Duration","t":8,"rt":$n[0].Single,"fg":"Duration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Duration","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Duration"},"fn":"Duration"},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"fn":"Name"},{"a":2,"n":"Timelines","t":16,"rt":$n[9].ExposedList$1(Spine.Timeline),"g":{"a":2,"n":"get_Timelines","t":8,"rt":$n[9].ExposedList$1(Spine.Timeline),"fg":"Timelines"},"s":{"a":2,"n":"set_Timelines","t":8,"p":[$n[9].ExposedList$1(Spine.Timeline)],"rt":$n[0].Void,"fs":"Timelines"},"fn":"Timelines"},{"a":4,"n":"duration","t":4,"rt":$n[0].Single,"sn":"duration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":4,"n":"timelineIds","t":4,"rt":$n[5].HashSet$1(System.Int32),"sn":"timelineIds"},{"a":4,"n":"timelines","t":4,"rt":$n[9].ExposedList$1(Spine.Timeline),"sn":"timelines"}]}; }, $n);
    /*Spine.Animation end.*/

    /*Spine.Timeline start.*/
    $m("Spine.Timeline", function () { return {"att":161,"a":2,"m":[{"ab":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"events","pt":$n[9].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[9].MixBlend,"ps":5},{"n":"direction","pt":$n[9].MixDirection,"ps":6}],"sn":"Spine$Timeline$Apply","rt":$n[0].Void,"p":[$n[9].Skeleton,$n[0].Single,$n[0].Single,$n[9].ExposedList$1(Spine.Event),$n[0].Single,$n[9].MixBlend,$n[9].MixDirection]},{"ab":true,"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"ab":true,"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"Spine$Timeline$PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Spine$Timeline$PropertyId"},{"a":1,"backing":true,"n":"<PropertyId>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"Spine$Timeline$PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Timeline end.*/

    /*Spine.MixBlend start.*/
    $m("Spine.MixBlend", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Add","is":true,"t":4,"rt":$n[9].MixBlend,"sn":"Add","box":function ($v) { return Bridge.box($v, Spine.MixBlend, System.Enum.toStringFn(Spine.MixBlend));}},{"a":2,"n":"First","is":true,"t":4,"rt":$n[9].MixBlend,"sn":"First","box":function ($v) { return Bridge.box($v, Spine.MixBlend, System.Enum.toStringFn(Spine.MixBlend));}},{"a":2,"n":"Replace","is":true,"t":4,"rt":$n[9].MixBlend,"sn":"Replace","box":function ($v) { return Bridge.box($v, Spine.MixBlend, System.Enum.toStringFn(Spine.MixBlend));}},{"a":2,"n":"Setup","is":true,"t":4,"rt":$n[9].MixBlend,"sn":"Setup","box":function ($v) { return Bridge.box($v, Spine.MixBlend, System.Enum.toStringFn(Spine.MixBlend));}}]}; }, $n);
    /*Spine.MixBlend end.*/

    /*Spine.MixDirection start.*/
    $m("Spine.MixDirection", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"In","is":true,"t":4,"rt":$n[9].MixDirection,"sn":"In","box":function ($v) { return Bridge.box($v, Spine.MixDirection, System.Enum.toStringFn(Spine.MixDirection));}},{"a":2,"n":"Out","is":true,"t":4,"rt":$n[9].MixDirection,"sn":"Out","box":function ($v) { return Bridge.box($v, Spine.MixDirection, System.Enum.toStringFn(Spine.MixDirection));}}]}; }, $n);
    /*Spine.MixDirection end.*/

    /*Spine.TimelineType start.*/
    $m("Spine.TimelineType", function () { return {"att":256,"a":4,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Attachment","is":true,"t":4,"rt":$n[9].TimelineType,"sn":"Attachment","box":function ($v) { return Bridge.box($v, Spine.TimelineType, System.Enum.toStringFn(Spine.TimelineType));}},{"a":2,"n":"Color","is":true,"t":4,"rt":$n[9].TimelineType,"sn":"Color","box":function ($v) { return Bridge.box($v, Spine.TimelineType, System.Enum.toStringFn(Spine.TimelineType));}},{"a":2,"n":"Deform","is":true,"t":4,"rt":$n[9].TimelineType,"sn":"Deform","box":function ($v) { return Bridge.box($v, Spine.TimelineType, System.Enum.toStringFn(Spine.TimelineType));}},{"a":2,"n":"DrawOrder","is":true,"t":4,"rt":$n[9].TimelineType,"sn":"DrawOrder","box":function ($v) { return Bridge.box($v, Spine.TimelineType, System.Enum.toStringFn(Spine.TimelineType));}},{"a":2,"n":"Event","is":true,"t":4,"rt":$n[9].TimelineType,"sn":"Event","box":function ($v) { return Bridge.box($v, Spine.TimelineType, System.Enum.toStringFn(Spine.TimelineType));}},{"a":2,"n":"IkConstraint","is":true,"t":4,"rt":$n[9].TimelineType,"sn":"IkConstraint","box":function ($v) { return Bridge.box($v, Spine.TimelineType, System.Enum.toStringFn(Spine.TimelineType));}},{"a":2,"n":"PathConstraintMix","is":true,"t":4,"rt":$n[9].TimelineType,"sn":"PathConstraintMix","box":function ($v) { return Bridge.box($v, Spine.TimelineType, System.Enum.toStringFn(Spine.TimelineType));}},{"a":2,"n":"PathConstraintPosition","is":true,"t":4,"rt":$n[9].TimelineType,"sn":"PathConstraintPosition","box":function ($v) { return Bridge.box($v, Spine.TimelineType, System.Enum.toStringFn(Spine.TimelineType));}},{"a":2,"n":"PathConstraintSpacing","is":true,"t":4,"rt":$n[9].TimelineType,"sn":"PathConstraintSpacing","box":function ($v) { return Bridge.box($v, Spine.TimelineType, System.Enum.toStringFn(Spine.TimelineType));}},{"a":2,"n":"Rotate","is":true,"t":4,"rt":$n[9].TimelineType,"sn":"Rotate","box":function ($v) { return Bridge.box($v, Spine.TimelineType, System.Enum.toStringFn(Spine.TimelineType));}},{"a":2,"n":"Scale","is":true,"t":4,"rt":$n[9].TimelineType,"sn":"Scale","box":function ($v) { return Bridge.box($v, Spine.TimelineType, System.Enum.toStringFn(Spine.TimelineType));}},{"a":2,"n":"Shear","is":true,"t":4,"rt":$n[9].TimelineType,"sn":"Shear","box":function ($v) { return Bridge.box($v, Spine.TimelineType, System.Enum.toStringFn(Spine.TimelineType));}},{"a":2,"n":"TransformConstraint","is":true,"t":4,"rt":$n[9].TimelineType,"sn":"TransformConstraint","box":function ($v) { return Bridge.box($v, Spine.TimelineType, System.Enum.toStringFn(Spine.TimelineType));}},{"a":2,"n":"Translate","is":true,"t":4,"rt":$n[9].TimelineType,"sn":"Translate","box":function ($v) { return Bridge.box($v, Spine.TimelineType, System.Enum.toStringFn(Spine.TimelineType));}},{"a":2,"n":"TwoColor","is":true,"t":4,"rt":$n[9].TimelineType,"sn":"TwoColor","box":function ($v) { return Bridge.box($v, Spine.TimelineType, System.Enum.toStringFn(Spine.TimelineType));}}]}; }, $n);
    /*Spine.TimelineType end.*/

    /*Spine.IBoneTimeline start.*/
    $m("Spine.IBoneTimeline", function () { return {"att":161,"a":2,"m":[{"ab":true,"a":2,"n":"BoneIndex","t":16,"rt":$n[0].Int32,"g":{"ab":true,"a":2,"n":"get_BoneIndex","t":8,"rt":$n[0].Int32,"fg":"Spine$IBoneTimeline$BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Spine$IBoneTimeline$BoneIndex"},{"a":1,"backing":true,"n":"<BoneIndex>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"Spine$IBoneTimeline$BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.IBoneTimeline end.*/

    /*Spine.ISlotTimeline start.*/
    $m("Spine.ISlotTimeline", function () { return {"att":161,"a":2,"m":[{"ab":true,"a":2,"n":"SlotIndex","t":16,"rt":$n[0].Int32,"g":{"ab":true,"a":2,"n":"get_SlotIndex","t":8,"rt":$n[0].Int32,"fg":"Spine$ISlotTimeline$SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Spine$ISlotTimeline$SlotIndex"},{"a":1,"backing":true,"n":"<SlotIndex>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"Spine$ISlotTimeline$SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.ISlotTimeline end.*/

    /*Spine.CurveTimeline start.*/
    $m("Spine.CurveTimeline", function () { return {"att":1048705,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"ab":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[9].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[9].MixBlend,"ps":5},{"n":"direction","pt":$n[9].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[9].Skeleton,$n[0].Single,$n[0].Single,$n[9].ExposedList$1(Spine.Event),$n[0].Single,$n[9].MixBlend,$n[9].MixDirection]},{"a":2,"n":"GetCurvePercent","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0},{"n":"percent","pt":$n[0].Single,"ps":1}],"sn":"GetCurvePercent","rt":$n[0].Single,"p":[$n[0].Int32,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GetCurveType","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetCurveType","rt":$n[0].Single,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"SetCurve","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0},{"n":"cx1","pt":$n[0].Single,"ps":1},{"n":"cy1","pt":$n[0].Single,"ps":2},{"n":"cx2","pt":$n[0].Single,"ps":3},{"n":"cy2","pt":$n[0].Single,"ps":4}],"sn":"SetCurve","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetLinear","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0}],"sn":"SetLinear","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"SetStepped","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0}],"sn":"SetStepped","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"FrameCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_FrameCount","t":8,"rt":$n[0].Int32,"fg":"FrameCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameCount"},{"ab":true,"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"ab":true,"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PropertyId"},{"a":3,"n":"BEZIER","is":true,"t":4,"rt":$n[0].Single,"sn":"BEZIER","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"BEZIER_SIZE","is":true,"t":4,"rt":$n[0].Int32,"sn":"BEZIER_SIZE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"LINEAR","is":true,"t":4,"rt":$n[0].Single,"sn":"LINEAR","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"STEPPED","is":true,"t":4,"rt":$n[0].Single,"sn":"STEPPED","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"curves","t":4,"rt":$n[0].Array.type(System.Single),"sn":"curves"},{"a":1,"backing":true,"n":"<PropertyId>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.CurveTimeline end.*/

    /*Spine.RotateTimeline start.*/
    $m("Spine.RotateTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[9].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[9].MixBlend,"ps":5},{"n":"direction","pt":$n[9].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[9].Skeleton,$n[0].Single,$n[0].Single,$n[9].ExposedList$1(Spine.Event),$n[0].Single,$n[9].MixBlend,$n[9].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"degrees","pt":$n[0].Single,"ps":2}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single]},{"a":2,"n":"BoneIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BoneIndex","t":8,"rt":$n[0].Int32,"fg":"BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_BoneIndex","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"BoneIndex"},"fn":"BoneIndex"},{"a":2,"n":"Frames","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Frames","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Frames"},"s":{"a":2,"n":"set_Frames","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Frames"},"fn":"Frames"},{"ov":true,"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PropertyId"},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"PREV_ROTATION","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_ROTATION","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"PREV_TIME","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_TIME","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"ROTATION","is":true,"t":4,"rt":$n[0].Int32,"sn":"ROTATION","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"boneIndex","t":4,"rt":$n[0].Int32,"sn":"boneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"frames","t":4,"rt":$n[0].Array.type(System.Single),"sn":"frames"}]}; }, $n);
    /*Spine.RotateTimeline end.*/

    /*Spine.TranslateTimeline start.*/
    $m("Spine.TranslateTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[9].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[9].MixBlend,"ps":5},{"n":"direction","pt":$n[9].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[9].Skeleton,$n[0].Single,$n[0].Single,$n[9].ExposedList$1(Spine.Event),$n[0].Single,$n[9].MixBlend,$n[9].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"x","pt":$n[0].Single,"ps":2},{"n":"y","pt":$n[0].Single,"ps":3}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"BoneIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BoneIndex","t":8,"rt":$n[0].Int32,"fg":"BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_BoneIndex","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"BoneIndex"},"fn":"BoneIndex"},{"a":2,"n":"Frames","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Frames","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Frames"},"s":{"a":2,"n":"set_Frames","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Frames"},"fn":"Frames"},{"ov":true,"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PropertyId"},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_TIME","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_TIME","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_X","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_X","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_Y","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_Y","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"X","is":true,"t":4,"rt":$n[0].Int32,"sn":"X","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"Y","is":true,"t":4,"rt":$n[0].Int32,"sn":"Y","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"boneIndex","t":4,"rt":$n[0].Int32,"sn":"boneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"frames","t":4,"rt":$n[0].Array.type(System.Single),"sn":"frames"}]}; }, $n);
    /*Spine.TranslateTimeline end.*/

    /*Spine.ScaleTimeline start.*/
    $m("Spine.ScaleTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[9].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[9].MixBlend,"ps":5},{"n":"direction","pt":$n[9].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[9].Skeleton,$n[0].Single,$n[0].Single,$n[9].ExposedList$1(Spine.Event),$n[0].Single,$n[9].MixBlend,$n[9].MixDirection]},{"ov":true,"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PropertyId"}]}; }, $n);
    /*Spine.ScaleTimeline end.*/

    /*Spine.ShearTimeline start.*/
    $m("Spine.ShearTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[9].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[9].MixBlend,"ps":5},{"n":"direction","pt":$n[9].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[9].Skeleton,$n[0].Single,$n[0].Single,$n[9].ExposedList$1(Spine.Event),$n[0].Single,$n[9].MixBlend,$n[9].MixDirection]},{"ov":true,"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PropertyId"}]}; }, $n);
    /*Spine.ShearTimeline end.*/

    /*Spine.ColorTimeline start.*/
    $m("Spine.ColorTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[9].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[9].MixBlend,"ps":5},{"n":"direction","pt":$n[9].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[9].Skeleton,$n[0].Single,$n[0].Single,$n[9].ExposedList$1(Spine.Event),$n[0].Single,$n[9].MixBlend,$n[9].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"r","pt":$n[0].Single,"ps":2},{"n":"g","pt":$n[0].Single,"ps":3},{"n":"b","pt":$n[0].Single,"ps":4},{"n":"a","pt":$n[0].Single,"ps":5}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"Frames","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Frames","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Frames"},"s":{"a":2,"n":"set_Frames","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Frames"},"fn":"Frames"},{"ov":true,"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PropertyId"},{"a":2,"n":"SlotIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotIndex","t":8,"rt":$n[0].Int32,"fg":"SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_SlotIndex","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"SlotIndex"},"fn":"SlotIndex"},{"a":3,"n":"A","is":true,"t":4,"rt":$n[0].Int32,"sn":"A","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"B","is":true,"t":4,"rt":$n[0].Int32,"sn":"B","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"G","is":true,"t":4,"rt":$n[0].Int32,"sn":"G","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_A","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_A","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_B","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_B","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_G","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_G","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_R","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_R","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_TIME","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_TIME","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"R","is":true,"t":4,"rt":$n[0].Int32,"sn":"R","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"frames","t":4,"rt":$n[0].Array.type(System.Single),"sn":"frames"},{"a":4,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.ColorTimeline end.*/

    /*Spine.TwoColorTimeline start.*/
    $m("Spine.TwoColorTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[9].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[9].MixBlend,"ps":5},{"n":"direction","pt":$n[9].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[9].Skeleton,$n[0].Single,$n[0].Single,$n[9].ExposedList$1(Spine.Event),$n[0].Single,$n[9].MixBlend,$n[9].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"r","pt":$n[0].Single,"ps":2},{"n":"g","pt":$n[0].Single,"ps":3},{"n":"b","pt":$n[0].Single,"ps":4},{"n":"a","pt":$n[0].Single,"ps":5},{"n":"r2","pt":$n[0].Single,"ps":6},{"n":"g2","pt":$n[0].Single,"ps":7},{"n":"b2","pt":$n[0].Single,"ps":8}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"Frames","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Frames","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Frames"},"fn":"Frames"},{"ov":true,"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PropertyId"},{"a":2,"n":"SlotIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotIndex","t":8,"rt":$n[0].Int32,"fg":"SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_SlotIndex","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"SlotIndex"},"fn":"SlotIndex"},{"a":3,"n":"A","is":true,"t":4,"rt":$n[0].Int32,"sn":"A","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"B","is":true,"t":4,"rt":$n[0].Int32,"sn":"B","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"B2","is":true,"t":4,"rt":$n[0].Int32,"sn":"B2","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"G","is":true,"t":4,"rt":$n[0].Int32,"sn":"G","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"G2","is":true,"t":4,"rt":$n[0].Int32,"sn":"G2","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_A","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_A","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_B","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_B","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_B2","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_B2","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_G","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_G","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_G2","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_G2","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_R","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_R","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_R2","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_R2","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_TIME","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_TIME","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"R","is":true,"t":4,"rt":$n[0].Int32,"sn":"R","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"R2","is":true,"t":4,"rt":$n[0].Int32,"sn":"R2","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"frames","t":4,"rt":$n[0].Array.type(System.Single),"sn":"frames"},{"a":4,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.TwoColorTimeline end.*/

    /*Spine.AttachmentTimeline start.*/
    $m("Spine.AttachmentTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[9].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[9].MixBlend,"ps":5},{"n":"direction","pt":$n[9].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[9].Skeleton,$n[0].Single,$n[0].Single,$n[9].ExposedList$1(Spine.Event),$n[0].Single,$n[9].MixBlend,$n[9].MixDirection]},{"a":1,"n":"SetAttachment","t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0},{"n":"slot","pt":$n[9].Slot,"ps":1},{"n":"attachmentName","pt":$n[0].String,"ps":2}],"sn":"SetAttachment","rt":$n[0].Void,"p":[$n[9].Skeleton,$n[9].Slot,$n[0].String]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"attachmentName","pt":$n[0].String,"ps":2}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].String]},{"a":2,"n":"AttachmentNames","t":16,"rt":$n[0].Array.type(System.String),"g":{"a":2,"n":"get_AttachmentNames","t":8,"rt":$n[0].Array.type(System.String),"fg":"AttachmentNames"},"s":{"a":2,"n":"set_AttachmentNames","t":8,"p":[$n[0].Array.type(System.String)],"rt":$n[0].Void,"fs":"AttachmentNames"},"fn":"AttachmentNames"},{"a":2,"n":"FrameCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_FrameCount","t":8,"rt":$n[0].Int32,"fg":"FrameCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameCount"},{"a":2,"n":"Frames","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Frames","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Frames"},"s":{"a":2,"n":"set_Frames","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Frames"},"fn":"Frames"},{"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PropertyId"},{"a":2,"n":"SlotIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotIndex","t":8,"rt":$n[0].Int32,"fg":"SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_SlotIndex","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"SlotIndex"},"fn":"SlotIndex"},{"a":4,"n":"attachmentNames","t":4,"rt":$n[0].Array.type(System.String),"sn":"attachmentNames"},{"a":4,"n":"frames","t":4,"rt":$n[0].Array.type(System.Single),"sn":"frames"},{"a":4,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.AttachmentTimeline end.*/

    /*Spine.DeformTimeline start.*/
    $m("Spine.DeformTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[9].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[9].MixBlend,"ps":5},{"n":"direction","pt":$n[9].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[9].Skeleton,$n[0].Single,$n[0].Single,$n[9].ExposedList$1(Spine.Event),$n[0].Single,$n[9].MixBlend,$n[9].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"vertices","pt":$n[0].Array.type(System.Single),"ps":2}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Array.type(System.Single)]},{"a":2,"n":"Attachment","t":16,"rt":$n[9].VertexAttachment,"g":{"a":2,"n":"get_Attachment","t":8,"rt":$n[9].VertexAttachment,"fg":"Attachment"},"s":{"a":2,"n":"set_Attachment","t":8,"p":[$n[9].VertexAttachment],"rt":$n[0].Void,"fs":"Attachment"},"fn":"Attachment"},{"a":2,"n":"Frames","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Frames","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Frames"},"s":{"a":2,"n":"set_Frames","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Frames"},"fn":"Frames"},{"ov":true,"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PropertyId"},{"a":2,"n":"SlotIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotIndex","t":8,"rt":$n[0].Int32,"fg":"SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_SlotIndex","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"SlotIndex"},"fn":"SlotIndex"},{"a":2,"n":"Vertices","t":16,"rt":$n[0].Array.type(System.Array.type(System.Single)),"g":{"a":2,"n":"get_Vertices","t":8,"rt":$n[0].Array.type(System.Array.type(System.Single)),"fg":"Vertices"},"s":{"a":2,"n":"set_Vertices","t":8,"p":[$n[0].Array.type(System.Array.type(System.Single))],"rt":$n[0].Void,"fs":"Vertices"},"fn":"Vertices"},{"a":4,"n":"attachment","t":4,"rt":$n[9].VertexAttachment,"sn":"attachment"},{"a":4,"n":"frameVertices","t":4,"rt":$n[0].Array.type(System.Array.type(System.Single)),"sn":"frameVertices"},{"a":4,"n":"frames","t":4,"rt":$n[0].Array.type(System.Single),"sn":"frames"},{"a":4,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.DeformTimeline end.*/

    /*Spine.EventTimeline start.*/
    $m("Spine.EventTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[9].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[9].MixBlend,"ps":5},{"n":"direction","pt":$n[9].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[9].Skeleton,$n[0].Single,$n[0].Single,$n[9].ExposedList$1(Spine.Event),$n[0].Single,$n[9].MixBlend,$n[9].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0},{"n":"e","pt":$n[9].Event,"ps":1}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[9].Event]},{"a":2,"n":"Events","t":16,"rt":System.Array.type(Spine.Event),"g":{"a":2,"n":"get_Events","t":8,"rt":System.Array.type(Spine.Event),"fg":"Events"},"s":{"a":2,"n":"set_Events","t":8,"p":[System.Array.type(Spine.Event)],"rt":$n[0].Void,"fs":"Events"},"fn":"Events"},{"a":2,"n":"FrameCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_FrameCount","t":8,"rt":$n[0].Int32,"fg":"FrameCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameCount"},{"a":2,"n":"Frames","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Frames","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Frames"},"s":{"a":2,"n":"set_Frames","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Frames"},"fn":"Frames"},{"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PropertyId"},{"a":1,"n":"events","t":4,"rt":System.Array.type(Spine.Event),"sn":"events"},{"a":4,"n":"frames","t":4,"rt":$n[0].Array.type(System.Single),"sn":"frames"}]}; }, $n);
    /*Spine.EventTimeline end.*/

    /*Spine.DrawOrderTimeline start.*/
    $m("Spine.DrawOrderTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[9].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[9].MixBlend,"ps":5},{"n":"direction","pt":$n[9].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[9].Skeleton,$n[0].Single,$n[0].Single,$n[9].ExposedList$1(Spine.Event),$n[0].Single,$n[9].MixBlend,$n[9].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"drawOrder","pt":$n[0].Array.type(System.Int32),"ps":2}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Array.type(System.Int32)]},{"a":2,"n":"DrawOrders","t":16,"rt":$n[0].Array.type(System.Array.type(System.Int32)),"g":{"a":2,"n":"get_DrawOrders","t":8,"rt":$n[0].Array.type(System.Array.type(System.Int32)),"fg":"DrawOrders"},"s":{"a":2,"n":"set_DrawOrders","t":8,"p":[$n[0].Array.type(System.Array.type(System.Int32))],"rt":$n[0].Void,"fs":"DrawOrders"},"fn":"DrawOrders"},{"a":2,"n":"FrameCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_FrameCount","t":8,"rt":$n[0].Int32,"fg":"FrameCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameCount"},{"a":2,"n":"Frames","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Frames","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Frames"},"s":{"a":2,"n":"set_Frames","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Frames"},"fn":"Frames"},{"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PropertyId"},{"a":1,"n":"drawOrders","t":4,"rt":$n[0].Array.type(System.Array.type(System.Int32)),"sn":"drawOrders"},{"a":4,"n":"frames","t":4,"rt":$n[0].Array.type(System.Single),"sn":"frames"}]}; }, $n);
    /*Spine.DrawOrderTimeline end.*/

    /*Spine.IkConstraintTimeline start.*/
    $m("Spine.IkConstraintTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[9].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[9].MixBlend,"ps":5},{"n":"direction","pt":$n[9].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[9].Skeleton,$n[0].Single,$n[0].Single,$n[9].ExposedList$1(Spine.Event),$n[0].Single,$n[9].MixBlend,$n[9].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"mix","pt":$n[0].Single,"ps":2},{"n":"softness","pt":$n[0].Single,"ps":3},{"n":"bendDirection","pt":$n[0].Int32,"ps":4},{"n":"compress","pt":$n[0].Boolean,"ps":5},{"n":"stretch","pt":$n[0].Boolean,"ps":6}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Int32,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"Frames","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Frames","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Frames"},"s":{"a":2,"n":"set_Frames","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Frames"},"fn":"Frames"},{"a":2,"n":"IkConstraintIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_IkConstraintIndex","t":8,"rt":$n[0].Int32,"fg":"IkConstraintIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_IkConstraintIndex","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"IkConstraintIndex"},"fn":"IkConstraintIndex"},{"ov":true,"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PropertyId"},{"a":1,"n":"BEND_DIRECTION","is":true,"t":4,"rt":$n[0].Int32,"sn":"BEND_DIRECTION","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"COMPRESS","is":true,"t":4,"rt":$n[0].Int32,"sn":"COMPRESS","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"MIX","is":true,"t":4,"rt":$n[0].Int32,"sn":"MIX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"PREV_BEND_DIRECTION","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_BEND_DIRECTION","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"PREV_COMPRESS","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_COMPRESS","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"PREV_MIX","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_MIX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"PREV_SOFTNESS","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_SOFTNESS","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"PREV_STRETCH","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_STRETCH","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"PREV_TIME","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_TIME","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"SOFTNESS","is":true,"t":4,"rt":$n[0].Int32,"sn":"SOFTNESS","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"STRETCH","is":true,"t":4,"rt":$n[0].Int32,"sn":"STRETCH","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"frames","t":4,"rt":$n[0].Array.type(System.Single),"sn":"frames"},{"a":4,"n":"ikConstraintIndex","t":4,"rt":$n[0].Int32,"sn":"ikConstraintIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.IkConstraintTimeline end.*/

    /*Spine.TransformConstraintTimeline start.*/
    $m("Spine.TransformConstraintTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[9].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[9].MixBlend,"ps":5},{"n":"direction","pt":$n[9].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[9].Skeleton,$n[0].Single,$n[0].Single,$n[9].ExposedList$1(Spine.Event),$n[0].Single,$n[9].MixBlend,$n[9].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"rotateMix","pt":$n[0].Single,"ps":2},{"n":"translateMix","pt":$n[0].Single,"ps":3},{"n":"scaleMix","pt":$n[0].Single,"ps":4},{"n":"shearMix","pt":$n[0].Single,"ps":5}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"Frames","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Frames","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Frames"},"s":{"a":2,"n":"set_Frames","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Frames"},"fn":"Frames"},{"ov":true,"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PropertyId"},{"a":2,"n":"TransformConstraintIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_TransformConstraintIndex","t":8,"rt":$n[0].Int32,"fg":"TransformConstraintIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_TransformConstraintIndex","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"TransformConstraintIndex"},"fn":"TransformConstraintIndex"},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"PREV_ROTATE","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_ROTATE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"PREV_SCALE","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_SCALE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"PREV_SHEAR","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_SHEAR","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"PREV_TIME","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_TIME","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"PREV_TRANSLATE","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_TRANSLATE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"ROTATE","is":true,"t":4,"rt":$n[0].Int32,"sn":"ROTATE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"SCALE","is":true,"t":4,"rt":$n[0].Int32,"sn":"SCALE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"SHEAR","is":true,"t":4,"rt":$n[0].Int32,"sn":"SHEAR","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"TRANSLATE","is":true,"t":4,"rt":$n[0].Int32,"sn":"TRANSLATE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"frames","t":4,"rt":$n[0].Array.type(System.Single),"sn":"frames"},{"a":4,"n":"transformConstraintIndex","t":4,"rt":$n[0].Int32,"sn":"transformConstraintIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.TransformConstraintTimeline end.*/

    /*Spine.PathConstraintPositionTimeline start.*/
    $m("Spine.PathConstraintPositionTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[9].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[9].MixBlend,"ps":5},{"n":"direction","pt":$n[9].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[9].Skeleton,$n[0].Single,$n[0].Single,$n[9].ExposedList$1(Spine.Event),$n[0].Single,$n[9].MixBlend,$n[9].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"position","pt":$n[0].Single,"ps":2}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single]},{"a":2,"n":"Frames","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Frames","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Frames"},"s":{"a":2,"n":"set_Frames","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Frames"},"fn":"Frames"},{"a":2,"n":"PathConstraintIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_PathConstraintIndex","t":8,"rt":$n[0].Int32,"fg":"PathConstraintIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_PathConstraintIndex","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"PathConstraintIndex"},"fn":"PathConstraintIndex"},{"ov":true,"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PropertyId"},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_TIME","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_TIME","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_VALUE","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_VALUE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"VALUE","is":true,"t":4,"rt":$n[0].Int32,"sn":"VALUE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"frames","t":4,"rt":$n[0].Array.type(System.Single),"sn":"frames"},{"a":4,"n":"pathConstraintIndex","t":4,"rt":$n[0].Int32,"sn":"pathConstraintIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.PathConstraintPositionTimeline end.*/

    /*Spine.PathConstraintSpacingTimeline start.*/
    $m("Spine.PathConstraintSpacingTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"events","pt":$n[9].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[9].MixBlend,"ps":5},{"n":"direction","pt":$n[9].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[9].Skeleton,$n[0].Single,$n[0].Single,$n[9].ExposedList$1(Spine.Event),$n[0].Single,$n[9].MixBlend,$n[9].MixDirection]},{"ov":true,"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PropertyId"}]}; }, $n);
    /*Spine.PathConstraintSpacingTimeline end.*/

    /*Spine.PathConstraintMixTimeline start.*/
    $m("Spine.PathConstraintMixTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[9].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[9].MixBlend,"ps":5},{"n":"direction","pt":$n[9].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[9].Skeleton,$n[0].Single,$n[0].Single,$n[9].ExposedList$1(Spine.Event),$n[0].Single,$n[9].MixBlend,$n[9].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"rotateMix","pt":$n[0].Single,"ps":2},{"n":"translateMix","pt":$n[0].Single,"ps":3}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"Frames","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Frames","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Frames"},"s":{"a":2,"n":"set_Frames","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Frames"},"fn":"Frames"},{"a":2,"n":"PathConstraintIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_PathConstraintIndex","t":8,"rt":$n[0].Int32,"fg":"PathConstraintIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_PathConstraintIndex","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"PathConstraintIndex"},"fn":"PathConstraintIndex"},{"ov":true,"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PropertyId"},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"PREV_ROTATE","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_ROTATE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"PREV_TIME","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_TIME","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"PREV_TRANSLATE","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_TRANSLATE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"ROTATE","is":true,"t":4,"rt":$n[0].Int32,"sn":"ROTATE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"TRANSLATE","is":true,"t":4,"rt":$n[0].Int32,"sn":"TRANSLATE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"frames","t":4,"rt":$n[0].Array.type(System.Single),"sn":"frames"},{"a":4,"n":"pathConstraintIndex","t":4,"rt":$n[0].Int32,"sn":"pathConstraintIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.PathConstraintMixTimeline end.*/

    /*Spine.AnimationState start.*/
    $m("Spine.AnimationState", function () { return {"nested":[Function,Function],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[9].AnimationStateData],"pi":[{"n":"data","pt":$n[9].AnimationStateData,"ps":0}],"sn":"ctor"},{"a":2,"n":"AddAnimation","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0},{"n":"animation","pt":$n[9].Animation,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2},{"n":"delay","pt":$n[0].Single,"ps":3}],"sn":"AddAnimation","rt":$n[9].TrackEntry,"p":[$n[0].Int32,$n[9].Animation,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"AddAnimation","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0},{"n":"animationName","pt":$n[0].String,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2},{"n":"delay","pt":$n[0].Single,"ps":3}],"sn":"AddAnimation$1","rt":$n[9].TrackEntry,"p":[$n[0].Int32,$n[0].String,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"AddEmptyAnimation","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0},{"n":"mixDuration","pt":$n[0].Single,"ps":1},{"n":"delay","pt":$n[0].Single,"ps":2}],"sn":"AddEmptyAnimation","rt":$n[9].TrackEntry,"p":[$n[0].Int32,$n[0].Single,$n[0].Single]},{"a":2,"n":"AddEventSubscribersFrom","t":8,"pi":[{"n":"src","pt":$n[9].AnimationState,"ps":0}],"sn":"AddEventSubscribersFrom","rt":$n[0].Void,"p":[$n[9].AnimationState]},{"a":1,"n":"AnimationsChanged","t":8,"sn":"AnimationsChanged","rt":$n[0].Void},{"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0}],"sn":"Apply","rt":$n[0].Boolean,"p":[$n[9].Skeleton],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ApplyAttachmentTimeline","t":8,"pi":[{"n":"timeline","pt":$n[9].AttachmentTimeline,"ps":0},{"n":"skeleton","pt":$n[9].Skeleton,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"blend","pt":$n[9].MixBlend,"ps":3},{"n":"attachments","pt":$n[0].Boolean,"ps":4}],"sn":"ApplyAttachmentTimeline","rt":$n[0].Void,"p":[$n[9].AttachmentTimeline,$n[9].Skeleton,$n[0].Single,$n[9].MixBlend,$n[0].Boolean]},{"a":2,"n":"ApplyEventTimelinesOnly","t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0}],"sn":"ApplyEventTimelinesOnly","rt":$n[0].Boolean,"p":[$n[9].Skeleton],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ApplyMixingFrom","t":8,"pi":[{"n":"to","pt":$n[9].TrackEntry,"ps":0},{"n":"skeleton","pt":$n[9].Skeleton,"ps":1},{"n":"blend","pt":$n[9].MixBlend,"ps":2}],"sn":"ApplyMixingFrom","rt":$n[0].Single,"p":[$n[9].TrackEntry,$n[9].Skeleton,$n[9].MixBlend],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"ApplyMixingFromEventTimelinesOnly","t":8,"pi":[{"n":"to","pt":$n[9].TrackEntry,"ps":0},{"n":"skeleton","pt":$n[9].Skeleton,"ps":1}],"sn":"ApplyMixingFromEventTimelinesOnly","rt":$n[0].Single,"p":[$n[9].TrackEntry,$n[9].Skeleton],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"ApplyRotateTimeline","is":true,"t":8,"pi":[{"n":"timeline","pt":$n[9].RotateTimeline,"ps":0},{"n":"skeleton","pt":$n[9].Skeleton,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"alpha","pt":$n[0].Single,"ps":3},{"n":"blend","pt":$n[9].MixBlend,"ps":4},{"n":"timelinesRotation","pt":$n[0].Array.type(System.Single),"ps":5},{"n":"i","pt":$n[0].Int32,"ps":6},{"n":"firstFrame","pt":$n[0].Boolean,"ps":7}],"sn":"ApplyRotateTimeline","rt":$n[0].Void,"p":[$n[9].RotateTimeline,$n[9].Skeleton,$n[0].Single,$n[0].Single,$n[9].MixBlend,$n[0].Array.type(System.Single),$n[0].Int32,$n[0].Boolean]},{"a":2,"n":"AssignEventSubscribersFrom","t":8,"pi":[{"n":"src","pt":$n[9].AnimationState,"ps":0}],"sn":"AssignEventSubscribersFrom","rt":$n[0].Void,"p":[$n[9].AnimationState]},{"a":2,"n":"ClearListenerNotifications","t":8,"sn":"ClearListenerNotifications","rt":$n[0].Void},{"a":2,"n":"ClearTrack","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0}],"sn":"ClearTrack","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"ClearTracks","t":8,"sn":"ClearTracks","rt":$n[0].Void},{"a":1,"n":"ComputeHold","t":8,"pi":[{"n":"entry","pt":$n[9].TrackEntry,"ps":0}],"sn":"ComputeHold","rt":$n[0].Void,"p":[$n[9].TrackEntry]},{"a":1,"n":"DisposeNext","t":8,"pi":[{"n":"entry","pt":$n[9].TrackEntry,"ps":0}],"sn":"DisposeNext","rt":$n[0].Void,"p":[$n[9].TrackEntry]},{"a":1,"n":"ExpandToIndex","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0}],"sn":"ExpandToIndex","rt":$n[9].TrackEntry,"p":[$n[0].Int32]},{"a":2,"n":"GetCurrent","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetCurrent","rt":$n[9].TrackEntry,"p":[$n[0].Int32]},{"a":1,"n":"NewTrackEntry","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0},{"n":"animation","pt":$n[9].Animation,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2},{"n":"last","pt":$n[9].TrackEntry,"ps":3}],"sn":"NewTrackEntry","rt":$n[9].TrackEntry,"p":[$n[0].Int32,$n[9].Animation,$n[0].Boolean,$n[9].TrackEntry]},{"a":4,"n":"OnComplete","t":8,"pi":[{"n":"entry","pt":$n[9].TrackEntry,"ps":0}],"sn":"OnComplete","rt":$n[0].Void,"p":[$n[9].TrackEntry]},{"a":4,"n":"OnDispose","t":8,"pi":[{"n":"entry","pt":$n[9].TrackEntry,"ps":0}],"sn":"OnDispose","rt":$n[0].Void,"p":[$n[9].TrackEntry]},{"a":4,"n":"OnEnd","t":8,"pi":[{"n":"entry","pt":$n[9].TrackEntry,"ps":0}],"sn":"OnEnd","rt":$n[0].Void,"p":[$n[9].TrackEntry]},{"a":4,"n":"OnEvent","t":8,"pi":[{"n":"entry","pt":$n[9].TrackEntry,"ps":0},{"n":"e","pt":$n[9].Event,"ps":1}],"sn":"OnEvent","rt":$n[0].Void,"p":[$n[9].TrackEntry,$n[9].Event]},{"a":4,"n":"OnInterrupt","t":8,"pi":[{"n":"entry","pt":$n[9].TrackEntry,"ps":0}],"sn":"OnInterrupt","rt":$n[0].Void,"p":[$n[9].TrackEntry]},{"a":4,"n":"OnStart","t":8,"pi":[{"n":"entry","pt":$n[9].TrackEntry,"ps":0}],"sn":"OnStart","rt":$n[0].Void,"p":[$n[9].TrackEntry]},{"a":1,"n":"QueueEvents","t":8,"pi":[{"n":"entry","pt":$n[9].TrackEntry,"ps":0},{"n":"animationTime","pt":$n[0].Single,"ps":1}],"sn":"QueueEvents","rt":$n[0].Void,"p":[$n[9].TrackEntry,$n[0].Single]},{"a":2,"n":"SetAnimation","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0},{"n":"animation","pt":$n[9].Animation,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2}],"sn":"SetAnimation","rt":$n[9].TrackEntry,"p":[$n[0].Int32,$n[9].Animation,$n[0].Boolean]},{"a":2,"n":"SetAnimation","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0},{"n":"animationName","pt":$n[0].String,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2}],"sn":"SetAnimation$1","rt":$n[9].TrackEntry,"p":[$n[0].Int32,$n[0].String,$n[0].Boolean]},{"a":1,"n":"SetAttachment","t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0},{"n":"slot","pt":$n[9].Slot,"ps":1},{"n":"attachmentName","pt":$n[0].String,"ps":2},{"n":"attachments","pt":$n[0].Boolean,"ps":3}],"sn":"SetAttachment","rt":$n[0].Void,"p":[$n[9].Skeleton,$n[9].Slot,$n[0].String,$n[0].Boolean]},{"a":1,"n":"SetCurrent","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"current","pt":$n[9].TrackEntry,"ps":1},{"n":"interrupt","pt":$n[0].Boolean,"ps":2}],"sn":"SetCurrent","rt":$n[0].Void,"p":[$n[0].Int32,$n[9].TrackEntry,$n[0].Boolean]},{"a":2,"n":"SetEmptyAnimation","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0},{"n":"mixDuration","pt":$n[0].Single,"ps":1}],"sn":"SetEmptyAnimation","rt":$n[9].TrackEntry,"p":[$n[0].Int32,$n[0].Single]},{"a":2,"n":"SetEmptyAnimations","t":8,"pi":[{"n":"mixDuration","pt":$n[0].Single,"ps":0}],"sn":"SetEmptyAnimations","rt":$n[0].Void,"p":[$n[0].Single]},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Update","t":8,"pi":[{"n":"delta","pt":$n[0].Single,"ps":0}],"sn":"Update","rt":$n[0].Void,"p":[$n[0].Single]},{"a":1,"n":"UpdateMixingFrom","t":8,"pi":[{"n":"to","pt":$n[9].TrackEntry,"ps":0},{"n":"delta","pt":$n[0].Single,"ps":1}],"sn":"UpdateMixingFrom","rt":$n[0].Boolean,"p":[$n[9].TrackEntry,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Data","t":16,"rt":$n[9].AnimationStateData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[9].AnimationStateData,"fg":"Data"},"s":{"a":2,"n":"set_Data","t":8,"p":[$n[9].AnimationStateData],"rt":$n[0].Void,"fs":"Data"},"fn":"Data"},{"a":2,"n":"TimeScale","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_TimeScale","t":8,"rt":$n[0].Single,"fg":"TimeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_TimeScale","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"TimeScale"},"fn":"TimeScale"},{"a":2,"n":"Tracks","t":16,"rt":$n[9].ExposedList$1(Spine.TrackEntry),"g":{"a":2,"n":"get_Tracks","t":8,"rt":$n[9].ExposedList$1(Spine.TrackEntry),"fg":"Tracks"},"fn":"Tracks"},{"a":4,"n":"Current","is":true,"t":4,"rt":$n[0].Int32,"sn":"Current","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"EmptyAnimation","is":true,"t":4,"rt":$n[9].Animation,"sn":"EmptyAnimation","ro":true},{"a":4,"n":"First","is":true,"t":4,"rt":$n[0].Int32,"sn":"First","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"HoldFirst","is":true,"t":4,"rt":$n[0].Int32,"sn":"HoldFirst","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"HoldMix","is":true,"t":4,"rt":$n[0].Int32,"sn":"HoldMix","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"HoldSubsequent","is":true,"t":4,"rt":$n[0].Int32,"sn":"HoldSubsequent","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"Setup","is":true,"t":4,"rt":$n[0].Int32,"sn":"Setup","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"Subsequent","is":true,"t":4,"rt":$n[0].Int32,"sn":"Subsequent","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"animationsChanged","t":4,"rt":$n[0].Boolean,"sn":"animationsChanged","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"data","t":4,"rt":$n[9].AnimationStateData,"sn":"data"},{"a":1,"n":"events","t":4,"rt":$n[9].ExposedList$1(Spine.Event),"sn":"events","ro":true},{"a":1,"n":"propertyIDs","t":4,"rt":$n[5].HashSet$1(System.Int32),"sn":"propertyIDs","ro":true},{"a":1,"n":"queue","t":4,"rt":$n[9].EventQueue,"sn":"queue","ro":true},{"a":1,"n":"timeScale","t":4,"rt":$n[0].Single,"sn":"timeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"trackEntryPool","t":4,"rt":$n[9].Pool$1(Spine.TrackEntry),"sn":"trackEntryPool","ro":true},{"a":1,"n":"tracks","t":4,"rt":$n[9].ExposedList$1(Spine.TrackEntry),"sn":"tracks","ro":true},{"a":1,"n":"unkeyedState","t":4,"rt":$n[0].Int32,"sn":"unkeyedState","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"Complete","t":2,"ad":{"a":2,"n":"add_Complete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Complete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"Dispose","t":2,"ad":{"a":2,"n":"add_Dispose","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addDispose","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Dispose","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeDispose","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"End","t":2,"ad":{"a":2,"n":"add_End","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addEnd","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_End","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeEnd","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"Event","t":2,"ad":{"a":2,"n":"add_Event","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addEvent","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Event","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeEvent","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"Interrupt","t":2,"ad":{"a":2,"n":"add_Interrupt","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addInterrupt","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Interrupt","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeInterrupt","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"Start","t":2,"ad":{"a":2,"n":"add_Start","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addStart","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Start","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeStart","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.AnimationState end.*/

    /*Spine.TrackEntry start.*/
    $m("Spine.TrackEntry", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":4,"n":"OnComplete","t":8,"sn":"OnComplete","rt":$n[0].Void},{"a":4,"n":"OnDispose","t":8,"sn":"OnDispose","rt":$n[0].Void},{"a":4,"n":"OnEnd","t":8,"sn":"OnEnd","rt":$n[0].Void},{"a":4,"n":"OnEvent","t":8,"pi":[{"n":"e","pt":$n[9].Event,"ps":0}],"sn":"OnEvent","rt":$n[0].Void,"p":[$n[9].Event]},{"a":4,"n":"OnInterrupt","t":8,"sn":"OnInterrupt","rt":$n[0].Void},{"a":4,"n":"OnStart","t":8,"sn":"OnStart","rt":$n[0].Void},{"a":2,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":2,"n":"ResetRotationDirections","t":8,"sn":"ResetRotationDirections","rt":$n[0].Void},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Alpha","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Alpha","t":8,"rt":$n[0].Single,"fg":"Alpha","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Alpha","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Alpha"},"fn":"Alpha"},{"a":2,"n":"Animation","t":16,"rt":$n[9].Animation,"g":{"a":2,"n":"get_Animation","t":8,"rt":$n[9].Animation,"fg":"Animation"},"fn":"Animation"},{"a":2,"n":"AnimationEnd","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AnimationEnd","t":8,"rt":$n[0].Single,"fg":"AnimationEnd","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AnimationEnd","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AnimationEnd"},"fn":"AnimationEnd"},{"a":2,"n":"AnimationLast","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AnimationLast","t":8,"rt":$n[0].Single,"fg":"AnimationLast","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AnimationLast","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AnimationLast"},"fn":"AnimationLast"},{"a":2,"n":"AnimationStart","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AnimationStart","t":8,"rt":$n[0].Single,"fg":"AnimationStart","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AnimationStart","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AnimationStart"},"fn":"AnimationStart"},{"a":2,"n":"AnimationTime","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AnimationTime","t":8,"rt":$n[0].Single,"fg":"AnimationTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"AnimationTime"},{"a":2,"n":"AttachmentThreshold","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AttachmentThreshold","t":8,"rt":$n[0].Single,"fg":"AttachmentThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AttachmentThreshold","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AttachmentThreshold"},"fn":"AttachmentThreshold"},{"a":2,"n":"Delay","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Delay","t":8,"rt":$n[0].Single,"fg":"Delay","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Delay","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Delay"},"fn":"Delay"},{"a":2,"n":"DrawOrderThreshold","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_DrawOrderThreshold","t":8,"rt":$n[0].Single,"fg":"DrawOrderThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_DrawOrderThreshold","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"DrawOrderThreshold"},"fn":"DrawOrderThreshold"},{"a":2,"n":"EventThreshold","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_EventThreshold","t":8,"rt":$n[0].Single,"fg":"EventThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_EventThreshold","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"EventThreshold"},"fn":"EventThreshold"},{"a":2,"n":"HoldPrevious","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_HoldPrevious","t":8,"rt":$n[0].Boolean,"fg":"HoldPrevious","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_HoldPrevious","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"HoldPrevious"},"fn":"HoldPrevious"},{"a":2,"n":"IsComplete","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsComplete","t":8,"rt":$n[0].Boolean,"fg":"IsComplete","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsComplete"},{"a":2,"n":"Loop","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Loop","t":8,"rt":$n[0].Boolean,"fg":"Loop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Loop","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Loop"},"fn":"Loop"},{"a":2,"n":"MixBlend","t":16,"rt":$n[9].MixBlend,"g":{"a":2,"n":"get_MixBlend","t":8,"rt":$n[9].MixBlend,"fg":"MixBlend","box":function ($v) { return Bridge.box($v, Spine.MixBlend, System.Enum.toStringFn(Spine.MixBlend));}},"s":{"a":2,"n":"set_MixBlend","t":8,"p":[$n[9].MixBlend],"rt":$n[0].Void,"fs":"MixBlend"},"fn":"MixBlend"},{"a":2,"n":"MixDuration","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixDuration","t":8,"rt":$n[0].Single,"fg":"MixDuration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixDuration","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixDuration"},"fn":"MixDuration"},{"a":2,"n":"MixTime","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixTime","t":8,"rt":$n[0].Single,"fg":"MixTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixTime","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixTime"},"fn":"MixTime"},{"a":2,"n":"MixingFrom","t":16,"rt":$n[9].TrackEntry,"g":{"a":2,"n":"get_MixingFrom","t":8,"rt":$n[9].TrackEntry,"fg":"MixingFrom"},"fn":"MixingFrom"},{"a":2,"n":"MixingTo","t":16,"rt":$n[9].TrackEntry,"g":{"a":2,"n":"get_MixingTo","t":8,"rt":$n[9].TrackEntry,"fg":"MixingTo"},"fn":"MixingTo"},{"a":2,"n":"Next","t":16,"rt":$n[9].TrackEntry,"g":{"a":2,"n":"get_Next","t":8,"rt":$n[9].TrackEntry,"fg":"Next"},"fn":"Next"},{"a":2,"n":"TimeScale","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_TimeScale","t":8,"rt":$n[0].Single,"fg":"TimeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_TimeScale","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"TimeScale"},"fn":"TimeScale"},{"a":2,"n":"TrackEnd","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_TrackEnd","t":8,"rt":$n[0].Single,"fg":"TrackEnd","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_TrackEnd","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"TrackEnd"},"fn":"TrackEnd"},{"a":2,"n":"TrackIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_TrackIndex","t":8,"rt":$n[0].Int32,"fg":"TrackIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"TrackIndex"},{"a":2,"n":"TrackTime","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_TrackTime","t":8,"rt":$n[0].Single,"fg":"TrackTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_TrackTime","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"TrackTime"},"fn":"TrackTime"},{"a":4,"n":"alpha","t":4,"rt":$n[0].Single,"sn":"alpha","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"animation","t":4,"rt":$n[9].Animation,"sn":"animation"},{"a":4,"n":"animationEnd","t":4,"rt":$n[0].Single,"sn":"animationEnd","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"animationLast","t":4,"rt":$n[0].Single,"sn":"animationLast","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"animationStart","t":4,"rt":$n[0].Single,"sn":"animationStart","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"attachmentThreshold","t":4,"rt":$n[0].Single,"sn":"attachmentThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"delay","t":4,"rt":$n[0].Single,"sn":"delay","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"drawOrderThreshold","t":4,"rt":$n[0].Single,"sn":"drawOrderThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"eventThreshold","t":4,"rt":$n[0].Single,"sn":"eventThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"holdPrevious","t":4,"rt":$n[0].Boolean,"sn":"holdPrevious","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"interruptAlpha","t":4,"rt":$n[0].Single,"sn":"interruptAlpha","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"loop","t":4,"rt":$n[0].Boolean,"sn":"loop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"mixBlend","t":4,"rt":$n[9].MixBlend,"sn":"mixBlend","box":function ($v) { return Bridge.box($v, Spine.MixBlend, System.Enum.toStringFn(Spine.MixBlend));}},{"a":4,"n":"mixDuration","t":4,"rt":$n[0].Single,"sn":"mixDuration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixTime","t":4,"rt":$n[0].Single,"sn":"mixTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixingFrom","t":4,"rt":$n[9].TrackEntry,"sn":"mixingFrom"},{"a":4,"n":"mixingTo","t":4,"rt":$n[9].TrackEntry,"sn":"mixingTo"},{"a":4,"n":"next","t":4,"rt":$n[9].TrackEntry,"sn":"next"},{"a":4,"n":"nextAnimationLast","t":4,"rt":$n[0].Single,"sn":"nextAnimationLast","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"nextTrackLast","t":4,"rt":$n[0].Single,"sn":"nextTrackLast","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"timeScale","t":4,"rt":$n[0].Single,"sn":"timeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"timelineHoldMix","t":4,"rt":$n[9].ExposedList$1(Spine.TrackEntry),"sn":"timelineHoldMix","ro":true},{"a":4,"n":"timelineMode","t":4,"rt":$n[9].ExposedList$1(System.Int32),"sn":"timelineMode","ro":true},{"a":4,"n":"timelinesRotation","t":4,"rt":$n[9].ExposedList$1(System.Single),"sn":"timelinesRotation","ro":true},{"a":4,"n":"totalAlpha","t":4,"rt":$n[0].Single,"sn":"totalAlpha","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"trackEnd","t":4,"rt":$n[0].Single,"sn":"trackEnd","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"trackIndex","t":4,"rt":$n[0].Int32,"sn":"trackIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"trackLast","t":4,"rt":$n[0].Single,"sn":"trackLast","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"trackTime","t":4,"rt":$n[0].Single,"sn":"trackTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Complete","t":2,"ad":{"a":2,"n":"add_Complete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Complete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"Dispose","t":2,"ad":{"a":2,"n":"add_Dispose","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addDispose","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Dispose","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeDispose","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"End","t":2,"ad":{"a":2,"n":"add_End","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addEnd","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_End","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeEnd","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"Event","t":2,"ad":{"a":2,"n":"add_Event","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addEvent","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Event","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeEvent","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"Interrupt","t":2,"ad":{"a":2,"n":"add_Interrupt","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addInterrupt","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Interrupt","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeInterrupt","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"Start","t":2,"ad":{"a":2,"n":"add_Start","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addStart","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Start","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeStart","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.TrackEntry end.*/

    /*Spine.EventQueue start.*/
    $m("Spine.EventQueue", function () { return {"nested":[$n[9].EventQueue.EventQueueEntry,$n[9].EventQueue.EventType],"att":1048576,"a":4,"m":[{"a":4,"n":".ctor","t":1,"p":[$n[9].AnimationState,Function,$n[9].Pool$1(Spine.TrackEntry)],"pi":[{"n":"state","pt":$n[9].AnimationState,"ps":0},{"n":"HandleAnimationsChanged","pt":Function,"ps":1},{"n":"trackEntryPool","pt":$n[9].Pool$1(Spine.TrackEntry),"ps":2}],"sn":"ctor"},{"a":4,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":4,"n":"Complete","t":8,"pi":[{"n":"entry","pt":$n[9].TrackEntry,"ps":0}],"sn":"Complete","rt":$n[0].Void,"p":[$n[9].TrackEntry]},{"a":4,"n":"Dispose","t":8,"pi":[{"n":"entry","pt":$n[9].TrackEntry,"ps":0}],"sn":"Dispose","rt":$n[0].Void,"p":[$n[9].TrackEntry]},{"a":4,"n":"Drain","t":8,"sn":"Drain","rt":$n[0].Void},{"a":4,"n":"End","t":8,"pi":[{"n":"entry","pt":$n[9].TrackEntry,"ps":0}],"sn":"End","rt":$n[0].Void,"p":[$n[9].TrackEntry]},{"a":4,"n":"Event","t":8,"pi":[{"n":"entry","pt":$n[9].TrackEntry,"ps":0},{"n":"e","pt":$n[9].Event,"ps":1}],"sn":"Event","rt":$n[0].Void,"p":[$n[9].TrackEntry,$n[9].Event]},{"a":4,"n":"Interrupt","t":8,"pi":[{"n":"entry","pt":$n[9].TrackEntry,"ps":0}],"sn":"Interrupt","rt":$n[0].Void,"p":[$n[9].TrackEntry]},{"a":4,"n":"Start","t":8,"pi":[{"n":"entry","pt":$n[9].TrackEntry,"ps":0}],"sn":"Start","rt":$n[0].Void,"p":[$n[9].TrackEntry]},{"a":4,"n":"drainDisabled","t":4,"rt":$n[0].Boolean,"sn":"drainDisabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"eventQueueEntries","t":4,"rt":$n[5].List$1(Spine.EventQueue.EventQueueEntry),"sn":"eventQueueEntries","ro":true},{"a":1,"n":"state","t":4,"rt":$n[9].AnimationState,"sn":"state","ro":true},{"a":1,"n":"trackEntryPool","t":4,"rt":$n[9].Pool$1(Spine.TrackEntry),"sn":"trackEntryPool","ro":true},{"a":4,"n":"AnimationsChanged","t":2,"ad":{"a":4,"n":"add_AnimationsChanged","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addAnimationsChanged","rt":$n[0].Void,"p":[Function]},"r":{"a":4,"n":"remove_AnimationsChanged","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeAnimationsChanged","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.EventQueue end.*/

    /*Spine.EventQueue+EventQueueEntry start.*/
    $m("Spine.EventQueue.EventQueueEntry", function () { return {"td":$n[9].EventQueue,"att":1048843,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[9].EventQueue.EventType,$n[9].TrackEntry,$n[9].Event],"pi":[{"n":"eventType","pt":$n[9].EventQueue.EventType,"ps":0},{"n":"trackEntry","pt":$n[9].TrackEntry,"ps":1},{"n":"e","dv":null,"o":true,"pt":$n[9].Event,"ps":2}],"sn":"$ctor1"},{"a":2,"n":"e","t":4,"rt":$n[9].Event,"sn":"e"},{"a":2,"n":"entry","t":4,"rt":$n[9].TrackEntry,"sn":"entry"},{"a":2,"n":"type","t":4,"rt":$n[9].EventQueue.EventType,"sn":"type","box":function ($v) { return Bridge.box($v, Spine.EventQueue.EventType, System.Enum.toStringFn(Spine.EventQueue.EventType));}}]}; }, $n);
    /*Spine.EventQueue+EventQueueEntry end.*/

    /*Spine.EventQueue+EventType start.*/
    $m("Spine.EventQueue.EventType", function () { return {"td":$n[9].EventQueue,"att":259,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Complete","is":true,"t":4,"rt":$n[9].EventQueue.EventType,"sn":"Complete","box":function ($v) { return Bridge.box($v, Spine.EventQueue.EventType, System.Enum.toStringFn(Spine.EventQueue.EventType));}},{"a":2,"n":"Dispose","is":true,"t":4,"rt":$n[9].EventQueue.EventType,"sn":"Dispose","box":function ($v) { return Bridge.box($v, Spine.EventQueue.EventType, System.Enum.toStringFn(Spine.EventQueue.EventType));}},{"a":2,"n":"End","is":true,"t":4,"rt":$n[9].EventQueue.EventType,"sn":"End","box":function ($v) { return Bridge.box($v, Spine.EventQueue.EventType, System.Enum.toStringFn(Spine.EventQueue.EventType));}},{"a":2,"n":"Event","is":true,"t":4,"rt":$n[9].EventQueue.EventType,"sn":"Event","box":function ($v) { return Bridge.box($v, Spine.EventQueue.EventType, System.Enum.toStringFn(Spine.EventQueue.EventType));}},{"a":2,"n":"Interrupt","is":true,"t":4,"rt":$n[9].EventQueue.EventType,"sn":"Interrupt","box":function ($v) { return Bridge.box($v, Spine.EventQueue.EventType, System.Enum.toStringFn(Spine.EventQueue.EventType));}},{"a":2,"n":"Start","is":true,"t":4,"rt":$n[9].EventQueue.EventType,"sn":"Start","box":function ($v) { return Bridge.box($v, Spine.EventQueue.EventType, System.Enum.toStringFn(Spine.EventQueue.EventType));}}]}; }, $n);
    /*Spine.EventQueue+EventType end.*/

    /*Spine.Pool$1 start.*/
    $m("Spine.Pool$1", function (T) { return {"nested":[$n[9].Pool$1.IPoolable],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32],"pi":[{"n":"initialCapacity","dv":16,"o":true,"pt":$n[0].Int32,"ps":0},{"n":"max","dv":2147483647,"o":true,"pt":$n[0].Int32,"ps":1}],"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Free","t":8,"pi":[{"n":"obj","pt":T,"ps":0}],"sn":"Free","rt":$n[0].Void,"p":[T]},{"a":2,"n":"Obtain","t":8,"sn":"Obtain","rt":T},{"a":3,"n":"Reset","t":8,"pi":[{"n":"obj","pt":T,"ps":0}],"sn":"Reset","rt":$n[0].Void,"p":[T]},{"a":2,"n":"Count","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Count","t":8,"rt":$n[0].Int32,"fg":"Count","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Count"},{"a":2,"n":"Peak","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Peak","t":8,"rt":$n[0].Int32,"fg":"Peak","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":1,"n":"set_Peak","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Peak"},"fn":"Peak"},{"a":1,"n":"freeObjects","t":4,"rt":$n[5].Stack$1(T),"sn":"freeObjects","ro":true},{"a":2,"n":"max","t":4,"rt":$n[0].Int32,"sn":"max","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"backing":true,"n":"<Peak>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"Peak","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Pool$1 end.*/

    /*Spine.Pool$1+IPoolable start.*/
    $m("Spine.Pool$1.IPoolable", function (T) { return {"td":$n[9].Pool$1(T),"att":162,"a":2,"m":[{"ab":true,"a":2,"n":"Reset","t":8,"sn":"Spine$Pool$1$IPoolable$" + Bridge.getTypeAlias(T) + "$Reset","rt":$n[0].Void}]}; }, $n);
    /*Spine.Pool$1+IPoolable end.*/

    /*Spine.AnimationStateData start.*/
    $m("Spine.AnimationStateData", function () { return {"nested":[$n[9].AnimationStateData.AnimationPair,$n[9].AnimationStateData.AnimationPairComparer],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[9].SkeletonData],"pi":[{"n":"skeletonData","pt":$n[9].SkeletonData,"ps":0}],"sn":"ctor"},{"a":2,"n":"GetMix","t":8,"pi":[{"n":"from","pt":$n[9].Animation,"ps":0},{"n":"to","pt":$n[9].Animation,"ps":1}],"sn":"GetMix","rt":$n[0].Single,"p":[$n[9].Animation,$n[9].Animation],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"SetMix","t":8,"pi":[{"n":"from","pt":$n[9].Animation,"ps":0},{"n":"to","pt":$n[9].Animation,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"SetMix","rt":$n[0].Void,"p":[$n[9].Animation,$n[9].Animation,$n[0].Single]},{"a":2,"n":"SetMix","t":8,"pi":[{"n":"fromName","pt":$n[0].String,"ps":0},{"n":"toName","pt":$n[0].String,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"SetMix$1","rt":$n[0].Void,"p":[$n[0].String,$n[0].String,$n[0].Single]},{"a":2,"n":"DefaultMix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_DefaultMix","t":8,"rt":$n[0].Single,"fg":"DefaultMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_DefaultMix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"DefaultMix"},"fn":"DefaultMix"},{"a":2,"n":"SkeletonData","t":16,"rt":$n[9].SkeletonData,"g":{"a":2,"n":"get_SkeletonData","t":8,"rt":$n[9].SkeletonData,"fg":"SkeletonData"},"fn":"SkeletonData"},{"a":1,"n":"animationToMixTime","t":4,"rt":$n[5].Dictionary$2(Spine.AnimationStateData.AnimationPair,System.Single),"sn":"animationToMixTime","ro":true},{"a":4,"n":"defaultMix","t":4,"rt":$n[0].Single,"sn":"defaultMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"skeletonData","t":4,"rt":$n[9].SkeletonData,"sn":"skeletonData"}]}; }, $n);
    /*Spine.AnimationStateData end.*/

    /*Spine.AnimationStateData+AnimationPair start.*/
    $m("Spine.AnimationStateData.AnimationPair", function () { return {"td":$n[9].AnimationStateData,"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[9].Animation,$n[9].Animation],"pi":[{"n":"a1","pt":$n[9].Animation,"ps":0},{"n":"a2","pt":$n[9].Animation,"ps":1}],"sn":"$ctor1"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"a1","t":4,"rt":$n[9].Animation,"sn":"a1","ro":true},{"a":2,"n":"a2","t":4,"rt":$n[9].Animation,"sn":"a2","ro":true}]}; }, $n);
    /*Spine.AnimationStateData+AnimationPair end.*/

    /*Spine.AnimationStateData+AnimationPairComparer start.*/
    $m("Spine.AnimationStateData.AnimationPairComparer", function () { return {"td":$n[9].AnimationStateData,"att":1048578,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Instance","is":true,"t":4,"rt":$n[9].AnimationStateData.AnimationPairComparer,"sn":"Instance","ro":true}]}; }, $n);
    /*Spine.AnimationStateData+AnimationPairComparer end.*/

    /*Spine.Atlas start.*/
    $m("Spine.Atlas", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[5].List$1(Spine.AtlasPage),$n[5].List$1(Spine.AtlasRegion)],"pi":[{"n":"pages","pt":$n[5].List$1(Spine.AtlasPage),"ps":0},{"n":"regions","pt":$n[5].List$1(Spine.AtlasRegion),"ps":1}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[10].TextReader,$n[0].String,$n[9].TextureLoader],"pi":[{"n":"reader","pt":$n[10].TextReader,"ps":0},{"n":"dir","pt":$n[0].String,"ps":1},{"n":"textureLoader","pt":$n[9].TextureLoader,"ps":2}],"sn":"$ctor1"},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"FindRegion","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"FindRegion","rt":$n[9].AtlasRegion,"p":[$n[0].String]},{"a":2,"n":"FlipV","t":8,"sn":"FlipV","rt":$n[0].Void},{"a":2,"n":"GetEnumerator","t":8,"sn":"GetEnumerator","rt":$n[5].IEnumerator$1(Spine.AtlasRegion)},{"a":1,"n":"Load","t":8,"pi":[{"n":"reader","pt":$n[10].TextReader,"ps":0},{"n":"imagesDir","pt":$n[0].String,"ps":1},{"n":"textureLoader","pt":$n[9].TextureLoader,"ps":2}],"sn":"Load","rt":$n[0].Void,"p":[$n[10].TextReader,$n[0].String,$n[9].TextureLoader]},{"a":1,"n":"ReadTuple","is":true,"t":8,"pi":[{"n":"reader","pt":$n[10].TextReader,"ps":0},{"n":"tuple","pt":$n[0].Array.type(System.String),"ps":1}],"sn":"ReadTuple","rt":$n[0].Int32,"p":[$n[10].TextReader,$n[0].Array.type(System.String)],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"ReadValue","is":true,"t":8,"pi":[{"n":"reader","pt":$n[10].TextReader,"ps":0}],"sn":"ReadValue","rt":$n[0].String,"p":[$n[10].TextReader]},{"a":2,"n":"Pages","t":16,"rt":$n[5].List$1(Spine.AtlasPage),"g":{"a":2,"n":"get_Pages","t":8,"rt":$n[5].List$1(Spine.AtlasPage),"fg":"Pages"},"fn":"Pages"},{"a":2,"n":"Regions","t":16,"rt":$n[5].List$1(Spine.AtlasRegion),"g":{"a":2,"n":"get_Regions","t":8,"rt":$n[5].List$1(Spine.AtlasRegion),"fg":"Regions"},"fn":"Regions"},{"a":1,"n":"pages","t":4,"rt":$n[5].List$1(Spine.AtlasPage),"sn":"pages","ro":true},{"a":1,"n":"regions","t":4,"rt":$n[5].List$1(Spine.AtlasRegion),"sn":"regions"},{"a":1,"n":"textureLoader","t":4,"rt":$n[9].TextureLoader,"sn":"textureLoader"}]}; }, $n);
    /*Spine.Atlas end.*/

    /*Spine.Format start.*/
    $m("Spine.Format", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Alpha","is":true,"t":4,"rt":$n[9].Format,"sn":"Alpha","box":function ($v) { return Bridge.box($v, Spine.Format, System.Enum.toStringFn(Spine.Format));}},{"a":2,"n":"Intensity","is":true,"t":4,"rt":$n[9].Format,"sn":"Intensity","box":function ($v) { return Bridge.box($v, Spine.Format, System.Enum.toStringFn(Spine.Format));}},{"a":2,"n":"LuminanceAlpha","is":true,"t":4,"rt":$n[9].Format,"sn":"LuminanceAlpha","box":function ($v) { return Bridge.box($v, Spine.Format, System.Enum.toStringFn(Spine.Format));}},{"a":2,"n":"RGB565","is":true,"t":4,"rt":$n[9].Format,"sn":"RGB565","box":function ($v) { return Bridge.box($v, Spine.Format, System.Enum.toStringFn(Spine.Format));}},{"a":2,"n":"RGB888","is":true,"t":4,"rt":$n[9].Format,"sn":"RGB888","box":function ($v) { return Bridge.box($v, Spine.Format, System.Enum.toStringFn(Spine.Format));}},{"a":2,"n":"RGBA4444","is":true,"t":4,"rt":$n[9].Format,"sn":"RGBA4444","box":function ($v) { return Bridge.box($v, Spine.Format, System.Enum.toStringFn(Spine.Format));}},{"a":2,"n":"RGBA8888","is":true,"t":4,"rt":$n[9].Format,"sn":"RGBA8888","box":function ($v) { return Bridge.box($v, Spine.Format, System.Enum.toStringFn(Spine.Format));}}]}; }, $n);
    /*Spine.Format end.*/

    /*Spine.TextureFilter start.*/
    $m("Spine.TextureFilter", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Linear","is":true,"t":4,"rt":$n[9].TextureFilter,"sn":"Linear","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}},{"a":2,"n":"MipMap","is":true,"t":4,"rt":$n[9].TextureFilter,"sn":"MipMap","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}},{"a":2,"n":"MipMapLinearLinear","is":true,"t":4,"rt":$n[9].TextureFilter,"sn":"MipMapLinearLinear","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}},{"a":2,"n":"MipMapLinearNearest","is":true,"t":4,"rt":$n[9].TextureFilter,"sn":"MipMapLinearNearest","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}},{"a":2,"n":"MipMapNearestLinear","is":true,"t":4,"rt":$n[9].TextureFilter,"sn":"MipMapNearestLinear","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}},{"a":2,"n":"MipMapNearestNearest","is":true,"t":4,"rt":$n[9].TextureFilter,"sn":"MipMapNearestNearest","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}},{"a":2,"n":"Nearest","is":true,"t":4,"rt":$n[9].TextureFilter,"sn":"Nearest","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}}]}; }, $n);
    /*Spine.TextureFilter end.*/

    /*Spine.TextureWrap start.*/
    $m("Spine.TextureWrap", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ClampToEdge","is":true,"t":4,"rt":$n[9].TextureWrap,"sn":"ClampToEdge","box":function ($v) { return Bridge.box($v, Spine.TextureWrap, System.Enum.toStringFn(Spine.TextureWrap));}},{"a":2,"n":"MirroredRepeat","is":true,"t":4,"rt":$n[9].TextureWrap,"sn":"MirroredRepeat","box":function ($v) { return Bridge.box($v, Spine.TextureWrap, System.Enum.toStringFn(Spine.TextureWrap));}},{"a":2,"n":"Repeat","is":true,"t":4,"rt":$n[9].TextureWrap,"sn":"Repeat","box":function ($v) { return Bridge.box($v, Spine.TextureWrap, System.Enum.toStringFn(Spine.TextureWrap));}}]}; }, $n);
    /*Spine.TextureWrap end.*/

    /*Spine.AtlasPage start.*/
    $m("Spine.AtlasPage", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clone","t":8,"sn":"Clone","rt":$n[9].AtlasPage},{"a":2,"n":"format","t":4,"rt":$n[9].Format,"sn":"format","box":function ($v) { return Bridge.box($v, Spine.Format, System.Enum.toStringFn(Spine.Format));}},{"a":2,"n":"height","t":4,"rt":$n[0].Int32,"sn":"height","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"magFilter","t":4,"rt":$n[9].TextureFilter,"sn":"magFilter","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}},{"a":2,"n":"minFilter","t":4,"rt":$n[9].TextureFilter,"sn":"minFilter","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}},{"a":2,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":2,"n":"rendererObject","t":4,"rt":$n[0].Object,"sn":"rendererObject"},{"a":2,"n":"uWrap","t":4,"rt":$n[9].TextureWrap,"sn":"uWrap","box":function ($v) { return Bridge.box($v, Spine.TextureWrap, System.Enum.toStringFn(Spine.TextureWrap));}},{"a":2,"n":"vWrap","t":4,"rt":$n[9].TextureWrap,"sn":"vWrap","box":function ($v) { return Bridge.box($v, Spine.TextureWrap, System.Enum.toStringFn(Spine.TextureWrap));}},{"a":2,"n":"width","t":4,"rt":$n[0].Int32,"sn":"width","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.AtlasPage end.*/

    /*Spine.AtlasRegion start.*/
    $m("Spine.AtlasRegion", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clone","t":8,"sn":"Clone","rt":$n[9].AtlasRegion},{"a":2,"n":"degrees","t":4,"rt":$n[0].Int32,"sn":"degrees","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"height","t":4,"rt":$n[0].Int32,"sn":"height","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"index","t":4,"rt":$n[0].Int32,"sn":"index","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":2,"n":"offsetX","t":4,"rt":$n[0].Single,"sn":"offsetX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"offsetY","t":4,"rt":$n[0].Single,"sn":"offsetY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"originalHeight","t":4,"rt":$n[0].Int32,"sn":"originalHeight","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"originalWidth","t":4,"rt":$n[0].Int32,"sn":"originalWidth","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"pads","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"pads"},{"a":2,"n":"page","t":4,"rt":$n[9].AtlasPage,"sn":"page"},{"a":2,"n":"rotate","t":4,"rt":$n[0].Boolean,"sn":"rotate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"splits","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"splits"},{"a":2,"n":"u","t":4,"rt":$n[0].Single,"sn":"u","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"u2","t":4,"rt":$n[0].Single,"sn":"u2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"v","t":4,"rt":$n[0].Single,"sn":"v","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"v2","t":4,"rt":$n[0].Single,"sn":"v2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"width","t":4,"rt":$n[0].Int32,"sn":"width","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"x","t":4,"rt":$n[0].Int32,"sn":"x","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"y","t":4,"rt":$n[0].Int32,"sn":"y","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.AtlasRegion end.*/

    /*Spine.TextureLoader start.*/
    $m("Spine.TextureLoader", function () { return {"att":161,"a":2,"m":[{"ab":true,"a":2,"n":"Load","t":8,"pi":[{"n":"page","pt":$n[9].AtlasPage,"ps":0},{"n":"path","pt":$n[0].String,"ps":1}],"sn":"Spine$TextureLoader$Load","rt":$n[0].Void,"p":[$n[9].AtlasPage,$n[0].String]},{"ab":true,"a":2,"n":"Unload","t":8,"pi":[{"n":"texture","pt":$n[0].Object,"ps":0}],"sn":"Spine$TextureLoader$Unload","rt":$n[0].Void,"p":[$n[0].Object]}]}; }, $n);
    /*Spine.TextureLoader end.*/

    /*Spine.AtlasAttachmentLoader start.*/
    $m("Spine.AtlasAttachmentLoader", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[System.Array.type(Spine.Atlas)],"pi":[{"n":"atlasArray","ip":true,"pt":System.Array.type(Spine.Atlas),"ps":0}],"sn":"ctor"},{"a":2,"n":"FindRegion","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"FindRegion","rt":$n[9].AtlasRegion,"p":[$n[0].String]},{"a":2,"n":"NewBoundingBoxAttachment","t":8,"pi":[{"n":"skin","pt":$n[9].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewBoundingBoxAttachment","rt":$n[9].BoundingBoxAttachment,"p":[$n[9].Skin,$n[0].String]},{"a":2,"n":"NewClippingAttachment","t":8,"pi":[{"n":"skin","pt":$n[9].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewClippingAttachment","rt":$n[9].ClippingAttachment,"p":[$n[9].Skin,$n[0].String]},{"a":2,"n":"NewMeshAttachment","t":8,"pi":[{"n":"skin","pt":$n[9].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2}],"sn":"NewMeshAttachment","rt":$n[9].MeshAttachment,"p":[$n[9].Skin,$n[0].String,$n[0].String]},{"a":2,"n":"NewPathAttachment","t":8,"pi":[{"n":"skin","pt":$n[9].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewPathAttachment","rt":$n[9].PathAttachment,"p":[$n[9].Skin,$n[0].String]},{"a":2,"n":"NewPointAttachment","t":8,"pi":[{"n":"skin","pt":$n[9].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewPointAttachment","rt":$n[9].PointAttachment,"p":[$n[9].Skin,$n[0].String]},{"a":2,"n":"NewRegionAttachment","t":8,"pi":[{"n":"skin","pt":$n[9].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2}],"sn":"NewRegionAttachment","rt":$n[9].RegionAttachment,"p":[$n[9].Skin,$n[0].String,$n[0].String]},{"a":1,"n":"atlasArray","t":4,"rt":System.Array.type(Spine.Atlas),"sn":"atlasArray"}]}; }, $n);
    /*Spine.AtlasAttachmentLoader end.*/

    /*Spine.Attachment start.*/
    $m("Spine.Attachment", function () { return {"att":1048705,"a":2,"m":[{"a":3,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"ab":true,"a":2,"n":"Copy","t":8,"sn":"Copy","rt":$n[9].Attachment},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"s":{"a":1,"n":"set_Name","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"Name"},"fn":"Name"},{"a":1,"backing":true,"n":"<Name>k__BackingField","t":4,"rt":$n[0].String,"sn":"Name"}]}; }, $n);
    /*Spine.Attachment end.*/

    /*Spine.IHasRendererObject start.*/
    $m("Spine.IHasRendererObject", function () { return {"att":161,"a":2,"m":[{"ab":true,"a":2,"n":"RendererObject","t":16,"rt":$n[0].Object,"g":{"ab":true,"a":2,"n":"get_RendererObject","t":8,"rt":$n[0].Object,"fg":"Spine$IHasRendererObject$RendererObject"},"s":{"ab":true,"a":2,"n":"set_RendererObject","t":8,"p":[$n[0].Object],"rt":$n[0].Void,"fs":"Spine$IHasRendererObject$RendererObject"},"fn":"Spine$IHasRendererObject$RendererObject"},{"a":1,"backing":true,"n":"<RendererObject>k__BackingField","t":4,"rt":$n[0].Object,"sn":"Spine$IHasRendererObject$RendererObject"}]}; }, $n);
    /*Spine.IHasRendererObject end.*/

    /*Spine.AttachmentLoader start.*/
    $m("Spine.AttachmentLoader", function () { return {"att":161,"a":2,"m":[{"ab":true,"a":2,"n":"NewBoundingBoxAttachment","t":8,"pi":[{"n":"skin","pt":$n[9].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"Spine$AttachmentLoader$NewBoundingBoxAttachment","rt":$n[9].BoundingBoxAttachment,"p":[$n[9].Skin,$n[0].String]},{"ab":true,"a":2,"n":"NewClippingAttachment","t":8,"pi":[{"n":"skin","pt":$n[9].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"Spine$AttachmentLoader$NewClippingAttachment","rt":$n[9].ClippingAttachment,"p":[$n[9].Skin,$n[0].String]},{"ab":true,"a":2,"n":"NewMeshAttachment","t":8,"pi":[{"n":"skin","pt":$n[9].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2}],"sn":"Spine$AttachmentLoader$NewMeshAttachment","rt":$n[9].MeshAttachment,"p":[$n[9].Skin,$n[0].String,$n[0].String]},{"ab":true,"a":2,"n":"NewPathAttachment","t":8,"pi":[{"n":"skin","pt":$n[9].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"Spine$AttachmentLoader$NewPathAttachment","rt":$n[9].PathAttachment,"p":[$n[9].Skin,$n[0].String]},{"ab":true,"a":2,"n":"NewPointAttachment","t":8,"pi":[{"n":"skin","pt":$n[9].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"Spine$AttachmentLoader$NewPointAttachment","rt":$n[9].PointAttachment,"p":[$n[9].Skin,$n[0].String]},{"ab":true,"a":2,"n":"NewRegionAttachment","t":8,"pi":[{"n":"skin","pt":$n[9].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2}],"sn":"Spine$AttachmentLoader$NewRegionAttachment","rt":$n[9].RegionAttachment,"p":[$n[9].Skin,$n[0].String,$n[0].String]}]}; }, $n);
    /*Spine.AttachmentLoader end.*/

    /*Spine.AttachmentType start.*/
    $m("Spine.AttachmentType", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Boundingbox","is":true,"t":4,"rt":$n[9].AttachmentType,"sn":"Boundingbox","box":function ($v) { return Bridge.box($v, Spine.AttachmentType, System.Enum.toStringFn(Spine.AttachmentType));}},{"a":2,"n":"Clipping","is":true,"t":4,"rt":$n[9].AttachmentType,"sn":"Clipping","box":function ($v) { return Bridge.box($v, Spine.AttachmentType, System.Enum.toStringFn(Spine.AttachmentType));}},{"a":2,"n":"Linkedmesh","is":true,"t":4,"rt":$n[9].AttachmentType,"sn":"Linkedmesh","box":function ($v) { return Bridge.box($v, Spine.AttachmentType, System.Enum.toStringFn(Spine.AttachmentType));}},{"a":2,"n":"Mesh","is":true,"t":4,"rt":$n[9].AttachmentType,"sn":"Mesh","box":function ($v) { return Bridge.box($v, Spine.AttachmentType, System.Enum.toStringFn(Spine.AttachmentType));}},{"a":2,"n":"Path","is":true,"t":4,"rt":$n[9].AttachmentType,"sn":"Path","box":function ($v) { return Bridge.box($v, Spine.AttachmentType, System.Enum.toStringFn(Spine.AttachmentType));}},{"a":2,"n":"Point","is":true,"t":4,"rt":$n[9].AttachmentType,"sn":"Point","box":function ($v) { return Bridge.box($v, Spine.AttachmentType, System.Enum.toStringFn(Spine.AttachmentType));}},{"a":2,"n":"Region","is":true,"t":4,"rt":$n[9].AttachmentType,"sn":"Region","box":function ($v) { return Bridge.box($v, Spine.AttachmentType, System.Enum.toStringFn(Spine.AttachmentType));}}]}; }, $n);
    /*Spine.AttachmentType end.*/

    /*Spine.BoundingBoxAttachment start.*/
    $m("Spine.BoundingBoxAttachment", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Copy","t":8,"sn":"Copy","rt":$n[9].Attachment}]}; }, $n);
    /*Spine.BoundingBoxAttachment end.*/

    /*Spine.ClippingAttachment start.*/
    $m("Spine.ClippingAttachment", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Copy","t":8,"sn":"Copy","rt":$n[9].Attachment},{"a":2,"n":"EndSlot","t":16,"rt":$n[9].SlotData,"g":{"a":2,"n":"get_EndSlot","t":8,"rt":$n[9].SlotData,"fg":"EndSlot"},"s":{"a":2,"n":"set_EndSlot","t":8,"p":[$n[9].SlotData],"rt":$n[0].Void,"fs":"EndSlot"},"fn":"EndSlot"},{"a":4,"n":"endSlot","t":4,"rt":$n[9].SlotData,"sn":"endSlot"}]}; }, $n);
    /*Spine.ClippingAttachment end.*/

    /*Spine.MeshAttachment start.*/
    $m("Spine.MeshAttachment", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Copy","t":8,"sn":"Copy","rt":$n[9].Attachment},{"a":2,"n":"NewLinkedMesh","t":8,"sn":"NewLinkedMesh","rt":$n[9].MeshAttachment},{"a":2,"n":"UpdateUVs","t":8,"sn":"UpdateUVs","rt":$n[0].Void},{"a":2,"n":"A","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_A","t":8,"rt":$n[0].Single,"fg":"A","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_A","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"A"},"fn":"A"},{"a":2,"n":"B","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_B","t":8,"rt":$n[0].Single,"fg":"B","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_B","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"B"},"fn":"B"},{"a":2,"n":"Edges","t":16,"rt":$n[0].Array.type(System.Int32),"g":{"a":2,"n":"get_Edges","t":8,"rt":$n[0].Array.type(System.Int32),"fg":"Edges"},"s":{"a":2,"n":"set_Edges","t":8,"p":[$n[0].Array.type(System.Int32)],"rt":$n[0].Void,"fs":"Edges"},"fn":"Edges"},{"a":2,"n":"G","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_G","t":8,"rt":$n[0].Single,"fg":"G","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_G","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"G"},"fn":"G"},{"a":2,"n":"Height","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Height","t":8,"rt":$n[0].Single,"fg":"Height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Height","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Height"},"fn":"Height"},{"a":2,"n":"HullLength","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_HullLength","t":8,"rt":$n[0].Int32,"fg":"HullLength","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_HullLength","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"HullLength"},"fn":"HullLength"},{"a":2,"n":"ParentMesh","t":16,"rt":$n[9].MeshAttachment,"g":{"a":2,"n":"get_ParentMesh","t":8,"rt":$n[9].MeshAttachment,"fg":"ParentMesh"},"s":{"a":2,"n":"set_ParentMesh","t":8,"p":[$n[9].MeshAttachment],"rt":$n[0].Void,"fs":"ParentMesh"},"fn":"ParentMesh"},{"a":2,"n":"Path","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Path","t":8,"rt":$n[0].String,"fg":"Path"},"s":{"a":2,"n":"set_Path","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"Path"},"fn":"Path"},{"a":2,"n":"R","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_R","t":8,"rt":$n[0].Single,"fg":"R","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_R","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"R"},"fn":"R"},{"a":2,"n":"RegionDegrees","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_RegionDegrees","t":8,"rt":$n[0].Int32,"fg":"RegionDegrees","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_RegionDegrees","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"RegionDegrees"},"fn":"RegionDegrees"},{"a":2,"n":"RegionHeight","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RegionHeight","t":8,"rt":$n[0].Single,"fg":"RegionHeight","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RegionHeight","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RegionHeight"},"fn":"RegionHeight"},{"a":2,"n":"RegionOffsetX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RegionOffsetX","t":8,"rt":$n[0].Single,"fg":"RegionOffsetX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RegionOffsetX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RegionOffsetX"},"fn":"RegionOffsetX"},{"a":2,"n":"RegionOffsetY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RegionOffsetY","t":8,"rt":$n[0].Single,"fg":"RegionOffsetY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RegionOffsetY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RegionOffsetY"},"fn":"RegionOffsetY"},{"a":2,"n":"RegionOriginalHeight","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RegionOriginalHeight","t":8,"rt":$n[0].Single,"fg":"RegionOriginalHeight","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RegionOriginalHeight","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RegionOriginalHeight"},"fn":"RegionOriginalHeight"},{"a":2,"n":"RegionOriginalWidth","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RegionOriginalWidth","t":8,"rt":$n[0].Single,"fg":"RegionOriginalWidth","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RegionOriginalWidth","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RegionOriginalWidth"},"fn":"RegionOriginalWidth"},{"a":2,"n":"RegionRotate","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_RegionRotate","t":8,"rt":$n[0].Boolean,"fg":"RegionRotate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_RegionRotate","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"RegionRotate"},"fn":"RegionRotate"},{"a":2,"n":"RegionU","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RegionU","t":8,"rt":$n[0].Single,"fg":"RegionU","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RegionU","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RegionU"},"fn":"RegionU"},{"a":2,"n":"RegionU2","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RegionU2","t":8,"rt":$n[0].Single,"fg":"RegionU2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RegionU2","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RegionU2"},"fn":"RegionU2"},{"a":2,"n":"RegionUVs","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_RegionUVs","t":8,"rt":$n[0].Array.type(System.Single),"fg":"RegionUVs"},"s":{"a":2,"n":"set_RegionUVs","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"RegionUVs"},"fn":"RegionUVs"},{"a":2,"n":"RegionV","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RegionV","t":8,"rt":$n[0].Single,"fg":"RegionV","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RegionV","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RegionV"},"fn":"RegionV"},{"a":2,"n":"RegionV2","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RegionV2","t":8,"rt":$n[0].Single,"fg":"RegionV2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RegionV2","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RegionV2"},"fn":"RegionV2"},{"a":2,"n":"RegionWidth","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RegionWidth","t":8,"rt":$n[0].Single,"fg":"RegionWidth","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RegionWidth","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RegionWidth"},"fn":"RegionWidth"},{"a":2,"n":"RendererObject","t":16,"rt":$n[0].Object,"g":{"a":2,"n":"get_RendererObject","t":8,"rt":$n[0].Object,"fg":"RendererObject"},"s":{"a":2,"n":"set_RendererObject","t":8,"p":[$n[0].Object],"rt":$n[0].Void,"fs":"RendererObject"},"fn":"RendererObject"},{"a":2,"n":"Triangles","t":16,"rt":$n[0].Array.type(System.Int32),"g":{"a":2,"n":"get_Triangles","t":8,"rt":$n[0].Array.type(System.Int32),"fg":"Triangles"},"s":{"a":2,"n":"set_Triangles","t":8,"p":[$n[0].Array.type(System.Int32)],"rt":$n[0].Void,"fs":"Triangles"},"fn":"Triangles"},{"a":2,"n":"UVs","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_UVs","t":8,"rt":$n[0].Array.type(System.Single),"fg":"UVs"},"s":{"a":2,"n":"set_UVs","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"UVs"},"fn":"UVs"},{"a":2,"n":"Width","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Width","t":8,"rt":$n[0].Single,"fg":"Width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Width","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Width"},"fn":"Width"},{"a":4,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"g","t":4,"rt":$n[0].Single,"sn":"g","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"hulllength","t":4,"rt":$n[0].Int32,"sn":"hulllength","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"parentMesh","t":4,"rt":$n[9].MeshAttachment,"sn":"parentMesh"},{"a":4,"n":"r","t":4,"rt":$n[0].Single,"sn":"r","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"regionHeight","t":4,"rt":$n[0].Single,"sn":"regionHeight","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"regionOffsetX","t":4,"rt":$n[0].Single,"sn":"regionOffsetX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"regionOffsetY","t":4,"rt":$n[0].Single,"sn":"regionOffsetY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"regionOriginalHeight","t":4,"rt":$n[0].Single,"sn":"regionOriginalHeight","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"regionOriginalWidth","t":4,"rt":$n[0].Single,"sn":"regionOriginalWidth","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"regionUVs","t":4,"rt":$n[0].Array.type(System.Single),"sn":"regionUVs"},{"a":4,"n":"regionWidth","t":4,"rt":$n[0].Single,"sn":"regionWidth","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"triangles","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"triangles"},{"a":4,"n":"uvs","t":4,"rt":$n[0].Array.type(System.Single),"sn":"uvs"},{"a":1,"backing":true,"n":"<Edges>k__BackingField","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"Edges"},{"a":1,"backing":true,"n":"<Height>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<Path>k__BackingField","t":4,"rt":$n[0].String,"sn":"Path"},{"a":1,"backing":true,"n":"<RegionDegrees>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"RegionDegrees","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"backing":true,"n":"<RegionRotate>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"RegionRotate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"backing":true,"n":"<RegionU>k__BackingField","t":4,"rt":$n[0].Single,"sn":"RegionU","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<RegionU2>k__BackingField","t":4,"rt":$n[0].Single,"sn":"RegionU2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<RegionV>k__BackingField","t":4,"rt":$n[0].Single,"sn":"RegionV","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<RegionV2>k__BackingField","t":4,"rt":$n[0].Single,"sn":"RegionV2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<RendererObject>k__BackingField","t":4,"rt":$n[0].Object,"sn":"RendererObject"},{"a":1,"backing":true,"n":"<Width>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.MeshAttachment end.*/

    /*Spine.PathAttachment start.*/
    $m("Spine.PathAttachment", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Copy","t":8,"sn":"Copy","rt":$n[9].Attachment},{"a":2,"n":"Closed","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Closed","t":8,"rt":$n[0].Boolean,"fg":"Closed","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Closed","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Closed"},"fn":"Closed"},{"a":2,"n":"ConstantSpeed","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_ConstantSpeed","t":8,"rt":$n[0].Boolean,"fg":"ConstantSpeed","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_ConstantSpeed","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"ConstantSpeed"},"fn":"ConstantSpeed"},{"a":2,"n":"Lengths","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Lengths","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Lengths"},"s":{"a":2,"n":"set_Lengths","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Lengths"},"fn":"Lengths"},{"a":4,"n":"closed","t":4,"rt":$n[0].Boolean,"sn":"closed","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"constantSpeed","t":4,"rt":$n[0].Boolean,"sn":"constantSpeed","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"lengths","t":4,"rt":$n[0].Array.type(System.Single),"sn":"lengths"}]}; }, $n);
    /*Spine.PathAttachment end.*/

    /*Spine.PointAttachment start.*/
    $m("Spine.PointAttachment", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":"ComputeWorldPosition","t":8,"pi":[{"n":"bone","pt":$n[9].Bone,"ps":0},{"n":"ox","out":true,"pt":$n[0].Single,"ps":1},{"n":"oy","out":true,"pt":$n[0].Single,"ps":2}],"sn":"ComputeWorldPosition","rt":$n[0].Void,"p":[$n[9].Bone,$n[0].Single,$n[0].Single]},{"a":2,"n":"ComputeWorldRotation","t":8,"pi":[{"n":"bone","pt":$n[9].Bone,"ps":0}],"sn":"ComputeWorldRotation","rt":$n[0].Single,"p":[$n[9].Bone],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"ov":true,"a":2,"n":"Copy","t":8,"sn":"Copy","rt":$n[9].Attachment},{"a":2,"n":"Rotation","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Rotation","t":8,"rt":$n[0].Single,"fg":"Rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Rotation","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Rotation"},"fn":"Rotation"},{"a":2,"n":"X","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_X","t":8,"rt":$n[0].Single,"fg":"X","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_X","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"X"},"fn":"X"},{"a":2,"n":"Y","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Y","t":8,"rt":$n[0].Single,"fg":"Y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Y","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Y"},"fn":"Y"},{"a":4,"n":"rotation","t":4,"rt":$n[0].Single,"sn":"rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.PointAttachment end.*/

    /*Spine.RegionAttachment start.*/
    $m("Spine.RegionAttachment", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":"ComputeWorldVertices","t":8,"pi":[{"n":"bone","pt":$n[9].Bone,"ps":0},{"n":"worldVertices","pt":$n[0].Array.type(System.Single),"ps":1},{"n":"offset","pt":$n[0].Int32,"ps":2},{"n":"stride","dv":2,"o":true,"pt":$n[0].Int32,"ps":3}],"sn":"ComputeWorldVertices","rt":$n[0].Void,"p":[$n[9].Bone,$n[0].Array.type(System.Single),$n[0].Int32,$n[0].Int32]},{"ov":true,"a":2,"n":"Copy","t":8,"sn":"Copy","rt":$n[9].Attachment},{"a":2,"n":"SetUVs","t":8,"pi":[{"n":"u","pt":$n[0].Single,"ps":0},{"n":"v","pt":$n[0].Single,"ps":1},{"n":"u2","pt":$n[0].Single,"ps":2},{"n":"v2","pt":$n[0].Single,"ps":3},{"n":"rotate","pt":$n[0].Boolean,"ps":4}],"sn":"SetUVs","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"UpdateOffset","t":8,"sn":"UpdateOffset","rt":$n[0].Void},{"a":2,"n":"A","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_A","t":8,"rt":$n[0].Single,"fg":"A","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_A","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"A"},"fn":"A"},{"a":2,"n":"B","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_B","t":8,"rt":$n[0].Single,"fg":"B","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_B","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"B"},"fn":"B"},{"a":2,"n":"G","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_G","t":8,"rt":$n[0].Single,"fg":"G","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_G","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"G"},"fn":"G"},{"a":2,"n":"Height","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Height","t":8,"rt":$n[0].Single,"fg":"Height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Height","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Height"},"fn":"Height"},{"a":2,"n":"Offset","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Offset","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Offset"},"fn":"Offset"},{"a":2,"n":"Path","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Path","t":8,"rt":$n[0].String,"fg":"Path"},"s":{"a":2,"n":"set_Path","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"Path"},"fn":"Path"},{"a":2,"n":"R","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_R","t":8,"rt":$n[0].Single,"fg":"R","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_R","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"R"},"fn":"R"},{"a":2,"n":"RegionHeight","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RegionHeight","t":8,"rt":$n[0].Single,"fg":"RegionHeight","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RegionHeight","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RegionHeight"},"fn":"RegionHeight"},{"a":2,"n":"RegionOffsetX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RegionOffsetX","t":8,"rt":$n[0].Single,"fg":"RegionOffsetX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RegionOffsetX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RegionOffsetX"},"fn":"RegionOffsetX"},{"a":2,"n":"RegionOffsetY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RegionOffsetY","t":8,"rt":$n[0].Single,"fg":"RegionOffsetY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RegionOffsetY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RegionOffsetY"},"fn":"RegionOffsetY"},{"a":2,"n":"RegionOriginalHeight","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RegionOriginalHeight","t":8,"rt":$n[0].Single,"fg":"RegionOriginalHeight","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RegionOriginalHeight","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RegionOriginalHeight"},"fn":"RegionOriginalHeight"},{"a":2,"n":"RegionOriginalWidth","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RegionOriginalWidth","t":8,"rt":$n[0].Single,"fg":"RegionOriginalWidth","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RegionOriginalWidth","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RegionOriginalWidth"},"fn":"RegionOriginalWidth"},{"a":2,"n":"RegionWidth","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RegionWidth","t":8,"rt":$n[0].Single,"fg":"RegionWidth","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RegionWidth","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RegionWidth"},"fn":"RegionWidth"},{"a":2,"n":"RendererObject","t":16,"rt":$n[0].Object,"g":{"a":2,"n":"get_RendererObject","t":8,"rt":$n[0].Object,"fg":"RendererObject"},"s":{"a":2,"n":"set_RendererObject","t":8,"p":[$n[0].Object],"rt":$n[0].Void,"fs":"RendererObject"},"fn":"RendererObject"},{"a":2,"n":"Rotation","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Rotation","t":8,"rt":$n[0].Single,"fg":"Rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Rotation","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Rotation"},"fn":"Rotation"},{"a":2,"n":"ScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleX","t":8,"rt":$n[0].Single,"fg":"ScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleX"},"fn":"ScaleX"},{"a":2,"n":"ScaleY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleY","t":8,"rt":$n[0].Single,"fg":"ScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleY"},"fn":"ScaleY"},{"a":2,"n":"UVs","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_UVs","t":8,"rt":$n[0].Array.type(System.Single),"fg":"UVs"},"fn":"UVs"},{"a":2,"n":"Width","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Width","t":8,"rt":$n[0].Single,"fg":"Width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Width","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Width"},"fn":"Width"},{"a":2,"n":"X","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_X","t":8,"rt":$n[0].Single,"fg":"X","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_X","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"X"},"fn":"X"},{"a":2,"n":"Y","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Y","t":8,"rt":$n[0].Single,"fg":"Y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Y","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Y"},"fn":"Y"},{"a":2,"n":"BLX","is":true,"t":4,"rt":$n[0].Int32,"sn":"BLX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BLY","is":true,"t":4,"rt":$n[0].Int32,"sn":"BLY","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BRX","is":true,"t":4,"rt":$n[0].Int32,"sn":"BRX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BRY","is":true,"t":4,"rt":$n[0].Int32,"sn":"BRY","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ULX","is":true,"t":4,"rt":$n[0].Int32,"sn":"ULX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ULY","is":true,"t":4,"rt":$n[0].Int32,"sn":"ULY","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"URX","is":true,"t":4,"rt":$n[0].Int32,"sn":"URX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"URY","is":true,"t":4,"rt":$n[0].Int32,"sn":"URY","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"g","t":4,"rt":$n[0].Single,"sn":"g","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"height","t":4,"rt":$n[0].Single,"sn":"height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"offset","t":4,"rt":$n[0].Array.type(System.Single),"sn":"offset"},{"a":4,"n":"r","t":4,"rt":$n[0].Single,"sn":"r","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"regionHeight","t":4,"rt":$n[0].Single,"sn":"regionHeight","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"regionOffsetX","t":4,"rt":$n[0].Single,"sn":"regionOffsetX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"regionOffsetY","t":4,"rt":$n[0].Single,"sn":"regionOffsetY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"regionOriginalHeight","t":4,"rt":$n[0].Single,"sn":"regionOriginalHeight","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"regionOriginalWidth","t":4,"rt":$n[0].Single,"sn":"regionOriginalWidth","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"regionWidth","t":4,"rt":$n[0].Single,"sn":"regionWidth","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"rotation","t":4,"rt":$n[0].Single,"sn":"rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"scaleX","t":4,"rt":$n[0].Single,"sn":"scaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"scaleY","t":4,"rt":$n[0].Single,"sn":"scaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"uvs","t":4,"rt":$n[0].Array.type(System.Single),"sn":"uvs"},{"a":4,"n":"width","t":4,"rt":$n[0].Single,"sn":"width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<Path>k__BackingField","t":4,"rt":$n[0].String,"sn":"Path"},{"a":1,"backing":true,"n":"<RendererObject>k__BackingField","t":4,"rt":$n[0].Object,"sn":"RendererObject"}]}; }, $n);
    /*Spine.RegionAttachment end.*/

    /*Spine.VertexAttachment start.*/
    $m("Spine.VertexAttachment", function () { return {"att":1048705,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":"ComputeWorldVertices","t":8,"pi":[{"n":"slot","pt":$n[9].Slot,"ps":0},{"n":"worldVertices","pt":$n[0].Array.type(System.Single),"ps":1}],"sn":"ComputeWorldVertices$1","rt":$n[0].Void,"p":[$n[9].Slot,$n[0].Array.type(System.Single)]},{"a":2,"n":"ComputeWorldVertices","t":8,"pi":[{"n":"slot","pt":$n[9].Slot,"ps":0},{"n":"start","pt":$n[0].Int32,"ps":1},{"n":"count","pt":$n[0].Int32,"ps":2},{"n":"worldVertices","pt":$n[0].Array.type(System.Single),"ps":3},{"n":"offset","pt":$n[0].Int32,"ps":4},{"n":"stride","dv":2,"o":true,"pt":$n[0].Int32,"ps":5}],"sn":"ComputeWorldVertices","rt":$n[0].Void,"p":[$n[9].Slot,$n[0].Int32,$n[0].Int32,$n[0].Array.type(System.Single),$n[0].Int32,$n[0].Int32]},{"a":4,"n":"CopyTo","t":8,"pi":[{"n":"attachment","pt":$n[9].VertexAttachment,"ps":0}],"sn":"CopyTo","rt":$n[0].Void,"p":[$n[9].VertexAttachment]},{"a":2,"n":"Bones","t":16,"rt":$n[0].Array.type(System.Int32),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[0].Array.type(System.Int32),"fg":"Bones"},"s":{"a":2,"n":"set_Bones","t":8,"p":[$n[0].Array.type(System.Int32)],"rt":$n[0].Void,"fs":"Bones"},"fn":"Bones"},{"a":2,"n":"DeformAttachment","t":16,"rt":$n[9].VertexAttachment,"g":{"a":2,"n":"get_DeformAttachment","t":8,"rt":$n[9].VertexAttachment,"fg":"DeformAttachment"},"s":{"a":2,"n":"set_DeformAttachment","t":8,"p":[$n[9].VertexAttachment],"rt":$n[0].Void,"fs":"DeformAttachment"},"fn":"DeformAttachment"},{"a":2,"n":"Id","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Id","t":8,"rt":$n[0].Int32,"fg":"Id","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Id"},{"a":2,"n":"Vertices","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Vertices","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Vertices"},"s":{"a":2,"n":"set_Vertices","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Vertices"},"fn":"Vertices"},{"a":2,"n":"WorldVerticesLength","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_WorldVerticesLength","t":8,"rt":$n[0].Int32,"fg":"WorldVerticesLength","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_WorldVerticesLength","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"WorldVerticesLength"},"fn":"WorldVerticesLength"},{"a":4,"n":"bones","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"bones"},{"a":4,"n":"deformAttachment","t":4,"rt":$n[9].VertexAttachment,"sn":"deformAttachment"},{"a":4,"n":"id","t":4,"rt":$n[0].Int32,"sn":"id","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"nextID","is":true,"t":4,"rt":$n[0].Int32,"sn":"nextID","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"nextIdLock","is":true,"t":4,"rt":$n[0].Object,"sn":"nextIdLock","ro":true},{"a":4,"n":"vertices","t":4,"rt":$n[0].Array.type(System.Single),"sn":"vertices"},{"a":4,"n":"worldVerticesLength","t":4,"rt":$n[0].Int32,"sn":"worldVerticesLength","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.VertexAttachment end.*/

    /*Spine.BlendMode start.*/
    $m("Spine.BlendMode", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Additive","is":true,"t":4,"rt":$n[9].BlendMode,"sn":"Additive","box":function ($v) { return Bridge.box($v, Spine.BlendMode, System.Enum.toStringFn(Spine.BlendMode));}},{"a":2,"n":"Multiply","is":true,"t":4,"rt":$n[9].BlendMode,"sn":"Multiply","box":function ($v) { return Bridge.box($v, Spine.BlendMode, System.Enum.toStringFn(Spine.BlendMode));}},{"a":2,"n":"Normal","is":true,"t":4,"rt":$n[9].BlendMode,"sn":"Normal","box":function ($v) { return Bridge.box($v, Spine.BlendMode, System.Enum.toStringFn(Spine.BlendMode));}},{"a":2,"n":"Screen","is":true,"t":4,"rt":$n[9].BlendMode,"sn":"Screen","box":function ($v) { return Bridge.box($v, Spine.BlendMode, System.Enum.toStringFn(Spine.BlendMode));}}]}; }, $n);
    /*Spine.BlendMode end.*/

    /*Spine.Bone start.*/
    $m("Spine.Bone", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[9].BoneData,$n[9].Skeleton,$n[9].Bone],"pi":[{"n":"data","pt":$n[9].BoneData,"ps":0},{"n":"skeleton","pt":$n[9].Skeleton,"ps":1},{"n":"parent","pt":$n[9].Bone,"ps":2}],"sn":"ctor"},{"a":2,"n":"LocalToWorld","t":8,"pi":[{"n":"localX","pt":$n[0].Single,"ps":0},{"n":"localY","pt":$n[0].Single,"ps":1},{"n":"worldX","out":true,"pt":$n[0].Single,"ps":2},{"n":"worldY","out":true,"pt":$n[0].Single,"ps":3}],"sn":"LocalToWorld","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"LocalToWorldRotation","t":8,"pi":[{"n":"localRotation","pt":$n[0].Single,"ps":0}],"sn":"LocalToWorldRotation","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"RotateWorld","t":8,"pi":[{"n":"degrees","pt":$n[0].Single,"ps":0}],"sn":"RotateWorld","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"SetToSetupPose","t":8,"sn":"SetToSetupPose","rt":$n[0].Void},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":4,"n":"UpdateAppliedTransform","t":8,"sn":"UpdateAppliedTransform","rt":$n[0].Void},{"a":2,"n":"UpdateWorldTransform","t":8,"sn":"UpdateWorldTransform","rt":$n[0].Void},{"a":2,"n":"UpdateWorldTransform","t":8,"pi":[{"n":"x","pt":$n[0].Single,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1},{"n":"rotation","pt":$n[0].Single,"ps":2},{"n":"scaleX","pt":$n[0].Single,"ps":3},{"n":"scaleY","pt":$n[0].Single,"ps":4},{"n":"shearX","pt":$n[0].Single,"ps":5},{"n":"shearY","pt":$n[0].Single,"ps":6}],"sn":"UpdateWorldTransform$1","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"WorldToLocal","t":8,"pi":[{"n":"worldX","pt":$n[0].Single,"ps":0},{"n":"worldY","pt":$n[0].Single,"ps":1},{"n":"localX","out":true,"pt":$n[0].Single,"ps":2},{"n":"localY","out":true,"pt":$n[0].Single,"ps":3}],"sn":"WorldToLocal","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"WorldToLocalRotation","t":8,"pi":[{"n":"worldRotation","pt":$n[0].Single,"ps":0}],"sn":"WorldToLocalRotation","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"A","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_A","t":8,"rt":$n[0].Single,"fg":"A","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"A"},{"a":2,"n":"AScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AScaleX","t":8,"rt":$n[0].Single,"fg":"AScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AScaleX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AScaleX"},"fn":"AScaleX"},{"a":2,"n":"AScaleY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AScaleY","t":8,"rt":$n[0].Single,"fg":"AScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AScaleY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AScaleY"},"fn":"AScaleY"},{"a":2,"n":"AShearX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AShearX","t":8,"rt":$n[0].Single,"fg":"AShearX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AShearX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AShearX"},"fn":"AShearX"},{"a":2,"n":"AShearY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AShearY","t":8,"rt":$n[0].Single,"fg":"AShearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AShearY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AShearY"},"fn":"AShearY"},{"a":2,"n":"AX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AX","t":8,"rt":$n[0].Single,"fg":"AX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AX"},"fn":"AX"},{"a":2,"n":"AY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AY","t":8,"rt":$n[0].Single,"fg":"AY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AY"},"fn":"AY"},{"a":2,"n":"Active","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Active","t":8,"rt":$n[0].Boolean,"fg":"Active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"Active"},{"a":2,"n":"AppliedRotation","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AppliedRotation","t":8,"rt":$n[0].Single,"fg":"AppliedRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AppliedRotation","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AppliedRotation"},"fn":"AppliedRotation"},{"a":2,"n":"B","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_B","t":8,"rt":$n[0].Single,"fg":"B","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"B"},{"a":2,"n":"C","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_C","t":8,"rt":$n[0].Single,"fg":"C","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"C"},{"a":2,"n":"Children","t":16,"rt":$n[9].ExposedList$1(Spine.Bone),"g":{"a":2,"n":"get_Children","t":8,"rt":$n[9].ExposedList$1(Spine.Bone),"fg":"Children"},"fn":"Children"},{"a":2,"n":"D","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_D","t":8,"rt":$n[0].Single,"fg":"D","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"D"},{"a":2,"n":"Data","t":16,"rt":$n[9].BoneData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[9].BoneData,"fg":"Data"},"fn":"Data"},{"a":2,"n":"Parent","t":16,"rt":$n[9].Bone,"g":{"a":2,"n":"get_Parent","t":8,"rt":$n[9].Bone,"fg":"Parent"},"fn":"Parent"},{"a":2,"n":"Rotation","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Rotation","t":8,"rt":$n[0].Single,"fg":"Rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Rotation","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Rotation"},"fn":"Rotation"},{"a":2,"n":"ScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleX","t":8,"rt":$n[0].Single,"fg":"ScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleX"},"fn":"ScaleX"},{"a":2,"n":"ScaleY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleY","t":8,"rt":$n[0].Single,"fg":"ScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleY"},"fn":"ScaleY"},{"a":2,"n":"ShearX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ShearX","t":8,"rt":$n[0].Single,"fg":"ShearX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ShearX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ShearX"},"fn":"ShearX"},{"a":2,"n":"ShearY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ShearY","t":8,"rt":$n[0].Single,"fg":"ShearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ShearY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ShearY"},"fn":"ShearY"},{"a":2,"n":"Skeleton","t":16,"rt":$n[9].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[9].Skeleton,"fg":"Skeleton"},"fn":"Skeleton"},{"a":2,"n":"WorldRotationX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_WorldRotationX","t":8,"rt":$n[0].Single,"fg":"WorldRotationX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"WorldRotationX"},{"a":2,"n":"WorldRotationY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_WorldRotationY","t":8,"rt":$n[0].Single,"fg":"WorldRotationY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"WorldRotationY"},{"a":2,"n":"WorldScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_WorldScaleX","t":8,"rt":$n[0].Single,"fg":"WorldScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"WorldScaleX"},{"a":2,"n":"WorldScaleY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_WorldScaleY","t":8,"rt":$n[0].Single,"fg":"WorldScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"WorldScaleY"},{"a":2,"n":"WorldToLocalRotationX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_WorldToLocalRotationX","t":8,"rt":$n[0].Single,"fg":"WorldToLocalRotationX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"WorldToLocalRotationX"},{"a":2,"n":"WorldToLocalRotationY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_WorldToLocalRotationY","t":8,"rt":$n[0].Single,"fg":"WorldToLocalRotationY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"WorldToLocalRotationY"},{"a":2,"n":"WorldX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_WorldX","t":8,"rt":$n[0].Single,"fg":"WorldX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"WorldX"},{"a":2,"n":"WorldY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_WorldY","t":8,"rt":$n[0].Single,"fg":"WorldY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"WorldY"},{"a":2,"n":"X","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_X","t":8,"rt":$n[0].Single,"fg":"X","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_X","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"X"},"fn":"X"},{"a":2,"n":"Y","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Y","t":8,"rt":$n[0].Single,"fg":"Y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Y","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Y"},"fn":"Y"},{"a":4,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"active","t":4,"rt":$n[0].Boolean,"sn":"active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"appliedValid","t":4,"rt":$n[0].Boolean,"sn":"appliedValid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"arotation","t":4,"rt":$n[0].Single,"sn":"arotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"ascaleX","t":4,"rt":$n[0].Single,"sn":"ascaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"ascaleY","t":4,"rt":$n[0].Single,"sn":"ascaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"ashearX","t":4,"rt":$n[0].Single,"sn":"ashearX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"ashearY","t":4,"rt":$n[0].Single,"sn":"ashearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"ax","t":4,"rt":$n[0].Single,"sn":"ax","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"ay","t":4,"rt":$n[0].Single,"sn":"ay","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"c","t":4,"rt":$n[0].Single,"sn":"c","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"children","t":4,"rt":$n[9].ExposedList$1(Spine.Bone),"sn":"children"},{"a":4,"n":"d","t":4,"rt":$n[0].Single,"sn":"d","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"data","t":4,"rt":$n[9].BoneData,"sn":"data"},{"a":4,"n":"parent","t":4,"rt":$n[9].Bone,"sn":"parent"},{"a":4,"n":"rotation","t":4,"rt":$n[0].Single,"sn":"rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"scaleX","t":4,"rt":$n[0].Single,"sn":"scaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"scaleY","t":4,"rt":$n[0].Single,"sn":"scaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"shearX","t":4,"rt":$n[0].Single,"sn":"shearX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"shearY","t":4,"rt":$n[0].Single,"sn":"shearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"skeleton","t":4,"rt":$n[9].Skeleton,"sn":"skeleton"},{"a":4,"n":"sorted","t":4,"rt":$n[0].Boolean,"sn":"sorted","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"worldX","t":4,"rt":$n[0].Single,"sn":"worldX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"worldY","t":4,"rt":$n[0].Single,"sn":"worldY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"yDown","is":true,"t":4,"rt":$n[0].Boolean,"sn":"yDown","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Bone end.*/

    /*Spine.BoneData start.*/
    $m("Spine.BoneData", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].String,$n[9].BoneData],"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"parent","pt":$n[9].BoneData,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Index","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Index","t":8,"rt":$n[0].Int32,"fg":"Index","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Index"},{"a":2,"n":"Length","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Length","t":8,"rt":$n[0].Single,"fg":"Length","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Length","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Length"},"fn":"Length"},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"fn":"Name"},{"a":2,"n":"Parent","t":16,"rt":$n[9].BoneData,"g":{"a":2,"n":"get_Parent","t":8,"rt":$n[9].BoneData,"fg":"Parent"},"fn":"Parent"},{"a":2,"n":"Rotation","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Rotation","t":8,"rt":$n[0].Single,"fg":"Rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Rotation","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Rotation"},"fn":"Rotation"},{"a":2,"n":"ScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleX","t":8,"rt":$n[0].Single,"fg":"ScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleX"},"fn":"ScaleX"},{"a":2,"n":"ScaleY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleY","t":8,"rt":$n[0].Single,"fg":"ScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleY"},"fn":"ScaleY"},{"a":2,"n":"ShearX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ShearX","t":8,"rt":$n[0].Single,"fg":"ShearX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ShearX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ShearX"},"fn":"ShearX"},{"a":2,"n":"ShearY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ShearY","t":8,"rt":$n[0].Single,"fg":"ShearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ShearY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ShearY"},"fn":"ShearY"},{"a":2,"n":"SkinRequired","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_SkinRequired","t":8,"rt":$n[0].Boolean,"fg":"SkinRequired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_SkinRequired","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"SkinRequired"},"fn":"SkinRequired"},{"a":2,"n":"TransformMode","t":16,"rt":$n[9].TransformMode,"g":{"a":2,"n":"get_TransformMode","t":8,"rt":$n[9].TransformMode,"fg":"TransformMode","box":function ($v) { return Bridge.box($v, Spine.TransformMode, System.Enum.toStringFn(Spine.TransformMode));}},"s":{"a":2,"n":"set_TransformMode","t":8,"p":[$n[9].TransformMode],"rt":$n[0].Void,"fs":"TransformMode"},"fn":"TransformMode"},{"a":2,"n":"X","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_X","t":8,"rt":$n[0].Single,"fg":"X","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_X","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"X"},"fn":"X"},{"a":2,"n":"Y","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Y","t":8,"rt":$n[0].Single,"fg":"Y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Y","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Y"},"fn":"Y"},{"a":4,"n":"index","t":4,"rt":$n[0].Int32,"sn":"index","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"length","t":4,"rt":$n[0].Single,"sn":"length","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":4,"n":"parent","t":4,"rt":$n[9].BoneData,"sn":"parent"},{"a":4,"n":"rotation","t":4,"rt":$n[0].Single,"sn":"rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"scaleX","t":4,"rt":$n[0].Single,"sn":"scaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"scaleY","t":4,"rt":$n[0].Single,"sn":"scaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"shearX","t":4,"rt":$n[0].Single,"sn":"shearX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"shearY","t":4,"rt":$n[0].Single,"sn":"shearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"skinRequired","t":4,"rt":$n[0].Boolean,"sn":"skinRequired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"transformMode","t":4,"rt":$n[9].TransformMode,"sn":"transformMode","box":function ($v) { return Bridge.box($v, Spine.TransformMode, System.Enum.toStringFn(Spine.TransformMode));}},{"a":4,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.BoneData end.*/

    /*Spine.TransformMode start.*/
    $m("Spine.TransformMode", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"NoRotationOrReflection","is":true,"t":4,"rt":$n[9].TransformMode,"sn":"NoRotationOrReflection","box":function ($v) { return Bridge.box($v, Spine.TransformMode, System.Enum.toStringFn(Spine.TransformMode));}},{"a":2,"n":"NoScale","is":true,"t":4,"rt":$n[9].TransformMode,"sn":"NoScale","box":function ($v) { return Bridge.box($v, Spine.TransformMode, System.Enum.toStringFn(Spine.TransformMode));}},{"a":2,"n":"NoScaleOrReflection","is":true,"t":4,"rt":$n[9].TransformMode,"sn":"NoScaleOrReflection","box":function ($v) { return Bridge.box($v, Spine.TransformMode, System.Enum.toStringFn(Spine.TransformMode));}},{"a":2,"n":"Normal","is":true,"t":4,"rt":$n[9].TransformMode,"sn":"Normal","box":function ($v) { return Bridge.box($v, Spine.TransformMode, System.Enum.toStringFn(Spine.TransformMode));}},{"a":2,"n":"OnlyTranslation","is":true,"t":4,"rt":$n[9].TransformMode,"sn":"OnlyTranslation","box":function ($v) { return Bridge.box($v, Spine.TransformMode, System.Enum.toStringFn(Spine.TransformMode));}}]}; }, $n);
    /*Spine.TransformMode end.*/

    /*Spine.ConstraintData start.*/
    $m("Spine.ConstraintData", function () { return {"att":1048705,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"fn":"Name"},{"a":2,"n":"Order","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Order","t":8,"rt":$n[0].Int32,"fg":"Order","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_Order","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Order"},"fn":"Order"},{"a":2,"n":"SkinRequired","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_SkinRequired","t":8,"rt":$n[0].Boolean,"fg":"SkinRequired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_SkinRequired","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"SkinRequired"},"fn":"SkinRequired"},{"a":4,"n":"name","t":4,"rt":$n[0].String,"sn":"name","ro":true},{"a":4,"n":"order","t":4,"rt":$n[0].Int32,"sn":"order","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"skinRequired","t":4,"rt":$n[0].Boolean,"sn":"skinRequired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.ConstraintData end.*/

    /*Spine.Event start.*/
    $m("Spine.Event", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Single,$n[9].EventData],"pi":[{"n":"time","pt":$n[0].Single,"ps":0},{"n":"data","pt":$n[9].EventData,"ps":1}],"sn":"ctor"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Balance","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Balance","t":8,"rt":$n[0].Single,"fg":"Balance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Balance","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Balance"},"fn":"Balance"},{"a":2,"n":"Data","t":16,"rt":$n[9].EventData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[9].EventData,"fg":"Data"},"fn":"Data"},{"a":2,"n":"Float","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Float","t":8,"rt":$n[0].Single,"fg":"Float","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Float","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Float"},"fn":"Float"},{"a":2,"n":"Int","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Int","t":8,"rt":$n[0].Int32,"fg":"Int","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_Int","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Int"},"fn":"Int"},{"a":2,"n":"String","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_String","t":8,"rt":$n[0].String,"fg":"String"},"s":{"a":2,"n":"set_String","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"String"},"fn":"String"},{"a":2,"n":"Time","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Time","t":8,"rt":$n[0].Single,"fg":"Time","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"Time"},{"a":2,"n":"Volume","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Volume","t":8,"rt":$n[0].Single,"fg":"Volume","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Volume","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Volume"},"fn":"Volume"},{"a":4,"n":"balance","t":4,"rt":$n[0].Single,"sn":"balance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"data","t":4,"rt":$n[9].EventData,"sn":"data","ro":true},{"a":4,"n":"floatValue","t":4,"rt":$n[0].Single,"sn":"floatValue","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"intValue","t":4,"rt":$n[0].Int32,"sn":"intValue","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"stringValue","t":4,"rt":$n[0].String,"sn":"stringValue"},{"a":4,"n":"time","t":4,"rt":$n[0].Single,"sn":"time","ro":true,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"volume","t":4,"rt":$n[0].Single,"sn":"volume","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Event end.*/

    /*Spine.EventData start.*/
    $m("Spine.EventData", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"AudioPath","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_AudioPath","t":8,"rt":$n[0].String,"fg":"AudioPath"},"s":{"a":2,"n":"set_AudioPath","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"AudioPath"},"fn":"AudioPath"},{"a":2,"n":"Balance","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Balance","t":8,"rt":$n[0].Single,"fg":"Balance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Balance","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Balance"},"fn":"Balance"},{"a":2,"n":"Float","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Float","t":8,"rt":$n[0].Single,"fg":"Float","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Float","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Float"},"fn":"Float"},{"a":2,"n":"Int","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Int","t":8,"rt":$n[0].Int32,"fg":"Int","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_Int","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Int"},"fn":"Int"},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"fn":"Name"},{"a":2,"n":"String","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_String","t":8,"rt":$n[0].String,"fg":"String"},"s":{"a":2,"n":"set_String","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"String"},"fn":"String"},{"a":2,"n":"Volume","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Volume","t":8,"rt":$n[0].Single,"fg":"Volume","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Volume","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Volume"},"fn":"Volume"},{"a":4,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":1,"backing":true,"n":"<AudioPath>k__BackingField","t":4,"rt":$n[0].String,"sn":"AudioPath"},{"a":1,"backing":true,"n":"<Balance>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Balance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<Float>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Float","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<Int>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"Int","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"backing":true,"n":"<String>k__BackingField","t":4,"rt":$n[0].String,"sn":"String"},{"a":1,"backing":true,"n":"<Volume>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Volume","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.EventData end.*/

    /*Spine.ExposedList$1 start.*/
    $m("Spine.ExposedList$1", function (T) { return {"nested":[$n[9].ExposedList$1.Enumerator],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[5].IEnumerable$1(T)],"pi":[{"n":"collection","pt":$n[5].IEnumerable$1(T),"ps":0}],"sn":"$ctor2"},{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"capacity","pt":$n[0].Int32,"ps":0}],"sn":"$ctor3"},{"a":4,"n":".ctor","t":1,"p":[System.Array.type(T),$n[0].Int32],"pi":[{"n":"data","pt":System.Array.type(T),"ps":0},{"n":"size","pt":$n[0].Int32,"ps":1}],"sn":"$ctor1"},{"a":2,"n":"Add","t":8,"pi":[{"n":"item","pt":T,"ps":0}],"sn":"Add","rt":$n[0].Void,"p":[T]},{"a":1,"n":"AddCollection","t":8,"pi":[{"n":"collection","pt":$n[5].ICollection$1(T),"ps":0}],"sn":"AddCollection","rt":$n[0].Void,"p":[$n[5].ICollection$1(T)]},{"a":1,"n":"AddEnumerable","t":8,"pi":[{"n":"enumerable","pt":$n[5].IEnumerable$1(T),"ps":0}],"sn":"AddEnumerable","rt":$n[0].Void,"p":[$n[5].IEnumerable$1(T)]},{"a":2,"n":"AddRange","t":8,"pi":[{"n":"list","pt":$n[9].ExposedList$1(T),"ps":0}],"sn":"AddRange","rt":$n[0].Void,"p":[$n[9].ExposedList$1(T)]},{"a":2,"n":"AddRange","t":8,"pi":[{"n":"collection","pt":$n[5].IEnumerable$1(T),"ps":0}],"sn":"AddRange$1","rt":$n[0].Void,"p":[$n[5].IEnumerable$1(T)]},{"a":2,"n":"BinarySearch","t":8,"pi":[{"n":"item","pt":T,"ps":0}],"sn":"BinarySearch","rt":$n[0].Int32,"p":[T],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BinarySearch","t":8,"pi":[{"n":"item","pt":T,"ps":0},{"n":"comparer","pt":$n[5].IComparer$1(T),"ps":1}],"sn":"BinarySearch$1","rt":$n[0].Int32,"p":[T,$n[5].IComparer$1(T)],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BinarySearch","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1},{"n":"item","pt":T,"ps":2},{"n":"comparer","pt":$n[5].IComparer$1(T),"ps":3}],"sn":"BinarySearch$2","rt":$n[0].Int32,"p":[$n[0].Int32,$n[0].Int32,T,$n[5].IComparer$1(T)],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"CheckCollection","t":8,"pi":[{"n":"collection","pt":$n[5].IEnumerable$1(T),"ps":0}],"sn":"CheckCollection","rt":$n[0].Void,"p":[$n[5].IEnumerable$1(T)]},{"a":1,"n":"CheckIndex","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0}],"sn":"CheckIndex","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"CheckMatch","is":true,"t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"CheckMatch","rt":$n[0].Void,"p":[Function]},{"a":1,"n":"CheckRange","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1}],"sn":"CheckRange","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Int32]},{"a":2,"n":"Clear","t":8,"pi":[{"n":"clearArray","dv":true,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"Clear","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"Contains","t":8,"pi":[{"n":"item","pt":T,"ps":0}],"sn":"Contains","rt":$n[0].Boolean,"p":[T],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"ConvertAll","t":8,"pi":[{"n":"converter","pt":Function,"ps":0}],"tpc":1,"tprm":["TOutput"],"sn":"ConvertAll","rt":$n[9].ExposedList$1(System.Object),"p":[Function]},{"a":2,"n":"CopyTo","t":8,"pi":[{"n":"array","pt":System.Array.type(T),"ps":0}],"sn":"CopyTo","rt":$n[0].Void,"p":[System.Array.type(T)]},{"a":2,"n":"CopyTo","t":8,"pi":[{"n":"array","pt":System.Array.type(T),"ps":0},{"n":"arrayIndex","pt":$n[0].Int32,"ps":1}],"sn":"CopyTo$1","rt":$n[0].Void,"p":[System.Array.type(T),$n[0].Int32]},{"a":2,"n":"CopyTo","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"array","pt":System.Array.type(T),"ps":1},{"n":"arrayIndex","pt":$n[0].Int32,"ps":2},{"n":"count","pt":$n[0].Int32,"ps":3}],"sn":"CopyTo$2","rt":$n[0].Void,"p":[$n[0].Int32,System.Array.type(T),$n[0].Int32,$n[0].Int32]},{"a":2,"n":"EnsureCapacity","t":8,"pi":[{"n":"min","pt":$n[0].Int32,"ps":0}],"sn":"EnsureCapacity","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"Exists","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"Exists","rt":$n[0].Boolean,"p":[Function],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Find","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"Find","rt":T,"p":[Function]},{"a":2,"n":"FindAll","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"FindAll","rt":$n[9].ExposedList$1(T),"p":[Function]},{"a":1,"n":"FindAllList","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"FindAllList","rt":$n[9].ExposedList$1(T),"p":[Function]},{"a":2,"n":"FindIndex","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"FindIndex$2","rt":$n[0].Int32,"p":[Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"FindIndex","t":8,"pi":[{"n":"startIndex","pt":$n[0].Int32,"ps":0},{"n":"match","pt":Function,"ps":1}],"sn":"FindIndex$1","rt":$n[0].Int32,"p":[$n[0].Int32,Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"FindIndex","t":8,"pi":[{"n":"startIndex","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1},{"n":"match","pt":Function,"ps":2}],"sn":"FindIndex","rt":$n[0].Int32,"p":[$n[0].Int32,$n[0].Int32,Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"FindLast","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"FindLast","rt":T,"p":[Function]},{"a":2,"n":"FindLastIndex","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"FindLastIndex$2","rt":$n[0].Int32,"p":[Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"FindLastIndex","t":8,"pi":[{"n":"startIndex","pt":$n[0].Int32,"ps":0},{"n":"match","pt":Function,"ps":1}],"sn":"FindLastIndex$1","rt":$n[0].Int32,"p":[$n[0].Int32,Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"FindLastIndex","t":8,"pi":[{"n":"startIndex","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1},{"n":"match","pt":Function,"ps":2}],"sn":"FindLastIndex","rt":$n[0].Int32,"p":[$n[0].Int32,$n[0].Int32,Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ForEach","t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"sn":"ForEach","rt":$n[0].Void,"p":[Function]},{"a":2,"n":"GetEnumerator","t":8,"sn":"GetEnumerator","rt":$n[9].ExposedList$1.Enumerator(T)},{"a":1,"n":"GetIndex","t":8,"pi":[{"n":"startIndex","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1},{"n":"match","pt":Function,"ps":2}],"sn":"GetIndex","rt":$n[0].Int32,"p":[$n[0].Int32,$n[0].Int32,Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"GetLastIndex","t":8,"pi":[{"n":"startIndex","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1},{"n":"match","pt":Function,"ps":2}],"sn":"GetLastIndex","rt":$n[0].Int32,"p":[$n[0].Int32,$n[0].Int32,Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"GetRange","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1}],"sn":"GetRange","rt":$n[9].ExposedList$1(T),"p":[$n[0].Int32,$n[0].Int32]},{"a":2,"n":"GrowIfNeeded","t":8,"pi":[{"n":"addedCount","pt":$n[0].Int32,"ps":0}],"sn":"GrowIfNeeded","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"IndexOf","t":8,"pi":[{"n":"item","pt":T,"ps":0}],"sn":"IndexOf","rt":$n[0].Int32,"p":[T],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"IndexOf","t":8,"pi":[{"n":"item","pt":T,"ps":0},{"n":"index","pt":$n[0].Int32,"ps":1}],"sn":"IndexOf$1","rt":$n[0].Int32,"p":[T,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"IndexOf","t":8,"pi":[{"n":"item","pt":T,"ps":0},{"n":"index","pt":$n[0].Int32,"ps":1},{"n":"count","pt":$n[0].Int32,"ps":2}],"sn":"IndexOf$2","rt":$n[0].Int32,"p":[T,$n[0].Int32,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"Insert","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"item","pt":T,"ps":1}],"sn":"Insert","rt":$n[0].Void,"p":[$n[0].Int32,T]},{"a":1,"n":"InsertCollection","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"collection","pt":$n[5].ICollection$1(T),"ps":1}],"sn":"InsertCollection","rt":$n[0].Void,"p":[$n[0].Int32,$n[5].ICollection$1(T)]},{"a":1,"n":"InsertEnumeration","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"enumerable","pt":$n[5].IEnumerable$1(T),"ps":1}],"sn":"InsertEnumeration","rt":$n[0].Void,"p":[$n[0].Int32,$n[5].IEnumerable$1(T)]},{"a":2,"n":"InsertRange","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"collection","pt":$n[5].IEnumerable$1(T),"ps":1}],"sn":"InsertRange","rt":$n[0].Void,"p":[$n[0].Int32,$n[5].IEnumerable$1(T)]},{"a":2,"n":"LastIndexOf","t":8,"pi":[{"n":"item","pt":T,"ps":0}],"sn":"LastIndexOf","rt":$n[0].Int32,"p":[T],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"LastIndexOf","t":8,"pi":[{"n":"item","pt":T,"ps":0},{"n":"index","pt":$n[0].Int32,"ps":1}],"sn":"LastIndexOf$1","rt":$n[0].Int32,"p":[T,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"LastIndexOf","t":8,"pi":[{"n":"item","pt":T,"ps":0},{"n":"index","pt":$n[0].Int32,"ps":1},{"n":"count","pt":$n[0].Int32,"ps":2}],"sn":"LastIndexOf$2","rt":$n[0].Int32,"p":[T,$n[0].Int32,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"Pop","t":8,"sn":"Pop","rt":T},{"a":2,"n":"Remove","t":8,"pi":[{"n":"item","pt":T,"ps":0}],"sn":"Remove","rt":$n[0].Boolean,"p":[T],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"RemoveAll","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"RemoveAll","rt":$n[0].Int32,"p":[Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"RemoveAt","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0}],"sn":"RemoveAt","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"RemoveRange","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1}],"sn":"RemoveRange","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Int32]},{"a":2,"n":"Resize","t":8,"pi":[{"n":"newSize","pt":$n[0].Int32,"ps":0}],"sn":"Resize","rt":$n[9].ExposedList$1(T),"p":[$n[0].Int32]},{"a":2,"n":"Reverse","t":8,"sn":"Reverse","rt":$n[0].Void},{"a":2,"n":"Reverse","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1}],"sn":"Reverse$1","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Int32]},{"a":1,"n":"Shift","t":8,"pi":[{"n":"start","pt":$n[0].Int32,"ps":0},{"n":"delta","pt":$n[0].Int32,"ps":1}],"sn":"Shift","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Int32]},{"a":2,"n":"Sort","t":8,"sn":"Sort","rt":$n[0].Void},{"a":2,"n":"Sort","t":8,"pi":[{"n":"comparer","pt":$n[5].IComparer$1(T),"ps":0}],"sn":"Sort$1","rt":$n[0].Void,"p":[$n[5].IComparer$1(T)]},{"a":2,"n":"Sort","t":8,"pi":[{"n":"comparison","pt":Function,"ps":0}],"sn":"Sort$2","rt":$n[0].Void,"p":[Function]},{"a":2,"n":"Sort","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1},{"n":"comparer","pt":$n[5].IComparer$1(T),"ps":2}],"sn":"Sort$3","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Int32,$n[5].IComparer$1(T)]},{"a":2,"n":"ToArray","t":8,"sn":"ToArray","rt":System.Array.type(T)},{"a":2,"n":"TrimExcess","t":8,"sn":"TrimExcess","rt":$n[0].Void},{"a":2,"n":"TrueForAll","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"TrueForAll","rt":$n[0].Boolean,"p":[Function],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Capacity","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Capacity","t":8,"rt":$n[0].Int32,"fg":"Capacity","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_Capacity","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Capacity"},"fn":"Capacity"},{"a":2,"n":"Count","t":4,"rt":$n[0].Int32,"sn":"Count","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"DefaultCapacity","is":true,"t":4,"rt":$n[0].Int32,"sn":"DefaultCapacity","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"EmptyArray","is":true,"t":4,"rt":System.Array.type(T),"sn":"EmptyArray","ro":true},{"a":2,"n":"Items","t":4,"rt":System.Array.type(T),"sn":"Items"},{"a":1,"n":"version","t":4,"rt":$n[0].Int32,"sn":"version","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.ExposedList$1 end.*/

    /*Spine.ExposedList$1+Enumerator start.*/
    $m("Spine.ExposedList$1.Enumerator", function (T) { return {"td":$n[9].ExposedList$1(T),"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":4,"n":".ctor","t":1,"p":[$n[9].ExposedList$1(T)],"pi":[{"n":"l","pt":$n[9].ExposedList$1(T),"ps":0}],"sn":"$ctor1"},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"MoveNext","t":8,"sn":"moveNext","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"VerifyState","t":8,"sn":"VerifyState","rt":$n[0].Void},{"a":2,"n":"Current","t":16,"rt":T,"g":{"a":2,"n":"get_Current","t":8,"rt":T,"fg":"Current"},"fn":"Current"},{"a":1,"n":"current","t":4,"rt":T,"sn":"current"},{"a":1,"n":"l","t":4,"rt":$n[9].ExposedList$1(T),"sn":"l"},{"a":1,"n":"next","t":4,"rt":$n[0].Int32,"sn":"next","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"ver","t":4,"rt":$n[0].Int32,"sn":"ver","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.ExposedList$1+Enumerator end.*/

    /*Spine.IkConstraint start.*/
    $m("Spine.IkConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[9].IkConstraint,$n[9].Skeleton],"pi":[{"n":"constraint","pt":$n[9].IkConstraint,"ps":0},{"n":"skeleton","pt":$n[9].Skeleton,"ps":1}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[9].IkConstraintData,$n[9].Skeleton],"pi":[{"n":"data","pt":$n[9].IkConstraintData,"ps":0},{"n":"skeleton","pt":$n[9].Skeleton,"ps":1}],"sn":"$ctor1"},{"a":2,"n":"Apply","t":8,"sn":"Apply","rt":$n[0].Void},{"a":2,"n":"Apply","is":true,"t":8,"pi":[{"n":"bone","pt":$n[9].Bone,"ps":0},{"n":"targetX","pt":$n[0].Single,"ps":1},{"n":"targetY","pt":$n[0].Single,"ps":2},{"n":"compress","pt":$n[0].Boolean,"ps":3},{"n":"stretch","pt":$n[0].Boolean,"ps":4},{"n":"uniform","pt":$n[0].Boolean,"ps":5},{"n":"alpha","pt":$n[0].Single,"ps":6}],"sn":"Apply$1","rt":$n[0].Void,"p":[$n[9].Bone,$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"Apply","is":true,"t":8,"pi":[{"n":"parent","pt":$n[9].Bone,"ps":0},{"n":"child","pt":$n[9].Bone,"ps":1},{"n":"targetX","pt":$n[0].Single,"ps":2},{"n":"targetY","pt":$n[0].Single,"ps":3},{"n":"bendDir","pt":$n[0].Int32,"ps":4},{"n":"stretch","pt":$n[0].Boolean,"ps":5},{"n":"softness","pt":$n[0].Single,"ps":6},{"n":"alpha","pt":$n[0].Single,"ps":7}],"sn":"Apply","rt":$n[0].Void,"p":[$n[9].Bone,$n[9].Bone,$n[0].Single,$n[0].Single,$n[0].Int32,$n[0].Boolean,$n[0].Single,$n[0].Single]},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"Active","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Active","t":8,"rt":$n[0].Boolean,"fg":"Active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"Active"},{"a":2,"n":"BendDirection","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BendDirection","t":8,"rt":$n[0].Int32,"fg":"BendDirection","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_BendDirection","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"BendDirection"},"fn":"BendDirection"},{"a":2,"n":"Bones","t":16,"rt":$n[9].ExposedList$1(Spine.Bone),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[9].ExposedList$1(Spine.Bone),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"Compress","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Compress","t":8,"rt":$n[0].Boolean,"fg":"Compress","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Compress","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Compress"},"fn":"Compress"},{"a":2,"n":"Data","t":16,"rt":$n[9].IkConstraintData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[9].IkConstraintData,"fg":"Data"},"fn":"Data"},{"a":2,"n":"Mix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Mix","t":8,"rt":$n[0].Single,"fg":"Mix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Mix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Mix"},"fn":"Mix"},{"a":2,"n":"Softness","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Softness","t":8,"rt":$n[0].Single,"fg":"Softness","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Softness","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Softness"},"fn":"Softness"},{"a":2,"n":"Stretch","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Stretch","t":8,"rt":$n[0].Boolean,"fg":"Stretch","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Stretch","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Stretch"},"fn":"Stretch"},{"a":2,"n":"Target","t":16,"rt":$n[9].Bone,"g":{"a":2,"n":"get_Target","t":8,"rt":$n[9].Bone,"fg":"Target"},"s":{"a":2,"n":"set_Target","t":8,"p":[$n[9].Bone],"rt":$n[0].Void,"fs":"Target"},"fn":"Target"},{"a":4,"n":"active","t":4,"rt":$n[0].Boolean,"sn":"active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"bendDirection","t":4,"rt":$n[0].Int32,"sn":"bendDirection","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"bones","t":4,"rt":$n[9].ExposedList$1(Spine.Bone),"sn":"bones"},{"a":4,"n":"compress","t":4,"rt":$n[0].Boolean,"sn":"compress","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"data","t":4,"rt":$n[9].IkConstraintData,"sn":"data"},{"a":4,"n":"mix","t":4,"rt":$n[0].Single,"sn":"mix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"softness","t":4,"rt":$n[0].Single,"sn":"softness","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"stretch","t":4,"rt":$n[0].Boolean,"sn":"stretch","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"target","t":4,"rt":$n[9].Bone,"sn":"target"}]}; }, $n);
    /*Spine.IkConstraint end.*/

    /*Spine.IkConstraintData start.*/
    $m("Spine.IkConstraintData", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":"BendDirection","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BendDirection","t":8,"rt":$n[0].Int32,"fg":"BendDirection","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_BendDirection","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"BendDirection"},"fn":"BendDirection"},{"a":2,"n":"Bones","t":16,"rt":$n[9].ExposedList$1(Spine.BoneData),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[9].ExposedList$1(Spine.BoneData),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"Compress","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Compress","t":8,"rt":$n[0].Boolean,"fg":"Compress","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Compress","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Compress"},"fn":"Compress"},{"a":2,"n":"Mix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Mix","t":8,"rt":$n[0].Single,"fg":"Mix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Mix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Mix"},"fn":"Mix"},{"a":2,"n":"Softness","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Softness","t":8,"rt":$n[0].Single,"fg":"Softness","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Softness","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Softness"},"fn":"Softness"},{"a":2,"n":"Stretch","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Stretch","t":8,"rt":$n[0].Boolean,"fg":"Stretch","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Stretch","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Stretch"},"fn":"Stretch"},{"a":2,"n":"Target","t":16,"rt":$n[9].BoneData,"g":{"a":2,"n":"get_Target","t":8,"rt":$n[9].BoneData,"fg":"Target"},"s":{"a":2,"n":"set_Target","t":8,"p":[$n[9].BoneData],"rt":$n[0].Void,"fs":"Target"},"fn":"Target"},{"a":2,"n":"Uniform","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Uniform","t":8,"rt":$n[0].Boolean,"fg":"Uniform","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Uniform","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Uniform"},"fn":"Uniform"},{"a":4,"n":"bendDirection","t":4,"rt":$n[0].Int32,"sn":"bendDirection","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"bones","t":4,"rt":$n[9].ExposedList$1(Spine.BoneData),"sn":"bones"},{"a":4,"n":"compress","t":4,"rt":$n[0].Boolean,"sn":"compress","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"mix","t":4,"rt":$n[0].Single,"sn":"mix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"softness","t":4,"rt":$n[0].Single,"sn":"softness","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"stretch","t":4,"rt":$n[0].Boolean,"sn":"stretch","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"target","t":4,"rt":$n[9].BoneData,"sn":"target"},{"a":4,"n":"uniform","t":4,"rt":$n[0].Boolean,"sn":"uniform","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.IkConstraintData end.*/

    /*Spine.IUpdatable start.*/
    $m("Spine.IUpdatable", function () { return {"att":161,"a":2,"m":[{"ab":true,"a":2,"n":"Update","t":8,"sn":"Spine$IUpdatable$Update","rt":$n[0].Void},{"ab":true,"a":2,"n":"Active","t":16,"rt":$n[0].Boolean,"g":{"ab":true,"a":2,"n":"get_Active","t":8,"rt":$n[0].Boolean,"fg":"Spine$IUpdatable$Active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"Spine$IUpdatable$Active"},{"a":1,"backing":true,"n":"<Active>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"Spine$IUpdatable$Active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.IUpdatable end.*/

    /*Spine.Json start.*/
    $m("Spine.Json", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"Deserialize","is":true,"t":8,"pi":[{"n":"text","pt":$n[10].TextReader,"ps":0}],"sn":"Deserialize","rt":$n[0].Object,"p":[$n[10].TextReader]}]}; }, $n);
    /*Spine.Json end.*/

    /*Spine.MathUtils start.*/
    $m("Spine.MathUtils", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"Atan2","is":true,"t":8,"pi":[{"n":"y","pt":$n[0].Single,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1}],"sn":"Atan2","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Clamp","is":true,"t":8,"pi":[{"n":"value","pt":$n[0].Single,"ps":0},{"n":"min","pt":$n[0].Single,"ps":1},{"n":"max","pt":$n[0].Single,"ps":2}],"sn":"Clamp","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Cos","is":true,"t":8,"pi":[{"n":"radians","pt":$n[0].Single,"ps":0}],"sn":"Cos","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"CosDeg","is":true,"t":8,"pi":[{"n":"degrees","pt":$n[0].Single,"ps":0}],"sn":"CosDeg","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"RandomTriangle","is":true,"t":8,"pi":[{"n":"min","pt":$n[0].Single,"ps":0},{"n":"max","pt":$n[0].Single,"ps":1}],"sn":"RandomTriangle","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"RandomTriangle","is":true,"t":8,"pi":[{"n":"min","pt":$n[0].Single,"ps":0},{"n":"max","pt":$n[0].Single,"ps":1},{"n":"mode","pt":$n[0].Single,"ps":2}],"sn":"RandomTriangle$1","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Sin","is":true,"t":8,"pi":[{"n":"radians","pt":$n[0].Single,"ps":0}],"sn":"Sin","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"SinDeg","is":true,"t":8,"pi":[{"n":"degrees","pt":$n[0].Single,"ps":0}],"sn":"SinDeg","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"DegRad","is":true,"t":4,"rt":$n[0].Single,"sn":"DegRad","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"PI","is":true,"t":4,"rt":$n[0].Single,"sn":"PI","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"PI2","is":true,"t":4,"rt":$n[0].Single,"sn":"PI2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"RadDeg","is":true,"t":4,"rt":$n[0].Single,"sn":"RadDeg","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"random","is":true,"t":4,"rt":$n[0].Random,"sn":"random"}]}; }, $n);
    /*Spine.MathUtils end.*/

    /*Spine.IInterpolation start.*/
    $m("Spine.IInterpolation", function () { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ab":true,"a":3,"n":"Apply","t":8,"pi":[{"n":"a","pt":$n[0].Single,"ps":0}],"sn":"Apply$1","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Apply","t":8,"pi":[{"n":"start","pt":$n[0].Single,"ps":0},{"n":"end","pt":$n[0].Single,"ps":1},{"n":"a","pt":$n[0].Single,"ps":2}],"sn":"Apply","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Pow2","is":true,"t":4,"rt":$n[9].IInterpolation,"sn":"Pow2"},{"a":2,"n":"Pow2Out","is":true,"t":4,"rt":$n[9].IInterpolation,"sn":"Pow2Out"}]}; }, $n);
    /*Spine.IInterpolation end.*/

    /*Spine.Pow start.*/
    $m("Spine.Pow", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Single],"pi":[{"n":"power","pt":$n[0].Single,"ps":0}],"sn":"ctor"},{"ov":true,"a":3,"n":"Apply","t":8,"pi":[{"n":"a","pt":$n[0].Single,"ps":0}],"sn":"Apply$1","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Power","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Power","t":8,"rt":$n[0].Single,"fg":"Power","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Power","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Power"},"fn":"Power"},{"a":1,"backing":true,"n":"<Power>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Power","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Pow end.*/

    /*Spine.PowOut start.*/
    $m("Spine.PowOut", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Single],"pi":[{"n":"power","pt":$n[0].Single,"ps":0}],"sn":"ctor"},{"ov":true,"a":3,"n":"Apply","t":8,"pi":[{"n":"a","pt":$n[0].Single,"ps":0}],"sn":"Apply$1","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.PowOut end.*/

    /*Spine.PathConstraint start.*/
    $m("Spine.PathConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[9].PathConstraint,$n[9].Skeleton],"pi":[{"n":"constraint","pt":$n[9].PathConstraint,"ps":0},{"n":"skeleton","pt":$n[9].Skeleton,"ps":1}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[9].PathConstraintData,$n[9].Skeleton],"pi":[{"n":"data","pt":$n[9].PathConstraintData,"ps":0},{"n":"skeleton","pt":$n[9].Skeleton,"ps":1}],"sn":"$ctor1"},{"a":1,"n":"AddAfterPosition","is":true,"t":8,"pi":[{"n":"p","pt":$n[0].Single,"ps":0},{"n":"temp","pt":$n[0].Array.type(System.Single),"ps":1},{"n":"i","pt":$n[0].Int32,"ps":2},{"n":"output","pt":$n[0].Array.type(System.Single),"ps":3},{"n":"o","pt":$n[0].Int32,"ps":4}],"sn":"AddAfterPosition","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Array.type(System.Single),$n[0].Int32,$n[0].Array.type(System.Single),$n[0].Int32]},{"a":1,"n":"AddBeforePosition","is":true,"t":8,"pi":[{"n":"p","pt":$n[0].Single,"ps":0},{"n":"temp","pt":$n[0].Array.type(System.Single),"ps":1},{"n":"i","pt":$n[0].Int32,"ps":2},{"n":"output","pt":$n[0].Array.type(System.Single),"ps":3},{"n":"o","pt":$n[0].Int32,"ps":4}],"sn":"AddBeforePosition","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Array.type(System.Single),$n[0].Int32,$n[0].Array.type(System.Single),$n[0].Int32]},{"a":1,"n":"AddCurvePosition","is":true,"t":8,"pi":[{"n":"p","pt":$n[0].Single,"ps":0},{"n":"x1","pt":$n[0].Single,"ps":1},{"n":"y1","pt":$n[0].Single,"ps":2},{"n":"cx1","pt":$n[0].Single,"ps":3},{"n":"cy1","pt":$n[0].Single,"ps":4},{"n":"cx2","pt":$n[0].Single,"ps":5},{"n":"cy2","pt":$n[0].Single,"ps":6},{"n":"x2","pt":$n[0].Single,"ps":7},{"n":"y2","pt":$n[0].Single,"ps":8},{"n":"output","pt":$n[0].Array.type(System.Single),"ps":9},{"n":"o","pt":$n[0].Int32,"ps":10},{"n":"tangents","pt":$n[0].Boolean,"ps":11}],"sn":"AddCurvePosition","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Array.type(System.Single),$n[0].Int32,$n[0].Boolean]},{"a":2,"n":"Apply","t":8,"sn":"Apply","rt":$n[0].Void},{"a":1,"n":"ComputeWorldPositions","t":8,"pi":[{"n":"path","pt":$n[9].PathAttachment,"ps":0},{"n":"spacesCount","pt":$n[0].Int32,"ps":1},{"n":"tangents","pt":$n[0].Boolean,"ps":2},{"n":"percentPosition","pt":$n[0].Boolean,"ps":3},{"n":"percentSpacing","pt":$n[0].Boolean,"ps":4}],"sn":"ComputeWorldPositions","rt":$n[0].Array.type(System.Single),"p":[$n[9].PathAttachment,$n[0].Int32,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"Active","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Active","t":8,"rt":$n[0].Boolean,"fg":"Active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"Active"},{"a":2,"n":"Bones","t":16,"rt":$n[9].ExposedList$1(Spine.Bone),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[9].ExposedList$1(Spine.Bone),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"Data","t":16,"rt":$n[9].PathConstraintData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[9].PathConstraintData,"fg":"Data"},"fn":"Data"},{"a":2,"n":"Position","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Position","t":8,"rt":$n[0].Single,"fg":"Position","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Position","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Position"},"fn":"Position"},{"a":2,"n":"RotateMix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RotateMix","t":8,"rt":$n[0].Single,"fg":"RotateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RotateMix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RotateMix"},"fn":"RotateMix"},{"a":2,"n":"Spacing","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Spacing","t":8,"rt":$n[0].Single,"fg":"Spacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Spacing","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Spacing"},"fn":"Spacing"},{"a":2,"n":"Target","t":16,"rt":$n[9].Slot,"g":{"a":2,"n":"get_Target","t":8,"rt":$n[9].Slot,"fg":"Target"},"s":{"a":2,"n":"set_Target","t":8,"p":[$n[9].Slot],"rt":$n[0].Void,"fs":"Target"},"fn":"Target"},{"a":2,"n":"TranslateMix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_TranslateMix","t":8,"rt":$n[0].Single,"fg":"TranslateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_TranslateMix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"TranslateMix"},"fn":"TranslateMix"},{"a":1,"n":"AFTER","is":true,"t":4,"rt":$n[0].Int32,"sn":"AFTER","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"BEFORE","is":true,"t":4,"rt":$n[0].Int32,"sn":"BEFORE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"Epsilon","is":true,"t":4,"rt":$n[0].Single,"sn":"Epsilon","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"NONE","is":true,"t":4,"rt":$n[0].Int32,"sn":"NONE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"active","t":4,"rt":$n[0].Boolean,"sn":"active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"bones","t":4,"rt":$n[9].ExposedList$1(Spine.Bone),"sn":"bones"},{"a":4,"n":"curves","t":4,"rt":$n[9].ExposedList$1(System.Single),"sn":"curves"},{"a":4,"n":"data","t":4,"rt":$n[9].PathConstraintData,"sn":"data"},{"a":4,"n":"lengths","t":4,"rt":$n[9].ExposedList$1(System.Single),"sn":"lengths"},{"a":4,"n":"position","t":4,"rt":$n[0].Single,"sn":"position","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"positions","t":4,"rt":$n[9].ExposedList$1(System.Single),"sn":"positions"},{"a":4,"n":"rotateMix","t":4,"rt":$n[0].Single,"sn":"rotateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"segments","t":4,"rt":$n[0].Array.type(System.Single),"sn":"segments"},{"a":4,"n":"spaces","t":4,"rt":$n[9].ExposedList$1(System.Single),"sn":"spaces"},{"a":4,"n":"spacing","t":4,"rt":$n[0].Single,"sn":"spacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"target","t":4,"rt":$n[9].Slot,"sn":"target"},{"a":4,"n":"translateMix","t":4,"rt":$n[0].Single,"sn":"translateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"world","t":4,"rt":$n[9].ExposedList$1(System.Single),"sn":"world"}]}; }, $n);
    /*Spine.PathConstraint end.*/

    /*Spine.PathConstraintData start.*/
    $m("Spine.PathConstraintData", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":"Bones","t":16,"rt":$n[9].ExposedList$1(Spine.BoneData),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[9].ExposedList$1(Spine.BoneData),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"OffsetRotation","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_OffsetRotation","t":8,"rt":$n[0].Single,"fg":"OffsetRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_OffsetRotation","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"OffsetRotation"},"fn":"OffsetRotation"},{"a":2,"n":"Position","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Position","t":8,"rt":$n[0].Single,"fg":"Position","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Position","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Position"},"fn":"Position"},{"a":2,"n":"PositionMode","t":16,"rt":$n[9].PositionMode,"g":{"a":2,"n":"get_PositionMode","t":8,"rt":$n[9].PositionMode,"fg":"PositionMode","box":function ($v) { return Bridge.box($v, Spine.PositionMode, System.Enum.toStringFn(Spine.PositionMode));}},"s":{"a":2,"n":"set_PositionMode","t":8,"p":[$n[9].PositionMode],"rt":$n[0].Void,"fs":"PositionMode"},"fn":"PositionMode"},{"a":2,"n":"RotateMix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RotateMix","t":8,"rt":$n[0].Single,"fg":"RotateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RotateMix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RotateMix"},"fn":"RotateMix"},{"a":2,"n":"RotateMode","t":16,"rt":$n[9].RotateMode,"g":{"a":2,"n":"get_RotateMode","t":8,"rt":$n[9].RotateMode,"fg":"RotateMode","box":function ($v) { return Bridge.box($v, Spine.RotateMode, System.Enum.toStringFn(Spine.RotateMode));}},"s":{"a":2,"n":"set_RotateMode","t":8,"p":[$n[9].RotateMode],"rt":$n[0].Void,"fs":"RotateMode"},"fn":"RotateMode"},{"a":2,"n":"Spacing","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Spacing","t":8,"rt":$n[0].Single,"fg":"Spacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Spacing","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Spacing"},"fn":"Spacing"},{"a":2,"n":"SpacingMode","t":16,"rt":$n[9].SpacingMode,"g":{"a":2,"n":"get_SpacingMode","t":8,"rt":$n[9].SpacingMode,"fg":"SpacingMode","box":function ($v) { return Bridge.box($v, Spine.SpacingMode, System.Enum.toStringFn(Spine.SpacingMode));}},"s":{"a":2,"n":"set_SpacingMode","t":8,"p":[$n[9].SpacingMode],"rt":$n[0].Void,"fs":"SpacingMode"},"fn":"SpacingMode"},{"a":2,"n":"Target","t":16,"rt":$n[9].SlotData,"g":{"a":2,"n":"get_Target","t":8,"rt":$n[9].SlotData,"fg":"Target"},"s":{"a":2,"n":"set_Target","t":8,"p":[$n[9].SlotData],"rt":$n[0].Void,"fs":"Target"},"fn":"Target"},{"a":2,"n":"TranslateMix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_TranslateMix","t":8,"rt":$n[0].Single,"fg":"TranslateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_TranslateMix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"TranslateMix"},"fn":"TranslateMix"},{"a":4,"n":"bones","t":4,"rt":$n[9].ExposedList$1(Spine.BoneData),"sn":"bones"},{"a":4,"n":"offsetRotation","t":4,"rt":$n[0].Single,"sn":"offsetRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"position","t":4,"rt":$n[0].Single,"sn":"position","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"positionMode","t":4,"rt":$n[9].PositionMode,"sn":"positionMode","box":function ($v) { return Bridge.box($v, Spine.PositionMode, System.Enum.toStringFn(Spine.PositionMode));}},{"a":4,"n":"rotateMix","t":4,"rt":$n[0].Single,"sn":"rotateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"rotateMode","t":4,"rt":$n[9].RotateMode,"sn":"rotateMode","box":function ($v) { return Bridge.box($v, Spine.RotateMode, System.Enum.toStringFn(Spine.RotateMode));}},{"a":4,"n":"spacing","t":4,"rt":$n[0].Single,"sn":"spacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"spacingMode","t":4,"rt":$n[9].SpacingMode,"sn":"spacingMode","box":function ($v) { return Bridge.box($v, Spine.SpacingMode, System.Enum.toStringFn(Spine.SpacingMode));}},{"a":4,"n":"target","t":4,"rt":$n[9].SlotData,"sn":"target"},{"a":4,"n":"translateMix","t":4,"rt":$n[0].Single,"sn":"translateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.PathConstraintData end.*/

    /*Spine.PositionMode start.*/
    $m("Spine.PositionMode", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Fixed","is":true,"t":4,"rt":$n[9].PositionMode,"sn":"Fixed","box":function ($v) { return Bridge.box($v, Spine.PositionMode, System.Enum.toStringFn(Spine.PositionMode));}},{"a":2,"n":"Percent","is":true,"t":4,"rt":$n[9].PositionMode,"sn":"Percent","box":function ($v) { return Bridge.box($v, Spine.PositionMode, System.Enum.toStringFn(Spine.PositionMode));}}]}; }, $n);
    /*Spine.PositionMode end.*/

    /*Spine.SpacingMode start.*/
    $m("Spine.SpacingMode", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Fixed","is":true,"t":4,"rt":$n[9].SpacingMode,"sn":"Fixed","box":function ($v) { return Bridge.box($v, Spine.SpacingMode, System.Enum.toStringFn(Spine.SpacingMode));}},{"a":2,"n":"Length","is":true,"t":4,"rt":$n[9].SpacingMode,"sn":"Length","box":function ($v) { return Bridge.box($v, Spine.SpacingMode, System.Enum.toStringFn(Spine.SpacingMode));}},{"a":2,"n":"Percent","is":true,"t":4,"rt":$n[9].SpacingMode,"sn":"Percent","box":function ($v) { return Bridge.box($v, Spine.SpacingMode, System.Enum.toStringFn(Spine.SpacingMode));}}]}; }, $n);
    /*Spine.SpacingMode end.*/

    /*Spine.RotateMode start.*/
    $m("Spine.RotateMode", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Chain","is":true,"t":4,"rt":$n[9].RotateMode,"sn":"Chain","box":function ($v) { return Bridge.box($v, Spine.RotateMode, System.Enum.toStringFn(Spine.RotateMode));}},{"a":2,"n":"ChainScale","is":true,"t":4,"rt":$n[9].RotateMode,"sn":"ChainScale","box":function ($v) { return Bridge.box($v, Spine.RotateMode, System.Enum.toStringFn(Spine.RotateMode));}},{"a":2,"n":"Tangent","is":true,"t":4,"rt":$n[9].RotateMode,"sn":"Tangent","box":function ($v) { return Bridge.box($v, Spine.RotateMode, System.Enum.toStringFn(Spine.RotateMode));}}]}; }, $n);
    /*Spine.RotateMode end.*/

    /*Spine.Skeleton start.*/
    $m("Spine.Skeleton", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[9].SkeletonData],"pi":[{"n":"data","pt":$n[9].SkeletonData,"ps":0}],"sn":"ctor"},{"a":2,"n":"FindBone","t":8,"pi":[{"n":"boneName","pt":$n[0].String,"ps":0}],"sn":"FindBone","rt":$n[9].Bone,"p":[$n[0].String]},{"a":2,"n":"FindBoneIndex","t":8,"pi":[{"n":"boneName","pt":$n[0].String,"ps":0}],"sn":"FindBoneIndex","rt":$n[0].Int32,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"FindIkConstraint","t":8,"pi":[{"n":"constraintName","pt":$n[0].String,"ps":0}],"sn":"FindIkConstraint","rt":$n[9].IkConstraint,"p":[$n[0].String]},{"a":2,"n":"FindPathConstraint","t":8,"pi":[{"n":"constraintName","pt":$n[0].String,"ps":0}],"sn":"FindPathConstraint","rt":$n[9].PathConstraint,"p":[$n[0].String]},{"a":2,"n":"FindSlot","t":8,"pi":[{"n":"slotName","pt":$n[0].String,"ps":0}],"sn":"FindSlot","rt":$n[9].Slot,"p":[$n[0].String]},{"a":2,"n":"FindSlotIndex","t":8,"pi":[{"n":"slotName","pt":$n[0].String,"ps":0}],"sn":"FindSlotIndex","rt":$n[0].Int32,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"FindTransformConstraint","t":8,"pi":[{"n":"constraintName","pt":$n[0].String,"ps":0}],"sn":"FindTransformConstraint","rt":$n[9].TransformConstraint,"p":[$n[0].String]},{"a":2,"n":"GetAttachment","t":8,"pi":[{"n":"slotIndex","pt":$n[0].Int32,"ps":0},{"n":"attachmentName","pt":$n[0].String,"ps":1}],"sn":"GetAttachment","rt":$n[9].Attachment,"p":[$n[0].Int32,$n[0].String]},{"a":2,"n":"GetAttachment","t":8,"pi":[{"n":"slotName","pt":$n[0].String,"ps":0},{"n":"attachmentName","pt":$n[0].String,"ps":1}],"sn":"GetAttachment$1","rt":$n[9].Attachment,"p":[$n[0].String,$n[0].String]},{"a":2,"n":"GetBounds","t":8,"pi":[{"n":"x","out":true,"pt":$n[0].Single,"ps":0},{"n":"y","out":true,"pt":$n[0].Single,"ps":1},{"n":"width","out":true,"pt":$n[0].Single,"ps":2},{"n":"height","out":true,"pt":$n[0].Single,"ps":3},{"n":"vertexBuffer","ref":true,"pt":$n[0].Array.type(System.Single),"ps":4}],"sn":"GetBounds","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Array.type(System.Single)]},{"a":2,"n":"SetAttachment","t":8,"pi":[{"n":"slotName","pt":$n[0].String,"ps":0},{"n":"attachmentName","pt":$n[0].String,"ps":1}],"sn":"SetAttachment","rt":$n[0].Void,"p":[$n[0].String,$n[0].String]},{"a":2,"n":"SetBonesToSetupPose","t":8,"sn":"SetBonesToSetupPose","rt":$n[0].Void},{"a":2,"n":"SetSkin","t":8,"pi":[{"n":"newSkin","pt":$n[9].Skin,"ps":0}],"sn":"SetSkin","rt":$n[0].Void,"p":[$n[9].Skin]},{"a":2,"n":"SetSkin","t":8,"pi":[{"n":"skinName","pt":$n[0].String,"ps":0}],"sn":"SetSkin$1","rt":$n[0].Void,"p":[$n[0].String]},{"a":2,"n":"SetSlotsToSetupPose","t":8,"sn":"SetSlotsToSetupPose","rt":$n[0].Void},{"a":2,"n":"SetToSetupPose","t":8,"sn":"SetToSetupPose","rt":$n[0].Void},{"a":1,"n":"SortBone","t":8,"pi":[{"n":"bone","pt":$n[9].Bone,"ps":0}],"sn":"SortBone","rt":$n[0].Void,"p":[$n[9].Bone]},{"a":1,"n":"SortIkConstraint","t":8,"pi":[{"n":"constraint","pt":$n[9].IkConstraint,"ps":0}],"sn":"SortIkConstraint","rt":$n[0].Void,"p":[$n[9].IkConstraint]},{"a":1,"n":"SortPathConstraint","t":8,"pi":[{"n":"constraint","pt":$n[9].PathConstraint,"ps":0}],"sn":"SortPathConstraint","rt":$n[0].Void,"p":[$n[9].PathConstraint]},{"a":1,"n":"SortPathConstraintAttachment","t":8,"pi":[{"n":"attachment","pt":$n[9].Attachment,"ps":0},{"n":"slotBone","pt":$n[9].Bone,"ps":1}],"sn":"SortPathConstraintAttachment","rt":$n[0].Void,"p":[$n[9].Attachment,$n[9].Bone]},{"a":1,"n":"SortPathConstraintAttachment","t":8,"pi":[{"n":"skin","pt":$n[9].Skin,"ps":0},{"n":"slotIndex","pt":$n[0].Int32,"ps":1},{"n":"slotBone","pt":$n[9].Bone,"ps":2}],"sn":"SortPathConstraintAttachment$1","rt":$n[0].Void,"p":[$n[9].Skin,$n[0].Int32,$n[9].Bone]},{"a":1,"n":"SortReset","is":true,"t":8,"pi":[{"n":"bones","pt":$n[9].ExposedList$1(Spine.Bone),"ps":0}],"sn":"SortReset","rt":$n[0].Void,"p":[$n[9].ExposedList$1(Spine.Bone)]},{"a":1,"n":"SortTransformConstraint","t":8,"pi":[{"n":"constraint","pt":$n[9].TransformConstraint,"ps":0}],"sn":"SortTransformConstraint","rt":$n[0].Void,"p":[$n[9].TransformConstraint]},{"a":2,"n":"Update","t":8,"pi":[{"n":"delta","pt":$n[0].Single,"ps":0}],"sn":"Update","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"UpdateCache","t":8,"sn":"UpdateCache","rt":$n[0].Void},{"a":2,"n":"UpdateWorldTransform","t":8,"sn":"UpdateWorldTransform","rt":$n[0].Void},{"a":2,"n":"UpdateWorldTransform","t":8,"pi":[{"n":"parent","pt":$n[9].Bone,"ps":0}],"sn":"UpdateWorldTransform$1","rt":$n[0].Void,"p":[$n[9].Bone]},{"a":2,"n":"A","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_A","t":8,"rt":$n[0].Single,"fg":"A","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_A","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"A"},"fn":"A"},{"a":2,"n":"B","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_B","t":8,"rt":$n[0].Single,"fg":"B","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_B","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"B"},"fn":"B"},{"a":2,"n":"Bones","t":16,"rt":$n[9].ExposedList$1(Spine.Bone),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[9].ExposedList$1(Spine.Bone),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"Data","t":16,"rt":$n[9].SkeletonData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[9].SkeletonData,"fg":"Data"},"fn":"Data"},{"a":2,"n":"DrawOrder","t":16,"rt":$n[9].ExposedList$1(Spine.Slot),"g":{"a":2,"n":"get_DrawOrder","t":8,"rt":$n[9].ExposedList$1(Spine.Slot),"fg":"DrawOrder"},"fn":"DrawOrder"},{"a":2,"n":"FlipX","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_FlipX","t":8,"rt":$n[0].Boolean,"fg":"FlipX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_FlipX","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"FlipX"},"fn":"FlipX"},{"a":2,"n":"FlipY","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_FlipY","t":8,"rt":$n[0].Boolean,"fg":"FlipY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_FlipY","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"FlipY"},"fn":"FlipY"},{"a":2,"n":"G","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_G","t":8,"rt":$n[0].Single,"fg":"G","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_G","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"G"},"fn":"G"},{"a":2,"n":"IkConstraints","t":16,"rt":$n[9].ExposedList$1(Spine.IkConstraint),"g":{"a":2,"n":"get_IkConstraints","t":8,"rt":$n[9].ExposedList$1(Spine.IkConstraint),"fg":"IkConstraints"},"fn":"IkConstraints"},{"a":2,"n":"PathConstraints","t":16,"rt":$n[9].ExposedList$1(Spine.PathConstraint),"g":{"a":2,"n":"get_PathConstraints","t":8,"rt":$n[9].ExposedList$1(Spine.PathConstraint),"fg":"PathConstraints"},"fn":"PathConstraints"},{"a":2,"n":"R","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_R","t":8,"rt":$n[0].Single,"fg":"R","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_R","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"R"},"fn":"R"},{"a":2,"n":"RootBone","t":16,"rt":$n[9].Bone,"g":{"a":2,"n":"get_RootBone","t":8,"rt":$n[9].Bone,"fg":"RootBone"},"fn":"RootBone"},{"a":2,"n":"ScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleX","t":8,"rt":$n[0].Single,"fg":"ScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleX"},"fn":"ScaleX"},{"a":2,"n":"ScaleY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleY","t":8,"rt":$n[0].Single,"fg":"ScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleY"},"fn":"ScaleY"},{"a":2,"n":"Skin","t":16,"rt":$n[9].Skin,"g":{"a":2,"n":"get_Skin","t":8,"rt":$n[9].Skin,"fg":"Skin"},"s":{"a":2,"n":"set_Skin","t":8,"p":[$n[9].Skin],"rt":$n[0].Void,"fs":"Skin"},"fn":"Skin"},{"a":2,"n":"Slots","t":16,"rt":$n[9].ExposedList$1(Spine.Slot),"g":{"a":2,"n":"get_Slots","t":8,"rt":$n[9].ExposedList$1(Spine.Slot),"fg":"Slots"},"fn":"Slots"},{"a":2,"n":"Time","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Time","t":8,"rt":$n[0].Single,"fg":"Time","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Time","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Time"},"fn":"Time"},{"a":2,"n":"TransformConstraints","t":16,"rt":$n[9].ExposedList$1(Spine.TransformConstraint),"g":{"a":2,"n":"get_TransformConstraints","t":8,"rt":$n[9].ExposedList$1(Spine.TransformConstraint),"fg":"TransformConstraints"},"fn":"TransformConstraints"},{"a":2,"n":"UpdateCacheList","t":16,"rt":$n[9].ExposedList$1(Spine.IUpdatable),"g":{"a":2,"n":"get_UpdateCacheList","t":8,"rt":$n[9].ExposedList$1(Spine.IUpdatable),"fg":"UpdateCacheList"},"fn":"UpdateCacheList"},{"a":2,"n":"X","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_X","t":8,"rt":$n[0].Single,"fg":"X","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_X","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"X"},"fn":"X"},{"a":2,"n":"Y","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Y","t":8,"rt":$n[0].Single,"fg":"Y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Y","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Y"},"fn":"Y"},{"a":4,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"bones","t":4,"rt":$n[9].ExposedList$1(Spine.Bone),"sn":"bones"},{"a":4,"n":"data","t":4,"rt":$n[9].SkeletonData,"sn":"data"},{"a":4,"n":"drawOrder","t":4,"rt":$n[9].ExposedList$1(Spine.Slot),"sn":"drawOrder"},{"a":4,"n":"g","t":4,"rt":$n[0].Single,"sn":"g","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"ikConstraints","t":4,"rt":$n[9].ExposedList$1(Spine.IkConstraint),"sn":"ikConstraints"},{"a":4,"n":"pathConstraints","t":4,"rt":$n[9].ExposedList$1(Spine.PathConstraint),"sn":"pathConstraints"},{"a":4,"n":"r","t":4,"rt":$n[0].Single,"sn":"r","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"scaleX","t":4,"rt":$n[0].Single,"sn":"scaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"scaleY","t":4,"rt":$n[0].Single,"sn":"scaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"skin","t":4,"rt":$n[9].Skin,"sn":"skin"},{"a":4,"n":"slots","t":4,"rt":$n[9].ExposedList$1(Spine.Slot),"sn":"slots"},{"a":4,"n":"time","t":4,"rt":$n[0].Single,"sn":"time","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"transformConstraints","t":4,"rt":$n[9].ExposedList$1(Spine.TransformConstraint),"sn":"transformConstraints"},{"a":4,"n":"updateCache","t":4,"rt":$n[9].ExposedList$1(Spine.IUpdatable),"sn":"updateCache"},{"a":4,"n":"updateCacheReset","t":4,"rt":$n[9].ExposedList$1(Spine.Bone),"sn":"updateCacheReset"},{"a":4,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Skeleton end.*/

    /*Spine.SkeletonBinary start.*/
    $m("Spine.SkeletonBinary", function () { return {"nested":[$n[9].SkeletonBinary.Vertices,$n[9].SkeletonBinary.SkeletonInput],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[System.Array.type(Spine.Atlas)],"pi":[{"n":"atlasArray","ip":true,"pt":System.Array.type(Spine.Atlas),"ps":0}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[9].AttachmentLoader],"pi":[{"n":"attachmentLoader","pt":$n[9].AttachmentLoader,"ps":0}],"sn":"$ctor1"},{"a":2,"n":"GetVersionString","is":true,"t":8,"pi":[{"n":"file","pt":$n[10].Stream,"ps":0}],"sn":"GetVersionString","rt":$n[0].String,"p":[$n[10].Stream]},{"a":1,"n":"ReadAnimation","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"input","pt":$n[9].SkeletonBinary.SkeletonInput,"ps":1},{"n":"skeletonData","pt":$n[9].SkeletonData,"ps":2}],"sn":"ReadAnimation","rt":$n[9].Animation,"p":[$n[0].String,$n[9].SkeletonBinary.SkeletonInput,$n[9].SkeletonData]},{"a":1,"n":"ReadAttachment","t":8,"pi":[{"n":"input","pt":$n[9].SkeletonBinary.SkeletonInput,"ps":0},{"n":"skeletonData","pt":$n[9].SkeletonData,"ps":1},{"n":"skin","pt":$n[9].Skin,"ps":2},{"n":"slotIndex","pt":$n[0].Int32,"ps":3},{"n":"attachmentName","pt":$n[0].String,"ps":4},{"n":"nonessential","pt":$n[0].Boolean,"ps":5}],"sn":"ReadAttachment","rt":$n[9].Attachment,"p":[$n[9].SkeletonBinary.SkeletonInput,$n[9].SkeletonData,$n[9].Skin,$n[0].Int32,$n[0].String,$n[0].Boolean]},{"a":1,"n":"ReadCurve","t":8,"pi":[{"n":"input","pt":$n[9].SkeletonBinary.SkeletonInput,"ps":0},{"n":"frameIndex","pt":$n[0].Int32,"ps":1},{"n":"timeline","pt":$n[9].CurveTimeline,"ps":2}],"sn":"ReadCurve","rt":$n[0].Void,"p":[$n[9].SkeletonBinary.SkeletonInput,$n[0].Int32,$n[9].CurveTimeline]},{"a":1,"n":"ReadFloatArray","t":8,"pi":[{"n":"input","pt":$n[9].SkeletonBinary.SkeletonInput,"ps":0},{"n":"n","pt":$n[0].Int32,"ps":1},{"n":"scale","pt":$n[0].Single,"ps":2}],"sn":"ReadFloatArray","rt":$n[0].Array.type(System.Single),"p":[$n[9].SkeletonBinary.SkeletonInput,$n[0].Int32,$n[0].Single]},{"a":1,"n":"ReadShortArray","t":8,"pi":[{"n":"input","pt":$n[9].SkeletonBinary.SkeletonInput,"ps":0}],"sn":"ReadShortArray","rt":$n[0].Array.type(System.Int32),"p":[$n[9].SkeletonBinary.SkeletonInput]},{"a":2,"n":"ReadSkeletonData","t":8,"pi":[{"n":"file","pt":$n[10].Stream,"ps":0}],"sn":"ReadSkeletonData","rt":$n[9].SkeletonData,"p":[$n[10].Stream]},{"a":2,"n":"ReadSkeletonData","t":8,"pi":[{"n":"path","pt":$n[0].String,"ps":0}],"sn":"ReadSkeletonData$1","rt":$n[9].SkeletonData,"p":[$n[0].String]},{"a":1,"n":"ReadSkin","t":8,"pi":[{"n":"input","pt":$n[9].SkeletonBinary.SkeletonInput,"ps":0},{"n":"skeletonData","pt":$n[9].SkeletonData,"ps":1},{"n":"defaultSkin","pt":$n[0].Boolean,"ps":2},{"n":"nonessential","pt":$n[0].Boolean,"ps":3}],"sn":"ReadSkin","rt":$n[9].Skin,"p":[$n[9].SkeletonBinary.SkeletonInput,$n[9].SkeletonData,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"ReadVertices","t":8,"pi":[{"n":"input","pt":$n[9].SkeletonBinary.SkeletonInput,"ps":0},{"n":"vertexCount","pt":$n[0].Int32,"ps":1}],"sn":"ReadVertices","rt":$n[9].SkeletonBinary.Vertices,"p":[$n[9].SkeletonBinary.SkeletonInput,$n[0].Int32]},{"a":2,"n":"Scale","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Scale","t":8,"rt":$n[0].Single,"fg":"Scale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Scale","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Scale"},"fn":"Scale"},{"a":2,"n":"BONE_ROTATE","is":true,"t":4,"rt":$n[0].Int32,"sn":"BONE_ROTATE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BONE_SCALE","is":true,"t":4,"rt":$n[0].Int32,"sn":"BONE_SCALE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BONE_SHEAR","is":true,"t":4,"rt":$n[0].Int32,"sn":"BONE_SHEAR","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BONE_TRANSLATE","is":true,"t":4,"rt":$n[0].Int32,"sn":"BONE_TRANSLATE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"CURVE_BEZIER","is":true,"t":4,"rt":$n[0].Int32,"sn":"CURVE_BEZIER","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"CURVE_LINEAR","is":true,"t":4,"rt":$n[0].Int32,"sn":"CURVE_LINEAR","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"CURVE_STEPPED","is":true,"t":4,"rt":$n[0].Int32,"sn":"CURVE_STEPPED","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"PATH_MIX","is":true,"t":4,"rt":$n[0].Int32,"sn":"PATH_MIX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"PATH_POSITION","is":true,"t":4,"rt":$n[0].Int32,"sn":"PATH_POSITION","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"PATH_SPACING","is":true,"t":4,"rt":$n[0].Int32,"sn":"PATH_SPACING","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"SLOT_ATTACHMENT","is":true,"t":4,"rt":$n[0].Int32,"sn":"SLOT_ATTACHMENT","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"SLOT_COLOR","is":true,"t":4,"rt":$n[0].Int32,"sn":"SLOT_COLOR","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"SLOT_TWO_COLOR","is":true,"t":4,"rt":$n[0].Int32,"sn":"SLOT_TWO_COLOR","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"TransformModeValues","is":true,"t":4,"rt":System.Array.type(Spine.TransformMode),"sn":"TransformModeValues","ro":true},{"a":1,"n":"attachmentLoader","t":4,"rt":$n[9].AttachmentLoader,"sn":"attachmentLoader"},{"a":1,"n":"linkedMeshes","t":4,"rt":$n[5].List$1(Spine.SkeletonJson.LinkedMesh),"sn":"linkedMeshes"},{"a":1,"backing":true,"n":"<Scale>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Scale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.SkeletonBinary end.*/

    /*Spine.SkeletonBinary+Vertices start.*/
    $m("Spine.SkeletonBinary.Vertices", function () { return {"td":$n[9].SkeletonBinary,"att":1048581,"a":4,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"bones","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"bones"},{"a":2,"n":"vertices","t":4,"rt":$n[0].Array.type(System.Single),"sn":"vertices"}]}; }, $n);
    /*Spine.SkeletonBinary+Vertices end.*/

    /*Spine.SkeletonBinary+SkeletonInput start.*/
    $m("Spine.SkeletonBinary.SkeletonInput", function () { return {"td":$n[9].SkeletonBinary,"att":1048581,"a":4,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[10].Stream],"pi":[{"n":"input","pt":$n[10].Stream,"ps":0}],"sn":"ctor"},{"a":2,"n":"GetVersionString","t":8,"sn":"GetVersionString","rt":$n[0].String},{"a":2,"n":"ReadBoolean","t":8,"sn":"ReadBoolean","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"ReadByte","t":8,"sn":"ReadByte","rt":$n[0].Byte,"box":function ($v) { return Bridge.box($v, System.Byte);}},{"a":2,"n":"ReadFloat","t":8,"sn":"ReadFloat","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"ReadFully","t":8,"pi":[{"n":"buffer","pt":$n[0].Array.type(System.Byte),"ps":0},{"n":"offset","pt":$n[0].Int32,"ps":1},{"n":"length","pt":$n[0].Int32,"ps":2}],"sn":"ReadFully","rt":$n[0].Void,"p":[$n[0].Array.type(System.Byte),$n[0].Int32,$n[0].Int32]},{"a":2,"n":"ReadInt","t":8,"sn":"ReadInt","rt":$n[0].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ReadInt","t":8,"pi":[{"n":"optimizePositive","pt":$n[0].Boolean,"ps":0}],"sn":"ReadInt$1","rt":$n[0].Int32,"p":[$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ReadSByte","t":8,"sn":"ReadSByte","rt":$n[0].SByte,"box":function ($v) { return Bridge.box($v, System.SByte);}},{"a":2,"n":"ReadString","t":8,"sn":"ReadString","rt":$n[0].String},{"a":2,"n":"ReadStringRef","t":8,"sn":"ReadStringRef","rt":$n[0].String},{"a":1,"n":"bytesBigEndian","t":4,"rt":$n[0].Array.type(System.Byte),"sn":"bytesBigEndian"},{"a":1,"n":"chars","t":4,"rt":$n[0].Array.type(System.Byte),"sn":"chars"},{"a":1,"n":"input","t":4,"rt":$n[10].Stream,"sn":"input"},{"a":4,"n":"strings","t":4,"rt":$n[9].ExposedList$1(System.String),"sn":"strings"}]}; }, $n);
    /*Spine.SkeletonBinary+SkeletonInput end.*/

    /*Spine.SkeletonBounds start.*/
    $m("Spine.SkeletonBounds", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AabbCompute","t":8,"sn":"AabbCompute","rt":$n[0].Void},{"a":2,"n":"AabbContainsPoint","t":8,"pi":[{"n":"x","pt":$n[0].Single,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1}],"sn":"AabbContainsPoint","rt":$n[0].Boolean,"p":[$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"AabbIntersectsSegment","t":8,"pi":[{"n":"x1","pt":$n[0].Single,"ps":0},{"n":"y1","pt":$n[0].Single,"ps":1},{"n":"x2","pt":$n[0].Single,"ps":2},{"n":"y2","pt":$n[0].Single,"ps":3}],"sn":"AabbIntersectsSegment","rt":$n[0].Boolean,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"AabbIntersectsSkeleton","t":8,"pi":[{"n":"bounds","pt":$n[9].SkeletonBounds,"ps":0}],"sn":"AabbIntersectsSkeleton","rt":$n[0].Boolean,"p":[$n[9].SkeletonBounds],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"ContainsPoint","t":8,"pi":[{"n":"x","pt":$n[0].Single,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1}],"sn":"ContainsPoint","rt":$n[9].BoundingBoxAttachment,"p":[$n[0].Single,$n[0].Single]},{"a":2,"n":"ContainsPoint","t":8,"pi":[{"n":"polygon","pt":$n[9].Polygon,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"y","pt":$n[0].Single,"ps":2}],"sn":"ContainsPoint$1","rt":$n[0].Boolean,"p":[$n[9].Polygon,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GetPolygon","t":8,"pi":[{"n":"attachment","pt":$n[9].BoundingBoxAttachment,"ps":0}],"sn":"GetPolygon","rt":$n[9].Polygon,"p":[$n[9].BoundingBoxAttachment]},{"a":2,"n":"IntersectsSegment","t":8,"pi":[{"n":"x1","pt":$n[0].Single,"ps":0},{"n":"y1","pt":$n[0].Single,"ps":1},{"n":"x2","pt":$n[0].Single,"ps":2},{"n":"y2","pt":$n[0].Single,"ps":3}],"sn":"IntersectsSegment","rt":$n[9].BoundingBoxAttachment,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"IntersectsSegment","t":8,"pi":[{"n":"polygon","pt":$n[9].Polygon,"ps":0},{"n":"x1","pt":$n[0].Single,"ps":1},{"n":"y1","pt":$n[0].Single,"ps":2},{"n":"x2","pt":$n[0].Single,"ps":3},{"n":"y2","pt":$n[0].Single,"ps":4}],"sn":"IntersectsSegment$1","rt":$n[0].Boolean,"p":[$n[9].Polygon,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Update","t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0},{"n":"updateAabb","pt":$n[0].Boolean,"ps":1}],"sn":"Update","rt":$n[0].Void,"p":[$n[9].Skeleton,$n[0].Boolean]},{"a":2,"n":"BoundingBoxes","t":16,"rt":$n[9].ExposedList$1(Spine.BoundingBoxAttachment),"g":{"a":2,"n":"get_BoundingBoxes","t":8,"rt":$n[9].ExposedList$1(Spine.BoundingBoxAttachment),"fg":"BoundingBoxes"},"s":{"a":1,"n":"set_BoundingBoxes","t":8,"p":[$n[9].ExposedList$1(Spine.BoundingBoxAttachment)],"rt":$n[0].Void,"fs":"BoundingBoxes"},"fn":"BoundingBoxes"},{"a":2,"n":"Height","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Height","t":8,"rt":$n[0].Single,"fg":"Height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"Height"},{"a":2,"n":"MaxX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MaxX","t":8,"rt":$n[0].Single,"fg":"MaxX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MaxX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MaxX"},"fn":"MaxX"},{"a":2,"n":"MaxY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MaxY","t":8,"rt":$n[0].Single,"fg":"MaxY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MaxY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MaxY"},"fn":"MaxY"},{"a":2,"n":"MinX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MinX","t":8,"rt":$n[0].Single,"fg":"MinX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MinX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MinX"},"fn":"MinX"},{"a":2,"n":"MinY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MinY","t":8,"rt":$n[0].Single,"fg":"MinY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MinY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MinY"},"fn":"MinY"},{"a":2,"n":"Polygons","t":16,"rt":$n[9].ExposedList$1(Spine.Polygon),"g":{"a":2,"n":"get_Polygons","t":8,"rt":$n[9].ExposedList$1(Spine.Polygon),"fg":"Polygons"},"s":{"a":1,"n":"set_Polygons","t":8,"p":[$n[9].ExposedList$1(Spine.Polygon)],"rt":$n[0].Void,"fs":"Polygons"},"fn":"Polygons"},{"a":2,"n":"Width","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Width","t":8,"rt":$n[0].Single,"fg":"Width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"Width"},{"a":1,"n":"maxX","t":4,"rt":$n[0].Single,"sn":"maxX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"maxY","t":4,"rt":$n[0].Single,"sn":"maxY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"minX","t":4,"rt":$n[0].Single,"sn":"minX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"minY","t":4,"rt":$n[0].Single,"sn":"minY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"polygonPool","t":4,"rt":$n[9].ExposedList$1(Spine.Polygon),"sn":"polygonPool"},{"a":1,"backing":true,"n":"<BoundingBoxes>k__BackingField","t":4,"rt":$n[9].ExposedList$1(Spine.BoundingBoxAttachment),"sn":"BoundingBoxes"},{"a":1,"backing":true,"n":"<Polygons>k__BackingField","t":4,"rt":$n[9].ExposedList$1(Spine.Polygon),"sn":"Polygons"}]}; }, $n);
    /*Spine.SkeletonBounds end.*/

    /*Spine.Polygon start.*/
    $m("Spine.Polygon", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Count","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Count","t":8,"rt":$n[0].Int32,"fg":"Count","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_Count","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Count"},"fn":"Count"},{"a":2,"n":"Vertices","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Vertices","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Vertices"},"s":{"a":2,"n":"set_Vertices","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Vertices"},"fn":"Vertices"},{"a":1,"backing":true,"n":"<Count>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"Count","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"backing":true,"n":"<Vertices>k__BackingField","t":4,"rt":$n[0].Array.type(System.Single),"sn":"Vertices"}]}; }, $n);
    /*Spine.Polygon end.*/

    /*Spine.SkeletonClipping start.*/
    $m("Spine.SkeletonClipping", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":4,"n":"Clip","t":8,"pi":[{"n":"x1","pt":$n[0].Single,"ps":0},{"n":"y1","pt":$n[0].Single,"ps":1},{"n":"x2","pt":$n[0].Single,"ps":2},{"n":"y2","pt":$n[0].Single,"ps":3},{"n":"x3","pt":$n[0].Single,"ps":4},{"n":"y3","pt":$n[0].Single,"ps":5},{"n":"clippingArea","pt":$n[9].ExposedList$1(System.Single),"ps":6},{"n":"output","pt":$n[9].ExposedList$1(System.Single),"ps":7}],"sn":"Clip","rt":$n[0].Boolean,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[9].ExposedList$1(System.Single),$n[9].ExposedList$1(System.Single)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"ClipEnd","t":8,"sn":"ClipEnd","rt":$n[0].Void},{"a":2,"n":"ClipEnd","t":8,"pi":[{"n":"slot","pt":$n[9].Slot,"ps":0}],"sn":"ClipEnd$1","rt":$n[0].Void,"p":[$n[9].Slot]},{"a":2,"n":"ClipStart","t":8,"pi":[{"n":"slot","pt":$n[9].Slot,"ps":0},{"n":"clip","pt":$n[9].ClippingAttachment,"ps":1}],"sn":"ClipStart","rt":$n[0].Int32,"p":[$n[9].Slot,$n[9].ClippingAttachment],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ClipTriangles","t":8,"pi":[{"n":"vertices","pt":$n[0].Array.type(System.Single),"ps":0},{"n":"verticesLength","pt":$n[0].Int32,"ps":1},{"n":"triangles","pt":$n[0].Array.type(System.Int32),"ps":2},{"n":"trianglesLength","pt":$n[0].Int32,"ps":3},{"n":"uvs","pt":$n[0].Array.type(System.Single),"ps":4}],"sn":"ClipTriangles","rt":$n[0].Void,"p":[$n[0].Array.type(System.Single),$n[0].Int32,$n[0].Array.type(System.Int32),$n[0].Int32,$n[0].Array.type(System.Single)]},{"a":2,"n":"MakeClockwise","is":true,"t":8,"pi":[{"n":"polygon","pt":$n[9].ExposedList$1(System.Single),"ps":0}],"sn":"MakeClockwise","rt":$n[0].Void,"p":[$n[9].ExposedList$1(System.Single)]},{"a":2,"n":"ClippedTriangles","t":16,"rt":$n[9].ExposedList$1(System.Int32),"g":{"a":2,"n":"get_ClippedTriangles","t":8,"rt":$n[9].ExposedList$1(System.Int32),"fg":"ClippedTriangles"},"fn":"ClippedTriangles"},{"a":2,"n":"ClippedUVs","t":16,"rt":$n[9].ExposedList$1(System.Single),"g":{"a":2,"n":"get_ClippedUVs","t":8,"rt":$n[9].ExposedList$1(System.Single),"fg":"ClippedUVs"},"fn":"ClippedUVs"},{"a":2,"n":"ClippedVertices","t":16,"rt":$n[9].ExposedList$1(System.Single),"g":{"a":2,"n":"get_ClippedVertices","t":8,"rt":$n[9].ExposedList$1(System.Single),"fg":"ClippedVertices"},"fn":"ClippedVertices"},{"a":2,"n":"IsClipping","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsClipping","t":8,"rt":$n[0].Boolean,"fg":"IsClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsClipping"},{"a":4,"n":"clipAttachment","t":4,"rt":$n[9].ClippingAttachment,"sn":"clipAttachment"},{"a":4,"n":"clipOutput","t":4,"rt":$n[9].ExposedList$1(System.Single),"sn":"clipOutput","ro":true},{"a":4,"n":"clippedTriangles","t":4,"rt":$n[9].ExposedList$1(System.Int32),"sn":"clippedTriangles","ro":true},{"a":4,"n":"clippedUVs","t":4,"rt":$n[9].ExposedList$1(System.Single),"sn":"clippedUVs","ro":true},{"a":4,"n":"clippedVertices","t":4,"rt":$n[9].ExposedList$1(System.Single),"sn":"clippedVertices","ro":true},{"a":4,"n":"clippingPolygon","t":4,"rt":$n[9].ExposedList$1(System.Single),"sn":"clippingPolygon","ro":true},{"a":4,"n":"clippingPolygons","t":4,"rt":$n[9].ExposedList$1(Spine.ExposedList$1(System.Single)),"sn":"clippingPolygons"},{"a":4,"n":"scratch","t":4,"rt":$n[9].ExposedList$1(System.Single),"sn":"scratch","ro":true},{"a":4,"n":"triangulator","t":4,"rt":$n[9].Triangulator,"sn":"triangulator","ro":true}]}; }, $n);
    /*Spine.SkeletonClipping end.*/

    /*Spine.SkeletonData start.*/
    $m("Spine.SkeletonData", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"FindAnimation","t":8,"pi":[{"n":"animationName","pt":$n[0].String,"ps":0}],"sn":"FindAnimation","rt":$n[9].Animation,"p":[$n[0].String]},{"a":2,"n":"FindBone","t":8,"pi":[{"n":"boneName","pt":$n[0].String,"ps":0}],"sn":"FindBone","rt":$n[9].BoneData,"p":[$n[0].String]},{"a":2,"n":"FindBoneIndex","t":8,"pi":[{"n":"boneName","pt":$n[0].String,"ps":0}],"sn":"FindBoneIndex","rt":$n[0].Int32,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"FindEvent","t":8,"pi":[{"n":"eventDataName","pt":$n[0].String,"ps":0}],"sn":"FindEvent","rt":$n[9].EventData,"p":[$n[0].String]},{"a":2,"n":"FindIkConstraint","t":8,"pi":[{"n":"constraintName","pt":$n[0].String,"ps":0}],"sn":"FindIkConstraint","rt":$n[9].IkConstraintData,"p":[$n[0].String]},{"a":2,"n":"FindPathConstraint","t":8,"pi":[{"n":"constraintName","pt":$n[0].String,"ps":0}],"sn":"FindPathConstraint","rt":$n[9].PathConstraintData,"p":[$n[0].String]},{"a":2,"n":"FindPathConstraintIndex","t":8,"pi":[{"n":"pathConstraintName","pt":$n[0].String,"ps":0}],"sn":"FindPathConstraintIndex","rt":$n[0].Int32,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"FindSkin","t":8,"pi":[{"n":"skinName","pt":$n[0].String,"ps":0}],"sn":"FindSkin","rt":$n[9].Skin,"p":[$n[0].String]},{"a":2,"n":"FindSlot","t":8,"pi":[{"n":"slotName","pt":$n[0].String,"ps":0}],"sn":"FindSlot","rt":$n[9].SlotData,"p":[$n[0].String]},{"a":2,"n":"FindSlotIndex","t":8,"pi":[{"n":"slotName","pt":$n[0].String,"ps":0}],"sn":"FindSlotIndex","rt":$n[0].Int32,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"FindTransformConstraint","t":8,"pi":[{"n":"constraintName","pt":$n[0].String,"ps":0}],"sn":"FindTransformConstraint","rt":$n[9].TransformConstraintData,"p":[$n[0].String]},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Animations","t":16,"rt":$n[9].ExposedList$1(Spine.Animation),"g":{"a":2,"n":"get_Animations","t":8,"rt":$n[9].ExposedList$1(Spine.Animation),"fg":"Animations"},"s":{"a":2,"n":"set_Animations","t":8,"p":[$n[9].ExposedList$1(Spine.Animation)],"rt":$n[0].Void,"fs":"Animations"},"fn":"Animations"},{"a":2,"n":"AudioPath","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_AudioPath","t":8,"rt":$n[0].String,"fg":"AudioPath"},"s":{"a":2,"n":"set_AudioPath","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"AudioPath"},"fn":"AudioPath"},{"a":2,"n":"Bones","t":16,"rt":$n[9].ExposedList$1(Spine.BoneData),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[9].ExposedList$1(Spine.BoneData),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"DefaultSkin","t":16,"rt":$n[9].Skin,"g":{"a":2,"n":"get_DefaultSkin","t":8,"rt":$n[9].Skin,"fg":"DefaultSkin"},"s":{"a":2,"n":"set_DefaultSkin","t":8,"p":[$n[9].Skin],"rt":$n[0].Void,"fs":"DefaultSkin"},"fn":"DefaultSkin"},{"a":2,"n":"Events","t":16,"rt":$n[9].ExposedList$1(Spine.EventData),"g":{"a":2,"n":"get_Events","t":8,"rt":$n[9].ExposedList$1(Spine.EventData),"fg":"Events"},"s":{"a":2,"n":"set_Events","t":8,"p":[$n[9].ExposedList$1(Spine.EventData)],"rt":$n[0].Void,"fs":"Events"},"fn":"Events"},{"a":2,"n":"Fps","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Fps","t":8,"rt":$n[0].Single,"fg":"Fps","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Fps","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Fps"},"fn":"Fps"},{"a":2,"n":"Hash","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Hash","t":8,"rt":$n[0].String,"fg":"Hash"},"s":{"a":2,"n":"set_Hash","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"Hash"},"fn":"Hash"},{"a":2,"n":"Height","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Height","t":8,"rt":$n[0].Single,"fg":"Height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Height","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Height"},"fn":"Height"},{"a":2,"n":"IkConstraints","t":16,"rt":$n[9].ExposedList$1(Spine.IkConstraintData),"g":{"a":2,"n":"get_IkConstraints","t":8,"rt":$n[9].ExposedList$1(Spine.IkConstraintData),"fg":"IkConstraints"},"s":{"a":2,"n":"set_IkConstraints","t":8,"p":[$n[9].ExposedList$1(Spine.IkConstraintData)],"rt":$n[0].Void,"fs":"IkConstraints"},"fn":"IkConstraints"},{"a":2,"n":"ImagesPath","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_ImagesPath","t":8,"rt":$n[0].String,"fg":"ImagesPath"},"s":{"a":2,"n":"set_ImagesPath","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"ImagesPath"},"fn":"ImagesPath"},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"s":{"a":2,"n":"set_Name","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"Name"},"fn":"Name"},{"a":2,"n":"PathConstraints","t":16,"rt":$n[9].ExposedList$1(Spine.PathConstraintData),"g":{"a":2,"n":"get_PathConstraints","t":8,"rt":$n[9].ExposedList$1(Spine.PathConstraintData),"fg":"PathConstraints"},"s":{"a":2,"n":"set_PathConstraints","t":8,"p":[$n[9].ExposedList$1(Spine.PathConstraintData)],"rt":$n[0].Void,"fs":"PathConstraints"},"fn":"PathConstraints"},{"a":2,"n":"Skins","t":16,"rt":$n[9].ExposedList$1(Spine.Skin),"g":{"a":2,"n":"get_Skins","t":8,"rt":$n[9].ExposedList$1(Spine.Skin),"fg":"Skins"},"s":{"a":2,"n":"set_Skins","t":8,"p":[$n[9].ExposedList$1(Spine.Skin)],"rt":$n[0].Void,"fs":"Skins"},"fn":"Skins"},{"a":2,"n":"Slots","t":16,"rt":$n[9].ExposedList$1(Spine.SlotData),"g":{"a":2,"n":"get_Slots","t":8,"rt":$n[9].ExposedList$1(Spine.SlotData),"fg":"Slots"},"fn":"Slots"},{"a":2,"n":"TransformConstraints","t":16,"rt":$n[9].ExposedList$1(Spine.TransformConstraintData),"g":{"a":2,"n":"get_TransformConstraints","t":8,"rt":$n[9].ExposedList$1(Spine.TransformConstraintData),"fg":"TransformConstraints"},"s":{"a":2,"n":"set_TransformConstraints","t":8,"p":[$n[9].ExposedList$1(Spine.TransformConstraintData)],"rt":$n[0].Void,"fs":"TransformConstraints"},"fn":"TransformConstraints"},{"a":2,"n":"Version","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Version","t":8,"rt":$n[0].String,"fg":"Version"},"s":{"a":2,"n":"set_Version","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"Version"},"fn":"Version"},{"a":2,"n":"Width","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Width","t":8,"rt":$n[0].Single,"fg":"Width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Width","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Width"},"fn":"Width"},{"a":2,"n":"X","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_X","t":8,"rt":$n[0].Single,"fg":"X","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_X","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"X"},"fn":"X"},{"a":2,"n":"Y","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Y","t":8,"rt":$n[0].Single,"fg":"Y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Y","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Y"},"fn":"Y"},{"a":4,"n":"animations","t":4,"rt":$n[9].ExposedList$1(Spine.Animation),"sn":"animations"},{"a":4,"n":"audioPath","t":4,"rt":$n[0].String,"sn":"audioPath"},{"a":4,"n":"bones","t":4,"rt":$n[9].ExposedList$1(Spine.BoneData),"sn":"bones"},{"a":4,"n":"defaultSkin","t":4,"rt":$n[9].Skin,"sn":"defaultSkin"},{"a":4,"n":"events","t":4,"rt":$n[9].ExposedList$1(Spine.EventData),"sn":"events"},{"a":4,"n":"fps","t":4,"rt":$n[0].Single,"sn":"fps","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"hash","t":4,"rt":$n[0].String,"sn":"hash"},{"a":4,"n":"height","t":4,"rt":$n[0].Single,"sn":"height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"ikConstraints","t":4,"rt":$n[9].ExposedList$1(Spine.IkConstraintData),"sn":"ikConstraints"},{"a":4,"n":"imagesPath","t":4,"rt":$n[0].String,"sn":"imagesPath"},{"a":4,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":4,"n":"pathConstraints","t":4,"rt":$n[9].ExposedList$1(Spine.PathConstraintData),"sn":"pathConstraints"},{"a":4,"n":"skins","t":4,"rt":$n[9].ExposedList$1(Spine.Skin),"sn":"skins"},{"a":4,"n":"slots","t":4,"rt":$n[9].ExposedList$1(Spine.SlotData),"sn":"slots"},{"a":4,"n":"transformConstraints","t":4,"rt":$n[9].ExposedList$1(Spine.TransformConstraintData),"sn":"transformConstraints"},{"a":4,"n":"version","t":4,"rt":$n[0].String,"sn":"version"},{"a":4,"n":"width","t":4,"rt":$n[0].Single,"sn":"width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.SkeletonData end.*/

    /*Spine.SkeletonJson start.*/
    $m("Spine.SkeletonJson", function () { return {"nested":[$n[9].SkeletonJson.LinkedMesh],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[System.Array.type(Spine.Atlas)],"pi":[{"n":"atlasArray","ip":true,"pt":System.Array.type(Spine.Atlas),"ps":0}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[9].AttachmentLoader],"pi":[{"n":"attachmentLoader","pt":$n[9].AttachmentLoader,"ps":0}],"sn":"$ctor1"},{"a":1,"n":"GetBoolean","is":true,"t":8,"pi":[{"n":"map","pt":$n[5].Dictionary$2(System.String,System.Object),"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"defaultValue","pt":$n[0].Boolean,"ps":2}],"sn":"GetBoolean","rt":$n[0].Boolean,"p":[$n[5].Dictionary$2(System.String,System.Object),$n[0].String,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"GetFloat","is":true,"t":8,"pi":[{"n":"map","pt":$n[5].Dictionary$2(System.String,System.Object),"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"defaultValue","pt":$n[0].Single,"ps":2}],"sn":"GetFloat","rt":$n[0].Single,"p":[$n[5].Dictionary$2(System.String,System.Object),$n[0].String,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"GetFloatArray","is":true,"t":8,"pi":[{"n":"map","pt":$n[5].Dictionary$2(System.String,System.Object),"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"scale","pt":$n[0].Single,"ps":2}],"sn":"GetFloatArray","rt":$n[0].Array.type(System.Single),"p":[$n[5].Dictionary$2(System.String,System.Object),$n[0].String,$n[0].Single]},{"a":1,"n":"GetInt","is":true,"t":8,"pi":[{"n":"map","pt":$n[5].Dictionary$2(System.String,System.Object),"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"defaultValue","pt":$n[0].Int32,"ps":2}],"sn":"GetInt","rt":$n[0].Int32,"p":[$n[5].Dictionary$2(System.String,System.Object),$n[0].String,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"GetIntArray","is":true,"t":8,"pi":[{"n":"map","pt":$n[5].Dictionary$2(System.String,System.Object),"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"GetIntArray","rt":$n[0].Array.type(System.Int32),"p":[$n[5].Dictionary$2(System.String,System.Object),$n[0].String]},{"a":1,"n":"GetString","is":true,"t":8,"pi":[{"n":"map","pt":$n[5].Dictionary$2(System.String,System.Object),"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"defaultValue","pt":$n[0].String,"ps":2}],"sn":"GetString","rt":$n[0].String,"p":[$n[5].Dictionary$2(System.String,System.Object),$n[0].String,$n[0].String]},{"a":1,"n":"ReadAnimation","t":8,"pi":[{"n":"map","pt":$n[5].Dictionary$2(System.String,System.Object),"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"skeletonData","pt":$n[9].SkeletonData,"ps":2}],"sn":"ReadAnimation","rt":$n[0].Void,"p":[$n[5].Dictionary$2(System.String,System.Object),$n[0].String,$n[9].SkeletonData]},{"a":1,"n":"ReadAttachment","t":8,"pi":[{"n":"map","pt":$n[5].Dictionary$2(System.String,System.Object),"ps":0},{"n":"skin","pt":$n[9].Skin,"ps":1},{"n":"slotIndex","pt":$n[0].Int32,"ps":2},{"n":"name","pt":$n[0].String,"ps":3},{"n":"skeletonData","pt":$n[9].SkeletonData,"ps":4}],"sn":"ReadAttachment","rt":$n[9].Attachment,"p":[$n[5].Dictionary$2(System.String,System.Object),$n[9].Skin,$n[0].Int32,$n[0].String,$n[9].SkeletonData]},{"a":1,"n":"ReadCurve","is":true,"t":8,"pi":[{"n":"valueMap","pt":$n[5].Dictionary$2(System.String,System.Object),"ps":0},{"n":"timeline","pt":$n[9].CurveTimeline,"ps":1},{"n":"frameIndex","pt":$n[0].Int32,"ps":2}],"sn":"ReadCurve","rt":$n[0].Void,"p":[$n[5].Dictionary$2(System.String,System.Object),$n[9].CurveTimeline,$n[0].Int32]},{"a":2,"n":"ReadSkeletonData","t":8,"pi":[{"n":"reader","pt":$n[10].TextReader,"ps":0}],"sn":"ReadSkeletonData","rt":$n[9].SkeletonData,"p":[$n[10].TextReader]},{"a":2,"n":"ReadSkeletonData","t":8,"pi":[{"n":"path","pt":$n[0].String,"ps":0}],"sn":"ReadSkeletonData$1","rt":$n[9].SkeletonData,"p":[$n[0].String]},{"a":1,"n":"ReadVertices","t":8,"pi":[{"n":"map","pt":$n[5].Dictionary$2(System.String,System.Object),"ps":0},{"n":"attachment","pt":$n[9].VertexAttachment,"ps":1},{"n":"verticesLength","pt":$n[0].Int32,"ps":2}],"sn":"ReadVertices","rt":$n[0].Void,"p":[$n[5].Dictionary$2(System.String,System.Object),$n[9].VertexAttachment,$n[0].Int32]},{"a":1,"n":"ToColor","is":true,"t":8,"pi":[{"n":"hexString","pt":$n[0].String,"ps":0},{"n":"colorIndex","pt":$n[0].Int32,"ps":1},{"n":"expectedLength","dv":8,"o":true,"pt":$n[0].Int32,"ps":2}],"sn":"ToColor","rt":$n[0].Single,"p":[$n[0].String,$n[0].Int32,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Scale","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Scale","t":8,"rt":$n[0].Single,"fg":"Scale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Scale","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Scale"},"fn":"Scale"},{"a":1,"n":"attachmentLoader","t":4,"rt":$n[9].AttachmentLoader,"sn":"attachmentLoader"},{"a":1,"n":"linkedMeshes","t":4,"rt":$n[5].List$1(Spine.SkeletonJson.LinkedMesh),"sn":"linkedMeshes"},{"a":1,"backing":true,"n":"<Scale>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Scale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.SkeletonJson end.*/

    /*Spine.SkeletonJson+LinkedMesh start.*/
    $m("Spine.SkeletonJson.LinkedMesh", function () { return {"td":$n[9].SkeletonJson,"att":1048581,"a":4,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[9].MeshAttachment,$n[0].String,$n[0].Int32,$n[0].String,$n[0].Boolean],"pi":[{"n":"mesh","pt":$n[9].MeshAttachment,"ps":0},{"n":"skin","pt":$n[0].String,"ps":1},{"n":"slotIndex","pt":$n[0].Int32,"ps":2},{"n":"parent","pt":$n[0].String,"ps":3},{"n":"inheritDeform","pt":$n[0].Boolean,"ps":4}],"sn":"ctor"},{"a":4,"n":"inheritDeform","t":4,"rt":$n[0].Boolean,"sn":"inheritDeform","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"mesh","t":4,"rt":$n[9].MeshAttachment,"sn":"mesh"},{"a":4,"n":"parent","t":4,"rt":$n[0].String,"sn":"parent"},{"a":4,"n":"skin","t":4,"rt":$n[0].String,"sn":"skin"},{"a":4,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.SkeletonJson+LinkedMesh end.*/

    /*Spine.Skin start.*/
    $m("Spine.Skin", function () { return {"nested":[$n[9].Skin.SkinEntry,$n[9].Skin.SkinEntryComparer],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":"AddSkin","t":8,"pi":[{"n":"skin","pt":$n[9].Skin,"ps":0}],"sn":"AddSkin","rt":$n[0].Void,"p":[$n[9].Skin]},{"a":4,"n":"AttachAll","t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0},{"n":"oldSkin","pt":$n[9].Skin,"ps":1}],"sn":"AttachAll","rt":$n[0].Void,"p":[$n[9].Skeleton,$n[9].Skin]},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"CopySkin","t":8,"pi":[{"n":"skin","pt":$n[9].Skin,"ps":0}],"sn":"CopySkin","rt":$n[0].Void,"p":[$n[9].Skin]},{"a":2,"n":"GetAttachment","t":8,"pi":[{"n":"slotIndex","pt":$n[0].Int32,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"GetAttachment","rt":$n[9].Attachment,"p":[$n[0].Int32,$n[0].String]},{"a":2,"n":"GetAttachments","t":8,"sn":"GetAttachments","rt":$n[5].ICollection$1(Spine.Skin.SkinEntry)},{"a":2,"n":"GetAttachments","t":8,"pi":[{"n":"slotIndex","pt":$n[0].Int32,"ps":0},{"n":"attachments","pt":$n[5].List$1(Spine.Skin.SkinEntry),"ps":1}],"sn":"GetAttachments$1","rt":$n[0].Void,"p":[$n[0].Int32,$n[5].List$1(Spine.Skin.SkinEntry)]},{"a":2,"n":"RemoveAttachment","t":8,"pi":[{"n":"slotIndex","pt":$n[0].Int32,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"RemoveAttachment","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].String]},{"a":2,"n":"SetAttachment","t":8,"pi":[{"n":"slotIndex","pt":$n[0].Int32,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"attachment","pt":$n[9].Attachment,"ps":2}],"sn":"SetAttachment","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].String,$n[9].Attachment]},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Attachments","t":16,"rt":$n[11].OrderedDictionary$2(Spine.Skin.SkinEntry,Spine.Attachment),"g":{"a":2,"n":"get_Attachments","t":8,"rt":$n[11].OrderedDictionary$2(Spine.Skin.SkinEntry,Spine.Attachment),"fg":"Attachments"},"fn":"Attachments"},{"a":2,"n":"Bones","t":16,"rt":$n[9].ExposedList$1(Spine.BoneData),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[9].ExposedList$1(Spine.BoneData),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"Constraints","t":16,"rt":$n[9].ExposedList$1(Spine.ConstraintData),"g":{"a":2,"n":"get_Constraints","t":8,"rt":$n[9].ExposedList$1(Spine.ConstraintData),"fg":"Constraints"},"fn":"Constraints"},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"fn":"Name"},{"a":1,"n":"attachments","t":4,"rt":$n[11].OrderedDictionary$2(Spine.Skin.SkinEntry,Spine.Attachment),"sn":"attachments"},{"a":4,"n":"bones","t":4,"rt":$n[9].ExposedList$1(Spine.BoneData),"sn":"bones","ro":true},{"a":4,"n":"constraints","t":4,"rt":$n[9].ExposedList$1(Spine.ConstraintData),"sn":"constraints","ro":true},{"a":4,"n":"name","t":4,"rt":$n[0].String,"sn":"name"}]}; }, $n);
    /*Spine.Skin end.*/

    /*Spine.Skin+SkinEntry start.*/
    $m("Spine.Skin.SkinEntry", function () { return {"td":$n[9].Skin,"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].String,$n[9].Attachment],"pi":[{"n":"slotIndex","pt":$n[0].Int32,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"attachment","pt":$n[9].Attachment,"ps":2}],"sn":"$ctor1"},{"a":2,"n":"Attachment","t":16,"rt":$n[9].Attachment,"g":{"a":2,"n":"get_Attachment","t":8,"rt":$n[9].Attachment,"fg":"Attachment"},"fn":"Attachment"},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"fn":"Name"},{"a":2,"n":"SlotIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotIndex","t":8,"rt":$n[0].Int32,"fg":"SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"SlotIndex"},{"a":1,"n":"attachment","t":4,"rt":$n[9].Attachment,"sn":"attachment","ro":true},{"a":4,"n":"hashCode","t":4,"rt":$n[0].Int32,"sn":"hashCode","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"name","t":4,"rt":$n[0].String,"sn":"name","ro":true},{"a":1,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Skin+SkinEntry end.*/

    /*Spine.Skin+SkinEntryComparer start.*/
    $m("Spine.Skin.SkinEntryComparer", function () { return {"td":$n[9].Skin,"att":1048579,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":4,"n":"Instance","is":true,"t":4,"rt":$n[9].Skin.SkinEntryComparer,"sn":"Instance","ro":true}]}; }, $n);
    /*Spine.Skin+SkinEntryComparer end.*/

    /*Spine.Slot start.*/
    $m("Spine.Slot", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[9].Slot,$n[9].Bone],"pi":[{"n":"slot","pt":$n[9].Slot,"ps":0},{"n":"bone","pt":$n[9].Bone,"ps":1}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[9].SlotData,$n[9].Bone],"pi":[{"n":"data","pt":$n[9].SlotData,"ps":0},{"n":"bone","pt":$n[9].Bone,"ps":1}],"sn":"$ctor1"},{"a":2,"n":"ClampColor","t":8,"sn":"ClampColor","rt":$n[0].Void},{"a":2,"n":"ClampSecondColor","t":8,"sn":"ClampSecondColor","rt":$n[0].Void},{"a":2,"n":"SetToSetupPose","t":8,"sn":"SetToSetupPose","rt":$n[0].Void},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"A","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_A","t":8,"rt":$n[0].Single,"fg":"A","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_A","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"A"},"fn":"A"},{"a":2,"n":"Attachment","t":16,"rt":$n[9].Attachment,"g":{"a":2,"n":"get_Attachment","t":8,"rt":$n[9].Attachment,"fg":"Attachment"},"s":{"a":2,"n":"set_Attachment","t":8,"p":[$n[9].Attachment],"rt":$n[0].Void,"fs":"Attachment"},"fn":"Attachment"},{"a":2,"n":"AttachmentTime","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AttachmentTime","t":8,"rt":$n[0].Single,"fg":"AttachmentTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AttachmentTime","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AttachmentTime"},"fn":"AttachmentTime"},{"a":2,"n":"B","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_B","t":8,"rt":$n[0].Single,"fg":"B","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_B","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"B"},"fn":"B"},{"a":2,"n":"B2","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_B2","t":8,"rt":$n[0].Single,"fg":"B2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_B2","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"B2"},"fn":"B2"},{"a":2,"n":"Bone","t":16,"rt":$n[9].Bone,"g":{"a":2,"n":"get_Bone","t":8,"rt":$n[9].Bone,"fg":"Bone"},"fn":"Bone"},{"a":2,"n":"Data","t":16,"rt":$n[9].SlotData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[9].SlotData,"fg":"Data"},"fn":"Data"},{"a":2,"n":"Deform","t":16,"rt":$n[9].ExposedList$1(System.Single),"g":{"a":2,"n":"get_Deform","t":8,"rt":$n[9].ExposedList$1(System.Single),"fg":"Deform"},"s":{"a":2,"n":"set_Deform","t":8,"p":[$n[9].ExposedList$1(System.Single)],"rt":$n[0].Void,"fs":"Deform"},"fn":"Deform"},{"a":2,"n":"G","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_G","t":8,"rt":$n[0].Single,"fg":"G","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_G","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"G"},"fn":"G"},{"a":2,"n":"G2","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_G2","t":8,"rt":$n[0].Single,"fg":"G2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_G2","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"G2"},"fn":"G2"},{"a":2,"n":"HasSecondColor","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_HasSecondColor","t":8,"rt":$n[0].Boolean,"fg":"HasSecondColor","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_HasSecondColor","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"HasSecondColor"},"fn":"HasSecondColor"},{"a":2,"n":"R","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_R","t":8,"rt":$n[0].Single,"fg":"R","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_R","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"R"},"fn":"R"},{"a":2,"n":"R2","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_R2","t":8,"rt":$n[0].Single,"fg":"R2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_R2","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"R2"},"fn":"R2"},{"a":2,"n":"Skeleton","t":16,"rt":$n[9].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[9].Skeleton,"fg":"Skeleton"},"fn":"Skeleton"},{"a":4,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"attachment","t":4,"rt":$n[9].Attachment,"sn":"attachment"},{"a":4,"n":"attachmentState","t":4,"rt":$n[0].Int32,"sn":"attachmentState","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"attachmentTime","t":4,"rt":$n[0].Single,"sn":"attachmentTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"b2","t":4,"rt":$n[0].Single,"sn":"b2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"bone","t":4,"rt":$n[9].Bone,"sn":"bone"},{"a":4,"n":"data","t":4,"rt":$n[9].SlotData,"sn":"data"},{"a":4,"n":"deform","t":4,"rt":$n[9].ExposedList$1(System.Single),"sn":"deform"},{"a":4,"n":"g","t":4,"rt":$n[0].Single,"sn":"g","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"g2","t":4,"rt":$n[0].Single,"sn":"g2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"hasSecondColor","t":4,"rt":$n[0].Boolean,"sn":"hasSecondColor","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"r","t":4,"rt":$n[0].Single,"sn":"r","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"r2","t":4,"rt":$n[0].Single,"sn":"r2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Slot end.*/

    /*Spine.SlotData start.*/
    $m("Spine.SlotData", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].String,$n[9].BoneData],"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"boneData","pt":$n[9].BoneData,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"A","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_A","t":8,"rt":$n[0].Single,"fg":"A","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_A","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"A"},"fn":"A"},{"a":2,"n":"AttachmentName","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_AttachmentName","t":8,"rt":$n[0].String,"fg":"AttachmentName"},"s":{"a":2,"n":"set_AttachmentName","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"AttachmentName"},"fn":"AttachmentName"},{"a":2,"n":"B","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_B","t":8,"rt":$n[0].Single,"fg":"B","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_B","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"B"},"fn":"B"},{"a":2,"n":"B2","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_B2","t":8,"rt":$n[0].Single,"fg":"B2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_B2","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"B2"},"fn":"B2"},{"a":2,"n":"BlendMode","t":16,"rt":$n[9].BlendMode,"g":{"a":2,"n":"get_BlendMode","t":8,"rt":$n[9].BlendMode,"fg":"BlendMode","box":function ($v) { return Bridge.box($v, Spine.BlendMode, System.Enum.toStringFn(Spine.BlendMode));}},"s":{"a":2,"n":"set_BlendMode","t":8,"p":[$n[9].BlendMode],"rt":$n[0].Void,"fs":"BlendMode"},"fn":"BlendMode"},{"a":2,"n":"BoneData","t":16,"rt":$n[9].BoneData,"g":{"a":2,"n":"get_BoneData","t":8,"rt":$n[9].BoneData,"fg":"BoneData"},"fn":"BoneData"},{"a":2,"n":"G","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_G","t":8,"rt":$n[0].Single,"fg":"G","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_G","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"G"},"fn":"G"},{"a":2,"n":"G2","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_G2","t":8,"rt":$n[0].Single,"fg":"G2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_G2","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"G2"},"fn":"G2"},{"a":2,"n":"HasSecondColor","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_HasSecondColor","t":8,"rt":$n[0].Boolean,"fg":"HasSecondColor","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_HasSecondColor","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"HasSecondColor"},"fn":"HasSecondColor"},{"a":2,"n":"Index","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Index","t":8,"rt":$n[0].Int32,"fg":"Index","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Index"},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"fn":"Name"},{"a":2,"n":"R","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_R","t":8,"rt":$n[0].Single,"fg":"R","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_R","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"R"},"fn":"R"},{"a":2,"n":"R2","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_R2","t":8,"rt":$n[0].Single,"fg":"R2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_R2","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"R2"},"fn":"R2"},{"a":4,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"attachmentName","t":4,"rt":$n[0].String,"sn":"attachmentName"},{"a":4,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"b2","t":4,"rt":$n[0].Single,"sn":"b2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"blendMode","t":4,"rt":$n[9].BlendMode,"sn":"blendMode","box":function ($v) { return Bridge.box($v, Spine.BlendMode, System.Enum.toStringFn(Spine.BlendMode));}},{"a":4,"n":"boneData","t":4,"rt":$n[9].BoneData,"sn":"boneData"},{"a":4,"n":"g","t":4,"rt":$n[0].Single,"sn":"g","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"g2","t":4,"rt":$n[0].Single,"sn":"g2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"hasSecondColor","t":4,"rt":$n[0].Boolean,"sn":"hasSecondColor","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"index","t":4,"rt":$n[0].Int32,"sn":"index","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":4,"n":"r","t":4,"rt":$n[0].Single,"sn":"r","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"r2","t":4,"rt":$n[0].Single,"sn":"r2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.SlotData end.*/

    /*Spine.TransformConstraint start.*/
    $m("Spine.TransformConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[9].TransformConstraint,$n[9].Skeleton],"pi":[{"n":"constraint","pt":$n[9].TransformConstraint,"ps":0},{"n":"skeleton","pt":$n[9].Skeleton,"ps":1}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[9].TransformConstraintData,$n[9].Skeleton],"pi":[{"n":"data","pt":$n[9].TransformConstraintData,"ps":0},{"n":"skeleton","pt":$n[9].Skeleton,"ps":1}],"sn":"$ctor1"},{"a":2,"n":"Apply","t":8,"sn":"Apply","rt":$n[0].Void},{"a":1,"n":"ApplyAbsoluteLocal","t":8,"sn":"ApplyAbsoluteLocal","rt":$n[0].Void},{"a":1,"n":"ApplyAbsoluteWorld","t":8,"sn":"ApplyAbsoluteWorld","rt":$n[0].Void},{"a":1,"n":"ApplyRelativeLocal","t":8,"sn":"ApplyRelativeLocal","rt":$n[0].Void},{"a":1,"n":"ApplyRelativeWorld","t":8,"sn":"ApplyRelativeWorld","rt":$n[0].Void},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"Active","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Active","t":8,"rt":$n[0].Boolean,"fg":"Active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"Active"},{"a":2,"n":"Bones","t":16,"rt":$n[9].ExposedList$1(Spine.Bone),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[9].ExposedList$1(Spine.Bone),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"Data","t":16,"rt":$n[9].TransformConstraintData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[9].TransformConstraintData,"fg":"Data"},"fn":"Data"},{"a":2,"n":"RotateMix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RotateMix","t":8,"rt":$n[0].Single,"fg":"RotateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RotateMix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RotateMix"},"fn":"RotateMix"},{"a":2,"n":"ScaleMix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleMix","t":8,"rt":$n[0].Single,"fg":"ScaleMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleMix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleMix"},"fn":"ScaleMix"},{"a":2,"n":"ShearMix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ShearMix","t":8,"rt":$n[0].Single,"fg":"ShearMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ShearMix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ShearMix"},"fn":"ShearMix"},{"a":2,"n":"Target","t":16,"rt":$n[9].Bone,"g":{"a":2,"n":"get_Target","t":8,"rt":$n[9].Bone,"fg":"Target"},"s":{"a":2,"n":"set_Target","t":8,"p":[$n[9].Bone],"rt":$n[0].Void,"fs":"Target"},"fn":"Target"},{"a":2,"n":"TranslateMix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_TranslateMix","t":8,"rt":$n[0].Single,"fg":"TranslateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_TranslateMix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"TranslateMix"},"fn":"TranslateMix"},{"a":4,"n":"active","t":4,"rt":$n[0].Boolean,"sn":"active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"bones","t":4,"rt":$n[9].ExposedList$1(Spine.Bone),"sn":"bones"},{"a":4,"n":"data","t":4,"rt":$n[9].TransformConstraintData,"sn":"data"},{"a":4,"n":"rotateMix","t":4,"rt":$n[0].Single,"sn":"rotateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"scaleMix","t":4,"rt":$n[0].Single,"sn":"scaleMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"shearMix","t":4,"rt":$n[0].Single,"sn":"shearMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"target","t":4,"rt":$n[9].Bone,"sn":"target"},{"a":4,"n":"translateMix","t":4,"rt":$n[0].Single,"sn":"translateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.TransformConstraint end.*/

    /*Spine.TransformConstraintData start.*/
    $m("Spine.TransformConstraintData", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":"Bones","t":16,"rt":$n[9].ExposedList$1(Spine.BoneData),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[9].ExposedList$1(Spine.BoneData),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"Local","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Local","t":8,"rt":$n[0].Boolean,"fg":"Local","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Local","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Local"},"fn":"Local"},{"a":2,"n":"OffsetRotation","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_OffsetRotation","t":8,"rt":$n[0].Single,"fg":"OffsetRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_OffsetRotation","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"OffsetRotation"},"fn":"OffsetRotation"},{"a":2,"n":"OffsetScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_OffsetScaleX","t":8,"rt":$n[0].Single,"fg":"OffsetScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_OffsetScaleX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"OffsetScaleX"},"fn":"OffsetScaleX"},{"a":2,"n":"OffsetScaleY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_OffsetScaleY","t":8,"rt":$n[0].Single,"fg":"OffsetScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_OffsetScaleY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"OffsetScaleY"},"fn":"OffsetScaleY"},{"a":2,"n":"OffsetShearY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_OffsetShearY","t":8,"rt":$n[0].Single,"fg":"OffsetShearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_OffsetShearY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"OffsetShearY"},"fn":"OffsetShearY"},{"a":2,"n":"OffsetX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_OffsetX","t":8,"rt":$n[0].Single,"fg":"OffsetX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_OffsetX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"OffsetX"},"fn":"OffsetX"},{"a":2,"n":"OffsetY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_OffsetY","t":8,"rt":$n[0].Single,"fg":"OffsetY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_OffsetY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"OffsetY"},"fn":"OffsetY"},{"a":2,"n":"Relative","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Relative","t":8,"rt":$n[0].Boolean,"fg":"Relative","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Relative","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Relative"},"fn":"Relative"},{"a":2,"n":"RotateMix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RotateMix","t":8,"rt":$n[0].Single,"fg":"RotateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RotateMix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RotateMix"},"fn":"RotateMix"},{"a":2,"n":"ScaleMix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleMix","t":8,"rt":$n[0].Single,"fg":"ScaleMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleMix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleMix"},"fn":"ScaleMix"},{"a":2,"n":"ShearMix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ShearMix","t":8,"rt":$n[0].Single,"fg":"ShearMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ShearMix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ShearMix"},"fn":"ShearMix"},{"a":2,"n":"Target","t":16,"rt":$n[9].BoneData,"g":{"a":2,"n":"get_Target","t":8,"rt":$n[9].BoneData,"fg":"Target"},"s":{"a":2,"n":"set_Target","t":8,"p":[$n[9].BoneData],"rt":$n[0].Void,"fs":"Target"},"fn":"Target"},{"a":2,"n":"TranslateMix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_TranslateMix","t":8,"rt":$n[0].Single,"fg":"TranslateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_TranslateMix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"TranslateMix"},"fn":"TranslateMix"},{"a":4,"n":"bones","t":4,"rt":$n[9].ExposedList$1(Spine.BoneData),"sn":"bones"},{"a":4,"n":"local","t":4,"rt":$n[0].Boolean,"sn":"local","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"offsetRotation","t":4,"rt":$n[0].Single,"sn":"offsetRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"offsetScaleX","t":4,"rt":$n[0].Single,"sn":"offsetScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"offsetScaleY","t":4,"rt":$n[0].Single,"sn":"offsetScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"offsetShearY","t":4,"rt":$n[0].Single,"sn":"offsetShearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"offsetX","t":4,"rt":$n[0].Single,"sn":"offsetX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"offsetY","t":4,"rt":$n[0].Single,"sn":"offsetY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"relative","t":4,"rt":$n[0].Boolean,"sn":"relative","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"rotateMix","t":4,"rt":$n[0].Single,"sn":"rotateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"scaleMix","t":4,"rt":$n[0].Single,"sn":"scaleMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"shearMix","t":4,"rt":$n[0].Single,"sn":"shearMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"target","t":4,"rt":$n[9].BoneData,"sn":"target"},{"a":4,"n":"translateMix","t":4,"rt":$n[0].Single,"sn":"translateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.TransformConstraintData end.*/

    /*Spine.Triangulator start.*/
    $m("Spine.Triangulator", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Decompose","t":8,"pi":[{"n":"verticesArray","pt":$n[9].ExposedList$1(System.Single),"ps":0},{"n":"triangles","pt":$n[9].ExposedList$1(System.Int32),"ps":1}],"sn":"Decompose","rt":$n[9].ExposedList$1(Spine.ExposedList$1(System.Single)),"p":[$n[9].ExposedList$1(System.Single),$n[9].ExposedList$1(System.Int32)]},{"a":1,"n":"IsConcave","is":true,"t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"vertexCount","pt":$n[0].Int32,"ps":1},{"n":"vertices","pt":$n[0].Array.type(System.Single),"ps":2},{"n":"indices","pt":$n[0].Array.type(System.Int32),"ps":3}],"sn":"IsConcave","rt":$n[0].Boolean,"p":[$n[0].Int32,$n[0].Int32,$n[0].Array.type(System.Single),$n[0].Array.type(System.Int32)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"PositiveArea","is":true,"t":8,"pi":[{"n":"p1x","pt":$n[0].Single,"ps":0},{"n":"p1y","pt":$n[0].Single,"ps":1},{"n":"p2x","pt":$n[0].Single,"ps":2},{"n":"p2y","pt":$n[0].Single,"ps":3},{"n":"p3x","pt":$n[0].Single,"ps":4},{"n":"p3y","pt":$n[0].Single,"ps":5}],"sn":"PositiveArea","rt":$n[0].Boolean,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Triangulate","t":8,"pi":[{"n":"verticesArray","pt":$n[9].ExposedList$1(System.Single),"ps":0}],"sn":"Triangulate","rt":$n[9].ExposedList$1(System.Int32),"p":[$n[9].ExposedList$1(System.Single)]},{"a":1,"n":"Winding","is":true,"t":8,"pi":[{"n":"p1x","pt":$n[0].Single,"ps":0},{"n":"p1y","pt":$n[0].Single,"ps":1},{"n":"p2x","pt":$n[0].Single,"ps":2},{"n":"p2y","pt":$n[0].Single,"ps":3},{"n":"p3x","pt":$n[0].Single,"ps":4},{"n":"p3y","pt":$n[0].Single,"ps":5}],"sn":"Winding","rt":$n[0].Int32,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"convexPolygons","t":4,"rt":$n[9].ExposedList$1(Spine.ExposedList$1(System.Single)),"sn":"convexPolygons","ro":true},{"a":1,"n":"convexPolygonsIndices","t":4,"rt":$n[9].ExposedList$1(Spine.ExposedList$1(System.Int32)),"sn":"convexPolygonsIndices","ro":true},{"a":1,"n":"indicesArray","t":4,"rt":$n[9].ExposedList$1(System.Int32),"sn":"indicesArray","ro":true},{"a":1,"n":"isConcaveArray","t":4,"rt":$n[9].ExposedList$1(System.Boolean),"sn":"isConcaveArray","ro":true},{"a":1,"n":"polygonIndicesPool","t":4,"rt":$n[9].Pool$1(Spine.ExposedList$1(System.Int32)),"sn":"polygonIndicesPool","ro":true},{"a":1,"n":"polygonPool","t":4,"rt":$n[9].Pool$1(Spine.ExposedList$1(System.Single)),"sn":"polygonPool","ro":true},{"a":1,"n":"triangles","t":4,"rt":$n[9].ExposedList$1(System.Int32),"sn":"triangles","ro":true}]}; }, $n);
    /*Spine.Triangulator end.*/

    /*Spine.BoneMatrix start.*/
    $m("Spine.BoneMatrix", function () { return {"att":1048841,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[9].Bone],"pi":[{"n":"bone","pt":$n[9].Bone,"ps":0}],"sn":"$ctor1"},{"a":2,"n":".ctor","t":1,"p":[$n[9].BoneData],"pi":[{"n":"boneData","pt":$n[9].BoneData,"ps":0}],"sn":"$ctor2"},{"a":2,"n":"CalculateSetupWorld","is":true,"t":8,"pi":[{"n":"boneData","pt":$n[9].BoneData,"ps":0}],"sn":"CalculateSetupWorld","rt":$n[9].BoneMatrix,"p":[$n[9].BoneData]},{"a":1,"n":"GetInheritedInternal","is":true,"t":8,"pi":[{"n":"boneData","pt":$n[9].BoneData,"ps":0},{"n":"parentMatrix","pt":$n[9].BoneMatrix,"ps":1}],"sn":"GetInheritedInternal","rt":$n[9].BoneMatrix,"p":[$n[9].BoneData,$n[9].BoneMatrix]},{"a":2,"n":"TransformMatrix","t":8,"pi":[{"n":"local","pt":$n[9].BoneMatrix,"ps":0}],"sn":"TransformMatrix","rt":$n[9].BoneMatrix,"p":[$n[9].BoneMatrix]},{"a":2,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"c","t":4,"rt":$n[0].Single,"sn":"c","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"d","t":4,"rt":$n[0].Single,"sn":"d","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.BoneMatrix end.*/

    /*Spine.SpineSkeletonExtensions start.*/
    $m("Spine.SpineSkeletonExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"AllowImmediateQueue","is":true,"t":8,"pi":[{"n":"trackEntry","pt":$n[9].TrackEntry,"ps":0}],"sn":"AllowImmediateQueue","rt":$n[0].Void,"p":[$n[9].TrackEntry]},{"a":2,"n":"InheritsRotation","is":true,"t":8,"pi":[{"n":"mode","pt":$n[9].TransformMode,"ps":0}],"sn":"InheritsRotation","rt":$n[0].Boolean,"p":[$n[9].TransformMode],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"InheritsScale","is":true,"t":8,"pi":[{"n":"mode","pt":$n[9].TransformMode,"ps":0}],"sn":"InheritsScale","rt":$n[0].Boolean,"p":[$n[9].TransformMode],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsRenderable","is":true,"t":8,"pi":[{"n":"a","pt":$n[9].Attachment,"ps":0}],"sn":"IsRenderable","rt":$n[0].Boolean,"p":[$n[9].Attachment],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsWeighted","is":true,"t":8,"pi":[{"n":"va","pt":$n[9].VertexAttachment,"ps":0}],"sn":"IsWeighted","rt":$n[0].Boolean,"p":[$n[9].VertexAttachment],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SetAttachmentToSetupPose","is":true,"t":8,"pi":[{"n":"slot","pt":$n[9].Slot,"ps":0}],"sn":"SetAttachmentToSetupPose","rt":$n[0].Void,"p":[$n[9].Slot]},{"a":2,"n":"SetColorToSetupPose","is":true,"t":8,"pi":[{"n":"slot","pt":$n[9].Slot,"ps":0}],"sn":"SetColorToSetupPose","rt":$n[0].Void,"p":[$n[9].Slot]},{"a":2,"n":"SetDrawOrderToSetupPose","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0}],"sn":"SetDrawOrderToSetupPose","rt":$n[0].Void,"p":[$n[9].Skeleton]},{"a":2,"n":"SetKeyedItemsToSetupPose","is":true,"t":8,"pi":[{"n":"animation","pt":$n[9].Animation,"ps":0},{"n":"skeleton","pt":$n[9].Skeleton,"ps":1}],"sn":"SetKeyedItemsToSetupPose","rt":$n[0].Void,"p":[$n[9].Animation,$n[9].Skeleton]},{"a":4,"n":"SetPropertyToSetupPose","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0},{"n":"propertyID","pt":$n[0].Int32,"ps":1}],"sn":"SetPropertyToSetupPose","rt":$n[0].Void,"p":[$n[9].Skeleton,$n[0].Int32]},{"a":2,"n":"SetSlotAttachmentToSetupPose","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0},{"n":"slotIndex","pt":$n[0].Int32,"ps":1}],"sn":"SetSlotAttachmentToSetupPose","rt":$n[0].Void,"p":[$n[9].Skeleton,$n[0].Int32]},{"a":2,"n":"SetSlotAttachmentsToSetupPose","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0}],"sn":"SetSlotAttachmentsToSetupPose","rt":$n[0].Void,"p":[$n[9].Skeleton]}]}; }, $n);
    /*Spine.SpineSkeletonExtensions end.*/

    /*Spine.Unity.AnimationReferenceAsset start.*/
    $m("Spine.Unity.AnimationReferenceAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Spine/Animation Reference Asset", order: 100
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"op_Implicit","is":true,"t":8,"pi":[{"n":"asset","pt":$n[12].AnimationReferenceAsset,"ps":0}],"sn":"op_Implicit","rt":$n[9].Animation,"p":[$n[12].AnimationReferenceAsset]},{"a":2,"n":"Animation","t":16,"rt":$n[9].Animation,"g":{"a":2,"n":"get_Animation","t":8,"rt":$n[9].Animation,"fg":"Animation"},"fn":"Animation"},{"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[12].SkeletonDataAsset,"g":{"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[12].SkeletonDataAsset,"fg":"SkeletonDataAsset"},"fn":"SkeletonDataAsset"},{"a":1,"n":"QuietSkeletonData","is":true,"t":4,"rt":$n[0].Boolean,"sn":"QuietSkeletonData","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"animation","t":4,"rt":$n[9].Animation,"sn":"animation"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false)],"a":3,"n":"animationName","t":4,"rt":$n[0].String,"sn":"animationName"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"skeletonDataAsset","t":4,"rt":$n[12].SkeletonDataAsset,"sn":"skeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.AnimationReferenceAsset end.*/

    /*Spine.Unity.AtlasAssetBase start.*/
    $m("Spine.Unity.AtlasAssetBase", function () { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ab":true,"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"ab":true,"a":2,"n":"GetAtlas","t":8,"sn":"GetAtlas","rt":$n[9].Atlas},{"ab":true,"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"ab":true,"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"ab":true,"a":2,"n":"MaterialCount","t":16,"rt":$n[0].Int32,"g":{"ab":true,"a":2,"n":"get_MaterialCount","t":8,"rt":$n[0].Int32,"fg":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MaterialCount"},{"ab":true,"a":2,"n":"Materials","t":16,"rt":$n[5].IEnumerable$1(UnityEngine.Material),"g":{"ab":true,"a":2,"n":"get_Materials","t":8,"rt":$n[5].IEnumerable$1(UnityEngine.Material),"fg":"Materials"},"fn":"Materials"},{"ab":true,"a":2,"n":"PrimaryMaterial","t":16,"rt":$n[1].Material,"g":{"ab":true,"a":2,"n":"get_PrimaryMaterial","t":8,"rt":$n[1].Material,"fg":"PrimaryMaterial"},"fn":"PrimaryMaterial"},{"a":1,"backing":true,"n":"<IsLoaded>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"backing":true,"n":"<MaterialCount>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"backing":true,"n":"<Materials>k__BackingField","t":4,"rt":$n[5].IEnumerable$1(UnityEngine.Material),"sn":"Materials"},{"a":1,"backing":true,"n":"<PrimaryMaterial>k__BackingField","t":4,"rt":$n[1].Material,"sn":"PrimaryMaterial"}]}; }, $n);
    /*Spine.Unity.AtlasAssetBase end.*/

    /*Spine.Unity.BlendModeMaterials start.*/
    $m("Spine.Unity.BlendModeMaterials", function () { return {"nested":[$n[12].BlendModeMaterials.ReplacementMaterial],"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ApplyMaterials","t":8,"pi":[{"n":"skeletonData","pt":$n[9].SkeletonData,"ps":0}],"sn":"ApplyMaterials","rt":$n[0].Void,"p":[$n[9].SkeletonData]},{"a":3,"n":"CloneAtlasRegionWithMaterial","t":8,"pi":[{"n":"originalRegion","pt":$n[9].AtlasRegion,"ps":0},{"n":"replacementMaterials","pt":$n[5].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"ps":1}],"sn":"CloneAtlasRegionWithMaterial","rt":$n[9].AtlasRegion,"p":[$n[9].AtlasRegion,$n[5].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)]},{"a":2,"n":"RequiresBlendModeMaterials","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_RequiresBlendModeMaterials","t":8,"rt":$n[0].Boolean,"fg":"RequiresBlendModeMaterials","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_RequiresBlendModeMaterials","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"RequiresBlendModeMaterials"},"fn":"RequiresBlendModeMaterials"},{"a":2,"n":"additiveMaterials","t":4,"rt":$n[5].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"sn":"additiveMaterials"},{"a":2,"n":"applyAdditiveMaterial","t":4,"rt":$n[0].Boolean,"sn":"applyAdditiveMaterial","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"multiplyMaterials","t":4,"rt":$n[5].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"sn":"multiplyMaterials"},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.HideInInspector()],"a":3,"n":"requiresBlendModeMaterials","t":4,"rt":$n[0].Boolean,"sn":"requiresBlendModeMaterials","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"screenMaterials","t":4,"rt":$n[5].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"sn":"screenMaterials"}]}; }, $n);
    /*Spine.Unity.BlendModeMaterials end.*/

    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial start.*/
    $m("Spine.Unity.BlendModeMaterials.ReplacementMaterial", function () { return {"td":$n[12].BlendModeMaterials,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"material","t":4,"rt":$n[1].Material,"sn":"material"},{"a":2,"n":"pageName","t":4,"rt":$n[0].String,"sn":"pageName"}]}; }, $n);
    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial end.*/

    /*Spine.Unity.EventDataReferenceAsset start.*/
    $m("Spine.Unity.EventDataReferenceAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Spine/EventData Reference Asset", order: 100
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"op_Implicit","is":true,"t":8,"pi":[{"n":"asset","pt":$n[12].EventDataReferenceAsset,"ps":0}],"sn":"op_Implicit","rt":$n[9].EventData,"p":[$n[12].EventDataReferenceAsset]},{"a":2,"n":"EventData","t":16,"rt":$n[9].EventData,"g":{"a":2,"n":"get_EventData","t":8,"rt":$n[9].EventData,"fg":"EventData"},"fn":"EventData"},{"a":1,"n":"QuietSkeletonData","is":true,"t":4,"rt":$n[0].Boolean,"sn":"QuietSkeletonData","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"eventData","t":4,"rt":$n[9].EventData,"sn":"eventData"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineEvent("", "skeletonDataAsset", true, false, false)],"a":3,"n":"eventName","t":4,"rt":$n[0].String,"sn":"eventName"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"skeletonDataAsset","t":4,"rt":$n[12].SkeletonDataAsset,"sn":"skeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.EventDataReferenceAsset end.*/

    /*Spine.Unity.RegionlessAttachmentLoader start.*/
    $m("Spine.Unity.RegionlessAttachmentLoader", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"NewBoundingBoxAttachment","t":8,"pi":[{"n":"skin","pt":$n[9].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewBoundingBoxAttachment","rt":$n[9].BoundingBoxAttachment,"p":[$n[9].Skin,$n[0].String]},{"a":2,"n":"NewClippingAttachment","t":8,"pi":[{"n":"skin","pt":$n[9].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewClippingAttachment","rt":$n[9].ClippingAttachment,"p":[$n[9].Skin,$n[0].String]},{"a":2,"n":"NewMeshAttachment","t":8,"pi":[{"n":"skin","pt":$n[9].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2}],"sn":"NewMeshAttachment","rt":$n[9].MeshAttachment,"p":[$n[9].Skin,$n[0].String,$n[0].String]},{"a":2,"n":"NewPathAttachment","t":8,"pi":[{"n":"skin","pt":$n[9].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewPathAttachment","rt":$n[9].PathAttachment,"p":[$n[9].Skin,$n[0].String]},{"a":2,"n":"NewPointAttachment","t":8,"pi":[{"n":"skin","pt":$n[9].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewPointAttachment","rt":$n[9].PointAttachment,"p":[$n[9].Skin,$n[0].String]},{"a":2,"n":"NewRegionAttachment","t":8,"pi":[{"n":"skin","pt":$n[9].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2}],"sn":"NewRegionAttachment","rt":$n[9].RegionAttachment,"p":[$n[9].Skin,$n[0].String,$n[0].String]},{"a":1,"n":"EmptyRegion","is":true,"t":16,"rt":$n[9].AtlasRegion,"g":{"a":1,"n":"get_EmptyRegion","t":8,"rt":$n[9].AtlasRegion,"fg":"EmptyRegion","is":true},"fn":"EmptyRegion"},{"a":1,"n":"emptyRegion","is":true,"t":4,"rt":$n[9].AtlasRegion,"sn":"emptyRegion"}]}; }, $n);
    /*Spine.Unity.RegionlessAttachmentLoader end.*/

    /*Spine.Unity.SkeletonDataAsset start.*/
    $m("Spine.Unity.SkeletonDataAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "New SkeletonDataAsset", menuName: "Spine/SkeletonData Asset"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"skeletonDataFile","pt":$n[1].TextAsset,"ps":0},{"n":"atlasAsset","pt":$n[12].AtlasAssetBase,"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"CreateRuntimeInstance","rt":$n[12].SkeletonDataAsset,"p":[$n[1].TextAsset,$n[12].AtlasAssetBase,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"skeletonDataFile","pt":$n[1].TextAsset,"ps":0},{"n":"atlasAssets","pt":System.Array.type(Spine.Unity.AtlasAssetBase),"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"CreateRuntimeInstance$1","rt":$n[12].SkeletonDataAsset,"p":[$n[1].TextAsset,System.Array.type(Spine.Unity.AtlasAssetBase),$n[0].Boolean,$n[0].Single]},{"a":2,"n":"FillStateData","t":8,"sn":"FillStateData","rt":$n[0].Void},{"a":2,"n":"GetAnimationStateData","t":8,"sn":"GetAnimationStateData","rt":$n[9].AnimationStateData},{"a":4,"n":"GetAtlasArray","t":8,"sn":"GetAtlasArray","rt":System.Array.type(Spine.Atlas)},{"a":2,"n":"GetSkeletonData","t":8,"pi":[{"n":"quiet","pt":$n[0].Boolean,"ps":0}],"sn":"GetSkeletonData","rt":$n[9].SkeletonData,"p":[$n[0].Boolean]},{"a":4,"n":"InitializeWithData","t":8,"pi":[{"n":"sd","pt":$n[9].SkeletonData,"ps":0}],"sn":"InitializeWithData","rt":$n[0].Void,"p":[$n[9].SkeletonData]},{"a":4,"n":"ReadSkeletonData","is":true,"t":8,"pi":[{"n":"bytes","pt":$n[0].Array.type(System.Byte),"ps":0},{"n":"attachmentLoader","pt":$n[9].AttachmentLoader,"ps":1},{"n":"scale","pt":$n[0].Single,"ps":2}],"sn":"ReadSkeletonData","rt":$n[9].SkeletonData,"p":[$n[0].Array.type(System.Byte),$n[9].AttachmentLoader,$n[0].Single]},{"a":4,"n":"ReadSkeletonData","is":true,"t":8,"pi":[{"n":"text","pt":$n[0].String,"ps":0},{"n":"attachmentLoader","pt":$n[9].AttachmentLoader,"ps":1},{"n":"scale","pt":$n[0].Single,"ps":2}],"sn":"ReadSkeletonData$1","rt":$n[9].SkeletonData,"p":[$n[0].String,$n[9].AttachmentLoader,$n[0].Single]},{"a":1,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"a":2,"n":"atlasAssets","t":4,"rt":System.Array.type(Spine.Unity.AtlasAssetBase),"sn":"atlasAssets"},{"a":2,"n":"blendModeMaterials","t":4,"rt":$n[12].BlendModeMaterials,"sn":"blendModeMaterials"},{"a":2,"n":"controller","t":4,"rt":$n[1].RuntimeAnimatorController,"sn":"controller"},{"a":2,"n":"defaultMix","t":4,"rt":$n[0].Single,"sn":"defaultMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"duration","t":4,"rt":$n[0].Array.type(System.Single),"sn":"duration"},{"at":[new Spine.Unity.SpineAnimation("", "", false, false)],"a":2,"n":"fromAnimation","t":4,"rt":$n[0].Array.type(System.String),"sn":"fromAnimation"},{"a":2,"n":"isUpgradingBlendModeMaterials","t":4,"rt":$n[0].Boolean,"sn":"isUpgradingBlendModeMaterials","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"scale","t":4,"rt":$n[0].Single,"sn":"scale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"skeletonData","t":4,"rt":$n[9].SkeletonData,"sn":"skeletonData"},{"at":[new UnityEngine.TooltipAttribute("Use SkeletonDataModifierAssets to apply changes to the SkeletonData after being loaded, such as apply blend mode Materials to Attachments under slots with special blend modes.")],"a":2,"n":"skeletonDataModifiers","t":4,"rt":$n[5].List$1(Spine.Unity.SkeletonDataModifierAsset),"sn":"skeletonDataModifiers"},{"a":2,"n":"skeletonJSON","t":4,"rt":$n[1].TextAsset,"sn":"skeletonJSON"},{"a":1,"n":"stateData","t":4,"rt":$n[9].AnimationStateData,"sn":"stateData"},{"at":[new Spine.Unity.SpineAnimation("", "", false, false)],"a":2,"n":"toAnimation","t":4,"rt":$n[0].Array.type(System.String),"sn":"toAnimation"}]}; }, $n);
    /*Spine.Unity.SkeletonDataAsset end.*/

    /*Spine.Unity.SkeletonDataCompatibility start.*/
    $m("Spine.Unity.SkeletonDataCompatibility", function () { return {"nested":[$n[12].SkeletonDataCompatibility.SourceType,$n[12].SkeletonDataCompatibility.VersionInfo,$n[12].SkeletonDataCompatibility.CompatibilityProblemInfo],"att":1048961,"a":2,"s":true}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility end.*/

    /*Spine.Unity.SkeletonDataCompatibility+SourceType start.*/
    $m("Spine.Unity.SkeletonDataCompatibility.SourceType", function () { return {"td":$n[12].SkeletonDataCompatibility,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Binary","is":true,"t":4,"rt":$n[12].SkeletonDataCompatibility.SourceType,"sn":"Binary","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonDataCompatibility.SourceType, System.Enum.toStringFn(Spine.Unity.SkeletonDataCompatibility.SourceType));}},{"a":2,"n":"Json","is":true,"t":4,"rt":$n[12].SkeletonDataCompatibility.SourceType,"sn":"Json","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonDataCompatibility.SourceType, System.Enum.toStringFn(Spine.Unity.SkeletonDataCompatibility.SourceType));}}]}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility+SourceType end.*/

    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo start.*/
    $m("Spine.Unity.SkeletonDataCompatibility.VersionInfo", function () { return {"td":$n[12].SkeletonDataCompatibility,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"rawVersion","t":4,"rt":$n[0].String,"sn":"rawVersion"},{"a":2,"n":"sourceType","t":4,"rt":$n[12].SkeletonDataCompatibility.SourceType,"sn":"sourceType","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonDataCompatibility.SourceType, System.Enum.toStringFn(Spine.Unity.SkeletonDataCompatibility.SourceType));}},{"a":2,"n":"version","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"version"}]}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo end.*/

    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo start.*/
    $m("Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo", function () { return {"td":$n[12].SkeletonDataCompatibility,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"DescriptionString","t":8,"sn":"DescriptionString","rt":$n[0].String},{"a":2,"n":"actualVersion","t":4,"rt":$n[12].SkeletonDataCompatibility.VersionInfo,"sn":"actualVersion"},{"a":2,"n":"compatibleVersions","t":4,"rt":$n[0].Array.type(System.Array.type(System.Int32)),"sn":"compatibleVersions"},{"a":2,"n":"explicitProblemDescription","t":4,"rt":$n[0].String,"sn":"explicitProblemDescription"}]}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo end.*/

    /*Spine.Unity.SkeletonDataModifierAsset start.*/
    $m("Spine.Unity.SkeletonDataModifierAsset", function () { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ab":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeletonData","pt":$n[9].SkeletonData,"ps":0}],"sn":"Apply","rt":$n[0].Void,"p":[$n[9].SkeletonData]}]}; }, $n);
    /*Spine.Unity.SkeletonDataModifierAsset end.*/

    /*Spine.Unity.SpineAtlasAsset start.*/
    $m("Spine.Unity.SpineAtlasAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "New Spine Atlas Asset", menuName: "Spine/Spine Atlas Asset"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"atlasText","pt":$n[1].TextAsset,"ps":0},{"n":"materials","pt":System.Array.type(UnityEngine.Material),"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2}],"sn":"CreateRuntimeInstance","rt":$n[12].SpineAtlasAsset,"p":[$n[1].TextAsset,System.Array.type(UnityEngine.Material),$n[0].Boolean]},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"atlasText","pt":$n[1].TextAsset,"ps":0},{"n":"textures","pt":System.Array.type(UnityEngine.Texture2D),"ps":1},{"n":"materialPropertySource","pt":$n[1].Material,"ps":2},{"n":"initialize","pt":$n[0].Boolean,"ps":3}],"sn":"CreateRuntimeInstance$1","rt":$n[12].SpineAtlasAsset,"p":[$n[1].TextAsset,System.Array.type(UnityEngine.Texture2D),$n[1].Material,$n[0].Boolean]},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"atlasText","pt":$n[1].TextAsset,"ps":0},{"n":"textures","pt":System.Array.type(UnityEngine.Texture2D),"ps":1},{"n":"shader","pt":$n[1].Shader,"ps":2},{"n":"initialize","pt":$n[0].Boolean,"ps":3}],"sn":"CreateRuntimeInstance$2","rt":$n[12].SpineAtlasAsset,"p":[$n[1].TextAsset,System.Array.type(UnityEngine.Texture2D),$n[1].Shader,$n[0].Boolean]},{"a":2,"n":"GenerateMesh","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"mesh","pt":$n[1].Mesh,"ps":1},{"n":"material","out":true,"pt":$n[1].Material,"ps":2},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"GenerateMesh","rt":$n[1].Mesh,"p":[$n[0].String,$n[1].Mesh,$n[1].Material,$n[0].Single]},{"ov":true,"a":2,"n":"GetAtlas","t":8,"sn":"GetAtlas","rt":$n[9].Atlas},{"a":1,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"ov":true,"a":2,"n":"MaterialCount","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_MaterialCount","t":8,"rt":$n[0].Int32,"fg":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MaterialCount"},{"ov":true,"a":2,"n":"Materials","t":16,"rt":$n[5].IEnumerable$1(UnityEngine.Material),"g":{"ov":true,"a":2,"n":"get_Materials","t":8,"rt":$n[5].IEnumerable$1(UnityEngine.Material),"fg":"Materials"},"fn":"Materials"},{"ov":true,"a":2,"n":"PrimaryMaterial","t":16,"rt":$n[1].Material,"g":{"ov":true,"a":2,"n":"get_PrimaryMaterial","t":8,"rt":$n[1].Material,"fg":"PrimaryMaterial"},"fn":"PrimaryMaterial"},{"a":3,"n":"atlas","t":4,"rt":$n[9].Atlas,"sn":"atlas"},{"a":2,"n":"atlasFile","t":4,"rt":$n[1].TextAsset,"sn":"atlasFile"},{"a":2,"n":"materials","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materials"}]}; }, $n);
    /*Spine.Unity.SpineAtlasAsset end.*/

    /*Spine.Unity.MaterialsTextureLoader start.*/
    $m("Spine.Unity.MaterialsTextureLoader", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[12].SpineAtlasAsset],"pi":[{"n":"atlasAsset","pt":$n[12].SpineAtlasAsset,"ps":0}],"sn":"ctor"},{"a":2,"n":"Load","t":8,"pi":[{"n":"page","pt":$n[9].AtlasPage,"ps":0},{"n":"path","pt":$n[0].String,"ps":1}],"sn":"Load","rt":$n[0].Void,"p":[$n[9].AtlasPage,$n[0].String]},{"a":2,"n":"Unload","t":8,"pi":[{"n":"texture","pt":$n[0].Object,"ps":0}],"sn":"Unload","rt":$n[0].Void,"p":[$n[0].Object]},{"a":1,"n":"atlasAsset","t":4,"rt":$n[12].SpineAtlasAsset,"sn":"atlasAsset"}]}; }, $n);
    /*Spine.Unity.MaterialsTextureLoader end.*/

    /*Spine.Unity.SpineSpriteAtlasAsset start.*/
    $m("Spine.Unity.SpineSpriteAtlasAsset", function () { return {"nested":[$n[12].SpineSpriteAtlasAsset.SavedRegionInfo],"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "New Spine SpriteAtlas Asset", menuName: "Spine/Spine SpriteAtlas Asset"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AccessPackedSprites","is":true,"t":8,"pi":[{"n":"spriteAtlas","pt":$n[13].SpriteAtlas,"ps":0}],"sn":"AccessPackedSprites","rt":System.Array.type(UnityEngine.Sprite),"p":[$n[13].SpriteAtlas]},{"a":2,"n":"AccessPackedTexture","is":true,"t":8,"pi":[{"n":"sprites","pt":System.Array.type(UnityEngine.Sprite),"ps":0}],"sn":"AccessPackedTexture","rt":$n[1].Texture2D,"p":[System.Array.type(UnityEngine.Sprite)]},{"a":3,"n":"AssignRegionsFromSavedRegions","t":8,"pi":[{"n":"sprites","pt":System.Array.type(UnityEngine.Sprite),"ps":0},{"n":"usedAtlas","pt":$n[9].Atlas,"ps":1}],"sn":"AssignRegionsFromSavedRegions","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Sprite),$n[9].Atlas]},{"ov":true,"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"spriteAtlasFile","pt":$n[13].SpriteAtlas,"ps":0},{"n":"materials","pt":System.Array.type(UnityEngine.Material),"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2}],"sn":"CreateRuntimeInstance","rt":$n[12].SpineSpriteAtlasAsset,"p":[$n[13].SpriteAtlas,System.Array.type(UnityEngine.Material),$n[0].Boolean]},{"ov":true,"a":2,"n":"GetAtlas","t":8,"sn":"GetAtlas","rt":$n[9].Atlas},{"a":1,"n":"LoadAtlas","t":8,"pi":[{"n":"spriteAtlas","pt":$n[13].SpriteAtlas,"ps":0}],"sn":"LoadAtlas","rt":$n[9].Atlas,"p":[$n[13].SpriteAtlas]},{"a":1,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"ov":true,"a":2,"n":"MaterialCount","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_MaterialCount","t":8,"rt":$n[0].Int32,"fg":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MaterialCount"},{"ov":true,"a":2,"n":"Materials","t":16,"rt":$n[5].IEnumerable$1(UnityEngine.Material),"g":{"ov":true,"a":2,"n":"get_Materials","t":8,"rt":$n[5].IEnumerable$1(UnityEngine.Material),"fg":"Materials"},"fn":"Materials"},{"ov":true,"a":2,"n":"PrimaryMaterial","t":16,"rt":$n[1].Material,"g":{"ov":true,"a":2,"n":"get_PrimaryMaterial","t":8,"rt":$n[1].Material,"fg":"PrimaryMaterial"},"fn":"PrimaryMaterial"},{"a":3,"n":"atlas","t":4,"rt":$n[9].Atlas,"sn":"atlas"},{"a":2,"n":"materials","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materials"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"savedRegions","t":4,"rt":System.Array.type(Spine.Unity.SpineSpriteAtlasAsset.SavedRegionInfo),"sn":"savedRegions"},{"a":2,"n":"spriteAtlasFile","t":4,"rt":$n[13].SpriteAtlas,"sn":"spriteAtlasFile"},{"a":2,"n":"updateRegionsInPlayMode","t":4,"rt":$n[0].Boolean,"sn":"updateRegionsInPlayMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineSpriteAtlasAsset end.*/

    /*Spine.Unity.SpineSpriteAtlasAsset+SavedRegionInfo start.*/
    $m("Spine.Unity.SpineSpriteAtlasAsset.SavedRegionInfo", function () { return {"td":$n[12].SpineSpriteAtlasAsset,"att":1056772,"a":3,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"height","t":4,"rt":$n[0].Single,"sn":"height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"packingRotation","t":4,"rt":$n[1].SpritePackingRotation,"sn":"packingRotation","box":function ($v) { return Bridge.box($v, UnityEngine.SpritePackingRotation, System.Enum.toStringFn(UnityEngine.SpritePackingRotation));}},{"a":2,"n":"width","t":4,"rt":$n[0].Single,"sn":"width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.SpineSpriteAtlasAsset+SavedRegionInfo end.*/

    /*Spine.Unity.BoneFollower start.*/
    $m("Spine.Unity.BoneFollower", function () { return {"nested":[$n[12].BoneFollower.AxisOrientation],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/BoneFollower"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoneFollower")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"HandleRebuildRenderer","t":8,"pi":[{"n":"skeletonRenderer","pt":$n[12].SkeletonRenderer,"ps":0}],"sn":"HandleRebuildRenderer","rt":$n[0].Void,"p":[$n[12].SkeletonRenderer]},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":2,"n":"SetBone","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"SetBone","rt":$n[0].Boolean,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[12].SkeletonRenderer,"g":{"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[12].SkeletonRenderer,"fg":"SkeletonRenderer"},"s":{"a":2,"n":"set_SkeletonRenderer","t":8,"p":[$n[12].SkeletonRenderer],"rt":$n[0].Void,"fs":"SkeletonRenderer"},"fn":"SkeletonRenderer"},{"a":2,"n":"bone","t":4,"rt":$n[9].Bone,"sn":"bone"},{"at":[new Spine.Unity.SpineBone("", "skeletonRenderer", true, false)],"a":2,"n":"boneName","t":4,"rt":$n[0].String,"sn":"boneName"},{"a":2,"n":"followBoneRotation","t":4,"rt":$n[0].Boolean,"sn":"followBoneRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the target bone's local scale. BoneFollower cannot inherit world/skewed scale because of UnityEngine.Transform property limitations.")],"a":2,"n":"followLocalScale","t":4,"rt":$n[0].Boolean,"sn":"followLocalScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the skeleton's flip state by controlling this Transform's local scale.")],"a":2,"n":"followSkeletonFlip","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonFlip","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followXYPosition","t":4,"rt":$n[0].Boolean,"sn":"followXYPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followZPosition","t":4,"rt":$n[0].Boolean,"sn":"followZPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("resetOnAwake")],"a":2,"n":"initializeOnAwake","t":4,"rt":$n[0].Boolean,"sn":"initializeOnAwake","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Applies when 'Follow Skeleton Flip' is disabled but 'Follow Bone Rotation' is enabled. When flipping the skeleton by scaling its Transform, this follower's rotation is adjusted instead of its scale to follow the bone orientation. When one of the axes is flipped,  only one axis can be followed, either the X or the Y axis, which is selected here.")],"a":2,"n":"maintainedAxisOrientation","t":4,"rt":$n[12].BoneFollower.AxisOrientation,"sn":"maintainedAxisOrientation","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[12].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[1].Transform,"sn":"skeletonTransform"},{"a":1,"n":"skeletonTransformIsParent","t":4,"rt":$n[0].Boolean,"sn":"skeletonTransformIsParent","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.BoneFollower end.*/

    /*Spine.Unity.BoneFollower+AxisOrientation start.*/
    $m("Spine.Unity.BoneFollower.AxisOrientation", function () { return {"td":$n[12].BoneFollower,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"XAxis","is":true,"t":4,"rt":$n[12].BoneFollower.AxisOrientation,"sn":"XAxis","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}},{"a":2,"n":"YAxis","is":true,"t":4,"rt":$n[12].BoneFollower.AxisOrientation,"sn":"YAxis","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}}]}; }, $n);
    /*Spine.Unity.BoneFollower+AxisOrientation end.*/

    /*Spine.Unity.BoneFollowerGraphic start.*/
    $m("Spine.Unity.BoneFollowerGraphic", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(UnityEngine.RectTransform),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.AddComponentMenu.ctor("Spine/UI/BoneFollowerGraphic"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoneFollowerGraphic")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":2,"n":"SetBone","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"SetBone","rt":$n[0].Boolean,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SkeletonGraphic","t":16,"rt":$n[12].SkeletonGraphic,"g":{"a":2,"n":"get_SkeletonGraphic","t":8,"rt":$n[12].SkeletonGraphic,"fg":"SkeletonGraphic"},"s":{"a":2,"n":"set_SkeletonGraphic","t":8,"p":[$n[12].SkeletonGraphic],"rt":$n[0].Void,"fs":"SkeletonGraphic"},"fn":"SkeletonGraphic"},{"a":2,"n":"bone","t":4,"rt":$n[9].Bone,"sn":"bone"},{"at":[new Spine.Unity.SpineBone("", "skeletonGraphic", true, false)],"a":2,"n":"boneName","t":4,"rt":$n[0].String,"sn":"boneName"},{"a":2,"n":"followBoneRotation","t":4,"rt":$n[0].Boolean,"sn":"followBoneRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the target bone's local scale. BoneFollower cannot inherit world/skewed scale because of UnityEngine.Transform property limitations.")],"a":2,"n":"followLocalScale","t":4,"rt":$n[0].Boolean,"sn":"followLocalScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the skeleton's flip state by controlling this Transform's local scale.")],"a":2,"n":"followSkeletonFlip","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonFlip","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followXYPosition","t":4,"rt":$n[0].Boolean,"sn":"followXYPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followZPosition","t":4,"rt":$n[0].Boolean,"sn":"followZPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initializeOnAwake","t":4,"rt":$n[0].Boolean,"sn":"initializeOnAwake","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Applies when 'Follow Skeleton Flip' is disabled but 'Follow Bone Rotation' is enabled. When flipping the skeleton by scaling its Transform, this follower's rotation is adjusted instead of its scale to follow the bone orientation. When one of the axes is flipped,  only one axis can be followed, either the X or the Y axis, which is selected here.")],"a":2,"n":"maintainedAxisOrientation","t":4,"rt":$n[12].BoneFollower.AxisOrientation,"sn":"maintainedAxisOrientation","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[12].SkeletonGraphic,"sn":"skeletonGraphic"},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[1].Transform,"sn":"skeletonTransform"},{"a":1,"n":"skeletonTransformIsParent","t":4,"rt":$n[0].Boolean,"sn":"skeletonTransformIsParent","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.BoneFollowerGraphic end.*/

    /*Spine.Unity.BoundingBoxFollower start.*/
    $m("Spine.Unity.BoundingBoxFollower", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoundingBoxFollower")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AddCollidersForSkin","t":8,"pi":[{"n":"skin","pt":$n[9].Skin,"ps":0},{"n":"slotIndex","pt":$n[0].Int32,"ps":1},{"n":"previousColliders","pt":System.Array.type(UnityEngine.PolygonCollider2D),"ps":2},{"n":"collidersCount","ref":true,"pt":$n[0].Int32,"ps":3}],"sn":"AddCollidersForSkin","rt":$n[0].Void,"p":[$n[9].Skin,$n[0].Int32,System.Array.type(UnityEngine.PolygonCollider2D),$n[0].Int32]},{"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"a":1,"n":"DisposeExcessCollidersAfter","t":8,"pi":[{"n":"requiredCount","pt":$n[0].Int32,"ps":0}],"sn":"DisposeExcessCollidersAfter","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"HandleRebuild","t":8,"pi":[{"n":"sr","pt":$n[12].SkeletonRenderer,"ps":0}],"sn":"HandleRebuild","rt":$n[0].Void,"p":[$n[12].SkeletonRenderer]},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"MatchAttachment","t":8,"pi":[{"n":"attachment","pt":$n[9].Attachment,"ps":0}],"sn":"MatchAttachment","rt":$n[0].Void,"p":[$n[9].Attachment]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"CurrentAttachment","t":16,"rt":$n[9].BoundingBoxAttachment,"g":{"a":2,"n":"get_CurrentAttachment","t":8,"rt":$n[9].BoundingBoxAttachment,"fg":"CurrentAttachment"},"fn":"CurrentAttachment"},{"a":2,"n":"CurrentAttachmentName","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_CurrentAttachmentName","t":8,"rt":$n[0].String,"fg":"CurrentAttachmentName"},"fn":"CurrentAttachmentName"},{"a":2,"n":"CurrentCollider","t":16,"rt":$n[1].PolygonCollider2D,"g":{"a":2,"n":"get_CurrentCollider","t":8,"rt":$n[1].PolygonCollider2D,"fg":"CurrentCollider"},"fn":"CurrentCollider"},{"a":2,"n":"IsTrigger","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsTrigger","t":8,"rt":$n[0].Boolean,"fg":"IsTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsTrigger"},{"a":2,"n":"Slot","t":16,"rt":$n[9].Slot,"g":{"a":2,"n":"get_Slot","t":8,"rt":$n[9].Slot,"fg":"Slot"},"fn":"Slot"},{"a":4,"n":"DebugMessages","is":true,"t":4,"rt":$n[0].Boolean,"sn":"DebugMessages","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"clearStateOnDisable","t":4,"rt":$n[0].Boolean,"sn":"clearStateOnDisable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"colliderTable","t":4,"rt":$n[5].Dictionary$2(Spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D),"sn":"colliderTable","ro":true},{"a":1,"n":"currentAttachment","t":4,"rt":$n[9].BoundingBoxAttachment,"sn":"currentAttachment"},{"a":1,"n":"currentAttachmentName","t":4,"rt":$n[0].String,"sn":"currentAttachmentName"},{"a":1,"n":"currentCollider","t":4,"rt":$n[1].PolygonCollider2D,"sn":"currentCollider"},{"a":2,"n":"isTrigger","t":4,"rt":$n[0].Boolean,"sn":"isTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"nameTable","t":4,"rt":$n[5].Dictionary$2(Spine.BoundingBoxAttachment,System.String),"sn":"nameTable","ro":true},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[12].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"slot","t":4,"rt":$n[9].Slot,"sn":"slot"},{"at":[new Spine.Unity.SpineSlot("", "skeletonRenderer", true, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"}]}; }, $n);
    /*Spine.Unity.BoundingBoxFollower end.*/

    /*Spine.Unity.BoundingBoxFollowerGraphic start.*/
    $m("Spine.Unity.BoundingBoxFollowerGraphic", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoundingBoxFollowerGraphic")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AddCollidersForSkin","t":8,"pi":[{"n":"skin","pt":$n[9].Skin,"ps":0},{"n":"slotIndex","pt":$n[0].Int32,"ps":1},{"n":"previousColliders","pt":System.Array.type(UnityEngine.PolygonCollider2D),"ps":2},{"n":"scale","pt":$n[0].Single,"ps":3},{"n":"collidersCount","ref":true,"pt":$n[0].Int32,"ps":4}],"sn":"AddCollidersForSkin","rt":$n[0].Void,"p":[$n[9].Skin,$n[0].Int32,System.Array.type(UnityEngine.PolygonCollider2D),$n[0].Single,$n[0].Int32]},{"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"a":1,"n":"DisposeExcessCollidersAfter","t":8,"pi":[{"n":"requiredCount","pt":$n[0].Int32,"ps":0}],"sn":"DisposeExcessCollidersAfter","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"HandleRebuild","t":8,"pi":[{"n":"sr","pt":$n[12].SkeletonGraphic,"ps":0}],"sn":"HandleRebuild","rt":$n[0].Void,"p":[$n[12].SkeletonGraphic]},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"MatchAttachment","t":8,"pi":[{"n":"attachment","pt":$n[9].Attachment,"ps":0}],"sn":"MatchAttachment","rt":$n[0].Void,"p":[$n[9].Attachment]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"CurrentAttachment","t":16,"rt":$n[9].BoundingBoxAttachment,"g":{"a":2,"n":"get_CurrentAttachment","t":8,"rt":$n[9].BoundingBoxAttachment,"fg":"CurrentAttachment"},"fn":"CurrentAttachment"},{"a":2,"n":"CurrentAttachmentName","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_CurrentAttachmentName","t":8,"rt":$n[0].String,"fg":"CurrentAttachmentName"},"fn":"CurrentAttachmentName"},{"a":2,"n":"CurrentCollider","t":16,"rt":$n[1].PolygonCollider2D,"g":{"a":2,"n":"get_CurrentCollider","t":8,"rt":$n[1].PolygonCollider2D,"fg":"CurrentCollider"},"fn":"CurrentCollider"},{"a":2,"n":"IsTrigger","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsTrigger","t":8,"rt":$n[0].Boolean,"fg":"IsTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsTrigger"},{"a":2,"n":"Slot","t":16,"rt":$n[9].Slot,"g":{"a":2,"n":"get_Slot","t":8,"rt":$n[9].Slot,"fg":"Slot"},"fn":"Slot"},{"a":4,"n":"DebugMessages","is":true,"t":4,"rt":$n[0].Boolean,"sn":"DebugMessages","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"clearStateOnDisable","t":4,"rt":$n[0].Boolean,"sn":"clearStateOnDisable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"colliderTable","t":4,"rt":$n[5].Dictionary$2(Spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D),"sn":"colliderTable","ro":true},{"a":1,"n":"currentAttachment","t":4,"rt":$n[9].BoundingBoxAttachment,"sn":"currentAttachment"},{"a":1,"n":"currentAttachmentName","t":4,"rt":$n[0].String,"sn":"currentAttachmentName"},{"a":1,"n":"currentCollider","t":4,"rt":$n[1].PolygonCollider2D,"sn":"currentCollider"},{"a":2,"n":"isTrigger","t":4,"rt":$n[0].Boolean,"sn":"isTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"nameTable","t":4,"rt":$n[5].Dictionary$2(Spine.BoundingBoxAttachment,System.String),"sn":"nameTable","ro":true},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[12].SkeletonGraphic,"sn":"skeletonGraphic"},{"a":1,"n":"slot","t":4,"rt":$n[9].Slot,"sn":"slot"},{"at":[new Spine.Unity.SpineSlot("", "skeletonGraphic", true, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"}]}; }, $n);
    /*Spine.Unity.BoundingBoxFollowerGraphic end.*/

    /*Spine.Unity.PointFollower start.*/
    $m("Spine.Unity.PointFollower", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/Point Follower"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#PointFollower")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"HandleRebuildRenderer","t":8,"pi":[{"n":"skeletonRenderer","pt":$n[12].SkeletonRenderer,"ps":0}],"sn":"HandleRebuildRenderer","rt":$n[0].Void,"p":[$n[12].SkeletonRenderer]},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":1,"n":"UpdateReferences","t":8,"sn":"UpdateReferences","rt":$n[0].Void},{"a":2,"n":"IsValid","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsValid","t":8,"rt":$n[0].Boolean,"fg":"IsValid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsValid"},{"a":2,"n":"SkeletonComponent","t":16,"rt":$n[12].ISkeletonComponent,"g":{"a":2,"n":"get_SkeletonComponent","t":8,"rt":$n[12].ISkeletonComponent,"fg":"SkeletonComponent"},"fn":"SkeletonComponent"},{"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[12].SkeletonRenderer,"g":{"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[12].SkeletonRenderer,"fg":"SkeletonRenderer"},"fn":"SkeletonRenderer"},{"a":1,"n":"bone","t":4,"rt":$n[9].Bone,"sn":"bone"},{"a":2,"n":"followRotation","t":4,"rt":$n[0].Boolean,"sn":"followRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followSkeletonFlip","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonFlip","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followSkeletonZPosition","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonZPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"point","t":4,"rt":$n[9].PointAttachment,"sn":"point"},{"at":[new Spine.Unity.SpineAttachment(true, false, false, "slotName", "skeletonRenderer", "", true, true)],"a":2,"n":"pointAttachmentName","t":4,"rt":$n[0].String,"sn":"pointAttachmentName"},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[12].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[1].Transform,"sn":"skeletonTransform"},{"a":1,"n":"skeletonTransformIsParent","t":4,"rt":$n[0].Boolean,"sn":"skeletonTransformIsParent","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSlot("", "skeletonRenderer", false, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"},{"a":1,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.PointFollower end.*/

    /*Spine.Unity.SkeletonMecanimRootMotion start.*/
    $m("Spine.Unity.SkeletonMecanimRootMotion", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonMecanimRootMotion")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":3,"n":"CalculateAnimationsMovementDelta","t":8,"sn":"CalculateAnimationsMovementDelta","rt":$n[1].Vector2},{"ov":true,"a":2,"n":"GetRemainingRootMotion","t":8,"pi":[{"n":"layerIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRemainingRootMotion","rt":$n[1].Vector2,"p":[$n[0].Int32]},{"ov":true,"a":2,"n":"GetRootMotionInfo","t":8,"pi":[{"n":"layerIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRootMotionInfo","rt":$n[12].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[0].Int32]},{"a":1,"n":"OnClipApplied","t":8,"pi":[{"n":"animation","pt":$n[9].Animation,"ps":0},{"n":"layerIndex","pt":$n[0].Int32,"ps":1},{"n":"weight","pt":$n[0].Single,"ps":2},{"n":"time","pt":$n[0].Single,"ps":3},{"n":"lastTime","pt":$n[0].Single,"ps":4},{"n":"playsBackward","pt":$n[0].Boolean,"ps":5}],"sn":"OnClipApplied","rt":$n[0].Void,"p":[$n[9].Animation,$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"ov":true,"a":3,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":3,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"SkeletonMecanim","t":16,"rt":$n[12].SkeletonMecanim,"g":{"a":2,"n":"get_SkeletonMecanim","t":8,"rt":$n[12].SkeletonMecanim,"fg":"SkeletonMecanim"},"fn":"SkeletonMecanim"},{"a":1,"n":"DefaultMecanimLayerFlags","is":true,"t":4,"rt":$n[0].Int32,"sn":"DefaultMecanimLayerFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"mecanimLayerFlags","t":4,"rt":$n[0].Int32,"sn":"mecanimLayerFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"movementDelta","t":4,"rt":$n[1].Vector2,"sn":"movementDelta"},{"a":1,"n":"skeletonMecanim","t":4,"rt":$n[12].SkeletonMecanim,"sn":"skeletonMecanim"}]}; }, $n);
    /*Spine.Unity.SkeletonMecanimRootMotion end.*/

    /*Spine.Unity.SkeletonRootMotion start.*/
    $m("Spine.Unity.SkeletonRootMotion", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRootMotion")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"ApplyMixAlphaToDelta","t":8,"pi":[{"n":"currentDelta","ref":true,"pt":$n[1].Vector2,"ps":0},{"n":"next","pt":$n[9].TrackEntry,"ps":1},{"n":"track","pt":$n[9].TrackEntry,"ps":2}],"sn":"ApplyMixAlphaToDelta","rt":$n[0].Void,"p":[$n[1].Vector2,$n[9].TrackEntry,$n[9].TrackEntry]},{"ov":true,"a":3,"n":"CalculateAnimationsMovementDelta","t":8,"sn":"CalculateAnimationsMovementDelta","rt":$n[1].Vector2},{"ov":true,"a":2,"n":"GetRemainingRootMotion","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRemainingRootMotion","rt":$n[1].Vector2,"p":[$n[0].Int32]},{"ov":true,"a":2,"n":"GetRootMotionInfo","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRootMotionInfo","rt":$n[12].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[0].Int32]},{"ov":true,"a":3,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":3,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"ov":true,"a":3,"n":"AdditionalScale","t":16,"rt":$n[0].Single,"g":{"ov":true,"a":3,"n":"get_AdditionalScale","t":8,"rt":$n[0].Single,"fg":"AdditionalScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"AdditionalScale"},{"a":1,"n":"DefaultAnimationTrackFlags","is":true,"t":4,"rt":$n[0].Int32,"sn":"DefaultAnimationTrackFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"animationState","t":4,"rt":$n[9].AnimationState,"sn":"animationState"},{"a":2,"n":"animationTrackFlags","t":4,"rt":$n[0].Int32,"sn":"animationTrackFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"canvas","t":4,"rt":$n[1].Canvas,"sn":"canvas"}]}; }, $n);
    /*Spine.Unity.SkeletonRootMotion end.*/

    /*Spine.Unity.SkeletonRootMotionBase start.*/
    $m("Spine.Unity.SkeletonRootMotionBase", function () { return {"nested":[$n[12].SkeletonRootMotionBase.RootMotionInfo],"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AdjustRootMotionToDistance","t":8,"pi":[{"n":"distanceToTarget","pt":$n[1].Vector2,"ps":0},{"n":"trackIndex","dv":0,"o":true,"pt":$n[0].Int32,"ps":1},{"n":"adjustX","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"adjustY","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"minX","dv":0.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"maxX","dv":3.40282347E+38,"o":true,"pt":$n[0].Single,"ps":5},{"n":"minY","dv":0.0,"o":true,"pt":$n[0].Single,"ps":6},{"n":"maxY","dv":3.40282347E+38,"o":true,"pt":$n[0].Single,"ps":7},{"n":"allowXTranslation","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"allowYTranslation","dv":false,"o":true,"pt":$n[0].Boolean,"ps":9}],"sn":"AdjustRootMotionToDistance","rt":$n[0].Void,"p":[$n[1].Vector2,$n[0].Int32,$n[0].Boolean,$n[0].Boolean,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"ApplyRootMotion","t":8,"pi":[{"n":"skeletonDelta","pt":$n[1].Vector2,"ps":0},{"n":"parentBoneScale","pt":$n[1].Vector2,"ps":1}],"sn":"ApplyRootMotion","rt":$n[0].Void,"p":[$n[1].Vector2,$n[1].Vector2]},{"ab":true,"a":3,"n":"CalculateAnimationsMovementDelta","t":8,"sn":"CalculateAnimationsMovementDelta","rt":$n[1].Vector2},{"a":1,"n":"ClearEffectiveBoneOffsets","t":8,"pi":[{"n":"parentBoneScale","pt":$n[1].Vector2,"ps":0}],"sn":"ClearEffectiveBoneOffsets","rt":$n[0].Void,"p":[$n[1].Vector2]},{"a":3,"n":"FindRigidbodyComponent","t":8,"sn":"FindRigidbodyComponent","rt":$n[0].Void},{"v":true,"a":3,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"GatherTopLevelBones","t":8,"sn":"GatherTopLevelBones","rt":$n[0].Void},{"a":2,"n":"GetAnimationRootMotion","t":8,"pi":[{"n":"animation","pt":$n[9].Animation,"ps":0}],"sn":"GetAnimationRootMotion","rt":$n[1].Vector2,"p":[$n[9].Animation]},{"a":2,"n":"GetAnimationRootMotion","t":8,"pi":[{"n":"startTime","pt":$n[0].Single,"ps":0},{"n":"endTime","pt":$n[0].Single,"ps":1},{"n":"animation","pt":$n[9].Animation,"ps":2}],"sn":"GetAnimationRootMotion$1","rt":$n[1].Vector2,"p":[$n[0].Single,$n[0].Single,$n[9].Animation]},{"a":2,"n":"GetAnimationRootMotionInfo","t":8,"pi":[{"n":"animation","pt":$n[9].Animation,"ps":0},{"n":"currentTime","pt":$n[0].Single,"ps":1}],"sn":"GetAnimationRootMotionInfo","rt":$n[12].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[9].Animation,$n[0].Single]},{"ab":true,"a":2,"n":"GetRemainingRootMotion","t":8,"pi":[{"n":"trackIndex","dv":0,"o":true,"pt":$n[0].Int32,"ps":0}],"sn":"GetRemainingRootMotion","rt":$n[1].Vector2,"p":[$n[0].Int32]},{"ab":true,"a":2,"n":"GetRootMotionInfo","t":8,"pi":[{"n":"trackIndex","dv":0,"o":true,"pt":$n[0].Int32,"ps":0}],"sn":"GetRootMotionInfo","rt":$n[12].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[0].Int32]},{"a":1,"n":"GetScaleAffectingRootMotion","t":8,"sn":"GetScaleAffectingRootMotion","rt":$n[1].Vector2},{"a":1,"n":"GetScaleAffectingRootMotion","t":8,"pi":[{"n":"parentBoneScale","out":true,"pt":$n[1].Vector2,"ps":0}],"sn":"GetScaleAffectingRootMotion$1","rt":$n[1].Vector2,"p":[$n[1].Vector2]},{"a":1,"n":"GetSkeletonSpaceMovementDelta","t":8,"pi":[{"n":"boneLocalDelta","pt":$n[1].Vector2,"ps":0},{"n":"parentBoneScale","out":true,"pt":$n[1].Vector2,"ps":1}],"sn":"GetSkeletonSpaceMovementDelta","rt":$n[1].Vector2,"p":[$n[1].Vector2,$n[1].Vector2]},{"a":1,"n":"GetTimelineMovementDelta","t":8,"pi":[{"n":"startTime","pt":$n[0].Single,"ps":0},{"n":"endTime","pt":$n[0].Single,"ps":1},{"n":"timeline","pt":$n[9].TranslateTimeline,"ps":2},{"n":"animation","pt":$n[9].Animation,"ps":3}],"sn":"GetTimelineMovementDelta","rt":$n[1].Vector2,"p":[$n[0].Single,$n[0].Single,$n[9].TranslateTimeline,$n[9].Animation]},{"a":1,"n":"HandleUpdateLocal","t":8,"pi":[{"n":"animatedSkeletonComponent","pt":$n[12].ISkeletonAnimation,"ps":0}],"sn":"HandleUpdateLocal","rt":$n[0].Void,"p":[$n[12].ISkeletonAnimation]},{"v":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"v":true,"a":3,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":1,"n":"SetEffectiveBoneOffsetsTo","t":8,"pi":[{"n":"displacementSkeletonSpace","pt":$n[1].Vector2,"ps":0},{"n":"parentBoneScale","pt":$n[1].Vector2,"ps":1}],"sn":"SetEffectiveBoneOffsetsTo","rt":$n[0].Void,"p":[$n[1].Vector2,$n[1].Vector2]},{"a":2,"n":"SetRootMotionBone","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"SetRootMotionBone","rt":$n[0].Void,"p":[$n[0].String]},{"v":true,"a":3,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"v":true,"a":3,"n":"AdditionalScale","t":16,"rt":$n[0].Single,"g":{"v":true,"a":3,"n":"get_AdditionalScale","t":8,"rt":$n[0].Single,"fg":"AdditionalScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"AdditionalScale"},{"a":2,"n":"UsesRigidbody","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_UsesRigidbody","t":8,"rt":$n[0].Boolean,"fg":"UsesRigidbody","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"UsesRigidbody"},{"a":3,"n":"initialOffset","t":4,"rt":$n[1].Vector2,"sn":"initialOffset"},{"a":2,"n":"rigidBody","t":4,"rt":$n[1].Rigidbody,"sn":"rigidBody"},{"at":[new UnityEngine.HeaderAttribute("Optional")],"a":2,"n":"rigidBody2D","t":4,"rt":$n[1].Rigidbody2D,"sn":"rigidBody2D"},{"a":3,"n":"rigidbodyDisplacement","t":4,"rt":$n[1].Vector2,"sn":"rigidbodyDisplacement"},{"a":3,"n":"rootMotionBone","t":4,"rt":$n[9].Bone,"sn":"rootMotionBone"},{"a":3,"n":"rootMotionBoneIndex","t":4,"rt":$n[0].Int32,"sn":"rootMotionBoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new Spine.Unity.SpineBone("", "", true, false),new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"rootMotionBoneName","t":4,"rt":$n[0].String,"sn":"rootMotionBoneName"},{"a":2,"n":"rootMotionScaleX","t":4,"rt":$n[0].Single,"sn":"rootMotionScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionScaleY","t":4,"rt":$n[0].Single,"sn":"rootMotionScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionTranslateXPerY","t":4,"rt":$n[0].Single,"sn":"rootMotionTranslateXPerY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionTranslateYPerX","t":4,"rt":$n[0].Single,"sn":"rootMotionTranslateYPerX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"skeletonComponent","t":4,"rt":$n[12].ISkeletonComponent,"sn":"skeletonComponent"},{"a":3,"n":"tempSkeletonDisplacement","t":4,"rt":$n[1].Vector2,"sn":"tempSkeletonDisplacement"},{"a":3,"n":"topLevelBones","t":4,"rt":$n[5].List$1(Spine.Bone),"sn":"topLevelBones"},{"a":2,"n":"transformPositionX","t":4,"rt":$n[0].Boolean,"sn":"transformPositionX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"transformPositionY","t":4,"rt":$n[0].Boolean,"sn":"transformPositionY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SkeletonRootMotionBase end.*/

    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo start.*/
    $m("Spine.Unity.SkeletonRootMotionBase.RootMotionInfo", function () { return {"td":$n[12].SkeletonRootMotionBase,"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"current","t":4,"rt":$n[1].Vector2,"sn":"current"},{"a":2,"n":"end","t":4,"rt":$n[1].Vector2,"sn":"end"},{"a":2,"n":"mid","t":4,"rt":$n[1].Vector2,"sn":"mid"},{"a":2,"n":"start","t":4,"rt":$n[1].Vector2,"sn":"start"},{"a":2,"n":"timeIsPastMid","t":4,"rt":$n[0].Boolean,"sn":"timeIsPastMid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo end.*/

    /*Spine.Unity.SkeletonAnimation start.*/
    $m("Spine.Unity.SkeletonAnimation", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/SkeletonAnimation"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonAnimation-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddToGameObject","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[1].GameObject,"ps":0},{"n":"skeletonDataAsset","pt":$n[12].SkeletonDataAsset,"ps":1},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"AddToGameObject","rt":$n[12].SkeletonAnimation,"p":[$n[1].GameObject,$n[12].SkeletonDataAsset,$n[0].Boolean]},{"a":3,"n":"ApplyAnimation","t":8,"sn":"ApplyAnimation","rt":$n[0].Void},{"ov":true,"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"ov":true,"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean,$n[0].Boolean]},{"ov":true,"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":2,"n":"NewSkeletonAnimationGameObject","is":true,"t":8,"pi":[{"n":"skeletonDataAsset","pt":$n[12].SkeletonDataAsset,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"NewSkeletonAnimationGameObject","rt":$n[12].SkeletonAnimation,"p":[$n[12].SkeletonDataAsset,$n[0].Boolean]},{"a":1,"n":"Update","t":8,"sn":"Update$1","rt":$n[0].Void},{"a":2,"n":"Update","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"Update","rt":$n[0].Void,"p":[$n[0].Single]},{"a":3,"n":"UpdateAnimationStatus","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"UpdateAnimationStatus","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"AnimationName","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_AnimationName","t":8,"rt":$n[0].String,"fg":"AnimationName"},"s":{"a":2,"n":"set_AnimationName","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"AnimationName"},"fn":"AnimationName"},{"a":2,"n":"AnimationState","t":16,"rt":$n[9].AnimationState,"g":{"a":2,"n":"get_AnimationState","t":8,"rt":$n[9].AnimationState,"fg":"AnimationState"},"fn":"AnimationState"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false)],"a":1,"n":"_animationName","t":4,"rt":$n[0].String,"sn":"_animationName"},{"a":2,"n":"loop","t":4,"rt":$n[0].Boolean,"sn":"loop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"state","t":4,"rt":$n[9].AnimationState,"sn":"state"},{"a":2,"n":"timeScale","t":4,"rt":$n[0].Single,"sn":"timeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"wasUpdatedAfterInit","t":4,"rt":$n[0].Boolean,"sn":"wasUpdatedAfterInit","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"BeforeApply","t":2,"ad":{"a":2,"n":"add_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addBeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeBeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateComplete","t":2,"ad":{"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateLocal","t":2,"ad":{"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateWorld","t":2,"ad":{"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_BeforeApply","t":2,"ad":{"a":3,"n":"add__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_BeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_BeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateComplete","t":2,"ad":{"a":3,"n":"add__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateLocal","t":2,"ad":{"a":3,"n":"add__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateWorld","t":2,"ad":{"a":3,"n":"add__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateWorld","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonAnimation end.*/

    /*Spine.Unity.SkeletonGraphic start.*/
    $m("Spine.Unity.SkeletonGraphic", function () { return {"nested":[Function],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.$ctor1(UnityEngine.CanvasRenderer, UnityEngine.RectTransform),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.AddComponentMenu.ctor("Spine/SkeletonGraphic (Unity UI Canvas)"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonGraphic-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddSkeletonGraphicComponent","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[1].GameObject,"ps":0},{"n":"skeletonDataAsset","pt":$n[12].SkeletonDataAsset,"ps":1},{"n":"material","pt":$n[1].Material,"ps":2}],"sn":"AddSkeletonGraphicComponent","rt":$n[12].SkeletonGraphic,"p":[$n[1].GameObject,$n[12].SkeletonDataAsset,$n[1].Material]},{"a":3,"n":"ApplyAnimation","t":8,"sn":"ApplyAnimation","rt":$n[0].Void},{"ov":true,"a":3,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":3,"n":"DestroyMeshes","t":8,"sn":"DestroyMeshes","rt":$n[0].Void},{"a":3,"n":"DisableUnusedCanvasRenderers","t":8,"pi":[{"n":"usedCount","pt":$n[0].Int32,"ps":0}],"sn":"DisableUnusedCanvasRenderers","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":3,"n":"DisposeMeshBuffers","t":8,"sn":"DisposeMeshBuffers","rt":$n[0].Void},{"a":3,"n":"EnsureCanvasRendererCount","t":8,"pi":[{"n":"targetCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureCanvasRendererCount","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":3,"n":"EnsureMeshesCount","t":8,"pi":[{"n":"targetCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureMeshesCount","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":3,"n":"EnsureSeparatorPartCount","t":8,"sn":"EnsureSeparatorPartCount","rt":$n[0].Void},{"a":2,"n":"GetLastMesh","t":8,"sn":"GetLastMesh","rt":$n[1].Mesh},{"a":2,"n":"HasMultipleSubmeshInstructions","t":8,"sn":"HasMultipleSubmeshInstructions","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"InitMeshBuffers","t":8,"sn":"InitMeshBuffers","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":3,"n":"MatchRectTransformMultipleRenderers","t":8,"sn":"MatchRectTransformMultipleRenderers","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"MatchRectTransformSingleRenderer","t":8,"sn":"MatchRectTransformSingleRenderer","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"MatchRectTransformWithBounds","t":8,"sn":"MatchRectTransformWithBounds","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"NewSkeletonGraphicGameObject","is":true,"t":8,"pi":[{"n":"skeletonDataAsset","pt":$n[12].SkeletonDataAsset,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1},{"n":"material","pt":$n[1].Material,"ps":2}],"sn":"NewSkeletonGraphicGameObject","rt":$n[12].SkeletonGraphic,"p":[$n[12].SkeletonDataAsset,$n[1].Transform,$n[1].Material]},{"a":2,"n":"OnBecameInvisible","t":8,"sn":"OnBecameInvisible","rt":$n[0].Void},{"a":2,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[0].Void},{"a":3,"n":"OnCullStateChanged","t":8,"pi":[{"n":"culled","pt":$n[0].Boolean,"ps":0}],"sn":"OnCullStateChanged","rt":$n[0].Void,"p":[$n[0].Boolean]},{"ov":true,"a":3,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"ReapplySeparatorSlotNames","t":8,"sn":"ReapplySeparatorSlotNames","rt":$n[0].Void},{"ov":true,"a":2,"n":"Rebuild","t":8,"pi":[{"n":"update","pt":$n[3].CanvasUpdate,"ps":0}],"sn":"Rebuild","rt":$n[0].Void,"p":[$n[3].CanvasUpdate]},{"a":1,"n":"SetRectTransformBounds","t":8,"pi":[{"n":"combinedBounds","pt":$n[1].Bounds,"ps":0}],"sn":"SetRectTransformBounds","rt":$n[0].Void,"p":[$n[1].Bounds]},{"a":3,"n":"SyncRawImagesWithCanvasRenderers","t":8,"sn":"SyncRawImagesWithCanvasRenderers","rt":$n[0].Void},{"a":2,"n":"TrimRenderers","t":8,"sn":"TrimRenderers","rt":$n[0].Void},{"v":true,"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"v":true,"a":2,"n":"Update","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"Update$1","rt":$n[0].Void,"p":[$n[0].Single]},{"a":3,"n":"UpdateAnimationStatus","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"UpdateAnimationStatus","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"UpdateMesh","t":8,"pi":[{"n":"keepRendererCount","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"UpdateMesh","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":3,"n":"UpdateMeshMultipleCanvasRenderers","t":8,"pi":[{"n":"currentInstructions","pt":$n[12].SkeletonRendererInstruction,"ps":0},{"n":"keepRendererCount","pt":$n[0].Boolean,"ps":1}],"sn":"UpdateMeshMultipleCanvasRenderers","rt":$n[0].Void,"p":[$n[12].SkeletonRendererInstruction,$n[0].Boolean]},{"a":3,"n":"UpdateMeshSingleCanvasRenderer","t":8,"sn":"UpdateMeshSingleCanvasRenderer","rt":$n[0].Void},{"a":3,"n":"UpdateSeparatorPartParents","t":8,"sn":"UpdateSeparatorPartParents","rt":$n[0].Void},{"a":2,"n":"AnimationState","t":16,"rt":$n[9].AnimationState,"g":{"a":2,"n":"get_AnimationState","t":8,"rt":$n[9].AnimationState,"fg":"AnimationState"},"fn":"AnimationState"},{"a":2,"n":"CustomMaterialOverride","t":16,"rt":$n[5].Dictionary$2(UnityEngine.Texture,UnityEngine.Material),"g":{"a":2,"n":"get_CustomMaterialOverride","t":8,"rt":$n[5].Dictionary$2(UnityEngine.Texture,UnityEngine.Material),"fg":"CustomMaterialOverride"},"fn":"CustomMaterialOverride"},{"a":2,"n":"CustomTextureOverride","t":16,"rt":$n[5].Dictionary$2(UnityEngine.Texture,UnityEngine.Texture),"g":{"a":2,"n":"get_CustomTextureOverride","t":8,"rt":$n[5].Dictionary$2(UnityEngine.Texture,UnityEngine.Texture),"fg":"CustomTextureOverride"},"fn":"CustomTextureOverride"},{"a":2,"n":"IsValid","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsValid","t":8,"rt":$n[0].Boolean,"fg":"IsValid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsValid"},{"a":2,"n":"MeshGenerator","t":16,"rt":$n[12].MeshGenerator,"g":{"a":2,"n":"get_MeshGenerator","t":8,"rt":$n[12].MeshGenerator,"fg":"MeshGenerator"},"fn":"MeshGenerator"},{"a":2,"n":"OverrideTexture","t":16,"rt":$n[1].Texture,"g":{"a":2,"n":"get_OverrideTexture","t":8,"rt":$n[1].Texture,"fg":"OverrideTexture"},"s":{"a":2,"n":"set_OverrideTexture","t":8,"p":[$n[1].Texture],"rt":$n[0].Void,"fs":"OverrideTexture"},"fn":"OverrideTexture"},{"a":2,"n":"SeparatorParts","t":16,"rt":$n[5].List$1(UnityEngine.Transform),"g":{"a":2,"n":"get_SeparatorParts","t":8,"rt":$n[5].List$1(UnityEngine.Transform),"fg":"SeparatorParts"},"fn":"SeparatorParts"},{"a":2,"n":"Skeleton","t":16,"rt":$n[9].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[9].Skeleton,"fg":"Skeleton"},"s":{"a":2,"n":"set_Skeleton","t":8,"p":[$n[9].Skeleton],"rt":$n[0].Void,"fs":"Skeleton"},"fn":"Skeleton"},{"a":2,"n":"SkeletonData","t":16,"rt":$n[9].SkeletonData,"g":{"a":2,"n":"get_SkeletonData","t":8,"rt":$n[9].SkeletonData,"fg":"SkeletonData"},"fn":"SkeletonData"},{"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[12].SkeletonDataAsset,"g":{"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[12].SkeletonDataAsset,"fg":"SkeletonDataAsset"},"fn":"SkeletonDataAsset"},{"a":2,"n":"UpdateMode","t":16,"rt":$n[12].UpdateMode,"g":{"a":2,"n":"get_UpdateMode","t":8,"rt":$n[12].UpdateMode,"fg":"UpdateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},"s":{"a":2,"n":"set_UpdateMode","t":8,"p":[$n[12].UpdateMode],"rt":$n[0].Void,"fs":"UpdateMode"},"fn":"UpdateMode"},{"ov":true,"a":2,"n":"mainTexture","t":16,"rt":$n[1].Texture,"g":{"ov":true,"a":2,"n":"get_mainTexture","t":8,"rt":$n[1].Texture,"fg":"mainTexture"},"fn":"mainTexture"},{"a":2,"n":"SeparatorPartGameObjectName","is":true,"t":4,"rt":$n[0].String,"sn":"SeparatorPartGameObjectName"},{"a":2,"n":"allowMultipleCanvasRenderers","t":4,"rt":$n[0].Boolean,"sn":"allowMultipleCanvasRenderers","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"baseTexture","t":4,"rt":$n[1].Texture,"sn":"baseTexture"},{"a":2,"n":"canvasRenderers","t":4,"rt":$n[5].List$1(UnityEngine.CanvasRenderer),"sn":"canvasRenderers"},{"a":1,"n":"currentInstructions","t":4,"rt":$n[12].SkeletonRendererInstruction,"sn":"currentInstructions"},{"a":1,"n":"customMaterialOverride","t":4,"rt":$n[5].Dictionary$2(UnityEngine.Texture,UnityEngine.Material),"sn":"customMaterialOverride","ro":true},{"a":1,"n":"customTextureOverride","t":4,"rt":$n[5].Dictionary$2(UnityEngine.Texture,UnityEngine.Texture),"sn":"customTextureOverride","ro":true},{"a":2,"n":"enableSeparatorSlots","t":4,"rt":$n[0].Boolean,"sn":"enableSeparatorSlots","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"freeze","t":4,"rt":$n[0].Boolean,"sn":"freeze","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipX","t":4,"rt":$n[0].Boolean,"sn":"initialFlipX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipY","t":4,"rt":$n[0].Boolean,"sn":"initialFlipY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSkin("", "skeletonDataAsset", true, false, true)],"a":2,"n":"initialSkinName","t":4,"rt":$n[0].String,"sn":"initialSkinName"},{"a":1,"n":"meshBuffers","t":4,"rt":$n[12].DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh),"sn":"meshBuffers"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"meshGenerator","t":4,"rt":$n[12].MeshGenerator,"sn":"meshGenerator"},{"a":1,"n":"meshes","t":4,"rt":$n[9].ExposedList$1(UnityEngine.Mesh),"sn":"meshes","ro":true},{"a":1,"n":"overrideTexture","t":4,"rt":$n[1].Texture,"sn":"overrideTexture"},{"a":3,"n":"rawImages","t":4,"rt":$n[5].List$1(UnityEngine.UI.RawImage),"sn":"rawImages"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"separatorParts","t":4,"rt":$n[5].List$1(UnityEngine.Transform),"sn":"separatorParts"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineSlot("", "", false, true, false)],"a":3,"n":"separatorSlotNames","t":4,"rt":$n[0].Array.type(System.String),"sn":"separatorSlotNames"},{"a":2,"n":"separatorSlots","t":4,"rt":$n[5].List$1(Spine.Slot),"sn":"separatorSlots","ro":true},{"a":3,"n":"skeleton","t":4,"rt":$n[9].Skeleton,"sn":"skeleton"},{"a":2,"n":"skeletonDataAsset","t":4,"rt":$n[12].SkeletonDataAsset,"sn":"skeletonDataAsset"},{"at":[new Spine.Unity.SpineAnimation("", "skeletonDataAsset", true, false)],"a":2,"n":"startingAnimation","t":4,"rt":$n[0].String,"sn":"startingAnimation"},{"a":2,"n":"startingLoop","t":4,"rt":$n[0].Boolean,"sn":"startingLoop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"state","t":4,"rt":$n[9].AnimationState,"sn":"state"},{"a":2,"n":"timeScale","t":4,"rt":$n[0].Single,"sn":"timeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"unscaledTime","t":4,"rt":$n[0].Boolean,"sn":"unscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"updateMode","t":4,"rt":$n[12].UpdateMode,"sn":"updateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"updateSeparatorPartLocation","t":4,"rt":$n[0].Boolean,"sn":"updateSeparatorPartLocation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"updateWhenInvisible","t":4,"rt":$n[12].UpdateMode,"sn":"updateWhenInvisible","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":3,"n":"usedRenderersCount","t":4,"rt":$n[0].Int32,"sn":"usedRenderersCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"wasUpdatedAfterInit","t":4,"rt":$n[0].Boolean,"sn":"wasUpdatedAfterInit","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"BeforeApply","t":2,"ad":{"a":2,"n":"add_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addBeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeBeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnPostProcessVertices","t":2,"ad":{"a":2,"n":"add_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnPostProcessVertices","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnPostProcessVertices","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnRebuild","t":2,"ad":{"a":2,"n":"add_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnRebuild","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateComplete","t":2,"ad":{"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateLocal","t":2,"ad":{"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateWorld","t":2,"ad":{"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateWorld","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonGraphic end.*/

    /*Spine.Unity.SkeletonMecanim start.*/
    $m("Spine.Unity.SkeletonMecanim", function () { return {"nested":[$n[12].SkeletonMecanim.MecanimTranslator],"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.Animator),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonMecanim-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":3,"n":"ApplyAnimation","t":8,"sn":"ApplyAnimation","rt":$n[0].Void},{"ov":true,"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean,$n[0].Boolean]},{"ov":true,"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"Translator","t":16,"rt":$n[12].SkeletonMecanim.MecanimTranslator,"g":{"a":2,"n":"get_Translator","t":8,"rt":$n[12].SkeletonMecanim.MecanimTranslator,"fg":"Translator"},"fn":"Translator"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"translator","t":4,"rt":$n[12].SkeletonMecanim.MecanimTranslator,"sn":"translator"},{"a":1,"n":"wasUpdatedAfterInit","t":4,"rt":$n[0].Boolean,"sn":"wasUpdatedAfterInit","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"BeforeApply","t":2,"ad":{"a":2,"n":"add_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addBeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeBeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateComplete","t":2,"ad":{"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateLocal","t":2,"ad":{"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateWorld","t":2,"ad":{"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_BeforeApply","t":2,"ad":{"a":3,"n":"add__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_BeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_BeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateComplete","t":2,"ad":{"a":3,"n":"add__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateLocal","t":2,"ad":{"a":3,"n":"add__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateWorld","t":2,"ad":{"a":3,"n":"add__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateWorld","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator", function () { return {"td":$n[12].SkeletonMecanim,"nested":[Function,$n[12].SkeletonMecanim.MecanimTranslator.MixMode,$n[12].SkeletonMecanim.MecanimTranslator.ClipInfos,$n[12].SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer,$n[12].SkeletonMecanim.MecanimTranslator.IntEqualityComparer],"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AnimationTime","is":true,"t":8,"pi":[{"n":"normalizedTime","pt":$n[0].Single,"ps":0},{"n":"clipLength","pt":$n[0].Single,"ps":1},{"n":"reversed","pt":$n[0].Boolean,"ps":2}],"sn":"AnimationTime","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"AnimationTime","is":true,"t":8,"pi":[{"n":"normalizedTime","pt":$n[0].Single,"ps":0},{"n":"clipLength","pt":$n[0].Single,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2},{"n":"reversed","pt":$n[0].Boolean,"ps":3}],"sn":"AnimationTime$1","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0}],"sn":"Apply","rt":$n[0].Void,"p":[$n[9].Skeleton]},{"a":1,"n":"ApplyAnimation","t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0},{"n":"info","pt":$n[1].AnimatorClipInfo,"ps":1},{"n":"stateInfo","pt":$n[1].AnimatorStateInfo,"ps":2},{"n":"layerIndex","pt":$n[0].Int32,"ps":3},{"n":"layerWeight","pt":$n[0].Single,"ps":4},{"n":"layerBlendMode","pt":$n[9].MixBlend,"ps":5},{"n":"useClipWeight1","dv":false,"o":true,"pt":$n[0].Boolean,"ps":6}],"sn":"ApplyAnimation","rt":$n[0].Boolean,"p":[$n[9].Skeleton,$n[1].AnimatorClipInfo,$n[1].AnimatorStateInfo,$n[0].Int32,$n[0].Single,$n[9].MixBlend,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ApplyInterruptionAnimation","t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0},{"n":"interpolateWeightTo1","pt":$n[0].Boolean,"ps":1},{"n":"info","pt":$n[1].AnimatorClipInfo,"ps":2},{"n":"stateInfo","pt":$n[1].AnimatorStateInfo,"ps":3},{"n":"layerIndex","pt":$n[0].Int32,"ps":4},{"n":"layerWeight","pt":$n[0].Single,"ps":5},{"n":"layerBlendMode","pt":$n[9].MixBlend,"ps":6},{"n":"interruptingClipTimeAddition","pt":$n[0].Single,"ps":7},{"n":"useClipWeight1","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8}],"sn":"ApplyInterruptionAnimation","rt":$n[0].Boolean,"p":[$n[9].Skeleton,$n[0].Boolean,$n[1].AnimatorClipInfo,$n[1].AnimatorStateInfo,$n[0].Int32,$n[0].Single,$n[9].MixBlend,$n[0].Single,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ClearClipInfosForLayers","t":8,"sn":"ClearClipInfosForLayers","rt":$n[0].Void},{"a":2,"n":"GetActiveAnimationAndTime","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0}],"sn":"GetActiveAnimationAndTime","rt":$n[5].KeyValuePair$2(Spine.Animation,System.Single),"p":[$n[0].Int32]},{"a":1,"n":"GetAnimation","t":8,"pi":[{"n":"clip","pt":$n[1].AnimationClip,"ps":0}],"sn":"GetAnimation","rt":$n[9].Animation,"p":[$n[1].AnimationClip]},{"a":1,"n":"GetAnimatorClipInfos","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0},{"n":"isInterruptionActive","out":true,"pt":$n[0].Boolean,"ps":1},{"n":"clipInfoCount","out":true,"pt":$n[0].Int32,"ps":2},{"n":"nextClipInfoCount","out":true,"pt":$n[0].Int32,"ps":3},{"n":"interruptingClipInfoCount","out":true,"pt":$n[0].Int32,"ps":4},{"n":"clipInfo","out":true,"pt":$n[5].IList$1(UnityEngine.AnimatorClipInfo),"ps":5},{"n":"nextClipInfo","out":true,"pt":$n[5].IList$1(UnityEngine.AnimatorClipInfo),"ps":6},{"n":"interruptingClipInfo","out":true,"pt":$n[5].IList$1(UnityEngine.AnimatorClipInfo),"ps":7},{"n":"shallInterpolateWeightTo1","out":true,"pt":$n[0].Boolean,"ps":8}],"sn":"GetAnimatorClipInfos","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[5].IList$1(UnityEngine.AnimatorClipInfo),$n[5].IList$1(UnityEngine.AnimatorClipInfo),$n[5].IList$1(UnityEngine.AnimatorClipInfo),$n[0].Boolean]},{"a":1,"n":"GetAnimatorStateInfos","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0},{"n":"isInterruptionActive","out":true,"pt":$n[0].Boolean,"ps":1},{"n":"stateInfo","out":true,"pt":$n[1].AnimatorStateInfo,"ps":2},{"n":"nextStateInfo","out":true,"pt":$n[1].AnimatorStateInfo,"ps":3},{"n":"interruptingStateInfo","out":true,"pt":$n[1].AnimatorStateInfo,"ps":4},{"n":"interruptingClipTimeAddition","out":true,"pt":$n[0].Single,"ps":5}],"sn":"GetAnimatorStateInfos","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean,$n[1].AnimatorStateInfo,$n[1].AnimatorStateInfo,$n[1].AnimatorStateInfo,$n[0].Single]},{"a":1,"n":"GetMixMode","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0},{"n":"layerBlendMode","pt":$n[9].MixBlend,"ps":1}],"sn":"GetMixMode","rt":$n[12].SkeletonMecanim.MecanimTranslator.MixMode,"p":[$n[0].Int32,$n[9].MixBlend],"box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}},{"a":1,"n":"GetStateUpdatesFromAnimator","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0}],"sn":"GetStateUpdatesFromAnimator","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"InitClipInfosForLayers","t":8,"sn":"InitClipInfosForLayers","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"animator","pt":$n[1].Animator,"ps":0},{"n":"skeletonDataAsset","pt":$n[12].SkeletonDataAsset,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[1].Animator,$n[12].SkeletonDataAsset]},{"a":1,"n":"OnClipAppliedCallback","t":8,"pi":[{"n":"clip","pt":$n[9].Animation,"ps":0},{"n":"stateInfo","pt":$n[1].AnimatorStateInfo,"ps":1},{"n":"layerIndex","pt":$n[0].Int32,"ps":2},{"n":"time","pt":$n[0].Single,"ps":3},{"n":"isLooping","pt":$n[0].Boolean,"ps":4},{"n":"weight","pt":$n[0].Single,"ps":5}],"sn":"OnClipAppliedCallback","rt":$n[0].Void,"p":[$n[9].Animation,$n[1].AnimatorStateInfo,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"Animator","t":16,"rt":$n[1].Animator,"g":{"a":2,"n":"get_Animator","t":8,"rt":$n[1].Animator,"fg":"Animator"},"fn":"Animator"},{"a":2,"n":"MecanimLayerCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_MecanimLayerCount","t":8,"rt":$n[0].Int32,"fg":"MecanimLayerCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MecanimLayerCount"},{"a":2,"n":"MecanimLayerNames","t":16,"rt":$n[0].Array.type(System.String),"g":{"a":2,"n":"get_MecanimLayerNames","t":8,"rt":$n[0].Array.type(System.String),"fg":"MecanimLayerNames"},"fn":"MecanimLayerNames"},{"a":1,"n":"WeightEpsilon","is":true,"t":4,"rt":$n[0].Single,"sn":"WeightEpsilon","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"animationTable","t":4,"rt":$n[5].Dictionary$2(System.Int32,Spine.Animation),"sn":"animationTable","ro":true},{"a":1,"n":"animator","t":4,"rt":$n[1].Animator,"sn":"animator"},{"a":2,"n":"autoReset","t":4,"rt":$n[0].Boolean,"sn":"autoReset","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"clipNameHashCodeTable","t":4,"rt":$n[5].Dictionary$2(UnityEngine.AnimationClip,System.Int32),"sn":"clipNameHashCodeTable","ro":true},{"a":2,"n":"layerBlendModes","t":4,"rt":System.Array.type(Spine.MixBlend),"sn":"layerBlendModes"},{"a":3,"n":"layerClipInfos","t":4,"rt":System.Array.type(Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos),"sn":"layerClipInfos"},{"a":2,"n":"layerMixModes","t":4,"rt":System.Array.type(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode),"sn":"layerMixModes"},{"a":1,"n":"previousAnimations","t":4,"rt":$n[5].List$1(Spine.Animation),"sn":"previousAnimations","ro":true},{"a":2,"n":"useCustomMixMode","t":4,"rt":$n[0].Boolean,"sn":"useCustomMixMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"OnClipApplied","t":2,"ad":{"a":2,"n":"add_OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnClipApplied","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnClipApplied","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_OnClipApplied","t":2,"ad":{"a":3,"n":"add__OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_OnClipApplied","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_OnClipApplied","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode", function () { return {"td":$n[12].SkeletonMecanim.MecanimTranslator,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AlwaysMix","is":true,"t":4,"rt":$n[12].SkeletonMecanim.MecanimTranslator.MixMode,"sn":"AlwaysMix","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}},{"a":2,"n":"Hard","is":true,"t":4,"rt":$n[12].SkeletonMecanim.MecanimTranslator.MixMode,"sn":"Hard","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}},{"a":2,"n":"MixNext","is":true,"t":4,"rt":$n[12].SkeletonMecanim.MecanimTranslator.MixMode,"sn":"MixNext","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos", function () { return {"td":$n[12].SkeletonMecanim.MecanimTranslator,"att":1048580,"a":3,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"clipInfoCount","t":4,"rt":$n[0].Int32,"sn":"clipInfoCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"clipInfos","t":4,"rt":$n[5].List$1(UnityEngine.AnimatorClipInfo),"sn":"clipInfos","ro":true},{"a":2,"n":"interruptingClipInfoCount","t":4,"rt":$n[0].Int32,"sn":"interruptingClipInfoCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"interruptingClipInfos","t":4,"rt":$n[5].List$1(UnityEngine.AnimatorClipInfo),"sn":"interruptingClipInfos","ro":true},{"a":2,"n":"interruptingClipTimeAddition","t":4,"rt":$n[0].Single,"sn":"interruptingClipTimeAddition","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"interruptingStateInfo","t":4,"rt":$n[1].AnimatorStateInfo,"sn":"interruptingStateInfo"},{"a":2,"n":"isInterruptionActive","t":4,"rt":$n[0].Boolean,"sn":"isInterruptionActive","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"isLastFrameOfInterruption","t":4,"rt":$n[0].Boolean,"sn":"isLastFrameOfInterruption","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"nextClipInfoCount","t":4,"rt":$n[0].Int32,"sn":"nextClipInfoCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"nextClipInfos","t":4,"rt":$n[5].List$1(UnityEngine.AnimatorClipInfo),"sn":"nextClipInfos","ro":true},{"a":2,"n":"nextStateInfo","t":4,"rt":$n[1].AnimatorStateInfo,"sn":"nextStateInfo"},{"a":2,"n":"stateInfo","t":4,"rt":$n[1].AnimatorStateInfo,"sn":"stateInfo"}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer", function () { return {"td":$n[12].SkeletonMecanim.MecanimTranslator,"att":1048579,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"x","pt":$n[1].AnimationClip,"ps":0},{"n":"y","pt":$n[1].AnimationClip,"ps":1}],"sn":"equals2","rt":$n[0].Boolean,"p":[$n[1].AnimationClip,$n[1].AnimationClip],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GetHashCode","t":8,"pi":[{"n":"o","pt":$n[1].AnimationClip,"ps":0}],"sn":"getHashCode2","rt":$n[0].Int32,"p":[$n[1].AnimationClip],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"Instance","is":true,"t":4,"rt":$n[5].IEqualityComparer$1(UnityEngine.AnimationClip),"sn":"Instance","ro":true}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer", function () { return {"td":$n[12].SkeletonMecanim.MecanimTranslator,"att":1048579,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"x","pt":$n[0].Int32,"ps":0},{"n":"y","pt":$n[0].Int32,"ps":1}],"sn":"equals2","rt":$n[0].Boolean,"p":[$n[0].Int32,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GetHashCode","t":8,"pi":[{"n":"o","pt":$n[0].Int32,"ps":0}],"sn":"getHashCode2","rt":$n[0].Int32,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"Instance","is":true,"t":4,"rt":$n[5].IEqualityComparer$1(System.Int32),"sn":"Instance","ro":true}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer end.*/

    /*Spine.Unity.SkeletonRenderer start.*/
    $m("Spine.Unity.SkeletonRenderer", function () { return {"nested":[$n[12].SkeletonRenderer.SpriteMaskInteractionMaterials,Function,Function],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.$ctor1(UnityEngine.MeshFilter, UnityEngine.MeshRenderer),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRenderer-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddSpineComponent","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[1].GameObject,"ps":0},{"n":"skeletonDataAsset","pt":$n[12].SkeletonDataAsset,"ps":1},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"tpc":1,"tprm":["T"],"sn":"AddSpineComponent","rt":System.Object,"p":[$n[1].GameObject,$n[12].SkeletonDataAsset,$n[0].Boolean]},{"a":1,"n":"AssignSpriteMaskMaterials","t":8,"sn":"AssignSpriteMaskMaterials","rt":$n[0].Void},{"v":true,"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"v":true,"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"a":2,"n":"EnsureMeshGeneratorCapacity","t":8,"pi":[{"n":"minimumVertexCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureMeshGeneratorCapacity","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"FindAndApplySeparatorSlots","t":8,"pi":[{"n":"slotNamePredicate","pt":Function,"ps":0},{"n":"clearExistingSeparators","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"updateStringArray","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"FindAndApplySeparatorSlots","rt":$n[0].Void,"p":[Function,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"FindAndApplySeparatorSlots","t":8,"pi":[{"n":"startsWith","pt":$n[0].String,"ps":0},{"n":"clearExistingSeparators","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"updateStringArray","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"FindAndApplySeparatorSlots$1","rt":$n[0].Void,"p":[$n[0].String,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"InitSpriteMaskMaterialsForMaskType","t":8,"pi":[{"n":"maskFunction","pt":$n[14].CompareFunction,"ps":0},{"n":"materialsToFill","ref":true,"pt":System.Array.type(UnityEngine.Material),"ps":1}],"sn":"InitSpriteMaskMaterialsForMaskType","rt":$n[0].Boolean,"p":[$n[14].CompareFunction,System.Array.type(UnityEngine.Material)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"InitSpriteMaskMaterialsInsideMask","t":8,"sn":"InitSpriteMaskMaterialsInsideMask","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"InitSpriteMaskMaterialsOutsideMask","t":8,"sn":"InitSpriteMaskMaterialsOutsideMask","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"v":true,"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean,$n[0].Boolean]},{"v":true,"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":2,"n":"NewSpineGameObject","is":true,"t":8,"pi":[{"n":"skeletonDataAsset","pt":$n[12].SkeletonDataAsset,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"tpc":1,"tprm":["T"],"sn":"NewSpineGameObject","rt":System.Object,"p":[$n[12].SkeletonDataAsset,$n[0].Boolean]},{"a":2,"n":"OnBecameInvisible","t":8,"sn":"OnBecameInvisible","rt":$n[0].Void},{"a":2,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[0].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"ReapplySeparatorSlotNames","t":8,"sn":"ReapplySeparatorSlotNames","rt":$n[0].Void},{"a":1,"n":"SetMaterialSettingsToFixDrawOrder","t":8,"sn":"SetMaterialSettingsToFixDrawOrder","rt":$n[0].Void},{"a":2,"n":"SetMeshSettings","t":8,"pi":[{"n":"settings","pt":$n[12].MeshGenerator.Settings,"ps":0}],"sn":"SetMeshSettings","rt":$n[0].Void,"p":[$n[12].MeshGenerator.Settings]},{"a":2,"n":"CustomMaterialOverride","t":16,"rt":$n[5].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"g":{"a":2,"n":"get_CustomMaterialOverride","t":8,"rt":$n[5].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"fg":"CustomMaterialOverride"},"fn":"CustomMaterialOverride"},{"a":2,"n":"CustomSlotMaterials","t":16,"rt":$n[5].Dictionary$2(Spine.Slot,UnityEngine.Material),"g":{"a":2,"n":"get_CustomSlotMaterials","t":8,"rt":$n[5].Dictionary$2(Spine.Slot,UnityEngine.Material),"fg":"CustomSlotMaterials"},"fn":"CustomSlotMaterials"},{"a":2,"n":"Skeleton","t":16,"rt":$n[9].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[9].Skeleton,"fg":"Skeleton"},"fn":"Skeleton"},{"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[12].SkeletonDataAsset,"g":{"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[12].SkeletonDataAsset,"fg":"SkeletonDataAsset"},"fn":"SkeletonDataAsset"},{"a":2,"n":"UpdateMode","t":16,"rt":$n[12].UpdateMode,"g":{"a":2,"n":"get_UpdateMode","t":8,"rt":$n[12].UpdateMode,"fg":"UpdateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},"s":{"a":2,"n":"set_UpdateMode","t":8,"p":[$n[12].UpdateMode],"rt":$n[0].Void,"fs":"UpdateMode"},"fn":"UpdateMode"},{"a":2,"n":"STENCIL_COMP_MASKINTERACTION_NONE","is":true,"t":4,"rt":$n[14].CompareFunction,"sn":"STENCIL_COMP_MASKINTERACTION_NONE","box":function ($v) { return Bridge.box($v, UnityEngine.Rendering.CompareFunction, System.Enum.toStringFn(UnityEngine.Rendering.CompareFunction));}},{"a":2,"n":"STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE","is":true,"t":4,"rt":$n[14].CompareFunction,"sn":"STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE","box":function ($v) { return Bridge.box($v, UnityEngine.Rendering.CompareFunction, System.Enum.toStringFn(UnityEngine.Rendering.CompareFunction));}},{"a":2,"n":"STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE","is":true,"t":4,"rt":$n[14].CompareFunction,"sn":"STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE","box":function ($v) { return Bridge.box($v, UnityEngine.Rendering.CompareFunction, System.Enum.toStringFn(UnityEngine.Rendering.CompareFunction));}},{"a":2,"n":"STENCIL_COMP_PARAM_ID","is":true,"t":4,"rt":$n[0].Int32,"sn":"STENCIL_COMP_PARAM_ID","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"SUBMESH_DUMMY_PARAM_ID","is":true,"t":4,"rt":$n[0].Int32,"sn":"SUBMESH_DUMMY_PARAM_ID","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("calculateNormals")],"a":2,"n":"addNormals","t":4,"rt":$n[0].Boolean,"sn":"addNormals","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"calculateTangents","t":4,"rt":$n[0].Boolean,"sn":"calculateTangents","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"clearStateOnDisable","t":4,"rt":$n[0].Boolean,"sn":"clearStateOnDisable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"currentInstructions","t":4,"rt":$n[12].SkeletonRendererInstruction,"sn":"currentInstructions","ro":true},{"a":1,"n":"customMaterialOverride","t":4,"rt":$n[5].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"sn":"customMaterialOverride","ro":true},{"a":1,"n":"customSlotMaterials","t":4,"rt":$n[5].Dictionary$2(Spine.Slot,UnityEngine.Material),"sn":"customSlotMaterials","ro":true},{"a":2,"n":"disableRenderingOnOverride","t":4,"rt":$n[0].Boolean,"sn":"disableRenderingOnOverride","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"fixDrawOrder","t":4,"rt":$n[0].Boolean,"sn":"fixDrawOrder","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"immutableTriangles","t":4,"rt":$n[0].Boolean,"sn":"immutableTriangles","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipX","t":4,"rt":$n[0].Boolean,"sn":"initialFlipX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipY","t":4,"rt":$n[0].Boolean,"sn":"initialFlipY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSkin("", "", true, false, true)],"a":2,"n":"initialSkinName","t":4,"rt":$n[0].String,"sn":"initialSkinName"},{"a":2,"n":"maskInteraction","t":4,"rt":$n[1].SpriteMaskInteraction,"sn":"maskInteraction","box":function ($v) { return Bridge.box($v, UnityEngine.SpriteMaskInteraction, System.Enum.toStringFn(UnityEngine.SpriteMaskInteraction));}},{"a":2,"n":"maskMaterials","t":4,"rt":$n[12].SkeletonRenderer.SpriteMaskInteractionMaterials,"sn":"maskMaterials"},{"a":1,"n":"meshFilter","t":4,"rt":$n[1].MeshFilter,"sn":"meshFilter"},{"a":1,"n":"meshGenerator","t":4,"rt":$n[12].MeshGenerator,"sn":"meshGenerator","ro":true},{"a":1,"n":"meshRenderer","t":4,"rt":$n[1].MeshRenderer,"sn":"meshRenderer"},{"a":2,"n":"pmaVertexColors","t":4,"rt":$n[0].Boolean,"sn":"pmaVertexColors","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"rendererBuffers","t":4,"rt":$n[12].MeshRendererBuffers,"sn":"rendererBuffers","ro":true},{"a":1,"n":"reusedPropertyBlock","t":4,"rt":$n[1].MaterialPropertyBlock,"sn":"reusedPropertyBlock"},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("submeshSeparators"),new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineSlot("", "", false, true, false)],"a":3,"n":"separatorSlotNames","t":4,"rt":$n[0].Array.type(System.String),"sn":"separatorSlotNames"},{"a":2,"n":"separatorSlots","t":4,"rt":$n[5].List$1(Spine.Slot),"sn":"separatorSlots","ro":true},{"a":2,"n":"singleSubmesh","t":4,"rt":$n[0].Boolean,"sn":"singleSubmesh","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"skeleton","t":4,"rt":$n[9].Skeleton,"sn":"skeleton"},{"a":2,"n":"skeletonDataAsset","t":4,"rt":$n[12].SkeletonDataAsset,"sn":"skeletonDataAsset"},{"a":2,"n":"tintBlack","t":4,"rt":$n[0].Boolean,"sn":"tintBlack","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"updateMode","t":4,"rt":$n[12].UpdateMode,"sn":"updateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"updateWhenInvisible","t":4,"rt":$n[12].UpdateMode,"sn":"updateWhenInvisible","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"useClipping","t":4,"rt":$n[0].Boolean,"sn":"useClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.RangeAttribute(-0.1, 0.0)],"a":2,"n":"zSpacing","t":4,"rt":$n[0].Single,"sn":"zSpacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GenerateMeshOverride","t":2,"ad":{"a":2,"n":"add_GenerateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addGenerateMeshOverride","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_GenerateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeGenerateMeshOverride","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnPostProcessVertices","t":2,"ad":{"a":2,"n":"add_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnPostProcessVertices","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnPostProcessVertices","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnRebuild","t":2,"ad":{"a":2,"n":"add_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnRebuild","rt":$n[0].Void,"p":[Function]}},{"a":1,"n":"generateMeshOverride","t":2,"ad":{"a":1,"n":"add_generateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addgenerateMeshOverride","rt":$n[0].Void,"p":[Function]},"r":{"a":1,"n":"remove_generateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removegenerateMeshOverride","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonRenderer end.*/

    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials start.*/
    $m("Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials", function () { return {"td":$n[12].SkeletonRenderer,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AnyMaterialCreated","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_AnyMaterialCreated","t":8,"rt":$n[0].Boolean,"fg":"AnyMaterialCreated","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"AnyMaterialCreated"},{"a":2,"n":"materialsInsideMask","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materialsInsideMask"},{"a":2,"n":"materialsMaskDisabled","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materialsMaskDisabled"},{"a":2,"n":"materialsOutsideMask","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materialsOutsideMask"}]}; }, $n);
    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials start.*/
    $m("Spine.Unity.SkeletonGraphicCustomMaterials", function () { return {"nested":[$n[12].SkeletonGraphicCustomMaterials.AtlasMaterialOverride,$n[12].SkeletonGraphicCustomMaterials.AtlasTextureOverride],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonGraphicCustomMaterials")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"RemoveCustomMaterialOverrides","t":8,"sn":"RemoveCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"RemoveCustomTextureOverrides","t":8,"sn":"RemoveCustomTextureOverrides","rt":$n[0].Void},{"a":1,"n":"SetCustomMaterialOverrides","t":8,"sn":"SetCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"SetCustomTextureOverrides","t":8,"sn":"SetCustomTextureOverrides","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customMaterialOverrides","t":4,"rt":$n[5].List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride),"sn":"customMaterialOverrides"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customTextureOverrides","t":4,"rt":$n[5].List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride),"sn":"customTextureOverrides"},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[12].SkeletonGraphic,"sn":"skeletonGraphic"}]}; }, $n);
    /*Spine.Unity.SkeletonGraphicCustomMaterials end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride start.*/
    $m("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride", function () { return {"td":$n[12].SkeletonGraphicCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[12].SkeletonGraphicCustomMaterials.AtlasMaterialOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[12].SkeletonGraphicCustomMaterials.AtlasMaterialOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"originalTexture","t":4,"rt":$n[1].Texture,"sn":"originalTexture"},{"a":2,"n":"overrideEnabled","t":4,"rt":$n[0].Boolean,"sn":"overrideEnabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"replacementMaterial","t":4,"rt":$n[1].Material,"sn":"replacementMaterial"}]}; }, $n);
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride start.*/
    $m("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride", function () { return {"td":$n[12].SkeletonGraphicCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[12].SkeletonGraphicCustomMaterials.AtlasTextureOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[12].SkeletonGraphicCustomMaterials.AtlasTextureOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"originalTexture","t":4,"rt":$n[1].Texture,"sn":"originalTexture"},{"a":2,"n":"overrideEnabled","t":4,"rt":$n[0].Boolean,"sn":"overrideEnabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"replacementTexture","t":4,"rt":$n[1].Texture,"sn":"replacementTexture"}]}; }, $n);
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials start.*/
    $m("Spine.Unity.SkeletonRendererCustomMaterials", function () { return {"nested":[$n[12].SkeletonRendererCustomMaterials.SlotMaterialOverride,$n[12].SkeletonRendererCustomMaterials.AtlasMaterialOverride],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRendererCustomMaterials")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"RemoveCustomMaterialOverrides","t":8,"sn":"RemoveCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"RemoveCustomSlotMaterials","t":8,"sn":"RemoveCustomSlotMaterials","rt":$n[0].Void},{"a":1,"n":"SetCustomMaterialOverrides","t":8,"sn":"SetCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"SetCustomSlotMaterials","t":8,"sn":"SetCustomSlotMaterials","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customMaterialOverrides","t":4,"rt":$n[5].List$1(Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride),"sn":"customMaterialOverrides"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customSlotMaterials","t":4,"rt":$n[5].List$1(Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride),"sn":"customSlotMaterials"},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[12].SkeletonRenderer,"sn":"skeletonRenderer"}]}; }, $n);
    /*Spine.Unity.SkeletonRendererCustomMaterials end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride start.*/
    $m("Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride", function () { return {"td":$n[12].SkeletonRendererCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[12].SkeletonRendererCustomMaterials.SlotMaterialOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[12].SkeletonRendererCustomMaterials.SlotMaterialOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"material","t":4,"rt":$n[1].Material,"sn":"material"},{"a":2,"n":"overrideDisabled","t":4,"rt":$n[0].Boolean,"sn":"overrideDisabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSlot("", "", false, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"}]}; }, $n);
    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride start.*/
    $m("Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride", function () { return {"td":$n[12].SkeletonRendererCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[12].SkeletonRendererCustomMaterials.AtlasMaterialOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[12].SkeletonRendererCustomMaterials.AtlasMaterialOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"originalMaterial","t":4,"rt":$n[1].Material,"sn":"originalMaterial"},{"a":2,"n":"overrideDisabled","t":4,"rt":$n[0].Boolean,"sn":"overrideDisabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"replacementMaterial","t":4,"rt":$n[1].Material,"sn":"replacementMaterial"}]}; }, $n);
    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonPartsRenderer start.*/
    $m("Spine.Unity.SkeletonPartsRenderer", function () { return {"nested":[Function],"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.$ctor1(UnityEngine.MeshRenderer, UnityEngine.MeshFilter),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRenderSeparator")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ClearMesh","t":8,"sn":"ClearMesh","rt":$n[0].Void},{"a":1,"n":"LazyIntialize","t":8,"sn":"LazyIntialize","rt":$n[0].Void},{"a":2,"n":"NewPartsRendererGameObject","is":true,"t":8,"pi":[{"n":"parent","pt":$n[1].Transform,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"sortingOrder","dv":0,"o":true,"pt":$n[0].Int32,"ps":2}],"sn":"NewPartsRendererGameObject","rt":$n[12].SkeletonPartsRenderer,"p":[$n[1].Transform,$n[0].String,$n[0].Int32]},{"a":2,"n":"RenderParts","t":8,"pi":[{"n":"instructions","pt":$n[9].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0},{"n":"startSubmesh","pt":$n[0].Int32,"ps":1},{"n":"endSubmesh","pt":$n[0].Int32,"ps":2}],"sn":"RenderParts","rt":$n[0].Void,"p":[$n[9].ExposedList$1(Spine.Unity.SubmeshInstruction),$n[0].Int32,$n[0].Int32]},{"a":2,"n":"SetPropertyBlock","t":8,"pi":[{"n":"block","pt":$n[1].MaterialPropertyBlock,"ps":0}],"sn":"SetPropertyBlock","rt":$n[0].Void,"p":[$n[1].MaterialPropertyBlock]},{"a":2,"n":"MeshFilter","t":16,"rt":$n[1].MeshFilter,"g":{"a":2,"n":"get_MeshFilter","t":8,"rt":$n[1].MeshFilter,"fg":"MeshFilter"},"fn":"MeshFilter"},{"a":2,"n":"MeshGenerator","t":16,"rt":$n[12].MeshGenerator,"g":{"a":2,"n":"get_MeshGenerator","t":8,"rt":$n[12].MeshGenerator,"fg":"MeshGenerator"},"fn":"MeshGenerator"},{"a":2,"n":"MeshRenderer","t":16,"rt":$n[1].MeshRenderer,"g":{"a":2,"n":"get_MeshRenderer","t":8,"rt":$n[1].MeshRenderer,"fg":"MeshRenderer"},"fn":"MeshRenderer"},{"a":1,"n":"buffers","t":4,"rt":$n[12].MeshRendererBuffers,"sn":"buffers"},{"a":1,"n":"currentInstructions","t":4,"rt":$n[12].SkeletonRendererInstruction,"sn":"currentInstructions"},{"a":1,"n":"meshFilter","t":4,"rt":$n[1].MeshFilter,"sn":"meshFilter"},{"a":1,"n":"meshGenerator","t":4,"rt":$n[12].MeshGenerator,"sn":"meshGenerator"},{"a":1,"n":"meshRenderer","t":4,"rt":$n[1].MeshRenderer,"sn":"meshRenderer"},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonPartsRenderer end.*/

    /*Spine.Unity.SkeletonRenderSeparator start.*/
    $m("Spine.Unity.SkeletonRenderSeparator", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRenderSeparator")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddPartsRenderer","t":8,"pi":[{"n":"sortingOrderIncrement","dv":5,"o":true,"pt":$n[0].Int32,"ps":0},{"n":"name","dv":null,"o":true,"pt":$n[0].String,"ps":1}],"sn":"AddPartsRenderer","rt":$n[12].SkeletonPartsRenderer,"p":[$n[0].Int32,$n[0].String]},{"a":2,"n":"AddToSkeletonRenderer","is":true,"t":8,"pi":[{"n":"skeletonRenderer","pt":$n[12].SkeletonRenderer,"ps":0},{"n":"sortingLayerID","dv":0,"o":true,"pt":$n[0].Int32,"ps":1},{"n":"extraPartsRenderers","dv":0,"o":true,"pt":$n[0].Int32,"ps":2},{"n":"sortingOrderIncrement","dv":5,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"baseSortingOrder","dv":0,"o":true,"pt":$n[0].Int32,"ps":4},{"n":"addMinimumPartsRenderers","dv":true,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"AddToSkeletonRenderer","rt":$n[12].SkeletonRenderSeparator,"p":[$n[12].SkeletonRenderer,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[0].Boolean]},{"a":1,"n":"HandleRender","t":8,"pi":[{"n":"instruction","pt":$n[12].SkeletonRendererInstruction,"ps":0}],"sn":"HandleRender","rt":$n[0].Void,"p":[$n[12].SkeletonRendererInstruction]},{"a":2,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[12].SkeletonRenderer,"g":{"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[12].SkeletonRenderer,"fg":"SkeletonRenderer"},"s":{"a":2,"n":"set_SkeletonRenderer","t":8,"p":[$n[12].SkeletonRenderer],"rt":$n[0].Void,"fs":"SkeletonRenderer"},"fn":"SkeletonRenderer"},{"a":2,"n":"DefaultSortingOrderIncrement","is":true,"t":4,"rt":$n[0].Int32,"sn":"DefaultSortingOrderIncrement","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"copiedBlock","t":4,"rt":$n[1].MaterialPropertyBlock,"sn":"copiedBlock"},{"at":[new UnityEngine.TooltipAttribute("Copies MeshRenderer flags into each parts renderer")],"a":2,"n":"copyMeshRendererFlags","t":4,"rt":$n[0].Boolean,"sn":"copyMeshRendererFlags","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"copyPropertyBlock","t":4,"rt":$n[0].Boolean,"sn":"copyPropertyBlock","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"mainMeshRenderer","t":4,"rt":$n[1].MeshRenderer,"sn":"mainMeshRenderer"},{"a":2,"n":"partsRenderers","t":4,"rt":$n[5].List$1(Spine.Unity.SkeletonPartsRenderer),"sn":"partsRenderers"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"skeletonRenderer","t":4,"rt":$n[12].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonRenderSeparator end.*/

    /*Spine.Unity.ActivateBasedOnFlipDirection start.*/
    $m("Spine.Unity.ActivateBasedOnFlipDirection", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"CompensateMovementAfterFlipX","t":8,"pi":[{"n":"toActivate","pt":$n[1].Transform,"ps":0},{"n":"toDeactivate","pt":$n[1].Transform,"ps":1}],"sn":"CompensateMovementAfterFlipX","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"HandleFlip","t":8,"pi":[{"n":"isFlippedX","pt":$n[0].Boolean,"ps":0}],"sn":"HandleFlip","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"ResetJointPositions","t":8,"pi":[{"n":"joints","pt":System.Array.type(UnityEngine.HingeJoint2D),"ps":0}],"sn":"ResetJointPositions","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.HingeJoint2D)]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"activeOnFlippedX","t":4,"rt":$n[1].GameObject,"sn":"activeOnFlippedX"},{"a":2,"n":"activeOnNormalX","t":4,"rt":$n[1].GameObject,"sn":"activeOnNormalX"},{"a":1,"n":"jointsFlippedX","t":4,"rt":System.Array.type(UnityEngine.HingeJoint2D),"sn":"jointsFlippedX"},{"a":1,"n":"jointsNormalX","t":4,"rt":System.Array.type(UnityEngine.HingeJoint2D),"sn":"jointsNormalX"},{"a":1,"n":"skeletonComponent","t":4,"rt":$n[12].ISkeletonComponent,"sn":"skeletonComponent"},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[12].SkeletonGraphic,"sn":"skeletonGraphic"},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[12].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"wasFlippedXBefore","t":4,"rt":$n[0].Boolean,"sn":"wasFlippedXBefore","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.ActivateBasedOnFlipDirection end.*/

    /*Spine.Unity.FollowLocationRigidbody start.*/
    $m("Spine.Unity.FollowLocationRigidbody", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.Rigidbody)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"ownRigidbody","t":4,"rt":$n[1].Rigidbody,"sn":"ownRigidbody"},{"a":2,"n":"reference","t":4,"rt":$n[1].Transform,"sn":"reference"}]}; }, $n);
    /*Spine.Unity.FollowLocationRigidbody end.*/

    /*Spine.Unity.FollowLocationRigidbody2D start.*/
    $m("Spine.Unity.FollowLocationRigidbody2D", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.Rigidbody2D)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":2,"n":"followFlippedX","t":4,"rt":$n[0].Boolean,"sn":"followFlippedX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ownRigidbody","t":4,"rt":$n[1].Rigidbody2D,"sn":"ownRigidbody"},{"a":2,"n":"reference","t":4,"rt":$n[1].Transform,"sn":"reference"}]}; }, $n);
    /*Spine.Unity.FollowLocationRigidbody2D end.*/

    /*Spine.Unity.FollowSkeletonUtilityRootRotation start.*/
    $m("Spine.Unity.FollowSkeletonUtilityRootRotation", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"CompensatePositionToXRotation","t":8,"sn":"CompensatePositionToXRotation","rt":$n[0].Void},{"a":1,"n":"CompensatePositionToYRotation","t":8,"sn":"CompensatePositionToYRotation","rt":$n[0].Void},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"FLIP_ANGLE_THRESHOLD","is":true,"t":4,"rt":$n[0].Single,"sn":"FLIP_ANGLE_THRESHOLD","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"prevLocalEulerAngles","t":4,"rt":$n[1].Vector3,"sn":"prevLocalEulerAngles"},{"a":2,"n":"reference","t":4,"rt":$n[1].Transform,"sn":"reference"}]}; }, $n);
    /*Spine.Unity.FollowSkeletonUtilityRootRotation end.*/

    /*Spine.Unity.SkeletonUtility start.*/
    $m("Spine.Unity.SkeletonUtility", function () { return {"nested":[Function],"att":1048833,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(Spine.Unity.ISkeletonAnimation),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonUtility")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddBoneRigidbody2D","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[1].GameObject,"ps":0},{"n":"isKinematic","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"gravityScale","dv":0.0,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"AddBoneRigidbody2D","rt":$n[1].Rigidbody2D,"p":[$n[1].GameObject,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"AddBoundingBoxAsComponent","is":true,"t":8,"pi":[{"n":"box","pt":$n[9].BoundingBoxAttachment,"ps":0},{"n":"slot","pt":$n[9].Slot,"ps":1},{"n":"gameObject","pt":$n[1].GameObject,"ps":2},{"n":"isTrigger","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"AddBoundingBoxAsComponent","rt":$n[1].PolygonCollider2D,"p":[$n[9].BoundingBoxAttachment,$n[9].Slot,$n[1].GameObject,$n[0].Boolean]},{"a":2,"n":"AddBoundingBoxGameObject","is":true,"t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"box","pt":$n[9].BoundingBoxAttachment,"ps":1},{"n":"slot","pt":$n[9].Slot,"ps":2},{"n":"parent","pt":$n[1].Transform,"ps":3},{"n":"isTrigger","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"AddBoundingBoxGameObject$1","rt":$n[1].PolygonCollider2D,"p":[$n[0].String,$n[9].BoundingBoxAttachment,$n[9].Slot,$n[1].Transform,$n[0].Boolean]},{"a":2,"n":"AddBoundingBoxGameObject","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0},{"n":"skinName","pt":$n[0].String,"ps":1},{"n":"slotName","pt":$n[0].String,"ps":2},{"n":"attachmentName","pt":$n[0].String,"ps":3},{"n":"parent","pt":$n[1].Transform,"ps":4},{"n":"isTrigger","dv":true,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"AddBoundingBoxGameObject","rt":$n[1].PolygonCollider2D,"p":[$n[9].Skeleton,$n[0].String,$n[0].String,$n[0].String,$n[1].Transform,$n[0].Boolean]},{"a":2,"n":"CollectBones","t":8,"sn":"CollectBones","rt":$n[0].Void},{"a":2,"n":"GetBoneRoot","t":8,"sn":"GetBoneRoot","rt":$n[1].Transform},{"a":2,"n":"GetBoundingBoxBounds","is":true,"t":8,"pi":[{"n":"boundingBox","pt":$n[9].BoundingBoxAttachment,"ps":0},{"n":"depth","dv":0.0,"o":true,"pt":$n[0].Single,"ps":1}],"sn":"GetBoundingBoxBounds","rt":$n[1].Bounds,"p":[$n[9].BoundingBoxAttachment,$n[0].Single]},{"a":1,"n":"HandleRendererReset","t":8,"pi":[{"n":"g","pt":$n[12].SkeletonGraphic,"ps":0}],"sn":"HandleRendererReset","rt":$n[0].Void,"p":[$n[12].SkeletonGraphic]},{"a":1,"n":"HandleRendererReset","t":8,"pi":[{"n":"r","pt":$n[12].SkeletonRenderer,"ps":0}],"sn":"HandleRendererReset$1","rt":$n[0].Void,"p":[$n[12].SkeletonRenderer]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"RegisterBone","t":8,"pi":[{"n":"bone","pt":$n[12].SkeletonUtilityBone,"ps":0}],"sn":"RegisterBone","rt":$n[0].Void,"p":[$n[12].SkeletonUtilityBone]},{"a":2,"n":"RegisterConstraint","t":8,"pi":[{"n":"constraint","pt":$n[12].SkeletonUtilityConstraint,"ps":0}],"sn":"RegisterConstraint","rt":$n[0].Void,"p":[$n[12].SkeletonUtilityConstraint]},{"a":2,"n":"ResubscribeEvents","t":8,"sn":"ResubscribeEvents","rt":$n[0].Void},{"a":2,"n":"SetColliderPointsLocal","is":true,"t":8,"pi":[{"n":"collider","pt":$n[1].PolygonCollider2D,"ps":0},{"n":"slot","pt":$n[9].Slot,"ps":1},{"n":"box","pt":$n[9].BoundingBoxAttachment,"ps":2},{"n":"scale","dv":1.0,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"SetColliderPointsLocal","rt":$n[0].Void,"p":[$n[1].PolygonCollider2D,$n[9].Slot,$n[9].BoundingBoxAttachment,$n[0].Single]},{"a":2,"n":"SpawnBone","t":8,"pi":[{"n":"bone","pt":$n[9].Bone,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1},{"n":"mode","pt":$n[12].SkeletonUtilityBone.Mode,"ps":2},{"n":"pos","pt":$n[0].Boolean,"ps":3},{"n":"rot","pt":$n[0].Boolean,"ps":4},{"n":"sca","pt":$n[0].Boolean,"ps":5}],"sn":"SpawnBone","rt":$n[1].GameObject,"p":[$n[9].Bone,$n[1].Transform,$n[12].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"SpawnBoneRecursively","t":8,"pi":[{"n":"bone","pt":$n[9].Bone,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1},{"n":"mode","pt":$n[12].SkeletonUtilityBone.Mode,"ps":2},{"n":"pos","pt":$n[0].Boolean,"ps":3},{"n":"rot","pt":$n[0].Boolean,"ps":4},{"n":"sca","pt":$n[0].Boolean,"ps":5}],"sn":"SpawnBoneRecursively","rt":$n[1].GameObject,"p":[$n[9].Bone,$n[1].Transform,$n[12].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"SpawnHierarchy","t":8,"pi":[{"n":"mode","pt":$n[12].SkeletonUtilityBone.Mode,"ps":0},{"n":"pos","pt":$n[0].Boolean,"ps":1},{"n":"rot","pt":$n[0].Boolean,"ps":2},{"n":"sca","pt":$n[0].Boolean,"ps":3}],"sn":"SpawnHierarchy","rt":$n[1].GameObject,"p":[$n[12].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"SpawnRoot","t":8,"pi":[{"n":"mode","pt":$n[12].SkeletonUtilityBone.Mode,"ps":0},{"n":"pos","pt":$n[0].Boolean,"ps":1},{"n":"rot","pt":$n[0].Boolean,"ps":2},{"n":"sca","pt":$n[0].Boolean,"ps":3}],"sn":"SpawnRoot","rt":$n[1].GameObject,"p":[$n[12].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"UnregisterBone","t":8,"pi":[{"n":"bone","pt":$n[12].SkeletonUtilityBone,"ps":0}],"sn":"UnregisterBone","rt":$n[0].Void,"p":[$n[12].SkeletonUtilityBone]},{"a":2,"n":"UnregisterConstraint","t":8,"pi":[{"n":"constraint","pt":$n[12].SkeletonUtilityConstraint,"ps":0}],"sn":"UnregisterConstraint","rt":$n[0].Void,"p":[$n[12].SkeletonUtilityConstraint]},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"UpdateAllBones","t":8,"pi":[{"n":"phase","pt":$n[12].SkeletonUtilityBone.UpdatePhase,"ps":0}],"sn":"UpdateAllBones","rt":$n[0].Void,"p":[$n[12].SkeletonUtilityBone.UpdatePhase]},{"a":1,"n":"UpdateComplete","t":8,"pi":[{"n":"anim","pt":$n[12].ISkeletonAnimation,"ps":0}],"sn":"UpdateComplete","rt":$n[0].Void,"p":[$n[12].ISkeletonAnimation]},{"a":1,"n":"UpdateLocal","t":8,"pi":[{"n":"anim","pt":$n[12].ISkeletonAnimation,"ps":0}],"sn":"UpdateLocal","rt":$n[0].Void,"p":[$n[12].ISkeletonAnimation]},{"a":1,"n":"UpdateWorld","t":8,"pi":[{"n":"anim","pt":$n[12].ISkeletonAnimation,"ps":0}],"sn":"UpdateWorld","rt":$n[0].Void,"p":[$n[12].ISkeletonAnimation]},{"a":2,"n":"IsValid","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsValid","t":8,"rt":$n[0].Boolean,"fg":"IsValid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsValid"},{"a":2,"n":"PositionScale","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_PositionScale","t":8,"rt":$n[0].Single,"fg":"PositionScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"PositionScale"},{"a":2,"n":"Skeleton","t":16,"rt":$n[9].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[9].Skeleton,"fg":"Skeleton"},"fn":"Skeleton"},{"a":2,"n":"SkeletonComponent","t":16,"rt":$n[12].ISkeletonComponent,"g":{"a":2,"n":"get_SkeletonComponent","t":8,"rt":$n[12].ISkeletonComponent,"fg":"SkeletonComponent"},"fn":"SkeletonComponent"},{"a":2,"n":"boneComponents","t":4,"rt":$n[5].List$1(Spine.Unity.SkeletonUtilityBone),"sn":"boneComponents"},{"a":2,"n":"boneRoot","t":4,"rt":$n[1].Transform,"sn":"boneRoot"},{"a":1,"n":"canvas","t":4,"rt":$n[1].Canvas,"sn":"canvas"},{"a":2,"n":"constraintComponents","t":4,"rt":$n[5].List$1(Spine.Unity.SkeletonUtilityConstraint),"sn":"constraintComponents"},{"a":2,"n":"flipBy180DegreeRotation","t":4,"rt":$n[0].Boolean,"sn":"flipBy180DegreeRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"hasConstraints","t":4,"rt":$n[0].Boolean,"sn":"hasConstraints","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"hasOverrideBones","t":4,"rt":$n[0].Boolean,"sn":"hasOverrideBones","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"needToReprocessBones","t":4,"rt":$n[0].Boolean,"sn":"needToReprocessBones","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"positionScale","t":4,"rt":$n[0].Single,"sn":"positionScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"skeletonAnimation","t":4,"rt":$n[12].ISkeletonAnimation,"sn":"skeletonAnimation"},{"a":1,"n":"skeletonComponent","t":4,"rt":$n[12].ISkeletonComponent,"sn":"skeletonComponent"},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"skeletonGraphic","t":4,"rt":$n[12].SkeletonGraphic,"sn":"skeletonGraphic"},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"skeletonRenderer","t":4,"rt":$n[12].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":2,"n":"OnReset","t":2,"ad":{"a":2,"n":"add_OnReset","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnReset","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnReset","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnReset","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonUtility end.*/

    /*Spine.Unity.SkeletonUtilityBone start.*/
    $m("Spine.Unity.SkeletonUtilityBone", function () { return {"nested":[$n[12].SkeletonUtilityBone.Mode,$n[12].SkeletonUtilityBone.UpdatePhase],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/SkeletonUtilityBone"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonUtilityBone")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddBoundingBox","t":8,"pi":[{"n":"skinName","pt":$n[0].String,"ps":0},{"n":"slotName","pt":$n[0].String,"ps":1},{"n":"attachmentName","pt":$n[0].String,"ps":2}],"sn":"AddBoundingBox","rt":$n[0].Void,"p":[$n[0].String,$n[0].String,$n[0].String]},{"a":2,"n":"BoneTransformModeIncompatible","is":true,"t":8,"pi":[{"n":"bone","pt":$n[9].Bone,"ps":0}],"sn":"BoneTransformModeIncompatible","rt":$n[0].Boolean,"p":[$n[9].Bone],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"DoUpdate","t":8,"pi":[{"n":"phase","pt":$n[12].SkeletonUtilityBone.UpdatePhase,"ps":0}],"sn":"DoUpdate","rt":$n[0].Void,"p":[$n[12].SkeletonUtilityBone.UpdatePhase]},{"a":1,"n":"HandleOnReset","t":8,"sn":"HandleOnReset","rt":$n[0].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":2,"n":"IncompatibleTransformMode","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IncompatibleTransformMode","t":8,"rt":$n[0].Boolean,"fg":"IncompatibleTransformMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IncompatibleTransformMode"},{"a":2,"n":"bone","t":4,"rt":$n[9].Bone,"sn":"bone"},{"a":2,"n":"boneName","t":4,"rt":$n[0].String,"sn":"boneName"},{"a":1,"n":"cachedTransform","t":4,"rt":$n[1].Transform,"sn":"cachedTransform"},{"a":2,"n":"hierarchy","t":4,"rt":$n[12].SkeletonUtility,"sn":"hierarchy"},{"a":1,"n":"incompatibleTransformMode","t":4,"rt":$n[0].Boolean,"sn":"incompatibleTransformMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"mode","t":4,"rt":$n[12].SkeletonUtilityBone.Mode,"sn":"mode","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.Mode, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.Mode));}},{"at":[new UnityEngine.RangeAttribute(0.0, 1.0)],"a":2,"n":"overrideAlpha","t":4,"rt":$n[0].Single,"sn":"overrideAlpha","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"parentReference","t":4,"rt":$n[1].Transform,"sn":"parentReference"},{"a":2,"n":"position","t":4,"rt":$n[0].Boolean,"sn":"position","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"rotation","t":4,"rt":$n[0].Boolean,"sn":"rotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"scale","t":4,"rt":$n[0].Boolean,"sn":"scale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[1].Transform,"sn":"skeletonTransform"},{"a":2,"n":"transformLerpComplete","t":4,"rt":$n[0].Boolean,"sn":"transformLerpComplete","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"zPosition","t":4,"rt":$n[0].Boolean,"sn":"zPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityBone end.*/

    /*Spine.Unity.SkeletonUtilityBone+Mode start.*/
    $m("Spine.Unity.SkeletonUtilityBone.Mode", function () { return {"td":$n[12].SkeletonUtilityBone,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Follow","is":true,"t":4,"rt":$n[12].SkeletonUtilityBone.Mode,"sn":"Follow","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.Mode, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.Mode));}},{"a":2,"n":"Override","is":true,"t":4,"rt":$n[12].SkeletonUtilityBone.Mode,"sn":"Override","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.Mode, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.Mode));}}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityBone+Mode end.*/

    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase start.*/
    $m("Spine.Unity.SkeletonUtilityBone.UpdatePhase", function () { return {"td":$n[12].SkeletonUtilityBone,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Complete","is":true,"t":4,"rt":$n[12].SkeletonUtilityBone.UpdatePhase,"sn":"Complete","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.UpdatePhase, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.UpdatePhase));}},{"a":2,"n":"Local","is":true,"t":4,"rt":$n[12].SkeletonUtilityBone.UpdatePhase,"sn":"Local","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.UpdatePhase, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.UpdatePhase));}},{"a":2,"n":"World","is":true,"t":4,"rt":$n[12].SkeletonUtilityBone.UpdatePhase,"sn":"World","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.UpdatePhase, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.UpdatePhase));}}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase end.*/

    /*Spine.Unity.SkeletonUtilityConstraint start.*/
    $m("Spine.Unity.SkeletonUtilityConstraint", function () { return {"att":1048705,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(Spine.Unity.SkeletonUtilityBone),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonUtilityConstraint")],"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ab":true,"a":2,"n":"DoUpdate","t":8,"sn":"DoUpdate","rt":$n[0].Void},{"v":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"v":true,"a":3,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":3,"n":"bone","t":4,"rt":$n[12].SkeletonUtilityBone,"sn":"bone"},{"a":3,"n":"hierarchy","t":4,"rt":$n[12].SkeletonUtility,"sn":"hierarchy"}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityConstraint end.*/

    /*Spine.Unity.UpdateMode start.*/
    $m("Spine.Unity.UpdateMode", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"EverythingExceptMesh","is":true,"t":4,"rt":$n[12].UpdateMode,"sn":"EverythingExceptMesh","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"FullUpdate","is":true,"t":4,"rt":$n[12].UpdateMode,"sn":"FullUpdate","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"Nothing","is":true,"t":4,"rt":$n[12].UpdateMode,"sn":"Nothing","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"OnlyAnimationStatus","is":true,"t":4,"rt":$n[12].UpdateMode,"sn":"OnlyAnimationStatus","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"OnlyEventTimelines","is":true,"t":4,"rt":$n[12].UpdateMode,"sn":"OnlyEventTimelines","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}}]}; }, $n);
    /*Spine.Unity.UpdateMode end.*/

    /*Spine.Unity.ISkeletonAnimation start.*/
    $m("Spine.Unity.ISkeletonAnimation", function () { return {"att":161,"a":2,"m":[{"ab":true,"a":2,"n":"Skeleton","t":16,"rt":$n[9].Skeleton,"g":{"ab":true,"a":2,"n":"get_Skeleton","t":8,"rt":$n[9].Skeleton,"fg":"Spine$Unity$ISkeletonAnimation$Skeleton"},"fn":"Spine$Unity$ISkeletonAnimation$Skeleton"},{"ab":true,"a":2,"n":"UpdateComplete","t":2,"ad":{"ab":true,"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"ab":true,"a":2,"n":"UpdateLocal","t":2,"ad":{"ab":true,"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"ab":true,"a":2,"n":"UpdateWorld","t":2,"ad":{"ab":true,"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":1,"backing":true,"n":"<Skeleton>k__BackingField","t":4,"rt":$n[9].Skeleton,"sn":"Spine$Unity$ISkeletonAnimation$Skeleton"}]}; }, $n);
    /*Spine.Unity.ISkeletonAnimation end.*/

    /*Spine.Unity.IHasSkeletonDataAsset start.*/
    $m("Spine.Unity.IHasSkeletonDataAsset", function () { return {"att":161,"a":2,"m":[{"ab":true,"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[12].SkeletonDataAsset,"g":{"ab":true,"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[12].SkeletonDataAsset,"fg":"Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"},"fn":"Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"},{"a":1,"backing":true,"n":"<SkeletonDataAsset>k__BackingField","t":4,"rt":$n[12].SkeletonDataAsset,"sn":"Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.IHasSkeletonDataAsset end.*/

    /*Spine.Unity.ISkeletonComponent start.*/
    $m("Spine.Unity.ISkeletonComponent", function () { return {"att":161,"a":2,"m":[{"ab":true,"a":2,"n":"Skeleton","t":16,"rt":$n[9].Skeleton,"g":{"ab":true,"a":2,"n":"get_Skeleton","t":8,"rt":$n[9].Skeleton,"fg":"Spine$Unity$ISkeletonComponent$Skeleton"},"fn":"Spine$Unity$ISkeletonComponent$Skeleton"},{"ab":true,"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[12].SkeletonDataAsset,"g":{"ab":true,"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[12].SkeletonDataAsset,"fg":"Spine$Unity$ISkeletonComponent$SkeletonDataAsset"},"fn":"Spine$Unity$ISkeletonComponent$SkeletonDataAsset"},{"a":1,"backing":true,"n":"<Skeleton>k__BackingField","t":4,"rt":$n[9].Skeleton,"sn":"Spine$Unity$ISkeletonComponent$Skeleton"},{"a":1,"backing":true,"n":"<SkeletonDataAsset>k__BackingField","t":4,"rt":$n[12].SkeletonDataAsset,"sn":"Spine$Unity$ISkeletonComponent$SkeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.ISkeletonComponent end.*/

    /*Spine.Unity.IAnimationStateComponent start.*/
    $m("Spine.Unity.IAnimationStateComponent", function () { return {"att":161,"a":2,"m":[{"ab":true,"a":2,"n":"AnimationState","t":16,"rt":$n[9].AnimationState,"g":{"ab":true,"a":2,"n":"get_AnimationState","t":8,"rt":$n[9].AnimationState,"fg":"Spine$Unity$IAnimationStateComponent$AnimationState"},"fn":"Spine$Unity$IAnimationStateComponent$AnimationState"},{"a":1,"backing":true,"n":"<AnimationState>k__BackingField","t":4,"rt":$n[9].AnimationState,"sn":"Spine$Unity$IAnimationStateComponent$AnimationState"}]}; }, $n);
    /*Spine.Unity.IAnimationStateComponent end.*/

    /*Spine.Unity.IHasSkeletonRenderer start.*/
    $m("Spine.Unity.IHasSkeletonRenderer", function () { return {"att":161,"a":2,"m":[{"ab":true,"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[12].SkeletonRenderer,"g":{"ab":true,"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[12].SkeletonRenderer,"fg":"Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer"},"fn":"Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer"},{"a":1,"backing":true,"n":"<SkeletonRenderer>k__BackingField","t":4,"rt":$n[12].SkeletonRenderer,"sn":"Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer"}]}; }, $n);
    /*Spine.Unity.IHasSkeletonRenderer end.*/

    /*Spine.Unity.IHasSkeletonComponent start.*/
    $m("Spine.Unity.IHasSkeletonComponent", function () { return {"att":161,"a":2,"m":[{"ab":true,"a":2,"n":"SkeletonComponent","t":16,"rt":$n[12].ISkeletonComponent,"g":{"ab":true,"a":2,"n":"get_SkeletonComponent","t":8,"rt":$n[12].ISkeletonComponent,"fg":"Spine$Unity$IHasSkeletonComponent$SkeletonComponent"},"fn":"Spine$Unity$IHasSkeletonComponent$SkeletonComponent"},{"a":1,"backing":true,"n":"<SkeletonComponent>k__BackingField","t":4,"rt":$n[12].ISkeletonComponent,"sn":"Spine$Unity$IHasSkeletonComponent$SkeletonComponent"}]}; }, $n);
    /*Spine.Unity.IHasSkeletonComponent end.*/

    /*Spine.Unity.DoubleBuffered$1 start.*/
    $m("Spine.Unity.DoubleBuffered$1", function (T) { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"GetCurrent","t":8,"sn":"GetCurrent","rt":T},{"a":2,"n":"GetNext","t":8,"sn":"GetNext","rt":T},{"a":1,"n":"a","t":4,"rt":T,"sn":"a","ro":true},{"a":1,"n":"b","t":4,"rt":T,"sn":"b","ro":true},{"a":1,"n":"usingA","t":4,"rt":$n[0].Boolean,"sn":"usingA","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.DoubleBuffered$1 end.*/

    /*Spine.Unity.MeshGeneratorBuffers start.*/
    $m("Spine.Unity.MeshGeneratorBuffers", function () { return {"att":1048841,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"colorBuffer","t":4,"rt":System.Array.type(UnityEngine.Color32),"sn":"colorBuffer"},{"a":2,"n":"meshGenerator","t":4,"rt":$n[12].MeshGenerator,"sn":"meshGenerator"},{"a":2,"n":"uvBuffer","t":4,"rt":System.Array.type(UnityEngine.Vector2),"sn":"uvBuffer"},{"a":2,"n":"vertexBuffer","t":4,"rt":System.Array.type(UnityEngine.Vector3),"sn":"vertexBuffer"},{"a":2,"n":"vertexCount","t":4,"rt":$n[0].Int32,"sn":"vertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Unity.MeshGeneratorBuffers end.*/

    /*Spine.Unity.MeshGenerator start.*/
    $m("Spine.Unity.MeshGenerator", function () { return {"nested":[$n[12].MeshGenerator.Settings],"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AddAttachmentTintBlack","t":8,"pi":[{"n":"r2","pt":$n[0].Single,"ps":0},{"n":"g2","pt":$n[0].Single,"ps":1},{"n":"b2","pt":$n[0].Single,"ps":2},{"n":"a","pt":$n[0].Single,"ps":3},{"n":"vertexCount","pt":$n[0].Int32,"ps":4}],"sn":"AddAttachmentTintBlack","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Int32]},{"a":2,"n":"AddSubmesh","t":8,"pi":[{"n":"instruction","pt":$n[12].SubmeshInstruction,"ps":0},{"n":"updateTriangles","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"AddSubmesh","rt":$n[0].Void,"p":[$n[12].SubmeshInstruction,$n[0].Boolean]},{"a":2,"n":"Begin","t":8,"sn":"Begin","rt":$n[0].Void},{"a":2,"n":"BuildMesh","t":8,"pi":[{"n":"instruction","pt":$n[12].SkeletonRendererInstruction,"ps":0},{"n":"updateTriangles","pt":$n[0].Boolean,"ps":1}],"sn":"BuildMesh","rt":$n[0].Void,"p":[$n[12].SkeletonRendererInstruction,$n[0].Boolean]},{"a":2,"n":"BuildMeshWithArrays","t":8,"pi":[{"n":"instruction","pt":$n[12].SkeletonRendererInstruction,"ps":0},{"n":"updateTriangles","pt":$n[0].Boolean,"ps":1}],"sn":"BuildMeshWithArrays","rt":$n[0].Void,"p":[$n[12].SkeletonRendererInstruction,$n[0].Boolean]},{"a":2,"n":"EnsureVertexCapacity","t":8,"pi":[{"n":"minimumVertexCount","pt":$n[0].Int32,"ps":0},{"n":"inlcudeTintBlack","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"includeTangents","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"includeNormals","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"EnsureVertexCapacity","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"FillLateVertexData","t":8,"pi":[{"n":"mesh","pt":$n[1].Mesh,"ps":0}],"sn":"FillLateVertexData","rt":$n[0].Void,"p":[$n[1].Mesh]},{"a":2,"n":"FillMeshLocal","is":true,"t":8,"pi":[{"n":"mesh","pt":$n[1].Mesh,"ps":0},{"n":"regionAttachment","pt":$n[9].RegionAttachment,"ps":1}],"sn":"FillMeshLocal$1","rt":$n[0].Void,"p":[$n[1].Mesh,$n[9].RegionAttachment]},{"a":2,"n":"FillMeshLocal","is":true,"t":8,"pi":[{"n":"mesh","pt":$n[1].Mesh,"ps":0},{"n":"meshAttachment","pt":$n[9].MeshAttachment,"ps":1},{"n":"skeletonData","pt":$n[9].SkeletonData,"ps":2}],"sn":"FillMeshLocal","rt":$n[0].Void,"p":[$n[1].Mesh,$n[9].MeshAttachment,$n[9].SkeletonData]},{"a":2,"n":"FillTriangles","t":8,"pi":[{"n":"mesh","pt":$n[1].Mesh,"ps":0}],"sn":"FillTriangles","rt":$n[0].Void,"p":[$n[1].Mesh]},{"a":2,"n":"FillVertexData","t":8,"pi":[{"n":"mesh","pt":$n[1].Mesh,"ps":0}],"sn":"FillVertexData","rt":$n[0].Void,"p":[$n[1].Mesh]},{"a":2,"n":"GenerateSingleSubmeshInstruction","is":true,"t":8,"pi":[{"n":"instructionOutput","pt":$n[12].SkeletonRendererInstruction,"ps":0},{"n":"skeleton","pt":$n[9].Skeleton,"ps":1},{"n":"material","pt":$n[1].Material,"ps":2}],"sn":"GenerateSingleSubmeshInstruction","rt":$n[0].Void,"p":[$n[12].SkeletonRendererInstruction,$n[9].Skeleton,$n[1].Material]},{"a":2,"n":"GenerateSkeletonRendererInstruction","is":true,"t":8,"pi":[{"n":"instructionOutput","pt":$n[12].SkeletonRendererInstruction,"ps":0},{"n":"skeleton","pt":$n[9].Skeleton,"ps":1},{"n":"customSlotMaterials","pt":$n[5].Dictionary$2(Spine.Slot,UnityEngine.Material),"ps":2},{"n":"separatorSlots","pt":$n[5].List$1(Spine.Slot),"ps":3},{"n":"generateMeshOverride","pt":$n[0].Boolean,"ps":4},{"n":"immutableTriangles","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"GenerateSkeletonRendererInstruction","rt":$n[0].Void,"p":[$n[12].SkeletonRendererInstruction,$n[9].Skeleton,$n[5].Dictionary$2(Spine.Slot,UnityEngine.Material),$n[5].List$1(Spine.Slot),$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"RequiresMultipleSubmeshesByDrawOrder","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0}],"sn":"RequiresMultipleSubmeshesByDrawOrder","rt":$n[0].Boolean,"p":[$n[9].Skeleton],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"ScaleVertexData","t":8,"pi":[{"n":"scale","pt":$n[0].Single,"ps":0}],"sn":"ScaleVertexData","rt":$n[0].Void,"p":[$n[0].Single]},{"a":4,"n":"SolveTangents2DBuffer","is":true,"t":8,"pi":[{"n":"tangents","pt":System.Array.type(UnityEngine.Vector4),"ps":0},{"n":"tempTanBuffer","pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"vertexCount","pt":$n[0].Int32,"ps":2}],"sn":"SolveTangents2DBuffer","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Vector4),System.Array.type(UnityEngine.Vector2),$n[0].Int32]},{"a":4,"n":"SolveTangents2DEnsureSize","is":true,"t":8,"pi":[{"n":"tangentBuffer","ref":true,"pt":System.Array.type(UnityEngine.Vector4),"ps":0},{"n":"tempTanBuffer","ref":true,"pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"vertexCount","pt":$n[0].Int32,"ps":2},{"n":"vertexBufferLength","pt":$n[0].Int32,"ps":3}],"sn":"SolveTangents2DEnsureSize","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Vector4),System.Array.type(UnityEngine.Vector2),$n[0].Int32,$n[0].Int32]},{"a":4,"n":"SolveTangents2DTriangles","is":true,"t":8,"pi":[{"n":"tempTanBuffer","pt":System.Array.type(UnityEngine.Vector2),"ps":0},{"n":"triangles","pt":$n[0].Array.type(System.Int32),"ps":1},{"n":"triangleCount","pt":$n[0].Int32,"ps":2},{"n":"vertices","pt":System.Array.type(UnityEngine.Vector3),"ps":3},{"n":"uvs","pt":System.Array.type(UnityEngine.Vector2),"ps":4},{"n":"vertexCount","pt":$n[0].Int32,"ps":5}],"sn":"SolveTangents2DTriangles","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Vector2),$n[0].Array.type(System.Int32),$n[0].Int32,System.Array.type(UnityEngine.Vector3),System.Array.type(UnityEngine.Vector2),$n[0].Int32]},{"a":2,"n":"TrimExcess","t":8,"sn":"TrimExcess","rt":$n[0].Void},{"a":2,"n":"TryReplaceMaterials","is":true,"t":8,"pi":[{"n":"workingSubmeshInstructions","pt":$n[9].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0},{"n":"customMaterialOverride","pt":$n[5].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"ps":1}],"sn":"TryReplaceMaterials","rt":$n[0].Void,"p":[$n[9].ExposedList$1(Spine.Unity.SubmeshInstruction),$n[5].Dictionary$2(UnityEngine.Material,UnityEngine.Material)]},{"a":2,"n":"Buffers","t":16,"rt":$n[12].MeshGeneratorBuffers,"g":{"a":2,"n":"get_Buffers","t":8,"rt":$n[12].MeshGeneratorBuffers,"fg":"Buffers"},"fn":"Buffers"},{"a":2,"n":"VertexCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_VertexCount","t":8,"rt":$n[0].Int32,"fg":"VertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"VertexCount"},{"a":1,"n":"AttachmentColors32","is":true,"t":4,"rt":$n[5].List$1(UnityEngine.Color32),"sn":"AttachmentColors32"},{"a":1,"n":"AttachmentIndices","is":true,"t":4,"rt":$n[5].List$1(System.Int32),"sn":"AttachmentIndices"},{"a":1,"n":"AttachmentUVs","is":true,"t":4,"rt":$n[5].List$1(UnityEngine.Vector2),"sn":"AttachmentUVs"},{"a":1,"n":"AttachmentVerts","is":true,"t":4,"rt":$n[5].List$1(UnityEngine.Vector3),"sn":"AttachmentVerts"},{"a":1,"n":"BoundsMaxDefault","is":true,"t":4,"rt":$n[0].Single,"sn":"BoundsMaxDefault","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"BoundsMinDefault","is":true,"t":4,"rt":$n[0].Single,"sn":"BoundsMinDefault","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"clipper","t":4,"rt":$n[9].SkeletonClipping,"sn":"clipper"},{"a":1,"n":"colorBuffer","t":4,"rt":$n[9].ExposedList$1(UnityEngine.Color32),"sn":"colorBuffer","ro":true},{"a":1,"n":"meshBoundsMax","t":4,"rt":$n[1].Vector2,"sn":"meshBoundsMax"},{"a":1,"n":"meshBoundsMin","t":4,"rt":$n[1].Vector2,"sn":"meshBoundsMin"},{"a":1,"n":"meshBoundsThickness","t":4,"rt":$n[0].Single,"sn":"meshBoundsThickness","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"normals","t":4,"rt":System.Array.type(UnityEngine.Vector3),"sn":"normals"},{"a":1,"n":"regionTriangles","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"regionTriangles"},{"a":2,"n":"settings","t":4,"rt":$n[12].MeshGenerator.Settings,"sn":"settings"},{"a":1,"n":"submeshIndex","t":4,"rt":$n[0].Int32,"sn":"submeshIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"submeshes","t":4,"rt":$n[9].ExposedList$1(Spine.ExposedList$1(System.Int32)),"sn":"submeshes","ro":true},{"a":1,"n":"tangents","t":4,"rt":System.Array.type(UnityEngine.Vector4),"sn":"tangents"},{"a":1,"n":"tempTanBuffer","t":4,"rt":System.Array.type(UnityEngine.Vector2),"sn":"tempTanBuffer"},{"a":1,"n":"tempVerts","t":4,"rt":$n[0].Array.type(System.Single),"sn":"tempVerts"},{"a":1,"n":"uv2","t":4,"rt":$n[9].ExposedList$1(UnityEngine.Vector2),"sn":"uv2"},{"a":1,"n":"uv3","t":4,"rt":$n[9].ExposedList$1(UnityEngine.Vector2),"sn":"uv3"},{"a":1,"n":"uvBuffer","t":4,"rt":$n[9].ExposedList$1(UnityEngine.Vector2),"sn":"uvBuffer","ro":true},{"a":1,"n":"vertexBuffer","t":4,"rt":$n[9].ExposedList$1(UnityEngine.Vector3),"sn":"vertexBuffer","ro":true}]}; }, $n);
    /*Spine.Unity.MeshGenerator end.*/

    /*Spine.Unity.MeshGenerator+Settings start.*/
    $m("Spine.Unity.MeshGenerator.Settings", function () { return {"td":$n[12].MeshGenerator,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Default","is":true,"t":16,"rt":$n[12].MeshGenerator.Settings,"g":{"a":2,"n":"get_Default","t":8,"rt":$n[12].MeshGenerator.Settings,"fg":"Default","is":true},"fn":"Default"},{"a":2,"n":"addNormals","t":4,"rt":$n[0].Boolean,"sn":"addNormals","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"calculateTangents","t":4,"rt":$n[0].Boolean,"sn":"calculateTangents","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Enable when using Additive blend mode at SkeletonGraphic under a CanvasGroup. When enabled, Additive alpha value is stored at uv2.g instead of color.a to capture CanvasGroup modifying color.a.")],"a":2,"n":"canvasGroupTintBlack","t":4,"rt":$n[0].Boolean,"sn":"canvasGroupTintBlack","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"immutableTriangles","t":4,"rt":$n[0].Boolean,"sn":"immutableTriangles","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.HeaderAttribute("Vertex Data")],"a":2,"n":"pmaVertexColors","t":4,"rt":$n[0].Boolean,"sn":"pmaVertexColors","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"tintBlack","t":4,"rt":$n[0].Boolean,"sn":"tintBlack","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"useClipping","t":4,"rt":$n[0].Boolean,"sn":"useClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.RangeAttribute(-0.1, 0.0)],"a":2,"n":"zSpacing","t":4,"rt":$n[0].Single,"sn":"zSpacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.MeshGenerator+Settings end.*/

    /*Spine.Unity.MeshRendererBuffers start.*/
    $m("Spine.Unity.MeshRendererBuffers", function () { return {"nested":[$n[12].MeshRendererBuffers.SmartMesh],"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"GetNextMesh","t":8,"sn":"GetNextMesh","rt":$n[12].MeshRendererBuffers.SmartMesh},{"a":2,"n":"GetUpdatedSharedMaterialsArray","t":8,"sn":"GetUpdatedSharedMaterialsArray","rt":System.Array.type(UnityEngine.Material)},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"MaterialsChangedInLastUpdate","t":8,"sn":"MaterialsChangedInLastUpdate","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"UpdateSharedMaterials","t":8,"pi":[{"n":"instructions","pt":$n[9].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0}],"sn":"UpdateSharedMaterials","rt":$n[0].Void,"p":[$n[9].ExposedList$1(Spine.Unity.SubmeshInstruction)]},{"a":1,"n":"doubleBufferedMesh","t":4,"rt":$n[12].DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh),"sn":"doubleBufferedMesh"},{"a":4,"n":"sharedMaterials","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"sharedMaterials"},{"a":4,"n":"submeshMaterials","t":4,"rt":$n[9].ExposedList$1(UnityEngine.Material),"sn":"submeshMaterials","ro":true}]}; }, $n);
    /*Spine.Unity.MeshRendererBuffers end.*/

    /*Spine.Unity.MeshRendererBuffers+SmartMesh start.*/
    $m("Spine.Unity.MeshRendererBuffers.SmartMesh", function () { return {"td":$n[12].MeshRendererBuffers,"att":1048578,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"instructionUsed","t":4,"rt":$n[12].SkeletonRendererInstruction,"sn":"instructionUsed"},{"a":2,"n":"mesh","t":4,"rt":$n[1].Mesh,"sn":"mesh"}]}; }, $n);
    /*Spine.Unity.MeshRendererBuffers+SmartMesh end.*/

    /*Spine.Unity.SkeletonRendererInstruction start.*/
    $m("Spine.Unity.SkeletonRendererInstruction", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"GeometryNotEqual","is":true,"t":8,"pi":[{"n":"a","pt":$n[12].SkeletonRendererInstruction,"ps":0},{"n":"b","pt":$n[12].SkeletonRendererInstruction,"ps":1}],"sn":"GeometryNotEqual","rt":$n[0].Boolean,"p":[$n[12].SkeletonRendererInstruction,$n[12].SkeletonRendererInstruction],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Set","t":8,"pi":[{"n":"other","pt":$n[12].SkeletonRendererInstruction,"ps":0}],"sn":"Set","rt":$n[0].Void,"p":[$n[12].SkeletonRendererInstruction]},{"a":2,"n":"SetWithSubset","t":8,"pi":[{"n":"instructions","pt":$n[9].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0},{"n":"startSubmesh","pt":$n[0].Int32,"ps":1},{"n":"endSubmesh","pt":$n[0].Int32,"ps":2}],"sn":"SetWithSubset","rt":$n[0].Void,"p":[$n[9].ExposedList$1(Spine.Unity.SubmeshInstruction),$n[0].Int32,$n[0].Int32]},{"a":2,"n":"attachments","t":4,"rt":$n[9].ExposedList$1(Spine.Attachment),"sn":"attachments","ro":true},{"a":2,"n":"hasActiveClipping","t":4,"rt":$n[0].Boolean,"sn":"hasActiveClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"immutableTriangles","t":4,"rt":$n[0].Boolean,"sn":"immutableTriangles","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"rawVertexCount","t":4,"rt":$n[0].Int32,"sn":"rawVertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"submeshInstructions","t":4,"rt":$n[9].ExposedList$1(Spine.Unity.SubmeshInstruction),"sn":"submeshInstructions","ro":true}]}; }, $n);
    /*Spine.Unity.SkeletonRendererInstruction end.*/

    /*Spine.Unity.SpineMesh start.*/
    $m("Spine.Unity.SpineMesh", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"NewSkeletonMesh","is":true,"t":8,"sn":"NewSkeletonMesh","rt":$n[1].Mesh},{"a":4,"n":"MeshHideflags","is":true,"t":4,"rt":$n[1].HideFlags,"sn":"MeshHideflags","box":function ($v) { return Bridge.box($v, UnityEngine.HideFlags, System.Enum.toStringFn(UnityEngine.HideFlags));}}]}; }, $n);
    /*Spine.Unity.SpineMesh end.*/

    /*Spine.Unity.SubmeshInstruction start.*/
    $m("Spine.Unity.SubmeshInstruction", function () { return {"att":1048841,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"SlotCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotCount","t":8,"rt":$n[0].Int32,"fg":"SlotCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"SlotCount"},{"a":2,"n":"endSlot","t":4,"rt":$n[0].Int32,"sn":"endSlot","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"forceSeparate","t":4,"rt":$n[0].Boolean,"sn":"forceSeparate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"hasClipping","t":4,"rt":$n[0].Boolean,"sn":"hasClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"material","t":4,"rt":$n[1].Material,"sn":"material"},{"a":2,"n":"preActiveClippingSlotSource","t":4,"rt":$n[0].Int32,"sn":"preActiveClippingSlotSource","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"rawFirstVertexIndex","t":4,"rt":$n[0].Int32,"sn":"rawFirstVertexIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"rawTriangleCount","t":4,"rt":$n[0].Int32,"sn":"rawTriangleCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"rawVertexCount","t":4,"rt":$n[0].Int32,"sn":"rawVertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"skeleton","t":4,"rt":$n[9].Skeleton,"sn":"skeleton"},{"a":2,"n":"startSlot","t":4,"rt":$n[0].Int32,"sn":"startSlot","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Unity.SubmeshInstruction end.*/

    /*Spine.Unity.BlendModeMaterialsAsset start.*/
    $m("Spine.Unity.BlendModeMaterialsAsset", function () { return {"nested":[$n[12].BlendModeMaterialsAsset.AtlasMaterialCache],"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Spine/SkeletonData Modifiers/Blend Mode Materials", order: 200
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeletonData","pt":$n[9].SkeletonData,"ps":0}],"sn":"Apply","rt":$n[0].Void,"p":[$n[9].SkeletonData]},{"a":2,"n":"ApplyMaterials","is":true,"t":8,"pi":[{"n":"skeletonData","pt":$n[9].SkeletonData,"ps":0},{"n":"multiplyTemplate","pt":$n[1].Material,"ps":1},{"n":"screenTemplate","pt":$n[1].Material,"ps":2},{"n":"additiveTemplate","pt":$n[1].Material,"ps":3},{"n":"includeAdditiveSlots","pt":$n[0].Boolean,"ps":4}],"sn":"ApplyMaterials","rt":$n[0].Void,"p":[$n[9].SkeletonData,$n[1].Material,$n[1].Material,$n[1].Material,$n[0].Boolean]},{"a":2,"n":"additiveMaterialTemplate","t":4,"rt":$n[1].Material,"sn":"additiveMaterialTemplate"},{"a":2,"n":"applyAdditiveMaterial","t":4,"rt":$n[0].Boolean,"sn":"applyAdditiveMaterial","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"multiplyMaterialTemplate","t":4,"rt":$n[1].Material,"sn":"multiplyMaterialTemplate"},{"a":2,"n":"screenMaterialTemplate","t":4,"rt":$n[1].Material,"sn":"screenMaterialTemplate"}]}; }, $n);
    /*Spine.Unity.BlendModeMaterialsAsset end.*/

    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache start.*/
    $m("Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache", function () { return {"td":$n[12].BlendModeMaterialsAsset,"att":1048579,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"CloneAtlasRegionWithMaterial","t":8,"pi":[{"n":"originalRegion","pt":$n[9].AtlasRegion,"ps":0},{"n":"materialTemplate","pt":$n[1].Material,"ps":1}],"sn":"CloneAtlasRegionWithMaterial","rt":$n[9].AtlasRegion,"p":[$n[9].AtlasRegion,$n[1].Material]},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":1,"n":"GetAtlasPageWithMaterial","t":8,"pi":[{"n":"originalPage","pt":$n[9].AtlasPage,"ps":0},{"n":"materialTemplate","pt":$n[1].Material,"ps":1}],"sn":"GetAtlasPageWithMaterial","rt":$n[9].AtlasPage,"p":[$n[9].AtlasPage,$n[1].Material]},{"a":1,"n":"cache","t":4,"rt":$n[5].Dictionary$2(System.Collections.Generic.KeyValuePair$2(Spine.AtlasPage,UnityEngine.Material),Spine.AtlasPage),"sn":"cache","ro":true}]}; }, $n);
    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache end.*/

    /*Spine.Unity.SpineAttributeBase start.*/
    $m("Spine.Unity.SpineAttributeBase", function () { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"dataField","t":4,"rt":$n[0].String,"sn":"dataField"},{"a":2,"n":"fallbackToTextField","t":4,"rt":$n[0].Boolean,"sn":"fallbackToTextField","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"includeNone","t":4,"rt":$n[0].Boolean,"sn":"includeNone","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"startsWith","t":4,"rt":$n[0].String,"sn":"startsWith"}]}; }, $n);
    /*Spine.Unity.SpineAttributeBase end.*/

    /*Spine.Unity.SpineBone start.*/
    $m("Spine.Unity.SpineBone", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"},{"a":2,"n":"GetBone","is":true,"t":8,"pi":[{"n":"boneName","pt":$n[0].String,"ps":0},{"n":"renderer","pt":$n[12].SkeletonRenderer,"ps":1}],"sn":"getBone","rt":$n[9].Bone,"p":[$n[0].String,$n[12].SkeletonRenderer]},{"a":2,"n":"GetBoneData","is":true,"t":8,"pi":[{"n":"boneName","pt":$n[0].String,"ps":0},{"n":"skeletonDataAsset","pt":$n[12].SkeletonDataAsset,"ps":1}],"sn":"getBoneData","rt":$n[9].BoneData,"p":[$n[0].String,$n[12].SkeletonDataAsset]}]}; }, $n);
    /*Spine.Unity.SpineBone end.*/

    /*Spine.Unity.SpineSlot start.*/
    $m("Spine.Unity.SpineSlot", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"containsBoundingBoxes","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ctor"},{"a":2,"n":"containsBoundingBoxes","t":4,"rt":$n[0].Boolean,"sn":"containsBoundingBoxes","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineSlot end.*/

    /*Spine.Unity.SpineAnimation start.*/
    $m("Spine.Unity.SpineAnimation", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpineAnimation end.*/

    /*Spine.Unity.SpineEvent start.*/
    $m("Spine.Unity.SpineEvent", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"audioOnly","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ctor"},{"a":2,"n":"audioOnly","t":4,"rt":$n[0].Boolean,"sn":"audioOnly","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineEvent end.*/

    /*Spine.Unity.SpineIkConstraint start.*/
    $m("Spine.Unity.SpineIkConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpineIkConstraint end.*/

    /*Spine.Unity.SpineTransformConstraint start.*/
    $m("Spine.Unity.SpineTransformConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpineTransformConstraint end.*/

    /*Spine.Unity.SpinePathConstraint start.*/
    $m("Spine.Unity.SpinePathConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpinePathConstraint end.*/

    /*Spine.Unity.SpineSkin start.*/
    $m("Spine.Unity.SpineSkin", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"defaultAsEmptyString","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ctor"},{"a":2,"n":"defaultAsEmptyString","t":4,"rt":$n[0].Boolean,"sn":"defaultAsEmptyString","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineSkin end.*/

    /*Spine.Unity.SpineAttachment start.*/
    $m("Spine.Unity.SpineAttachment", function () { return {"nested":[$n[12].SpineAttachment.Hierarchy],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].String,$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"currentSkinOnly","dv":true,"o":true,"pt":$n[0].Boolean,"ps":0},{"n":"returnAttachmentPath","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"placeholdersOnly","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"slotField","dv":"","o":true,"pt":$n[0].String,"ps":3},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":4},{"n":"skinField","dv":"","o":true,"pt":$n[0].String,"ps":5},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":7}],"sn":"ctor"},{"a":2,"n":"GetAttachment","is":true,"t":8,"pi":[{"n":"attachmentPath","pt":$n[0].String,"ps":0},{"n":"skeletonData","pt":$n[9].SkeletonData,"ps":1}],"sn":"getAttachment","rt":$n[9].Attachment,"p":[$n[0].String,$n[9].SkeletonData]},{"a":2,"n":"GetAttachment","is":true,"t":8,"pi":[{"n":"attachmentPath","pt":$n[0].String,"ps":0},{"n":"skeletonDataAsset","pt":$n[12].SkeletonDataAsset,"ps":1}],"sn":"getAttachment$1","rt":$n[9].Attachment,"p":[$n[0].String,$n[12].SkeletonDataAsset]},{"a":2,"n":"GetHierarchy","is":true,"t":8,"pi":[{"n":"fullPath","pt":$n[0].String,"ps":0}],"sn":"getHierarchy","rt":$n[12].SpineAttachment.Hierarchy,"p":[$n[0].String]},{"a":2,"n":"currentSkinOnly","t":4,"rt":$n[0].Boolean,"sn":"currentSkinOnly","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"placeholdersOnly","t":4,"rt":$n[0].Boolean,"sn":"placeholdersOnly","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"returnAttachmentPath","t":4,"rt":$n[0].Boolean,"sn":"returnAttachmentPath","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"skinField","t":4,"rt":$n[0].String,"sn":"skinField"},{"a":2,"n":"slotField","t":4,"rt":$n[0].String,"sn":"slotField"}]}; }, $n);
    /*Spine.Unity.SpineAttachment end.*/

    /*Spine.Unity.SpineAttachment+Hierarchy start.*/
    $m("Spine.Unity.SpineAttachment.Hierarchy", function () { return {"td":$n[12].SpineAttachment,"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"fullPath","pt":$n[0].String,"ps":0}],"sn":"$ctor1"},{"a":2,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":2,"n":"skin","t":4,"rt":$n[0].String,"sn":"skin"},{"a":2,"n":"slot","t":4,"rt":$n[0].String,"sn":"slot"}]}; }, $n);
    /*Spine.Unity.SpineAttachment+Hierarchy end.*/

    /*Spine.Unity.SpineAtlasRegion start.*/
    $m("Spine.Unity.SpineAtlasRegion", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"atlasAssetField","dv":"","o":true,"pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":"atlasAssetField","t":4,"rt":$n[0].String,"sn":"atlasAssetField"}]}; }, $n);
    /*Spine.Unity.SpineAtlasRegion end.*/

    /*Spine.Unity.SkeletonExtensions start.*/
    $m("Spine.Unity.SkeletonExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"a","pt":$n[9].MeshAttachment,"ps":0}],"sn":"GetColor","rt":$n[1].Color,"p":[$n[9].MeshAttachment]},{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"a","pt":$n[9].RegionAttachment,"ps":0}],"sn":"GetColor$1","rt":$n[1].Color,"p":[$n[9].RegionAttachment]},{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"s","pt":$n[9].Skeleton,"ps":0}],"sn":"GetColor$2","rt":$n[1].Color,"p":[$n[9].Skeleton]},{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"s","pt":$n[9].Slot,"ps":0}],"sn":"GetColor$3","rt":$n[1].Color,"p":[$n[9].Slot]},{"a":2,"n":"GetColorTintBlack","is":true,"t":8,"pi":[{"n":"s","pt":$n[9].Slot,"ps":0}],"sn":"GetColorTintBlack","rt":$n[1].Color,"p":[$n[9].Slot]},{"a":2,"n":"GetLocalPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[9].Bone,"ps":0}],"sn":"GetLocalPosition","rt":$n[1].Vector2,"p":[$n[9].Bone]},{"a":2,"n":"GetLocalQuaternion","is":true,"t":8,"pi":[{"n":"bone","pt":$n[9].Bone,"ps":0}],"sn":"GetLocalQuaternion","rt":$n[1].Quaternion,"p":[$n[9].Bone]},{"a":2,"n":"GetLocalScale","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0}],"sn":"GetLocalScale","rt":$n[1].Vector2,"p":[$n[9].Skeleton]},{"a":2,"n":"GetLocalVertices","is":true,"t":8,"pi":[{"n":"va","pt":$n[9].VertexAttachment,"ps":0},{"n":"slot","pt":$n[9].Slot,"ps":1},{"n":"buffer","pt":System.Array.type(UnityEngine.Vector2),"ps":2}],"sn":"GetLocalVertices","rt":System.Array.type(UnityEngine.Vector2),"p":[$n[9].VertexAttachment,$n[9].Slot,System.Array.type(UnityEngine.Vector2)]},{"a":2,"n":"GetMaterial","is":true,"t":8,"pi":[{"n":"a","pt":$n[9].Attachment,"ps":0}],"sn":"GetMaterial","rt":$n[1].Material,"p":[$n[9].Attachment]},{"a":2,"n":"GetMatrix4x4","is":true,"t":8,"pi":[{"n":"bone","pt":$n[9].Bone,"ps":0}],"sn":"GetMatrix4x4","rt":$n[1].Matrix4x4,"p":[$n[9].Bone]},{"a":2,"n":"GetQuaternion","is":true,"t":8,"pi":[{"n":"bone","pt":$n[9].Bone,"ps":0}],"sn":"GetQuaternion","rt":$n[1].Quaternion,"p":[$n[9].Bone]},{"a":2,"n":"GetSkeletonSpacePosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[9].Bone,"ps":0}],"sn":"GetSkeletonSpacePosition","rt":$n[1].Vector2,"p":[$n[9].Bone]},{"a":2,"n":"GetSkeletonSpacePosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[9].Bone,"ps":0},{"n":"boneLocal","pt":$n[1].Vector2,"ps":1}],"sn":"GetSkeletonSpacePosition$1","rt":$n[1].Vector2,"p":[$n[9].Bone,$n[1].Vector2]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[9].Bone,"ps":0},{"n":"spineGameObjectTransform","pt":$n[1].Transform,"ps":1}],"sn":"GetWorldPosition","rt":$n[1].Vector3,"p":[$n[9].Bone,$n[1].Transform]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[9].Bone,"ps":0},{"n":"spineGameObjectTransform","pt":$n[1].Transform,"ps":1},{"n":"positionScale","pt":$n[0].Single,"ps":2}],"sn":"GetWorldPosition$1","rt":$n[1].Vector3,"p":[$n[9].Bone,$n[1].Transform,$n[0].Single]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[9].PointAttachment,"ps":0},{"n":"bone","pt":$n[9].Bone,"ps":1},{"n":"spineGameObjectTransform","pt":$n[1].Transform,"ps":2}],"sn":"GetWorldPosition$2","rt":$n[1].Vector3,"p":[$n[9].PointAttachment,$n[9].Bone,$n[1].Transform]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[9].PointAttachment,"ps":0},{"n":"slot","pt":$n[9].Slot,"ps":1},{"n":"spineGameObjectTransform","pt":$n[1].Transform,"ps":2}],"sn":"GetWorldPosition$3","rt":$n[1].Vector3,"p":[$n[9].PointAttachment,$n[9].Slot,$n[1].Transform]},{"a":2,"n":"GetWorldToLocalMatrix","is":true,"t":8,"pi":[{"n":"bone","pt":$n[9].Bone,"ps":0},{"n":"ia","out":true,"pt":$n[0].Single,"ps":1},{"n":"ib","out":true,"pt":$n[0].Single,"ps":2},{"n":"ic","out":true,"pt":$n[0].Single,"ps":3},{"n":"id","out":true,"pt":$n[0].Single,"ps":4}],"sn":"GetWorldToLocalMatrix","rt":$n[0].Void,"p":[$n[9].Bone,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"GetWorldVertices","is":true,"t":8,"pi":[{"n":"a","pt":$n[9].VertexAttachment,"ps":0},{"n":"slot","pt":$n[9].Slot,"ps":1},{"n":"buffer","pt":System.Array.type(UnityEngine.Vector2),"ps":2}],"sn":"GetWorldVertices","rt":System.Array.type(UnityEngine.Vector2),"p":[$n[9].VertexAttachment,$n[9].Slot,System.Array.type(UnityEngine.Vector2)]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[9].MeshAttachment,"ps":0},{"n":"color","pt":$n[1].Color,"ps":1}],"sn":"SetColor","rt":$n[0].Void,"p":[$n[9].MeshAttachment,$n[1].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[9].MeshAttachment,"ps":0},{"n":"color","pt":$n[1].Color32,"ps":1}],"sn":"SetColor$1","rt":$n[0].Void,"p":[$n[9].MeshAttachment,$n[1].Color32]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[9].RegionAttachment,"ps":0},{"n":"color","pt":$n[1].Color,"ps":1}],"sn":"SetColor$2","rt":$n[0].Void,"p":[$n[9].RegionAttachment,$n[1].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[9].RegionAttachment,"ps":0},{"n":"color","pt":$n[1].Color32,"ps":1}],"sn":"SetColor$3","rt":$n[0].Void,"p":[$n[9].RegionAttachment,$n[1].Color32]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0},{"n":"color","pt":$n[1].Color,"ps":1}],"sn":"SetColor$4","rt":$n[0].Void,"p":[$n[9].Skeleton,$n[1].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0},{"n":"color","pt":$n[1].Color32,"ps":1}],"sn":"SetColor$5","rt":$n[0].Void,"p":[$n[9].Skeleton,$n[1].Color32]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"slot","pt":$n[9].Slot,"ps":0},{"n":"color","pt":$n[1].Color,"ps":1}],"sn":"SetColor$6","rt":$n[0].Void,"p":[$n[9].Slot,$n[1].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"slot","pt":$n[9].Slot,"ps":0},{"n":"color","pt":$n[1].Color32,"ps":1}],"sn":"SetColor$7","rt":$n[0].Void,"p":[$n[9].Slot,$n[1].Color32]},{"a":2,"n":"SetLocalPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[9].Bone,"ps":0},{"n":"position","pt":$n[1].Vector2,"ps":1}],"sn":"SetLocalPosition","rt":$n[0].Void,"p":[$n[9].Bone,$n[1].Vector2]},{"a":2,"n":"SetLocalPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[9].Bone,"ps":0},{"n":"position","pt":$n[1].Vector3,"ps":1}],"sn":"SetLocalPosition$1","rt":$n[0].Void,"p":[$n[9].Bone,$n[1].Vector3]},{"a":2,"n":"SetLocalScale","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0},{"n":"scale","pt":$n[1].Vector2,"ps":1}],"sn":"SetLocalScale","rt":$n[0].Void,"p":[$n[9].Skeleton,$n[1].Vector2]},{"a":2,"n":"SetPositionSkeletonSpace","is":true,"t":8,"pi":[{"n":"bone","pt":$n[9].Bone,"ps":0},{"n":"skeletonSpacePosition","pt":$n[1].Vector2,"ps":1}],"sn":"SetPositionSkeletonSpace","rt":$n[1].Vector2,"p":[$n[9].Bone,$n[1].Vector2]},{"a":2,"n":"WorldToLocal","is":true,"t":8,"pi":[{"n":"bone","pt":$n[9].Bone,"ps":0},{"n":"worldPosition","pt":$n[1].Vector2,"ps":1}],"sn":"WorldToLocal","rt":$n[1].Vector2,"p":[$n[9].Bone,$n[1].Vector2]},{"a":1,"n":"ByteToFloat","is":true,"t":4,"rt":$n[0].Single,"sn":"ByteToFloat","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.SkeletonExtensions end.*/

    /*Spine.Unity.WaitForSpineAnimation start.*/
    $m("Spine.Unity.WaitForSpineAnimation", function () { return {"nested":[$n[12].WaitForSpineAnimation.AnimationEventTypes],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[9].TrackEntry,$n[12].WaitForSpineAnimation.AnimationEventTypes],"pi":[{"n":"trackEntry","pt":$n[9].TrackEntry,"ps":0},{"n":"eventsToWaitFor","pt":$n[12].WaitForSpineAnimation.AnimationEventTypes,"ps":1}],"sn":"ctor"},{"a":1,"n":"HandleComplete","t":8,"pi":[{"n":"trackEntry","pt":$n[9].TrackEntry,"ps":0}],"sn":"HandleComplete","rt":$n[0].Void,"p":[$n[9].TrackEntry]},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"trackEntry","pt":$n[9].TrackEntry,"ps":0},{"n":"eventsToWaitFor","pt":$n[12].WaitForSpineAnimation.AnimationEventTypes,"ps":1}],"sn":"NowWaitFor","rt":$n[12].WaitForSpineAnimation,"p":[$n[9].TrackEntry,$n[12].WaitForSpineAnimation.AnimationEventTypes]},{"a":3,"n":"SafeSubscribe","t":8,"pi":[{"n":"trackEntry","pt":$n[9].TrackEntry,"ps":0},{"n":"eventsToWaitFor","pt":$n[12].WaitForSpineAnimation.AnimationEventTypes,"ps":1}],"sn":"SafeSubscribe","rt":$n[0].Void,"p":[$n[9].TrackEntry,$n[12].WaitForSpineAnimation.AnimationEventTypes]},{"a":1,"n":"m_WasFired","t":4,"rt":$n[0].Boolean,"sn":"m_WasFired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.WaitForSpineAnimation end.*/

    /*Spine.Unity.WaitForSpineAnimation+AnimationEventTypes start.*/
    $m("Spine.Unity.WaitForSpineAnimation.AnimationEventTypes", function () { return {"td":$n[12].WaitForSpineAnimation,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Complete","is":true,"t":4,"rt":$n[12].WaitForSpineAnimation.AnimationEventTypes,"sn":"Complete","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}},{"a":2,"n":"Dispose","is":true,"t":4,"rt":$n[12].WaitForSpineAnimation.AnimationEventTypes,"sn":"Dispose","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}},{"a":2,"n":"End","is":true,"t":4,"rt":$n[12].WaitForSpineAnimation.AnimationEventTypes,"sn":"End","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}},{"a":2,"n":"Interrupt","is":true,"t":4,"rt":$n[12].WaitForSpineAnimation.AnimationEventTypes,"sn":"Interrupt","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}},{"a":2,"n":"Start","is":true,"t":4,"rt":$n[12].WaitForSpineAnimation.AnimationEventTypes,"sn":"Start","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}}]}; }, $n);
    /*Spine.Unity.WaitForSpineAnimation+AnimationEventTypes end.*/

    /*Spine.Unity.WaitForSpineAnimationComplete start.*/
    $m("Spine.Unity.WaitForSpineAnimationComplete", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[9].TrackEntry,$n[0].Boolean],"pi":[{"n":"trackEntry","pt":$n[9].TrackEntry,"ps":0},{"n":"includeEndEvent","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"ctor"},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"trackEntry","pt":$n[9].TrackEntry,"ps":0},{"n":"includeEndEvent","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"NowWaitFor$1","rt":$n[12].WaitForSpineAnimationComplete,"p":[$n[9].TrackEntry,$n[0].Boolean]}]}; }, $n);
    /*Spine.Unity.WaitForSpineAnimationComplete end.*/

    /*Spine.Unity.WaitForSpineAnimationEnd start.*/
    $m("Spine.Unity.WaitForSpineAnimationEnd", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[9].TrackEntry],"pi":[{"n":"trackEntry","pt":$n[9].TrackEntry,"ps":0}],"sn":"ctor"},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"trackEntry","pt":$n[9].TrackEntry,"ps":0}],"sn":"NowWaitFor$1","rt":$n[12].WaitForSpineAnimationEnd,"p":[$n[9].TrackEntry]}]}; }, $n);
    /*Spine.Unity.WaitForSpineAnimationEnd end.*/

    /*Spine.Unity.WaitForSpineEvent start.*/
    $m("Spine.Unity.WaitForSpineEvent", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[9].AnimationState,$n[9].EventData,$n[0].Boolean],"pi":[{"n":"state","pt":$n[9].AnimationState,"ps":0},{"n":"eventDataReference","pt":$n[9].EventData,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[9].AnimationState,$n[0].String,$n[0].Boolean],"pi":[{"n":"state","pt":$n[9].AnimationState,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"$ctor1"},{"a":2,"n":".ctor","t":1,"p":[$n[12].SkeletonAnimation,$n[9].EventData,$n[0].Boolean],"pi":[{"n":"skeletonAnimation","pt":$n[12].SkeletonAnimation,"ps":0},{"n":"eventDataReference","pt":$n[9].EventData,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"$ctor2"},{"a":2,"n":".ctor","t":1,"p":[$n[12].SkeletonAnimation,$n[0].String,$n[0].Boolean],"pi":[{"n":"skeletonAnimation","pt":$n[12].SkeletonAnimation,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"$ctor3"},{"a":1,"n":"Clear","t":8,"pi":[{"n":"state","pt":$n[9].AnimationState,"ps":0}],"sn":"Clear","rt":$n[0].Void,"p":[$n[9].AnimationState]},{"a":1,"n":"HandleAnimationStateEvent","t":8,"pi":[{"n":"trackEntry","pt":$n[9].TrackEntry,"ps":0},{"n":"e","pt":$n[9].Event,"ps":1}],"sn":"HandleAnimationStateEvent","rt":$n[0].Void,"p":[$n[9].TrackEntry,$n[9].Event]},{"a":1,"n":"HandleAnimationStateEventByName","t":8,"pi":[{"n":"trackEntry","pt":$n[9].TrackEntry,"ps":0},{"n":"e","pt":$n[9].Event,"ps":1}],"sn":"HandleAnimationStateEventByName","rt":$n[0].Void,"p":[$n[9].TrackEntry,$n[9].Event]},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"state","pt":$n[9].AnimationState,"ps":0},{"n":"eventDataReference","pt":$n[9].EventData,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"NowWaitFor","rt":$n[12].WaitForSpineEvent,"p":[$n[9].AnimationState,$n[9].EventData,$n[0].Boolean]},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"state","pt":$n[9].AnimationState,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"NowWaitFor$1","rt":$n[12].WaitForSpineEvent,"p":[$n[9].AnimationState,$n[0].String,$n[0].Boolean]},{"a":1,"n":"Subscribe","t":8,"pi":[{"n":"state","pt":$n[9].AnimationState,"ps":0},{"n":"eventDataReference","pt":$n[9].EventData,"ps":1},{"n":"unsubscribe","pt":$n[0].Boolean,"ps":2}],"sn":"Subscribe","rt":$n[0].Void,"p":[$n[9].AnimationState,$n[9].EventData,$n[0].Boolean]},{"a":1,"n":"SubscribeByName","t":8,"pi":[{"n":"state","pt":$n[9].AnimationState,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribe","pt":$n[0].Boolean,"ps":2}],"sn":"SubscribeByName","rt":$n[0].Void,"p":[$n[9].AnimationState,$n[0].String,$n[0].Boolean]},{"a":2,"n":"WillUnsubscribeAfterFiring","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_WillUnsubscribeAfterFiring","t":8,"rt":$n[0].Boolean,"fg":"WillUnsubscribeAfterFiring","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_WillUnsubscribeAfterFiring","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"WillUnsubscribeAfterFiring"},"fn":"WillUnsubscribeAfterFiring"},{"a":1,"n":"m_AnimationState","t":4,"rt":$n[9].AnimationState,"sn":"m_AnimationState"},{"a":1,"n":"m_EventName","t":4,"rt":$n[0].String,"sn":"m_EventName"},{"a":1,"n":"m_TargetEvent","t":4,"rt":$n[9].EventData,"sn":"m_TargetEvent"},{"a":1,"n":"m_WasFired","t":4,"rt":$n[0].Boolean,"sn":"m_WasFired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"m_unsubscribeAfterFiring","t":4,"rt":$n[0].Boolean,"sn":"m_unsubscribeAfterFiring","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.WaitForSpineEvent end.*/

    /*Spine.Unity.WaitForSpineTrackEntryEnd start.*/
    $m("Spine.Unity.WaitForSpineTrackEntryEnd", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[9].TrackEntry],"pi":[{"n":"trackEntry","pt":$n[9].TrackEntry,"ps":0}],"sn":"ctor"},{"a":1,"n":"HandleEnd","t":8,"pi":[{"n":"trackEntry","pt":$n[9].TrackEntry,"ps":0}],"sn":"HandleEnd","rt":$n[0].Void,"p":[$n[9].TrackEntry]},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"trackEntry","pt":$n[9].TrackEntry,"ps":0}],"sn":"NowWaitFor","rt":$n[12].WaitForSpineTrackEntryEnd,"p":[$n[9].TrackEntry]},{"a":1,"n":"SafeSubscribe","t":8,"pi":[{"n":"trackEntry","pt":$n[9].TrackEntry,"ps":0}],"sn":"SafeSubscribe","rt":$n[0].Void,"p":[$n[9].TrackEntry]},{"a":1,"n":"m_WasFired","t":4,"rt":$n[0].Boolean,"sn":"m_WasFired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.WaitForSpineTrackEntryEnd end.*/

    /*Spine.Unity.AnimationTools.TimelineExtensions start.*/
    $m("Spine.Unity.AnimationTools.TimelineExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"Evaluate","is":true,"t":8,"pi":[{"n":"timeline","pt":$n[9].TranslateTimeline,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"skeletonData","dv":null,"o":true,"pt":$n[9].SkeletonData,"ps":2}],"sn":"Evaluate","rt":$n[1].Vector2,"p":[$n[9].TranslateTimeline,$n[0].Single,$n[9].SkeletonData]},{"a":2,"n":"FindTranslateTimelineForBone","is":true,"t":8,"pi":[{"n":"a","pt":$n[9].Animation,"ps":0},{"n":"boneIndex","pt":$n[0].Int32,"ps":1}],"sn":"FindTranslateTimelineForBone","rt":$n[9].TranslateTimeline,"p":[$n[9].Animation,$n[0].Int32]}]}; }, $n);
    /*Spine.Unity.AnimationTools.TimelineExtensions end.*/

    /*Spine.Unity.AttachmentTools.AtlasUtilities start.*/
    $m("Spine.Unity.AttachmentTools.AtlasUtilities", function () { return {"nested":[$n[15].AtlasUtilities.IntAndAtlasRegionKey],"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"ClearCache","is":true,"t":8,"sn":"ClearCache","rt":$n[0].Void},{"a":1,"n":"CopyTexture","is":true,"t":8,"pi":[{"n":"source","pt":$n[1].Texture2D,"ps":0},{"n":"sourceRect","pt":$n[1].Rect,"ps":1},{"n":"destination","pt":$n[1].Texture2D,"ps":2}],"sn":"CopyTexture","rt":$n[0].Void,"p":[$n[1].Texture2D,$n[1].Rect,$n[1].Texture2D]},{"a":1,"n":"CopyTextureApplyPMA","is":true,"t":8,"pi":[{"n":"source","pt":$n[1].Texture2D,"ps":0},{"n":"sourceRect","pt":$n[1].Rect,"ps":1},{"n":"destination","pt":$n[1].Texture2D,"ps":2}],"sn":"CopyTextureApplyPMA","rt":$n[0].Void,"p":[$n[1].Texture2D,$n[1].Rect,$n[1].Texture2D]},{"a":1,"n":"CopyTextureAttributesFrom","is":true,"t":8,"pi":[{"n":"destination","pt":$n[1].Texture2D,"ps":0},{"n":"source","pt":$n[1].Texture2D,"ps":1}],"sn":"CopyTextureAttributesFrom","rt":$n[0].Void,"p":[$n[1].Texture2D,$n[1].Texture2D]},{"a":1,"n":"GetClone","is":true,"t":8,"pi":[{"n":"t","pt":$n[1].Texture2D,"ps":0},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":1},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"linear","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"applyPMA","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"GetClone","rt":$n[1].Texture2D,"p":[$n[1].Texture2D,$n[1].TextureFormat,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"GetMainTexture","is":true,"t":8,"pi":[{"n":"region","pt":$n[9].AtlasRegion,"ps":0}],"sn":"GetMainTexture","rt":$n[1].Texture2D,"p":[$n[9].AtlasRegion]},{"a":2,"n":"GetRepackedAttachments","is":true,"t":8,"pi":[{"n":"sourceAttachments","pt":$n[5].List$1(Spine.Attachment),"ps":0},{"n":"outputAttachments","pt":$n[5].List$1(Spine.Attachment),"ps":1},{"n":"materialPropertySource","pt":$n[1].Material,"ps":2},{"n":"outputMaterial","out":true,"pt":$n[1].Material,"ps":3},{"n":"outputTexture","out":true,"pt":$n[1].Texture2D,"ps":4},{"n":"maxAtlasSize","dv":1024,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"padding","dv":2,"o":true,"pt":$n[0].Int32,"ps":6},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":7},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"newAssetName","dv":"Repacked Attachments","o":true,"pt":$n[0].String,"ps":9},{"n":"clearCache","dv":false,"o":true,"pt":$n[0].Boolean,"ps":10},{"n":"useOriginalNonrenderables","dv":true,"o":true,"pt":$n[0].Boolean,"ps":11}],"sn":"GetRepackedAttachments","rt":$n[0].Void,"p":[$n[5].List$1(Spine.Attachment),$n[5].List$1(Spine.Attachment),$n[1].Material,$n[1].Material,$n[1].Texture2D,$n[0].Int32,$n[0].Int32,$n[1].TextureFormat,$n[0].Boolean,$n[0].String,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"GetRepackedSkin","is":true,"t":8,"pi":[{"n":"o","pt":$n[9].Skin,"ps":0},{"n":"newName","pt":$n[0].String,"ps":1},{"n":"materialPropertySource","pt":$n[1].Material,"ps":2},{"n":"outputMaterial","out":true,"pt":$n[1].Material,"ps":3},{"n":"outputTexture","out":true,"pt":$n[1].Texture2D,"ps":4},{"n":"maxAtlasSize","dv":1024,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"padding","dv":2,"o":true,"pt":$n[0].Int32,"ps":6},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":7},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"useOriginalNonrenderables","dv":true,"o":true,"pt":$n[0].Boolean,"ps":9},{"n":"clearCache","dv":false,"o":true,"pt":$n[0].Boolean,"ps":10},{"n":"additionalTexturePropertyIDsToCopy","dv":null,"o":true,"pt":$n[0].Array.type(System.Int32),"ps":11},{"n":"additionalOutputTextures","dv":null,"o":true,"pt":System.Array.type(UnityEngine.Texture2D),"ps":12},{"n":"additionalTextureFormats","dv":null,"o":true,"pt":System.Array.type(UnityEngine.TextureFormat),"ps":13},{"n":"additionalTextureIsLinear","dv":null,"o":true,"pt":$n[0].Array.type(System.Boolean),"ps":14}],"sn":"GetRepackedSkin","rt":$n[9].Skin,"p":[$n[9].Skin,$n[0].String,$n[1].Material,$n[1].Material,$n[1].Texture2D,$n[0].Int32,$n[0].Int32,$n[1].TextureFormat,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].Array.type(System.Int32),System.Array.type(UnityEngine.Texture2D),System.Array.type(UnityEngine.TextureFormat),$n[0].Array.type(System.Boolean)]},{"a":2,"n":"GetRepackedSkin","is":true,"t":8,"pi":[{"n":"o","pt":$n[9].Skin,"ps":0},{"n":"newName","pt":$n[0].String,"ps":1},{"n":"shader","pt":$n[1].Shader,"ps":2},{"n":"outputMaterial","out":true,"pt":$n[1].Material,"ps":3},{"n":"outputTexture","out":true,"pt":$n[1].Texture2D,"ps":4},{"n":"maxAtlasSize","dv":1024,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"padding","dv":2,"o":true,"pt":$n[0].Int32,"ps":6},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":7},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[1].Material,"ps":9},{"n":"clearCache","dv":false,"o":true,"pt":$n[0].Boolean,"ps":10},{"n":"useOriginalNonrenderables","dv":true,"o":true,"pt":$n[0].Boolean,"ps":11},{"n":"additionalTexturePropertyIDsToCopy","dv":null,"o":true,"pt":$n[0].Array.type(System.Int32),"ps":12},{"n":"additionalOutputTextures","dv":null,"o":true,"pt":System.Array.type(UnityEngine.Texture2D),"ps":13},{"n":"additionalTextureFormats","dv":null,"o":true,"pt":System.Array.type(UnityEngine.TextureFormat),"ps":14},{"n":"additionalTextureIsLinear","dv":null,"o":true,"pt":$n[0].Array.type(System.Boolean),"ps":15}],"sn":"GetRepackedSkin$1","rt":$n[9].Skin,"p":[$n[9].Skin,$n[0].String,$n[1].Shader,$n[1].Material,$n[1].Texture2D,$n[0].Int32,$n[0].Int32,$n[1].TextureFormat,$n[0].Boolean,$n[1].Material,$n[0].Boolean,$n[0].Boolean,$n[0].Array.type(System.Int32),System.Array.type(UnityEngine.Texture2D),System.Array.type(UnityEngine.TextureFormat),$n[0].Array.type(System.Boolean)]},{"a":1,"n":"GetSpineAtlasRect","is":true,"t":8,"pi":[{"n":"region","pt":$n[9].AtlasRegion,"ps":0},{"n":"includeRotate","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"GetSpineAtlasRect","rt":$n[1].Rect,"p":[$n[9].AtlasRegion,$n[0].Boolean]},{"a":1,"n":"GetTexture","is":true,"t":8,"pi":[{"n":"region","pt":$n[9].AtlasRegion,"ps":0},{"n":"texturePropertyId","pt":$n[0].Int32,"ps":1}],"sn":"GetTexture","rt":$n[1].Texture2D,"p":[$n[9].AtlasRegion,$n[0].Int32]},{"a":1,"n":"GetTexture","is":true,"t":8,"pi":[{"n":"region","pt":$n[9].AtlasRegion,"ps":0},{"n":"texturePropertyName","pt":$n[0].String,"ps":1}],"sn":"GetTexture$1","rt":$n[1].Texture2D,"p":[$n[9].AtlasRegion,$n[0].String]},{"a":1,"n":"GetUnityRect","is":true,"t":8,"pi":[{"n":"region","pt":$n[9].AtlasRegion,"ps":0}],"sn":"GetUnityRect","rt":$n[1].Rect,"p":[$n[9].AtlasRegion]},{"a":1,"n":"GetUnityRect","is":true,"t":8,"pi":[{"n":"region","pt":$n[9].AtlasRegion,"ps":0},{"n":"textureHeight","pt":$n[0].Int32,"ps":1}],"sn":"GetUnityRect$1","rt":$n[1].Rect,"p":[$n[9].AtlasRegion,$n[0].Int32]},{"at":[new UnityEngine.RuntimeInitializeOnLoadMethodAttribute.$ctor1(4)],"a":1,"n":"Init","is":true,"t":8,"sn":"Init","rt":$n[0].Void},{"a":1,"n":"InverseLerp","is":true,"t":8,"pi":[{"n":"a","pt":$n[0].Single,"ps":0},{"n":"b","pt":$n[0].Single,"ps":1},{"n":"value","pt":$n[0].Single,"ps":2}],"sn":"InverseLerp","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"IsRenderable","is":true,"t":8,"pi":[{"n":"a","pt":$n[9].Attachment,"ps":0}],"sn":"IsRenderable","rt":$n[0].Boolean,"p":[$n[9].Attachment],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"SpineUnityFlipRect","is":true,"t":8,"pi":[{"n":"rect","pt":$n[1].Rect,"ps":0},{"n":"textureHeight","pt":$n[0].Int32,"ps":1}],"sn":"SpineUnityFlipRect","rt":$n[1].Rect,"p":[$n[1].Rect,$n[0].Int32]},{"a":1,"n":"TextureRectToUVRect","is":true,"t":8,"pi":[{"n":"textureRect","pt":$n[1].Rect,"ps":0},{"n":"texWidth","pt":$n[0].Int32,"ps":1},{"n":"texHeight","pt":$n[0].Int32,"ps":2}],"sn":"TextureRectToUVRect","rt":$n[1].Rect,"p":[$n[1].Rect,$n[0].Int32,$n[0].Int32]},{"a":2,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"s","pt":$n[1].Sprite,"ps":0},{"n":"page","pt":$n[9].AtlasPage,"ps":1}],"sn":"ToAtlasRegion","rt":$n[9].AtlasRegion,"p":[$n[1].Sprite,$n[9].AtlasPage]},{"a":4,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"s","pt":$n[1].Sprite,"ps":0},{"n":"isolatedTexture","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"ToAtlasRegion$4","rt":$n[9].AtlasRegion,"p":[$n[1].Sprite,$n[0].Boolean]},{"a":2,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"s","pt":$n[1].Sprite,"ps":0},{"n":"material","pt":$n[1].Material,"ps":1}],"sn":"ToAtlasRegion$1","rt":$n[9].AtlasRegion,"p":[$n[1].Sprite,$n[1].Material]},{"a":2,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"t","pt":$n[1].Texture2D,"ps":0},{"n":"materialPropertySource","pt":$n[1].Material,"ps":1},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"ToAtlasRegion$2","rt":$n[9].AtlasRegion,"p":[$n[1].Texture2D,$n[1].Material,$n[0].Single]},{"a":2,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"t","pt":$n[1].Texture2D,"ps":0},{"n":"shader","pt":$n[1].Shader,"ps":1},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":2},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[1].Material,"ps":3}],"sn":"ToAtlasRegion$3","rt":$n[9].AtlasRegion,"p":[$n[1].Texture2D,$n[1].Shader,$n[0].Single,$n[1].Material]},{"a":2,"n":"ToAtlasRegionPMAClone","is":true,"t":8,"pi":[{"n":"s","pt":$n[1].Sprite,"ps":0},{"n":"materialPropertySource","pt":$n[1].Material,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ToAtlasRegionPMAClone","rt":$n[9].AtlasRegion,"p":[$n[1].Sprite,$n[1].Material,$n[1].TextureFormat,$n[0].Boolean]},{"a":2,"n":"ToAtlasRegionPMAClone","is":true,"t":8,"pi":[{"n":"t","pt":$n[1].Texture2D,"ps":0},{"n":"materialPropertySource","pt":$n[1].Material,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ToAtlasRegionPMAClone$2","rt":$n[9].AtlasRegion,"p":[$n[1].Texture2D,$n[1].Material,$n[1].TextureFormat,$n[0].Boolean]},{"a":2,"n":"ToAtlasRegionPMAClone","is":true,"t":8,"pi":[{"n":"s","pt":$n[1].Sprite,"ps":0},{"n":"shader","pt":$n[1].Shader,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[1].Material,"ps":4}],"sn":"ToAtlasRegionPMAClone$1","rt":$n[9].AtlasRegion,"p":[$n[1].Sprite,$n[1].Shader,$n[1].TextureFormat,$n[0].Boolean,$n[1].Material]},{"a":2,"n":"ToAtlasRegionPMAClone","is":true,"t":8,"pi":[{"n":"t","pt":$n[1].Texture2D,"ps":0},{"n":"shader","pt":$n[1].Shader,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[1].Material,"ps":4}],"sn":"ToAtlasRegionPMAClone$3","rt":$n[9].AtlasRegion,"p":[$n[1].Texture2D,$n[1].Shader,$n[1].TextureFormat,$n[0].Boolean,$n[1].Material]},{"a":2,"n":"ToSpineAtlasPage","is":true,"t":8,"pi":[{"n":"m","pt":$n[1].Material,"ps":0}],"sn":"ToSpineAtlasPage","rt":$n[9].AtlasPage,"p":[$n[1].Material]},{"a":2,"n":"ToSprite","is":true,"t":8,"pi":[{"n":"ar","pt":$n[9].AtlasRegion,"ps":0},{"n":"pixelsPerUnit","dv":100.0,"o":true,"pt":$n[0].Single,"ps":1}],"sn":"ToSprite","rt":$n[1].Sprite,"p":[$n[9].AtlasRegion,$n[0].Single]},{"a":1,"n":"ToTexture","is":true,"t":8,"pi":[{"n":"s","pt":$n[1].Sprite,"ps":0},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":1},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"linear","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"applyPMA","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ToTexture$1","rt":$n[1].Texture2D,"p":[$n[1].Sprite,$n[1].TextureFormat,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"ToTexture","is":true,"t":8,"pi":[{"n":"ar","pt":$n[9].AtlasRegion,"ps":0},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":1},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"texturePropertyId","dv":0,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"linear","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"applyPMA","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"ToTexture","rt":$n[1].Texture2D,"p":[$n[9].AtlasRegion,$n[1].TextureFormat,$n[0].Boolean,$n[0].Int32,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"UVRectToAtlasRegion","is":true,"t":8,"pi":[{"n":"uvRect","pt":$n[1].Rect,"ps":0},{"n":"referenceRegion","pt":$n[9].AtlasRegion,"ps":1},{"n":"page","pt":$n[9].AtlasPage,"ps":2}],"sn":"UVRectToAtlasRegion","rt":$n[9].AtlasRegion,"p":[$n[1].Rect,$n[9].AtlasRegion,$n[9].AtlasPage]},{"a":1,"n":"UVRectToTextureRect","is":true,"t":8,"pi":[{"n":"uvRect","pt":$n[1].Rect,"ps":0},{"n":"texWidth","pt":$n[0].Int32,"ps":1},{"n":"texHeight","pt":$n[0].Int32,"ps":2}],"sn":"UVRectToTextureRect","rt":$n[1].Rect,"p":[$n[1].Rect,$n[0].Int32,$n[0].Int32]},{"a":1,"n":"CachedRegionTextures","is":true,"t":4,"rt":$n[5].Dictionary$2(Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey,UnityEngine.Texture2D),"sn":"CachedRegionTextures"},{"a":1,"n":"CachedRegionTexturesList","is":true,"t":4,"rt":$n[5].List$1(UnityEngine.Texture2D),"sn":"CachedRegionTexturesList"},{"a":4,"n":"DefaultMipmapBias","is":true,"t":4,"rt":$n[0].Single,"sn":"DefaultMipmapBias","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"DefaultScale","is":true,"t":4,"rt":$n[0].Single,"sn":"DefaultScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"NonrenderingRegion","is":true,"t":4,"rt":$n[0].Int32,"sn":"NonrenderingRegion","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"SpineTextureFormat","is":true,"t":4,"rt":$n[1].TextureFormat,"sn":"SpineTextureFormat","box":function ($v) { return Bridge.box($v, UnityEngine.TextureFormat, System.Enum.toStringFn(UnityEngine.TextureFormat));}},{"a":4,"n":"UseMipMaps","is":true,"t":4,"rt":$n[0].Boolean,"sn":"UseMipMaps","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"existingRegions","is":true,"t":4,"rt":$n[5].Dictionary$2(Spine.AtlasRegion,System.Int32),"sn":"existingRegions","ro":true},{"a":1,"n":"originalRegions","is":true,"t":4,"rt":$n[5].List$1(Spine.AtlasRegion),"sn":"originalRegions","ro":true},{"a":1,"n":"regionIndices","is":true,"t":4,"rt":$n[5].List$1(System.Int32),"sn":"regionIndices","ro":true},{"a":1,"n":"repackedAttachments","is":true,"t":4,"rt":$n[5].List$1(Spine.Attachment),"sn":"repackedAttachments","ro":true},{"a":1,"n":"repackedRegions","is":true,"t":4,"rt":$n[5].List$1(Spine.AtlasRegion),"sn":"repackedRegions","ro":true},{"a":1,"n":"texturesToPack","is":true,"t":4,"rt":$n[5].List$1(UnityEngine.Texture2D),"sn":"texturesToPack","ro":true},{"a":1,"n":"texturesToPackAtParam","is":true,"t":4,"rt":System.Array.type(System.Collections.Generic.List$1(UnityEngine.Texture2D)),"sn":"texturesToPackAtParam"}]}; }, $n);
    /*Spine.Unity.AttachmentTools.AtlasUtilities end.*/

    /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey start.*/
    $m("Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey", function () { return {"td":$n[15].AtlasUtilities,"att":1048843,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[9].AtlasRegion],"pi":[{"n":"i","pt":$n[0].Int32,"ps":0},{"n":"region","pt":$n[9].AtlasRegion,"ps":1}],"sn":"$ctor1"},{"ov":true,"a":2,"n":"GetHashCode","t":8,"sn":"getHashCode","rt":$n[0].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"i","t":4,"rt":$n[0].Int32,"sn":"i","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"region","t":4,"rt":$n[9].AtlasRegion,"sn":"region"}]}; }, $n);
    /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey end.*/

    /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions start.*/
    $m("Spine.Unity.AttachmentTools.AttachmentCloneExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"GetCopy","is":true,"t":8,"pi":[{"n":"o","pt":$n[9].Attachment,"ps":0},{"n":"cloneMeshesAsLinked","pt":$n[0].Boolean,"ps":1}],"sn":"GetCopy","rt":$n[9].Attachment,"p":[$n[9].Attachment,$n[0].Boolean]},{"a":2,"n":"GetLinkedMesh","is":true,"t":8,"pi":[{"n":"o","pt":$n[9].MeshAttachment,"ps":0},{"n":"newLinkedMeshName","pt":$n[0].String,"ps":1},{"n":"region","pt":$n[9].AtlasRegion,"ps":2}],"sn":"GetLinkedMesh","rt":$n[9].MeshAttachment,"p":[$n[9].MeshAttachment,$n[0].String,$n[9].AtlasRegion]},{"a":2,"n":"GetLinkedMesh","is":true,"t":8,"pi":[{"n":"o","pt":$n[9].MeshAttachment,"ps":0},{"n":"sprite","pt":$n[1].Sprite,"ps":1},{"n":"materialPropertySource","pt":$n[1].Material,"ps":2}],"sn":"GetLinkedMesh$1","rt":$n[9].MeshAttachment,"p":[$n[9].MeshAttachment,$n[1].Sprite,$n[1].Material]},{"a":2,"n":"GetLinkedMesh","is":true,"t":8,"pi":[{"n":"o","pt":$n[9].MeshAttachment,"ps":0},{"n":"sprite","pt":$n[1].Sprite,"ps":1},{"n":"shader","pt":$n[1].Shader,"ps":2},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[1].Material,"ps":3}],"sn":"GetLinkedMesh$2","rt":$n[9].MeshAttachment,"p":[$n[9].MeshAttachment,$n[1].Sprite,$n[1].Shader,$n[1].Material]},{"a":2,"n":"GetRemappedClone","is":true,"t":8,"pi":[{"n":"o","pt":$n[9].Attachment,"ps":0},{"n":"atlasRegion","pt":$n[9].AtlasRegion,"ps":1},{"n":"cloneMeshAsLinked","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"useOriginalRegionSize","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":4}],"sn":"GetRemappedClone","rt":$n[9].Attachment,"p":[$n[9].Attachment,$n[9].AtlasRegion,$n[0].Boolean,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"GetRemappedClone","is":true,"t":8,"pi":[{"n":"o","pt":$n[9].Attachment,"ps":0},{"n":"sprite","pt":$n[1].Sprite,"ps":1},{"n":"sourceMaterial","pt":$n[1].Material,"ps":2},{"n":"premultiplyAlpha","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"cloneMeshAsLinked","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"useOriginalRegionSize","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5},{"n":"pivotShiftsMeshUVCoords","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6},{"n":"useOriginalRegionScale","dv":false,"o":true,"pt":$n[0].Boolean,"ps":7}],"sn":"GetRemappedClone$1","rt":$n[9].Attachment,"p":[$n[9].Attachment,$n[1].Sprite,$n[1].Material,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]}]}; }, $n);
    /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions end.*/

    /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions start.*/
    $m("Spine.Unity.AttachmentTools.AttachmentRegionExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"GetRegion","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[9].Attachment,"ps":0}],"sn":"GetRegion","rt":$n[9].AtlasRegion,"p":[$n[9].Attachment]},{"a":2,"n":"GetRegion","is":true,"t":8,"pi":[{"n":"meshAttachment","pt":$n[9].MeshAttachment,"ps":0}],"sn":"GetRegion$1","rt":$n[9].AtlasRegion,"p":[$n[9].MeshAttachment]},{"a":2,"n":"GetRegion","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[9].RegionAttachment,"ps":0}],"sn":"GetRegion$2","rt":$n[9].AtlasRegion,"p":[$n[9].RegionAttachment]},{"a":2,"n":"SetPositionOffset","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[9].RegionAttachment,"ps":0},{"n":"offset","pt":$n[1].Vector2,"ps":1}],"sn":"SetPositionOffset$1","rt":$n[0].Void,"p":[$n[9].RegionAttachment,$n[1].Vector2]},{"a":2,"n":"SetPositionOffset","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[9].RegionAttachment,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"y","pt":$n[0].Single,"ps":2}],"sn":"SetPositionOffset","rt":$n[0].Void,"p":[$n[9].RegionAttachment,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetRegion","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[9].Attachment,"ps":0},{"n":"region","pt":$n[9].AtlasRegion,"ps":1},{"n":"updateOffset","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"SetRegion","rt":$n[0].Void,"p":[$n[9].Attachment,$n[9].AtlasRegion,$n[0].Boolean]},{"a":2,"n":"SetRegion","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[9].MeshAttachment,"ps":0},{"n":"region","pt":$n[9].AtlasRegion,"ps":1},{"n":"updateUVs","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"SetRegion$1","rt":$n[0].Void,"p":[$n[9].MeshAttachment,$n[9].AtlasRegion,$n[0].Boolean]},{"a":2,"n":"SetRegion","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[9].RegionAttachment,"ps":0},{"n":"region","pt":$n[9].AtlasRegion,"ps":1},{"n":"updateOffset","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"SetRegion$2","rt":$n[0].Void,"p":[$n[9].RegionAttachment,$n[9].AtlasRegion,$n[0].Boolean]},{"a":2,"n":"SetRotation","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[9].RegionAttachment,"ps":0},{"n":"rotation","pt":$n[0].Single,"ps":1}],"sn":"SetRotation","rt":$n[0].Void,"p":[$n[9].RegionAttachment,$n[0].Single]},{"a":2,"n":"SetScale","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[9].RegionAttachment,"ps":0},{"n":"scale","pt":$n[1].Vector2,"ps":1}],"sn":"SetScale$1","rt":$n[0].Void,"p":[$n[9].RegionAttachment,$n[1].Vector2]},{"a":2,"n":"SetScale","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[9].RegionAttachment,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"y","pt":$n[0].Single,"ps":2}],"sn":"SetScale","rt":$n[0].Void,"p":[$n[9].RegionAttachment,$n[0].Single,$n[0].Single]},{"a":2,"n":"ToRegionAttachment","is":true,"t":8,"pi":[{"n":"sprite","pt":$n[1].Sprite,"ps":0},{"n":"page","pt":$n[9].AtlasPage,"ps":1},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"ToRegionAttachment$1","rt":$n[9].RegionAttachment,"p":[$n[1].Sprite,$n[9].AtlasPage,$n[0].Single]},{"a":2,"n":"ToRegionAttachment","is":true,"t":8,"pi":[{"n":"sprite","pt":$n[1].Sprite,"ps":0},{"n":"material","pt":$n[1].Material,"ps":1},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"ToRegionAttachment$2","rt":$n[9].RegionAttachment,"p":[$n[1].Sprite,$n[1].Material,$n[0].Single]},{"a":2,"n":"ToRegionAttachment","is":true,"t":8,"pi":[{"n":"region","pt":$n[9].AtlasRegion,"ps":0},{"n":"attachmentName","pt":$n[0].String,"ps":1},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":2},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"ToRegionAttachment","rt":$n[9].RegionAttachment,"p":[$n[9].AtlasRegion,$n[0].String,$n[0].Single,$n[0].Single]},{"a":2,"n":"ToRegionAttachmentPMAClone","is":true,"t":8,"pi":[{"n":"sprite","pt":$n[1].Sprite,"ps":0},{"n":"materialPropertySource","pt":$n[1].Material,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":4}],"sn":"ToRegionAttachmentPMAClone","rt":$n[9].RegionAttachment,"p":[$n[1].Sprite,$n[1].Material,$n[1].TextureFormat,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"ToRegionAttachmentPMAClone","is":true,"t":8,"pi":[{"n":"sprite","pt":$n[1].Sprite,"ps":0},{"n":"shader","pt":$n[1].Shader,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[1].Material,"ps":4},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":5}],"sn":"ToRegionAttachmentPMAClone$1","rt":$n[9].RegionAttachment,"p":[$n[1].Sprite,$n[1].Shader,$n[1].TextureFormat,$n[0].Boolean,$n[1].Material,$n[0].Single]}]}; }, $n);
    /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions end.*/

    /*Spine.Unity.AttachmentTools.SkinUtilities start.*/
    $m("Spine.Unity.AttachmentTools.SkinUtilities", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"AddAttachments","is":true,"t":8,"pi":[{"n":"skin","pt":$n[9].Skin,"ps":0},{"n":"otherSkin","pt":$n[9].Skin,"ps":1}],"sn":"AddAttachments","rt":$n[0].Void,"p":[$n[9].Skin,$n[9].Skin]},{"a":2,"n":"Append","is":true,"t":8,"pi":[{"n":"destination","pt":$n[9].Skin,"ps":0},{"n":"source","pt":$n[9].Skin,"ps":1}],"sn":"Append","rt":$n[0].Void,"p":[$n[9].Skin,$n[9].Skin]},{"a":2,"n":"Clear","is":true,"t":8,"pi":[{"n":"skin","pt":$n[9].Skin,"ps":0}],"sn":"Clear","rt":$n[0].Void,"p":[$n[9].Skin]},{"a":2,"n":"CopyTo","is":true,"t":8,"pi":[{"n":"source","pt":$n[9].Skin,"ps":0},{"n":"destination","pt":$n[9].Skin,"ps":1},{"n":"overwrite","pt":$n[0].Boolean,"ps":2},{"n":"cloneAttachments","pt":$n[0].Boolean,"ps":3},{"n":"cloneMeshesAsLinked","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"CopyTo","rt":$n[0].Void,"p":[$n[9].Skin,$n[9].Skin,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"GetAttachment","is":true,"t":8,"pi":[{"n":"skin","pt":$n[9].Skin,"ps":0},{"n":"slotName","pt":$n[0].String,"ps":1},{"n":"keyName","pt":$n[0].String,"ps":2},{"n":"skeleton","pt":$n[9].Skeleton,"ps":3}],"sn":"GetAttachment","rt":$n[9].Attachment,"p":[$n[9].Skin,$n[0].String,$n[0].String,$n[9].Skeleton]},{"a":2,"n":"GetClone","is":true,"t":8,"pi":[{"n":"original","pt":$n[9].Skin,"ps":0}],"sn":"GetClone","rt":$n[9].Skin,"p":[$n[9].Skin]},{"a":2,"n":"GetClonedSkin","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0},{"n":"newSkinName","pt":$n[0].String,"ps":1},{"n":"includeDefaultSkin","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"cloneAttachments","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"cloneMeshesAsLinked","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"GetClonedSkin","rt":$n[9].Skin,"p":[$n[9].Skeleton,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"RemoveAttachment","is":true,"t":8,"pi":[{"n":"skin","pt":$n[9].Skin,"ps":0},{"n":"slotName","pt":$n[0].String,"ps":1},{"n":"keyName","pt":$n[0].String,"ps":2},{"n":"skeletonData","pt":$n[9].SkeletonData,"ps":3}],"sn":"RemoveAttachment","rt":$n[0].Void,"p":[$n[9].Skin,$n[0].String,$n[0].String,$n[9].SkeletonData]},{"a":2,"n":"SetAttachment","is":true,"t":8,"pi":[{"n":"skin","pt":$n[9].Skin,"ps":0},{"n":"slotIndex","pt":$n[0].Int32,"ps":1},{"n":"keyName","pt":$n[0].String,"ps":2},{"n":"attachment","pt":$n[9].Attachment,"ps":3}],"sn":"SetAttachment","rt":$n[0].Void,"p":[$n[9].Skin,$n[0].Int32,$n[0].String,$n[9].Attachment]},{"a":2,"n":"SetAttachment","is":true,"t":8,"pi":[{"n":"skin","pt":$n[9].Skin,"ps":0},{"n":"slotName","pt":$n[0].String,"ps":1},{"n":"keyName","pt":$n[0].String,"ps":2},{"n":"attachment","pt":$n[9].Attachment,"ps":3},{"n":"skeleton","pt":$n[9].Skeleton,"ps":4}],"sn":"SetAttachment$1","rt":$n[0].Void,"p":[$n[9].Skin,$n[0].String,$n[0].String,$n[9].Attachment,$n[9].Skeleton]},{"a":2,"n":"UnshareSkin","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[9].Skeleton,"ps":0},{"n":"includeDefaultSkin","pt":$n[0].Boolean,"ps":1},{"n":"unshareAttachments","pt":$n[0].Boolean,"ps":2},{"n":"state","dv":null,"o":true,"pt":$n[9].AnimationState,"ps":3}],"sn":"UnshareSkin","rt":$n[9].Skin,"p":[$n[9].Skeleton,$n[0].Boolean,$n[0].Boolean,$n[9].AnimationState]}]}; }, $n);
    /*Spine.Unity.AttachmentTools.SkinUtilities end.*/

    /*Spine.Unity.Deprecated.SlotBlendModes start.*/
    $m("Spine.Unity.Deprecated.SlotBlendModes", function () { return {"nested":[$n[16].SlotBlendModes.MaterialTexturePair,$n[16].SlotBlendModes.MaterialWithRefcount,$n[16].SlotBlendModes.SlotMaterialTextureTuple],"att":1048577,"a":2,"at":[new UnityEngine.DisallowMultipleComponent()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Apply","t":8,"sn":"Apply","rt":$n[0].Void},{"a":4,"n":"GetExistingMaterialFor","is":true,"t":8,"pi":[{"n":"materialSource","pt":$n[1].Material,"ps":0},{"n":"texture","pt":$n[1].Texture2D,"ps":1}],"sn":"GetExistingMaterialFor","rt":$n[16].SlotBlendModes.MaterialWithRefcount,"p":[$n[1].Material,$n[1].Texture2D]},{"a":4,"n":"GetOrAddMaterialFor","is":true,"t":8,"pi":[{"n":"materialSource","pt":$n[1].Material,"ps":0},{"n":"texture","pt":$n[1].Texture2D,"ps":1}],"sn":"GetOrAddMaterialFor","rt":$n[1].Material,"p":[$n[1].Material,$n[1].Texture2D]},{"a":2,"n":"GetTexture","t":8,"sn":"GetTexture","rt":$n[0].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":2,"n":"Remove","t":8,"sn":"Remove","rt":$n[0].Void},{"a":4,"n":"RemoveMaterialFromTable","is":true,"t":8,"pi":[{"n":"materialSource","pt":$n[1].Material,"ps":0},{"n":"texture","pt":$n[1].Texture2D,"ps":1}],"sn":"RemoveMaterialFromTable","rt":$n[0].Void,"p":[$n[1].Material,$n[1].Texture2D]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"Applied","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Applied","t":8,"rt":$n[0].Boolean,"fg":"Applied","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":1,"n":"set_Applied","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Applied"},"fn":"Applied"},{"a":4,"n":"MaterialTable","is":true,"t":16,"rt":$n[5].Dictionary$2(Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair,Spine.Unity.Deprecated.SlotBlendModes.MaterialWithRefcount),"g":{"a":4,"n":"get_MaterialTable","t":8,"rt":$n[5].Dictionary$2(Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair,Spine.Unity.Deprecated.SlotBlendModes.MaterialWithRefcount),"fg":"MaterialTable","is":true},"fn":"MaterialTable"},{"a":1,"n":"materialTable","is":true,"t":4,"rt":$n[5].Dictionary$2(Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair,Spine.Unity.Deprecated.SlotBlendModes.MaterialWithRefcount),"sn":"materialTable"},{"a":2,"n":"multiplyMaterialSource","t":4,"rt":$n[1].Material,"sn":"multiplyMaterialSource"},{"a":2,"n":"screenMaterialSource","t":4,"rt":$n[1].Material,"sn":"screenMaterialSource"},{"a":1,"n":"slotsWithCustomMaterial","t":4,"rt":System.Array.type(Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple),"sn":"slotsWithCustomMaterial"},{"a":1,"n":"texture","t":4,"rt":$n[1].Texture2D,"sn":"texture"},{"a":1,"backing":true,"n":"<Applied>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"Applied","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.Deprecated.SlotBlendModes end.*/

    /*Spine.Unity.Deprecated.SlotBlendModes+MaterialTexturePair start.*/
    $m("Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair", function () { return {"td":$n[16].SlotBlendModes,"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"material","t":4,"rt":$n[1].Material,"sn":"material"},{"a":2,"n":"texture2D","t":4,"rt":$n[1].Texture2D,"sn":"texture2D"}]}; }, $n);
    /*Spine.Unity.Deprecated.SlotBlendModes+MaterialTexturePair end.*/

    /*Spine.Unity.Deprecated.SlotBlendModes+MaterialWithRefcount start.*/
    $m("Spine.Unity.Deprecated.SlotBlendModes.MaterialWithRefcount", function () { return {"td":$n[16].SlotBlendModes,"att":1048581,"a":4,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[1].Material],"pi":[{"n":"mat","pt":$n[1].Material,"ps":0}],"sn":"ctor"},{"a":2,"n":"materialClone","t":4,"rt":$n[1].Material,"sn":"materialClone"},{"a":2,"n":"refcount","t":4,"rt":$n[0].Int32,"sn":"refcount","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Unity.Deprecated.SlotBlendModes+MaterialWithRefcount end.*/

    /*Spine.Unity.Deprecated.SlotBlendModes+SlotMaterialTextureTuple start.*/
    $m("Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple", function () { return {"td":$n[16].SlotBlendModes,"att":1048845,"a":4,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[9].Slot,$n[1].Material,$n[1].Texture2D],"pi":[{"n":"slot","pt":$n[9].Slot,"ps":0},{"n":"material","pt":$n[1].Material,"ps":1},{"n":"texture","pt":$n[1].Texture2D,"ps":2}],"sn":"$ctor1"},{"a":2,"n":"material","t":4,"rt":$n[1].Material,"sn":"material"},{"a":2,"n":"slot","t":4,"rt":$n[9].Slot,"sn":"slot"},{"a":2,"n":"texture2D","t":4,"rt":$n[1].Texture2D,"sn":"texture2D"}]}; }, $n);
    /*Spine.Unity.Deprecated.SlotBlendModes+SlotMaterialTextureTuple end.*/

    /*Spine.Collections.OrderedDictionary$2 start.*/
    $m("Spine.Collections.OrderedDictionary$2", function (TKey, TValue) { return {"nested":[$n[11].OrderedDictionary$2.KeyCollection,$n[11].OrderedDictionary$2.ValueCollection],"att":1048833,"a":2,"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[5].IEqualityComparer$1(TKey)],"pi":[{"n":"comparer","pt":$n[5].IEqualityComparer$1(TKey),"ps":0}],"sn":"$ctor1"},{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"capacity","pt":$n[0].Int32,"ps":0}],"sn":"$ctor2"},{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[5].IEqualityComparer$1(TKey)],"pi":[{"n":"capacity","pt":$n[0].Int32,"ps":0},{"n":"comparer","pt":$n[5].IEqualityComparer$1(TKey),"ps":1}],"sn":"$ctor3"},{"a":2,"n":"Add","t":8,"pi":[{"n":"key","pt":TKey,"ps":0},{"n":"value","pt":TValue,"ps":1}],"sn":"add","rt":$n[0].Void,"p":[TKey,TValue]},{"a":2,"n":"Clear","t":8,"sn":"clear","rt":$n[0].Void},{"a":2,"n":"ContainsKey","t":8,"pi":[{"n":"key","pt":TKey,"ps":0}],"sn":"containsKey","rt":$n[0].Boolean,"p":[TKey],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GetEnumerator","t":8,"sn":"GetEnumerator","rt":$n[5].IEnumerator$1(System.Collections.Generic.KeyValuePair$2(TKey,TValue))},{"a":2,"n":"GetKey","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0}],"sn":"GetKey","rt":TKey,"p":[$n[0].Int32]},{"a":2,"n":"IndexOf","t":8,"pi":[{"n":"key","pt":TKey,"ps":0}],"sn":"IndexOf","rt":$n[0].Int32,"p":[TKey],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"Insert","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"key","pt":TKey,"ps":1},{"n":"value","pt":TValue,"ps":2}],"sn":"Insert","rt":$n[0].Void,"p":[$n[0].Int32,TKey,TValue]},{"a":2,"n":"Remove","t":8,"pi":[{"n":"key","pt":TKey,"ps":0}],"sn":"remove","rt":$n[0].Boolean,"p":[TKey],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"RemoveAt","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0}],"sn":"removeAt","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"TryGetValue","t":8,"pi":[{"n":"key","pt":TKey,"ps":0},{"n":"value","out":true,"pt":TValue,"ps":1}],"sn":"tryGetValue","rt":$n[0].Boolean,"p":[TKey,TValue],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Comparer","t":16,"rt":$n[5].IEqualityComparer$1(TKey),"g":{"a":2,"n":"get_Comparer","t":8,"rt":$n[5].IEqualityComparer$1(TKey),"fg":"Comparer"},"fn":"Comparer"},{"a":2,"n":"Count","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Count","t":8,"rt":$n[0].Int32,"fg":"Count","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Count"},{"a":2,"n":"Item","t":16,"rt":TValue,"p":[$n[0].Int32],"i":true,"ipi":[{"n":"index","pt":$n[0].Int32,"ps":0}],"g":{"a":2,"n":"get_Item","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0}],"sn":"getItem$1","rt":TValue,"p":[$n[0].Int32]},"s":{"a":2,"n":"set_Item","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"value","pt":TValue,"ps":1}],"sn":"setItem$1","rt":$n[0].Void,"p":[$n[0].Int32,TValue]}},{"a":2,"n":"Item","t":16,"rt":TValue,"p":[TKey],"i":true,"ipi":[{"n":"key","pt":TKey,"ps":0}],"g":{"a":2,"n":"get_Item","t":8,"pi":[{"n":"key","pt":TKey,"ps":0}],"sn":"getItem","rt":TValue,"p":[TKey]},"s":{"a":2,"n":"set_Item","t":8,"pi":[{"n":"key","pt":TKey,"ps":0},{"n":"value","pt":TValue,"ps":1}],"sn":"setItem","rt":$n[0].Void,"p":[TKey,TValue]}},{"a":2,"n":"Keys","t":16,"rt":$n[11].OrderedDictionary$2.KeyCollection(TKey,TValue),"g":{"a":2,"n":"get_Keys","t":8,"rt":$n[11].OrderedDictionary$2.KeyCollection(TKey,TValue),"fg":"Keys"},"fn":"Keys"},{"a":2,"n":"Values","t":16,"rt":$n[11].OrderedDictionary$2.ValueCollection(TKey,TValue),"g":{"a":2,"n":"get_Values","t":8,"rt":$n[11].OrderedDictionary$2.ValueCollection(TKey,TValue),"fg":"Values"},"fn":"Values"},{"a":1,"n":"CollectionModifiedMessage","is":true,"t":4,"rt":$n[0].String,"sn":"CollectionModifiedMessage"},{"a":1,"n":"EditReadOnlyListMessage","is":true,"t":4,"rt":$n[0].String,"sn":"EditReadOnlyListMessage"},{"a":1,"n":"IndexOutOfRangeMessage","is":true,"t":4,"rt":$n[0].String,"sn":"IndexOutOfRangeMessage"},{"a":1,"n":"dictionary","t":4,"rt":$n[5].Dictionary$2(TKey,System.Int32),"sn":"dictionary","ro":true},{"a":1,"n":"keys","t":4,"rt":$n[5].List$1(TKey),"sn":"keys","ro":true},{"a":1,"n":"values","t":4,"rt":$n[5].List$1(TValue),"sn":"values","ro":true},{"a":1,"n":"version","t":4,"rt":$n[0].Int32,"sn":"version","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Collections.OrderedDictionary$2 end.*/

    /*Spine.Collections.OrderedDictionary$2+KeyCollection start.*/
    $m("Spine.Collections.OrderedDictionary$2.KeyCollection", function (TKey, TValue) { return {"td":$n[11].OrderedDictionary$2(TKey,TValue),"att":1048834,"a":2,"m":[{"a":4,"n":".ctor","t":1,"p":[$n[5].Dictionary$2(TKey,System.Int32)],"pi":[{"n":"dictionary","pt":$n[5].Dictionary$2(TKey,System.Int32),"ps":0}],"sn":"ctor"},{"a":2,"n":"CopyTo","t":8,"pi":[{"n":"array","pt":System.Array.type(TKey),"ps":0},{"n":"arrayIndex","pt":$n[0].Int32,"ps":1}],"sn":"copyTo","rt":$n[0].Void,"p":[System.Array.type(TKey),$n[0].Int32]},{"a":2,"n":"GetEnumerator","t":8,"sn":"GetEnumerator","rt":$n[5].IEnumerator$1(TKey)},{"a":2,"n":"Count","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Count","t":8,"rt":$n[0].Int32,"fg":"Count","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Count"},{"a":1,"n":"dictionary","t":4,"rt":$n[5].Dictionary$2(TKey,System.Int32),"sn":"dictionary","ro":true}]}; }, $n);
    /*Spine.Collections.OrderedDictionary$2+KeyCollection end.*/

    /*Spine.Collections.OrderedDictionary$2+ValueCollection start.*/
    $m("Spine.Collections.OrderedDictionary$2.ValueCollection", function (TKey, TValue) { return {"td":$n[11].OrderedDictionary$2(TKey,TValue),"att":1048834,"a":2,"m":[{"a":4,"n":".ctor","t":1,"p":[$n[5].List$1(TValue)],"pi":[{"n":"values","pt":$n[5].List$1(TValue),"ps":0}],"sn":"ctor"},{"a":2,"n":"CopyTo","t":8,"pi":[{"n":"array","pt":System.Array.type(TValue),"ps":0},{"n":"arrayIndex","pt":$n[0].Int32,"ps":1}],"sn":"copyTo","rt":$n[0].Void,"p":[System.Array.type(TValue),$n[0].Int32]},{"a":2,"n":"GetEnumerator","t":8,"sn":"GetEnumerator","rt":$n[5].IEnumerator$1(TValue)},{"a":2,"n":"Count","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Count","t":8,"rt":$n[0].Int32,"fg":"Count","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Count"},{"a":1,"n":"values","t":4,"rt":$n[5].List$1(TValue),"sn":"values","ro":true}]}; }, $n);
    /*Spine.Collections.OrderedDictionary$2+ValueCollection end.*/

    /*Spine.Collections.OrderedDictionaryDebugView$2 start.*/
    $m("Spine.Collections.OrderedDictionaryDebugView$2", function (TKey, TValue) { return {"att":1048576,"a":4,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[11].OrderedDictionary$2(TKey,TValue)],"pi":[{"n":"dictionary","pt":$n[11].OrderedDictionary$2(TKey,TValue),"ps":0}],"sn":"ctor"},{"a":2,"n":"Items","t":16,"rt":System.Array.type(System.Collections.Generic.KeyValuePair$2(TKey,TValue)),"g":{"a":2,"n":"get_Items","t":8,"rt":System.Array.type(System.Collections.Generic.KeyValuePair$2(TKey,TValue)),"fg":"Items"},"fn":"Items"},{"a":1,"n":"dictionary","t":4,"rt":$n[11].OrderedDictionary$2(TKey,TValue),"sn":"dictionary","ro":true}]}; }, $n);
    /*Spine.Collections.OrderedDictionaryDebugView$2 end.*/

    /*Spine.Collections.CollectionExtensions start.*/
    $m("Spine.Collections.CollectionExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"ToOrderedDictionary","is":true,"t":8,"pi":[{"n":"source","pt":$n[5].IEnumerable$1(System.Object),"ps":0},{"n":"keySelector","pt":Function,"ps":1}],"tpc":2,"tprm":["TSource","TKey"],"sn":"ToOrderedDictionary","rt":$n[11].OrderedDictionary$2(System.Object,System.Object),"p":[$n[5].IEnumerable$1(System.Object),Function]},{"a":2,"n":"ToOrderedDictionary","is":true,"t":8,"pi":[{"n":"source","pt":$n[5].IEnumerable$1(System.Object),"ps":0},{"n":"keySelector","pt":Function,"ps":1},{"n":"comparer","pt":$n[5].IEqualityComparer$1(System.Object),"ps":2}],"tpc":2,"tprm":["TSource","TKey"],"sn":"ToOrderedDictionary$1","rt":$n[11].OrderedDictionary$2(System.Object,System.Object),"p":[$n[5].IEnumerable$1(System.Object),Function,$n[5].IEqualityComparer$1(System.Object)]}]}; }, $n);
    /*Spine.Collections.CollectionExtensions end.*/

    /*BezierCurve.BezierCollider2D start.*/
    $m("BezierCurve.BezierCollider2D", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.EdgeCollider2D)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Calculate2DPoints","t":8,"sn":"Calculate2DPoints","rt":System.Array.type(UnityEngine.Vector2)},{"a":1,"n":"CalculateBezierPoint","t":8,"pi":[{"n":"t","pt":$n[0].Single,"ps":0},{"n":"p0","pt":$n[1].Vector3,"ps":1},{"n":"handlerP0","pt":$n[1].Vector3,"ps":2},{"n":"handlerP1","pt":$n[1].Vector3,"ps":3},{"n":"p1","pt":$n[1].Vector3,"ps":4}],"sn":"CalculateBezierPoint","rt":$n[1].Vector3,"p":[$n[0].Single,$n[1].Vector3,$n[1].Vector3,$n[1].Vector3,$n[1].Vector3]},{"a":2,"n":"firstPoint","t":4,"rt":$n[1].Vector2,"sn":"firstPoint"},{"a":2,"n":"handlerFirstPoint","t":4,"rt":$n[1].Vector2,"sn":"handlerFirstPoint"},{"a":2,"n":"handlerSecondPoint","t":4,"rt":$n[1].Vector2,"sn":"handlerSecondPoint"},{"a":2,"n":"pointsQuantity","t":4,"rt":$n[0].Int32,"sn":"pointsQuantity","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"secondPoint","t":4,"rt":$n[1].Vector2,"sn":"secondPoint"}]}; }, $n);
    /*BezierCurve.BezierCollider2D end.*/

    /*DG.Tweening.DOTweenModuleAudio start.*/
    $m("DG.Tweening.DOTweenModuleAudio", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOComplete","is":true,"t":8,"pi":[{"n":"target","pt":$n[17].AudioMixer,"ps":0},{"n":"withCallbacks","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"DOComplete","rt":$n[0].Int32,"p":[$n[17].AudioMixer,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].AudioSource,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade","rt":$n[18].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[1].AudioSource,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFlip","is":true,"t":8,"pi":[{"n":"target","pt":$n[17].AudioMixer,"ps":0}],"sn":"DOFlip","rt":$n[0].Int32,"p":[$n[17].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOGoto","is":true,"t":8,"pi":[{"n":"target","pt":$n[17].AudioMixer,"ps":0},{"n":"to","pt":$n[0].Single,"ps":1},{"n":"andPlay","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"DOGoto","rt":$n[0].Int32,"p":[$n[17].AudioMixer,$n[0].Single,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOKill","is":true,"t":8,"pi":[{"n":"target","pt":$n[17].AudioMixer,"ps":0},{"n":"complete","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"DOKill","rt":$n[0].Int32,"p":[$n[17].AudioMixer,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPause","is":true,"t":8,"pi":[{"n":"target","pt":$n[17].AudioMixer,"ps":0}],"sn":"DOPause","rt":$n[0].Int32,"p":[$n[17].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPitch","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].AudioSource,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPitch","rt":$n[18].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[1].AudioSource,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOPlay","is":true,"t":8,"pi":[{"n":"target","pt":$n[17].AudioMixer,"ps":0}],"sn":"DOPlay","rt":$n[0].Int32,"p":[$n[17].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPlayBackwards","is":true,"t":8,"pi":[{"n":"target","pt":$n[17].AudioMixer,"ps":0}],"sn":"DOPlayBackwards","rt":$n[0].Int32,"p":[$n[17].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPlayForward","is":true,"t":8,"pi":[{"n":"target","pt":$n[17].AudioMixer,"ps":0}],"sn":"DOPlayForward","rt":$n[0].Int32,"p":[$n[17].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DORestart","is":true,"t":8,"pi":[{"n":"target","pt":$n[17].AudioMixer,"ps":0}],"sn":"DORestart","rt":$n[0].Int32,"p":[$n[17].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DORewind","is":true,"t":8,"pi":[{"n":"target","pt":$n[17].AudioMixer,"ps":0}],"sn":"DORewind","rt":$n[0].Int32,"p":[$n[17].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOSetFloat","is":true,"t":8,"pi":[{"n":"target","pt":$n[17].AudioMixer,"ps":0},{"n":"floatName","pt":$n[0].String,"ps":1},{"n":"endValue","pt":$n[0].Single,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOSetFloat","rt":$n[18].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[17].AudioMixer,$n[0].String,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOSmoothRewind","is":true,"t":8,"pi":[{"n":"target","pt":$n[17].AudioMixer,"ps":0}],"sn":"DOSmoothRewind","rt":$n[0].Int32,"p":[$n[17].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOTogglePause","is":true,"t":8,"pi":[{"n":"target","pt":$n[17].AudioMixer,"ps":0}],"sn":"DOTogglePause","rt":$n[0].Int32,"p":[$n[17].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*DG.Tweening.DOTweenModuleAudio end.*/

    /*DG.Tweening.DOTweenModulePhysics start.*/
    $m("DG.Tweening.DOTweenModulePhysics", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOJump","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"endValue","pt":$n[1].Vector3,"ps":1},{"n":"jumpPower","pt":$n[0].Single,"ps":2},{"n":"numJumps","pt":$n[0].Int32,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOJump","rt":$n[19].Sequence,"p":[$n[1].Rigidbody,$n[1].Vector3,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":4,"n":"DOLocalPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"path","pt":$n[20].Path,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathMode","dv":1,"o":true,"pt":$n[19].PathMode,"ps":3}],"sn":"DOLocalPath$1","rt":$n[18].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].Rigidbody,$n[20].Path,$n[0].Single,$n[19].PathMode]},{"a":2,"n":"DOLocalPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector3),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[19].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[19].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOLocalPath","rt":$n[18].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].Rigidbody,System.Array.type(UnityEngine.Vector3),$n[0].Single,$n[19].PathType,$n[19].PathMode,$n[0].Int32,$n[0].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DOLookAt","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"towards","pt":$n[1].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"axisConstraint","dv":0,"o":true,"pt":$n[19].AxisConstraint,"ps":3},{"n":"up","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Vector3),"ps":4}],"sn":"DOLookAt","rt":$n[18].TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions),"p":[$n[1].Rigidbody,$n[1].Vector3,$n[0].Single,$n[19].AxisConstraint,$n[0].Nullable$1(UnityEngine.Vector3)]},{"a":2,"n":"DOMove","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"endValue","pt":$n[1].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMove","rt":$n[18].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody,$n[1].Vector3,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveX","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveX","rt":$n[18].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveY","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveY","rt":$n[18].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveZ","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveZ","rt":$n[18].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":4,"n":"DOPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"path","pt":$n[20].Path,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathMode","dv":1,"o":true,"pt":$n[19].PathMode,"ps":3}],"sn":"DOPath$1","rt":$n[18].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].Rigidbody,$n[20].Path,$n[0].Single,$n[19].PathMode]},{"a":2,"n":"DOPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector3),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[19].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[19].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOPath","rt":$n[18].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].Rigidbody,System.Array.type(UnityEngine.Vector3),$n[0].Single,$n[19].PathType,$n[19].PathMode,$n[0].Int32,$n[0].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DORotate","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"endValue","pt":$n[1].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"mode","dv":0,"o":true,"pt":$n[19].RotateMode,"ps":3}],"sn":"DORotate","rt":$n[18].TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions),"p":[$n[1].Rigidbody,$n[1].Vector3,$n[0].Single,$n[19].RotateMode]}]}; }, $n);
    /*DG.Tweening.DOTweenModulePhysics end.*/

    /*DG.Tweening.DOTweenModulePhysics2D start.*/
    $m("DG.Tweening.DOTweenModulePhysics2D", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOJump","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"jumpPower","pt":$n[0].Single,"ps":2},{"n":"numJumps","pt":$n[0].Int32,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOJump","rt":$n[19].Sequence,"p":[$n[1].Rigidbody2D,$n[1].Vector2,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":4,"n":"DOLocalPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"path","pt":$n[20].Path,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathMode","dv":1,"o":true,"pt":$n[19].PathMode,"ps":3}],"sn":"DOLocalPath$1","rt":$n[18].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].Rigidbody2D,$n[20].Path,$n[0].Single,$n[19].PathMode]},{"a":2,"n":"DOLocalPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[19].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[19].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOLocalPath","rt":$n[18].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].Rigidbody2D,System.Array.type(UnityEngine.Vector2),$n[0].Single,$n[19].PathType,$n[19].PathMode,$n[0].Int32,$n[0].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DOMove","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMove","rt":$n[18].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody2D,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveX","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveX","rt":$n[18].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody2D,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveY","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveY","rt":$n[18].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody2D,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":4,"n":"DOPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"path","pt":$n[20].Path,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathMode","dv":1,"o":true,"pt":$n[19].PathMode,"ps":3}],"sn":"DOPath$1","rt":$n[18].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].Rigidbody2D,$n[20].Path,$n[0].Single,$n[19].PathMode]},{"a":2,"n":"DOPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[19].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[19].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOPath","rt":$n[18].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].Rigidbody2D,System.Array.type(UnityEngine.Vector2),$n[0].Single,$n[19].PathType,$n[19].PathMode,$n[0].Int32,$n[0].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DORotate","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DORotate","rt":$n[18].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[1].Rigidbody2D,$n[0].Single,$n[0].Single]}]}; }, $n);
    /*DG.Tweening.DOTweenModulePhysics2D end.*/

    /*DG.Tweening.DOTweenModuleSprite start.*/
    $m("DG.Tweening.DOTweenModuleSprite", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor","rt":$n[19].Tweener,"p":[$n[1].SpriteRenderer,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor","rt":$n[18].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[1].SpriteRenderer,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade","rt":$n[18].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[1].SpriteRenderer,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].SpriteRenderer,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[19].Sequence,"p":[$n[1].SpriteRenderer,pc.ColorGradient,$n[0].Single]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleSprite end.*/

    /*DG.Tweening.DOTweenModuleUI start.*/
    $m("DG.Tweening.DOTweenModuleUI", function () { return {"nested":[$n[19].DOTweenModuleUI.Utils],"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOAnchorMax","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorMax","rt":$n[18].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorMin","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorMin","rt":$n[18].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos","rt":$n[18].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3D","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3D","rt":$n[18].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector3,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3DX","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3DX","rt":$n[18].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3DY","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3DY","rt":$n[18].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3DZ","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3DZ","rt":$n[18].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPosX","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPosX","rt":$n[18].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPosY","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPosY","rt":$n[18].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Graphic,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor","rt":$n[19].Tweener,"p":[$n[3].Graphic,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Image,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor$1","rt":$n[19].Tweener,"p":[$n[3].Image,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Text,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor$2","rt":$n[19].Tweener,"p":[$n[3].Text,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Graphic,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor","rt":$n[18].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[3].Graphic,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Image,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor$1","rt":$n[18].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[3].Image,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Outline,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor$2","rt":$n[18].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[3].Outline,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Text,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor$3","rt":$n[18].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[3].Text,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOCounter","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Text,"ps":0},{"n":"fromValue","pt":$n[0].Int32,"ps":1},{"n":"endValue","pt":$n[0].Int32,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3},{"n":"addThousandsSeparator","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"culture","dv":null,"o":true,"pt":$n[21].CultureInfo,"ps":5}],"sn":"DOCounter","rt":$n[18].TweenerCore$3(System.Int32,System.Int32,DG.Tweening.Plugins.Options.NoOptions),"p":[$n[3].Text,$n[0].Int32,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[21].CultureInfo]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].CanvasGroup,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade","rt":$n[18].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[1].CanvasGroup,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Graphic,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$1","rt":$n[18].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[3].Graphic,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Image,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$2","rt":$n[18].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[3].Image,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Outline,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$3","rt":$n[18].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[3].Outline,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Text,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$4","rt":$n[18].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[3].Text,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFillAmount","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Image,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFillAmount","rt":$n[18].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[3].Image,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFlexibleSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].LayoutElement,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOFlexibleSize","rt":$n[18].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].LayoutElement,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Image,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[19].Sequence,"p":[$n[3].Image,pc.ColorGradient,$n[0].Single]},{"a":2,"n":"DOHorizontalNormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].ScrollRect,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOHorizontalNormalizedPos","rt":$n[19].Tweener,"p":[$n[3].ScrollRect,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOJumpAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"jumpPower","pt":$n[0].Single,"ps":2},{"n":"numJumps","pt":$n[0].Int32,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOJumpAnchorPos","rt":$n[19].Sequence,"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMinSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].LayoutElement,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMinSize","rt":$n[18].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].LayoutElement,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DONormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].ScrollRect,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DONormalizedPos","rt":$n[19].Tweener,"p":[$n[3].ScrollRect,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOPivot","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPivot","rt":$n[18].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single]},{"a":2,"n":"DOPivotX","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPivotX","rt":$n[18].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOPivotY","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPivotY","rt":$n[18].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOPreferredSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].LayoutElement,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOPreferredSize","rt":$n[18].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].LayoutElement,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOPunchAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"punch","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"elasticity","dv":1.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOPunchAnchorPos","rt":$n[19].Tweener,"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOScale","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Outline,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOScale","rt":$n[18].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].Outline,$n[1].Vector2,$n[0].Single]},{"a":2,"n":"DOShakeAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"duration","pt":$n[0].Single,"ps":1},{"n":"strength","dv":100.0,"o":true,"pt":$n[0].Single,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"randomness","dv":90.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5},{"n":"fadeOut","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6}],"sn":"DOShakeAnchorPos","rt":$n[19].Tweener,"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"DOShakeAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"duration","pt":$n[0].Single,"ps":1},{"n":"strength","pt":$n[1].Vector2,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"randomness","dv":90.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5},{"n":"fadeOut","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6}],"sn":"DOShakeAnchorPos$1","rt":$n[19].Tweener,"p":[$n[1].RectTransform,$n[0].Single,$n[1].Vector2,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"DOShapeCircle","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"center","pt":$n[1].Vector2,"ps":1},{"n":"endValueDegrees","pt":$n[0].Single,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3},{"n":"relativeCenter","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOShapeCircle","rt":$n[18].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.CircleOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"DOSizeDelta","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOSizeDelta","rt":$n[18].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOText","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Text,"ps":0},{"n":"endValue","pt":$n[0].String,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"richTextEnabled","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"scrambleMode","dv":0,"o":true,"pt":$n[19].ScrambleMode,"ps":4},{"n":"scrambleChars","dv":null,"o":true,"pt":$n[0].String,"ps":5}],"sn":"DOText","rt":$n[18].TweenerCore$3(System.String,System.String,DG.Tweening.Plugins.Options.StringOptions),"p":[$n[3].Text,$n[0].String,$n[0].Single,$n[0].Boolean,$n[19].ScrambleMode,$n[0].String]},{"a":2,"n":"DOValue","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Slider,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOValue","rt":$n[18].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[3].Slider,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOVerticalNormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].ScrollRect,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOVerticalNormalizedPos","rt":$n[19].Tweener,"p":[$n[3].ScrollRect,$n[0].Single,$n[0].Single,$n[0].Boolean]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUI end.*/

    /*DG.Tweening.DOTweenModuleUI+Utils start.*/
    $m("DG.Tweening.DOTweenModuleUI.Utils", function () { return {"td":$n[19].DOTweenModuleUI,"att":1048962,"a":2,"s":true,"m":[{"a":2,"n":"SwitchToRectTransform","is":true,"t":8,"pi":[{"n":"from","pt":$n[1].RectTransform,"ps":0},{"n":"to","pt":$n[1].RectTransform,"ps":1}],"sn":"SwitchToRectTransform","rt":$n[1].Vector2,"p":[$n[1].RectTransform,$n[1].RectTransform]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUI+Utils end.*/

    /*DG.Tweening.DOTweenModuleUnityVersion start.*/
    $m("DG.Tweening.DOTweenModuleUnityVersion", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Material,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[19].Sequence,"p":[$n[1].Material,pc.ColorGradient,$n[0].Single]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Material,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"property","pt":$n[0].String,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOGradientColor$1","rt":$n[19].Sequence,"p":[$n[1].Material,pc.ColorGradient,$n[0].String,$n[0].Single]},{"a":2,"n":"DOOffset","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Material,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"propertyID","pt":$n[0].Int32,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOOffset","rt":$n[18].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Material,$n[1].Vector2,$n[0].Int32,$n[0].Single]},{"a":2,"n":"DOTiling","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Material,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"propertyID","pt":$n[0].Int32,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOTiling","rt":$n[18].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Material,$n[1].Vector2,$n[0].Int32,$n[0].Single]},{"a":2,"n":"WaitForCompletion","is":true,"t":8,"pi":[{"n":"t","pt":$n[19].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForCompletion","rt":$n[1].CustomYieldInstruction,"p":[$n[19].Tween,$n[0].Boolean]},{"a":2,"n":"WaitForElapsedLoops","is":true,"t":8,"pi":[{"n":"t","pt":$n[19].Tween,"ps":0},{"n":"elapsedLoops","pt":$n[0].Int32,"ps":1},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":2}],"sn":"WaitForElapsedLoops","rt":$n[1].CustomYieldInstruction,"p":[$n[19].Tween,$n[0].Int32,$n[0].Boolean]},{"a":2,"n":"WaitForKill","is":true,"t":8,"pi":[{"n":"t","pt":$n[19].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForKill","rt":$n[1].CustomYieldInstruction,"p":[$n[19].Tween,$n[0].Boolean]},{"a":2,"n":"WaitForPosition","is":true,"t":8,"pi":[{"n":"t","pt":$n[19].Tween,"ps":0},{"n":"position","pt":$n[0].Single,"ps":1},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":2}],"sn":"WaitForPosition","rt":$n[1].CustomYieldInstruction,"p":[$n[19].Tween,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"WaitForRewind","is":true,"t":8,"pi":[{"n":"t","pt":$n[19].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForRewind","rt":$n[1].CustomYieldInstruction,"p":[$n[19].Tween,$n[0].Boolean]},{"a":2,"n":"WaitForStart","is":true,"t":8,"pi":[{"n":"t","pt":$n[19].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForStart","rt":$n[1].CustomYieldInstruction,"p":[$n[19].Tween,$n[0].Boolean]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUnityVersion end.*/

    /*DG.Tweening.DOTweenCYInstruction start.*/
    $m("DG.Tweening.DOTweenCYInstruction", function () { return {"nested":[$n[19].DOTweenCYInstruction.WaitForCompletion,$n[19].DOTweenCYInstruction.WaitForRewind,$n[19].DOTweenCYInstruction.WaitForKill,$n[19].DOTweenCYInstruction.WaitForElapsedLoops,$n[19].DOTweenCYInstruction.WaitForPosition,$n[19].DOTweenCYInstruction.WaitForStart],"att":1048961,"a":2,"s":true}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForCompletion", function () { return {"td":$n[19].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[19].Tween],"pi":[{"n":"tween","pt":$n[19].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[19].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForRewind", function () { return {"td":$n[19].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[19].Tween],"pi":[{"n":"tween","pt":$n[19].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[19].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForKill start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForKill", function () { return {"td":$n[19].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[19].Tween],"pi":[{"n":"tween","pt":$n[19].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[19].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForKill end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops", function () { return {"td":$n[19].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[19].Tween,$n[0].Int32],"pi":[{"n":"tween","pt":$n[19].Tween,"ps":0},{"n":"elapsedLoops","pt":$n[0].Int32,"ps":1}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"elapsedLoops","t":4,"rt":$n[0].Int32,"sn":"elapsedLoops","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"t","t":4,"rt":$n[19].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForPosition", function () { return {"td":$n[19].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[19].Tween,$n[0].Single],"pi":[{"n":"tween","pt":$n[19].Tween,"ps":0},{"n":"position","pt":$n[0].Single,"ps":1}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"position","t":4,"rt":$n[0].Single,"sn":"position","ro":true,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"t","t":4,"rt":$n[19].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForStart start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForStart", function () { return {"td":$n[19].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[19].Tween],"pi":[{"n":"tween","pt":$n[19].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[19].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForStart end.*/

    /*DG.Tweening.DOTweenModuleUtils start.*/
    $m("DG.Tweening.DOTweenModuleUtils", function () { return {"nested":[$n[19].DOTweenModuleUtils.Physics],"att":1048961,"a":2,"s":true,"m":[{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":2,"n":"Init","is":true,"t":8,"sn":"Init","rt":$n[0].Void},{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":1,"n":"Preserver","is":true,"t":8,"sn":"Preserver","rt":$n[0].Void},{"a":1,"n":"_initialized","is":true,"t":4,"rt":$n[0].Boolean,"sn":"_initialized","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUtils end.*/

    /*DG.Tweening.DOTweenModuleUtils+Physics start.*/
    $m("DG.Tweening.DOTweenModuleUtils.Physics", function () { return {"td":$n[19].DOTweenModuleUtils,"att":1048962,"a":2,"s":true,"m":[{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":2,"n":"CreateDOTweenPathTween","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].MonoBehaviour,"ps":0},{"n":"tweenRigidbody","pt":$n[0].Boolean,"ps":1},{"n":"isLocal","pt":$n[0].Boolean,"ps":2},{"n":"path","pt":$n[20].Path,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"pathMode","pt":$n[19].PathMode,"ps":5}],"sn":"CreateDOTweenPathTween","rt":$n[18].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].MonoBehaviour,$n[0].Boolean,$n[0].Boolean,$n[20].Path,$n[0].Single,$n[19].PathMode]},{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":2,"n":"HasRigidbody","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Component,"ps":0}],"sn":"HasRigidbody","rt":$n[0].Boolean,"p":[$n[1].Component],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"HasRigidbody2D","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Component,"ps":0}],"sn":"HasRigidbody2D","rt":$n[0].Boolean,"p":[$n[1].Component],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SetOrientationOnPath","is":true,"t":8,"pi":[{"n":"options","pt":$n[22].PathOptions,"ps":0},{"n":"t","pt":$n[19].Tween,"ps":1},{"n":"newRot","pt":$n[1].Quaternion,"ps":2},{"n":"trans","pt":$n[1].Transform,"ps":3}],"sn":"SetOrientationOnPath","rt":$n[0].Void,"p":[$n[22].PathOptions,$n[19].Tween,$n[1].Quaternion,$n[1].Transform]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUtils+Physics end.*/

    }});
